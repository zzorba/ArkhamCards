diff --git a/node_modules/react-native-gesture-handler/Directions.js b/node_modules/react-native-gesture-handler/Directions.js
deleted file mode 100644
index f9b935a..0000000
--- a/node_modules/react-native-gesture-handler/Directions.js
+++ /dev/null
@@ -1,3 +0,0 @@
-import RNGestureHandlerModule from './RNGestureHandlerModule';
-
-export default RNGestureHandlerModule.Direction;
diff --git a/node_modules/react-native-gesture-handler/DrawerLayout.d.ts b/node_modules/react-native-gesture-handler/DrawerLayout.d.ts
deleted file mode 100644
index 2636b0f..0000000
--- a/node_modules/react-native-gesture-handler/DrawerLayout.d.ts
+++ /dev/null
@@ -1,50 +0,0 @@
-declare module 'react-native-gesture-handler/DrawerLayout' {
-  import * as React from 'react'
-  import { Animated, StatusBarAnimation, StyleProp, ViewStyle } from 'react-native';
-
-  export type DrawerPosition = 'left' | 'right';
-
-  export type DrawerState = 'Idle' | 'Dragging' | 'Settling';
-
-  export type DrawerType = 'front' | 'back' | 'slide';
-
-  export type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';
-
-  export type DrawerKeyboardDismissMode = 'none' | 'on-drag';
-
-  export interface DrawerLayoutProperties {
-    renderNavigationView: (
-      progressAnimatedValue: Animated.Value
-    ) => React.ReactNode;
-    drawerPosition?: DrawerPosition;
-    drawerWidth?: number;
-    drawerBackgroundColor?: string;
-    drawerLockMode?: DrawerLockMode;
-    keyboardDismissMode?: DrawerKeyboardDismissMode;
-    onDrawerClose?: () => void;
-    onDrawerOpen?: () => void;
-    onDrawerStateChanged?: (
-      newState: DrawerState,
-      drawerWillShow: boolean
-    ) => void;
-    useNativeAnimations?: boolean;
-
-    drawerType?: DrawerType;
-    edgeWidth?: number;
-    minSwipeDistance?: number;
-    hideStatusBar?: boolean;
-    statusBarAnimation?: StatusBarAnimation;
-    overlayColor?: string;
-    contentContainerStyle?: StyleProp<ViewStyle>;
-    enableTrackpadTwoFingerGesture?: boolean;
-  }
-
-  interface DrawerMovementOptionType {
-    velocity?: number;
-  }
-
-  export default class DrawerLayout extends React.Component<DrawerLayoutProperties> {
-    openDrawer: (options?: DrawerMovementOptionType) => void;
-    closeDrawer: (options?: DrawerMovementOptionType) => void;
-  }
-}
diff --git a/node_modules/react-native-gesture-handler/GestureButtons.js b/node_modules/react-native-gesture-handler/GestureButtons.js
deleted file mode 100644
index 68bc2b8..0000000
--- a/node_modules/react-native-gesture-handler/GestureButtons.js
+++ /dev/null
@@ -1,177 +0,0 @@
-import PropTypes from 'prop-types';
-import React from 'react';
-import { Animated, Platform, processColor, StyleSheet } from 'react-native';
-
-import createNativeWrapper from './createNativeWrapper';
-import GestureHandlerButton from './GestureHandlerButton';
-import State from './State';
-
-export const RawButton = createNativeWrapper(GestureHandlerButton, {
-  shouldCancelWhenOutside: false,
-  shouldActivateOnStart: false,
-});
-
-/* Buttons */
-
-export class BaseButton extends React.Component {
-  static propTypes = {
-    ...RawButton.propTypes,
-    onPress: PropTypes.func,
-    onActiveStateChange: PropTypes.func,
-  };
-
-  constructor(props) {
-    super(props);
-    this._lastActive = false;
-  }
-
-  _handleEvent = ({ nativeEvent }) => {
-    const { state, oldState, pointerInside } = nativeEvent;
-    const active = pointerInside && state === State.ACTIVE;
-
-    if (active !== this._lastActive && this.props.onActiveStateChange) {
-      this.props.onActiveStateChange(active);
-    }
-
-    if (
-      oldState === State.ACTIVE &&
-      state !== State.CANCELLED &&
-      this._lastActive &&
-      this.props.onPress
-    ) {
-      this.props.onPress(active);
-    }
-
-    this._lastActive = active;
-  };
-
-  // Normally, the parent would execute it's handler first,
-  // then forward the event to listeners. However, here our handler
-  // is virtually only forwarding events to listeners, so we reverse the order
-  // to keep the proper order of the callbacks (from "raw" ones to "processed").
-  _onHandlerStateChange = e => {
-    this.props.onHandlerStateChange && this.props.onHandlerStateChange(e);
-    this._handleEvent(e);
-  };
-
-  _onGestureEvent = e => {
-    this.props.onGestureEvent && this.props.onGestureEvent(e);
-    this._handleEvent(e);
-  };
-
-  render() {
-    const { rippleColor, ...rest } = this.props;
-
-    return (
-      <RawButton
-        rippleColor={processColor(rippleColor)}
-        {...rest}
-        onGestureEvent={this._onGestureEvent}
-        onHandlerStateChange={this._onHandlerStateChange}
-      />
-    );
-  }
-}
-
-const AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);
-
-const btnStyles = StyleSheet.create({
-  underlay: {
-    position: 'absolute',
-    left: 0,
-    right: 0,
-    bottom: 0,
-    top: 0,
-  },
-});
-
-export class RectButton extends React.Component {
-  static propTypes = BaseButton.propTypes;
-
-  static defaultProps = {
-    activeOpacity: 0.105,
-    underlayColor: 'black',
-  };
-
-  constructor(props) {
-    super(props);
-    this._opacity = new Animated.Value(0);
-  }
-
-  _onActiveStateChange = active => {
-    if (Platform.OS !== 'android') {
-      this._opacity.setValue(active ? this.props.activeOpacity : 0);
-    }
-
-    this.props.onActiveStateChange && this.props.onActiveStateChange(active);
-  };
-
-  render() {
-    const { children, style, ...rest } = this.props;
-
-    const resolvedStyle = StyleSheet.flatten(style ?? {});
-
-    return (
-      <BaseButton
-        {...rest}
-        style={resolvedStyle}
-        onActiveStateChange={this._onActiveStateChange}>
-        <Animated.View
-          style={[
-            btnStyles.underlay,
-            {
-              opacity: this._opacity,
-              backgroundColor: this.props.underlayColor,
-              borderRadius: resolvedStyle.borderRadius,
-              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
-              borderTopRightRadius: resolvedStyle.borderTopRightRadius,
-              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
-              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,
-            },
-          ]}
-        />
-        {children}
-      </BaseButton>
-    );
-  }
-}
-
-export class BorderlessButton extends React.Component {
-  static propTypes = {
-    ...BaseButton.propTypes,
-    borderless: PropTypes.bool,
-  };
-
-  static defaultProps = {
-    activeOpacity: 0.3,
-    borderless: true,
-  };
-
-  constructor(props) {
-    super(props);
-    this._opacity = new Animated.Value(1);
-  }
-
-  _onActiveStateChange = active => {
-    if (Platform.OS !== 'android') {
-      this._opacity.setValue(active ? this.props.activeOpacity : 1);
-    }
-
-    this.props.onActiveStateChange && this.props.onActiveStateChange(active);
-  };
-
-  render() {
-    const { children, style, ...rest } = this.props;
-
-    return (
-      <AnimatedBaseButton
-        {...rest}
-        onActiveStateChange={this._onActiveStateChange}
-        style={[style, Platform.OS === 'ios' && { opacity: this._opacity }]}>
-        {children}
-      </AnimatedBaseButton>
-    );
-  }
-}
-
-export { default as PureNativeButton } from './GestureHandlerButton';
diff --git a/node_modules/react-native-gesture-handler/GestureComponents.js b/node_modules/react-native-gesture-handler/GestureComponents.js
deleted file mode 100644
index b7f2207..0000000
--- a/node_modules/react-native-gesture-handler/GestureComponents.js
+++ /dev/null
@@ -1,58 +0,0 @@
-import React from 'react';
-import ReactNative from 'react-native';
-
-import createNativeWrapper from './createNativeWrapper';
-
-const MEMOIZED = new WeakMap();
-
-function memoizeWrap(Component, config) {
-  if (Component == null) {
-    return null;
-  }
-  let memoized = MEMOIZED.get(Component);
-  if (!memoized) {
-    memoized = createNativeWrapper(Component, config);
-    MEMOIZED.set(Component, memoized);
-  }
-  return memoized;
-}
-
-module.exports = {
-  /* RN's components */
-  get ScrollView() {
-    return memoizeWrap(ReactNative.ScrollView, {
-      disallowInterruption: true,
-      shouldCancelWhenOutside: false,
-    });
-  },
-  get Switch() {
-    return memoizeWrap(ReactNative.Switch, {
-      shouldCancelWhenOutside: false,
-      shouldActivateOnStart: true,
-      disallowInterruption: true,
-    });
-  },
-  get TextInput() {
-    return memoizeWrap(ReactNative.TextInput);
-  },
-  get DrawerLayoutAndroid() {
-    const DrawerLayoutAndroid = memoizeWrap(ReactNative.DrawerLayoutAndroid, {
-      disallowInterruption: true,
-    });
-    DrawerLayoutAndroid.positions = ReactNative.DrawerLayoutAndroid.positions;
-    return DrawerLayoutAndroid;
-  },
-  get FlatList() {
-    if (!MEMOIZED.FlatList) {
-      const ScrollView = this.ScrollView;
-      MEMOIZED.FlatList = React.forwardRef((props, ref) => (
-        <ReactNative.FlatList
-          ref={ref}
-          {...props}
-          renderScrollComponent={scrollProps => <ScrollView {...scrollProps} />}
-        />
-      ));
-    }
-    return MEMOIZED.FlatList;
-  },
-};
diff --git a/node_modules/react-native-gesture-handler/GestureHandler.js b/node_modules/react-native-gesture-handler/GestureHandler.js
deleted file mode 100644
index 1bfc93c..0000000
--- a/node_modules/react-native-gesture-handler/GestureHandler.js
+++ /dev/null
@@ -1,12 +0,0 @@
-export { default as createNativeWrapper } from './createNativeWrapper';
-export { default as Directions } from './Directions';
-export { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';
-export { default as GestureHandlerRootView } from './GestureHandlerRootView';
-export {
-  default as NativeViewGestureHandler,
-} from './NativeViewGestureHandler';
-export { default as State } from './State';
-
-export * from './GestureButtons';
-export * from './GestureComponents';
-export * from './Gestures';
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerButton.js b/node_modules/react-native-gesture-handler/GestureHandlerButton.js
deleted file mode 100644
index 41c5c1a..0000000
--- a/node_modules/react-native-gesture-handler/GestureHandlerButton.js
+++ /dev/null
@@ -1,8 +0,0 @@
-import { requireNativeComponent } from 'react-native';
-
-const RNGestureHandlerButton = requireNativeComponent(
-  'RNGestureHandlerButton',
-  null
-);
-
-export default RNGestureHandlerButton;
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerPropTypes.js b/node_modules/react-native-gesture-handler/GestureHandlerPropTypes.js
deleted file mode 100644
index a8c65db..0000000
--- a/node_modules/react-native-gesture-handler/GestureHandlerPropTypes.js
+++ /dev/null
@@ -1,45 +0,0 @@
-import PropTypes from 'prop-types';
-
-// If changed, add changes to NATIVE_WRAPPER_PROPS_FILTER as well
-const GestureHandlerPropTypes = {
-  id: PropTypes.string,
-  minPointers: PropTypes.number,
-  enabled: PropTypes.bool,
-  waitFor: PropTypes.oneOfType([
-    PropTypes.string,
-    PropTypes.object,
-    PropTypes.arrayOf(
-      PropTypes.oneOfType([PropTypes.string, PropTypes.object])
-    ),
-  ]),
-  simultaneousHandlers: PropTypes.oneOfType([
-    PropTypes.string,
-    PropTypes.object,
-    PropTypes.arrayOf(
-      PropTypes.oneOfType([PropTypes.string, PropTypes.object])
-    ),
-  ]),
-  shouldCancelWhenOutside: PropTypes.bool,
-  hitSlop: PropTypes.oneOfType([
-    PropTypes.number,
-    PropTypes.shape({
-      left: PropTypes.number,
-      top: PropTypes.number,
-      right: PropTypes.number,
-      bottom: PropTypes.number,
-      vertical: PropTypes.number,
-      horizontal: PropTypes.number,
-      width: PropTypes.number,
-      height: PropTypes.number,
-    }),
-  ]),
-  onGestureEvent: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
-  onHandlerStateChange: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
-  onBegan: PropTypes.func,
-  onFailed: PropTypes.func,
-  onCancelled: PropTypes.func,
-  onActivated: PropTypes.func,
-  onEnded: PropTypes.func,
-};
-
-export default GestureHandlerPropTypes;
diff --git a/node_modules/react-native-gesture-handler/Gestures.js b/node_modules/react-native-gesture-handler/Gestures.js
deleted file mode 100644
index 7b66204..0000000
--- a/node_modules/react-native-gesture-handler/Gestures.js
+++ /dev/null
@@ -1,279 +0,0 @@
-import PropTypes from 'prop-types';
-import React from 'react';
-
-import createHandler from './createHandler';
-import GestureHandlerPropTypes from './GestureHandlerPropTypes';
-import PlatformConstants from './PlatformConstants';
-
-export const TapGestureHandler = createHandler(
-  'TapGestureHandler',
-  {
-    ...GestureHandlerPropTypes,
-    maxDurationMs: PropTypes.number,
-    maxDelayMs: PropTypes.number,
-    numberOfTaps: PropTypes.number,
-    maxDeltaX: PropTypes.number,
-    maxDeltaY: PropTypes.number,
-    maxDist: PropTypes.number,
-    minPointers: PropTypes.number,
-  },
-  {}
-);
-
-export const FlingGestureHandler = createHandler(
-  'FlingGestureHandler',
-  {
-    ...GestureHandlerPropTypes,
-    numberOfPointers: PropTypes.number,
-    direction: PropTypes.number,
-  },
-  {}
-);
-
-class ForceTouchFallback extends React.Component {
-  componentDidMount() {
-    console.warn(
-      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'
-    );
-  }
-  render() {
-    return this.props.children;
-  }
-}
-
-export const ForceTouchGestureHandler =
-  PlatformConstants && PlatformConstants.forceTouchAvailable
-    ? createHandler(
-        'ForceTouchGestureHandler',
-        {
-          ...GestureHandlerPropTypes,
-          minForce: PropTypes.number,
-          maxForce: PropTypes.number,
-          feedbackOnActivation: PropTypes.bool,
-        },
-        {}
-      )
-    : ForceTouchFallback;
-
-ForceTouchGestureHandler.forceTouchAvailable =
-  (PlatformConstants && PlatformConstants.forceTouchAvailable) || false;
-
-export const LongPressGestureHandler = createHandler(
-  'LongPressGestureHandler',
-  {
-    ...GestureHandlerPropTypes,
-    minDurationMs: PropTypes.number,
-    maxDist: PropTypes.number,
-  },
-  {}
-);
-
-function validatePanGestureHandlerProps(props) {
-  if (props.minDeltaX && props.activeOffsetX) {
-    throw new Error(
-      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`
-    );
-  }
-  if (props.maxDeltaX && props.failOffsetX) {
-    throw new Error(
-      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`
-    );
-  }
-  if (props.minDeltaY && props.activeOffsetY) {
-    throw new Error(
-      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`
-    );
-  }
-  if (props.maxDeltaY && props.failOffsetY) {
-    throw new Error(
-      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`
-    );
-  }
-  if (
-    Array.isArray(props.activeOffsetX) &&
-    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)
-  ) {
-    throw new Error(
-      `First element of activeOffsetX should be negative, a the second one should be positive`
-    );
-  }
-
-  if (
-    Array.isArray(props.activeOffsetY) &&
-    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)
-  ) {
-    throw new Error(
-      `First element of activeOffsetY should be negative, a the second one should be positive`
-    );
-  }
-
-  if (
-    Array.isArray(props.failOffsetX) &&
-    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)
-  ) {
-    throw new Error(
-      `First element of failOffsetX should be negative, a the second one should be positive`
-    );
-  }
-
-  if (
-    Array.isArray(props.failOffsetY) &&
-    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)
-  ) {
-    throw new Error(
-      `First element of failOffsetY should be negative, a the second one should be positive`
-    );
-  }
-}
-
-function transformPanGestureHandlerProps(props) {
-  const res = { ...props };
-  if (props.minDeltaX !== undefined) {
-    delete res['minDeltaX'];
-    res.activeOffsetXStart = -props.minDeltaX;
-    res.activeOffsetXEnd = props.minDeltaX;
-  }
-  if (props.maxDeltaX !== undefined) {
-    delete res['maxDeltaX'];
-    res.failOffsetXStart = -props.maxDeltaX;
-    res.failOffsetXEnd = props.maxDeltaX;
-  }
-  if (props.minOffsetX !== undefined) {
-    delete res['minOffsetX'];
-    if (props.minOffsetX < 0) {
-      res.activeOffsetXStart = props.minOffsetX;
-    } else {
-      res.activeOffsetXEnd = props.minOffsetX;
-    }
-  }
-
-  if (props.minDeltaY !== undefined) {
-    delete res['minDeltaY'];
-    res.activeOffsetYStart = -props.minDeltaY;
-    res.activeOffsetYEnd = props.minDeltaY;
-  }
-  if (props.maxDeltaY !== undefined) {
-    delete res['maxDeltaY'];
-    res.failOffsetYStart = -props.maxDeltaY;
-    res.failOffsetYEnd = props.maxDeltaY;
-  }
-
-  if (props.minOffsetY !== undefined) {
-    delete res['minOffsetY'];
-    if (props.minOffsetY < 0) {
-      res.activeOffsetYStart = props.minOffsetY;
-    } else {
-      res.activeOffsetYEnd = props.minOffsetY;
-    }
-  }
-
-  if (props.activeOffsetX !== undefined) {
-    delete res['activeOffsetX'];
-    if (Array.isArray(props.activeOffsetX)) {
-      res.activeOffsetXStart = props.activeOffsetX[0];
-      res.activeOffsetXEnd = props.activeOffsetX[1];
-    } else if (props.activeOffsetX < 0) {
-      res.activeOffsetXStart = props.activeOffsetX;
-    } else {
-      res.activeOffsetXEnd = props.activeOffsetX;
-    }
-  }
-
-  if (props.activeOffsetY !== undefined) {
-    delete res['activeOffsetY'];
-    if (Array.isArray(props.activeOffsetY)) {
-      res.activeOffsetYStart = props.activeOffsetY[0];
-      res.activeOffsetYEnd = props.activeOffsetY[1];
-    } else if (props.activeOffsetY < 0) {
-      res.activeOffsetYStart = props.activeOffsetY;
-    } else {
-      res.activeOffsetYEnd = props.activeOffsetY;
-    }
-  }
-
-  if (props.failOffsetX !== undefined) {
-    delete res['failOffsetX'];
-    if (Array.isArray(props.failOffsetX)) {
-      res.failOffsetXStart = props.failOffsetX[0];
-      res.failOffsetXEnd = props.failOffsetX[1];
-    } else if (props.failOffsetX < 0) {
-      res.failOffsetXStart = props.failOffsetX;
-    } else {
-      res.failOffsetXEnd = props.failOffsetX;
-    }
-  }
-
-  if (props.failOffsetY !== undefined) {
-    delete res['failOffsetY'];
-    if (Array.isArray(props.failOffsetY)) {
-      res.failOffsetYStart = props.failOffsetY[0];
-      res.failOffsetYEnd = props.failOffsetY[1];
-    } else if (props.failOffsetY < 0) {
-      res.failOffsetYStart = props.failOffsetY;
-    } else {
-      res.failOffsetYEnd = props.failOffsetY;
-    }
-  }
-
-  return res;
-}
-
-function managePanProps(props) {
-  if (__DEV__) {
-    validatePanGestureHandlerProps(props);
-  }
-  return transformPanGestureHandlerProps(props);
-}
-
-export const PanGestureHandler = createHandler(
-  'PanGestureHandler',
-  {
-    ...GestureHandlerPropTypes,
-    activeOffsetY: PropTypes.oneOfType([
-      PropTypes.number,
-      PropTypes.arrayOf(PropTypes.number),
-    ]),
-    activeOffsetX: PropTypes.oneOfType([
-      PropTypes.number,
-      PropTypes.arrayOf(PropTypes.number),
-    ]),
-    failOffsetY: PropTypes.oneOfType([
-      PropTypes.number,
-      PropTypes.arrayOf(PropTypes.number),
-    ]),
-    failOffsetX: PropTypes.oneOfType([
-      PropTypes.number,
-      PropTypes.arrayOf(PropTypes.number),
-    ]),
-    minDist: PropTypes.number,
-    minVelocity: PropTypes.number,
-    minVelocityX: PropTypes.number,
-    minVelocityY: PropTypes.number,
-    minPointers: PropTypes.number,
-    maxPointers: PropTypes.number,
-    avgTouches: PropTypes.bool,
-    enableTrackpadTwoFingerGesture: PropTypes.bool,
-  },
-  {},
-  managePanProps,
-  {
-    activeOffsetYStart: true,
-    activeOffsetYEnd: true,
-    activeOffsetXStart: true,
-    activeOffsetXEnd: true,
-    failOffsetYStart: true,
-    failOffsetYEnd: true,
-    failOffsetXStart: true,
-    failOffsetXEnd: true,
-  }
-);
-export const PinchGestureHandler = createHandler(
-  'PinchGestureHandler',
-  GestureHandlerPropTypes,
-  {}
-);
-export const RotationGestureHandler = createHandler(
-  'RotationGestureHandler',
-  GestureHandlerPropTypes,
-  {}
-);
diff --git a/node_modules/react-native-gesture-handler/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/NativeViewGestureHandler.js
deleted file mode 100644
index 1ebf04f..0000000
--- a/node_modules/react-native-gesture-handler/NativeViewGestureHandler.js
+++ /dev/null
@@ -1,14 +0,0 @@
-import PropTypes from 'prop-types';
-
-import createHandler from './createHandler';
-import GestureHandlerPropTypes from './GestureHandlerPropTypes';
-
-const NativeViewGestureHandler = createHandler('NativeViewGestureHandler', {
-  ...GestureHandlerPropTypes,
-
-  // If changed, add changes to NATIVE_WRAPPER_PROPS_FILTER as well
-  shouldActivateOnStart: PropTypes.bool,
-  disallowInterruption: PropTypes.bool,
-});
-
-export default NativeViewGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/PlatformConstants.js b/node_modules/react-native-gesture-handler/PlatformConstants.js
deleted file mode 100644
index bfdc61b..0000000
--- a/node_modules/react-native-gesture-handler/PlatformConstants.js
+++ /dev/null
@@ -1,3 +0,0 @@
-import { NativeModules } from 'react-native';
-
-export default NativeModules.PlatformConstants;
diff --git a/node_modules/react-native-gesture-handler/RNGestureHandlerModule.js b/node_modules/react-native-gesture-handler/RNGestureHandlerModule.js
deleted file mode 100644
index 7fed8ce..0000000
--- a/node_modules/react-native-gesture-handler/RNGestureHandlerModule.js
+++ /dev/null
@@ -1,5 +0,0 @@
-import { NativeModules } from 'react-native';
-
-const { RNGestureHandlerModule } = NativeModules;
-
-export default RNGestureHandlerModule;
diff --git a/node_modules/react-native-gesture-handler/State.js b/node_modules/react-native-gesture-handler/State.js
deleted file mode 100644
index 222773e..0000000
--- a/node_modules/react-native-gesture-handler/State.js
+++ /dev/null
@@ -1,19 +0,0 @@
-const State = {
-  UNDETERMINED: 0,
-  FAILED: 1,
-  BEGAN: 2,
-  CANCELLED: 3,
-  ACTIVE: 4,
-  END: 5,
-};
-
-State.print = state => {
-  const keys = Object.keys(State);
-  for (let i = 0; i < keys.length; i++) {
-    if (state === State[keys[i]]) {
-      return keys[i];
-    }
-  }
-};
-
-export default State;
diff --git a/node_modules/react-native-gesture-handler/Swipeable.d.ts b/node_modules/react-native-gesture-handler/Swipeable.d.ts
deleted file mode 100644
index 9c6cba0..0000000
--- a/node_modules/react-native-gesture-handler/Swipeable.d.ts
+++ /dev/null
@@ -1,61 +0,0 @@
-declare module 'react-native-gesture-handler/Swipeable' {
-  import * as React from 'react'
-  import { Animated, StyleProp, ViewStyle } from 'react-native';
-  import { PanGestureHandlerProperties } from 'react-native-gesture-handler'
-  type SwipeableExcludes = Exclude<keyof PanGestureHandlerProperties, 'onGestureEvent' | 'onHandlerStateChange'>
-
-  interface SwipeableProperties extends Pick<PanGestureHandlerProperties, SwipeableExcludes> {
-    enableTrackpadTwoFingerGesture?: boolean;
-    friction?: number;
-    leftThreshold?: number;
-    rightThreshold?: number;
-    overshootLeft?: boolean;
-    overshootRight?: boolean;
-    overshootFriction?: number,
-    onSwipeableLeftOpen?: () => void;
-    onSwipeableRightOpen?: () => void;
-    onSwipeableOpen?: () => void;
-    onSwipeableClose?: () => void;
-    onSwipeableLeftWillOpen?: () => void;
-    onSwipeableRightWillOpen?: () => void;
-    onSwipeableWillOpen?: () => void;
-    onSwipeableWillClose?: () => void;
-    /**
-     *
-     * This map describes the values to use as inputRange for extra interpolation:
-     * AnimatedValue: [startValue, endValue]
-     *
-     * progressAnimatedValue: [0, 1]
-     * dragAnimatedValue: [0, +]
-     *
-     * To support `rtl` flexbox layouts use `flexDirection` styling.
-     * */
-    renderLeftActions?: (
-      progressAnimatedValue: Animated.AnimatedInterpolation,
-      dragAnimatedValue: Animated.AnimatedInterpolation
-    ) => React.ReactNode;
-    /**
-     *
-     * This map describes the values to use as inputRange for extra interpolation:
-     * AnimatedValue: [startValue, endValue]
-     *
-     * progressAnimatedValue: [0, 1]
-     * dragAnimatedValue: [0, -]
-     *
-     * To support `rtl` flexbox layouts use `flexDirection` styling.
-     * */
-    renderRightActions?: (
-      progressAnimatedValue: Animated.AnimatedInterpolation,
-      dragAnimatedValue: Animated.AnimatedInterpolation
-    ) => React.ReactNode;
-    useNativeAnimations?: boolean;
-    containerStyle?: StyleProp<ViewStyle>;
-    childrenContainerStyle?: StyleProp<ViewStyle>;
-  }
-
-  export default class Swipeable extends React.Component<SwipeableProperties> {
-    close: () => void;
-    openLeft: () => void;
-    openRight: () => void;
-  }
-}
diff --git a/node_modules/react-native-gesture-handler/__mocks__/RNGestureHandlerModule.js b/node_modules/react-native-gesture-handler/__mocks__/RNGestureHandlerModule.js
deleted file mode 100644
index 2df6a09..0000000
--- a/node_modules/react-native-gesture-handler/__mocks__/RNGestureHandlerModule.js
+++ /dev/null
@@ -1,17 +0,0 @@
-import { View, ScrollView } from 'react-native'
-
-export default {
-  ScrollView,
-  PanGestureHandler: View,
-  attachGestureHandler: () => {},
-  createGestureHandler: () => {},
-  dropGestureHandler: () => {},
-  updateGestureHandler: () => {},
-  Direction: {
-    RIGHT: 1,
-    LEFT: 2,
-    UP: 4,
-    DOWN: 8,
-  },
-  State: { BEGAN: 'BEGAN', FAILED: 'FAILED', ACTIVE: 'ACTIVE', END: 'END', UNDETERMINED: 'UNDETERMINED' },
-};
diff --git a/node_modules/react-native-gesture-handler/createHandler.js b/node_modules/react-native-gesture-handler/createHandler.js
deleted file mode 100644
index d45a9a3..0000000
--- a/node_modules/react-native-gesture-handler/createHandler.js
+++ /dev/null
@@ -1,375 +0,0 @@
-import React from 'react';
-import {
-  findNodeHandle as findNodeHandleRN,
-  NativeModules,
-  Touchable,
-  Platform,
-} from 'react-native';
-import deepEqual from 'fbjs/lib/areEqual';
-import RNGestureHandlerModule from './RNGestureHandlerModule';
-import State from './State';
-
-function findNodeHandle(node) {
-  if (Platform.OS === 'web') return node;
-  return findNodeHandleRN(node);
-}
-
-const { UIManager = {} } = NativeModules;
-
-const customGHEventsConfig = {
-  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },
-  onGestureHandlerStateChange: {
-    registrationName: 'onGestureHandlerStateChange',
-  },
-};
-
-// Add gesture specific events to genericDirectEventTypes object exported from UIManager
-// native module.
-// Once new event types are registered with react it is possible to dispatch these
-// events to all kind of native views.
-UIManager.genericDirectEventTypes = {
-  ...UIManager.genericDirectEventTypes,
-  ...customGHEventsConfig,
-};
-// In newer versions of RN the `genericDirectEventTypes` is located in the object
-// returned by UIManager.getConstants(), we need to add it there as well to make
-// it compatible with RN 61+
-if (UIManager.getConstants) {
-  UIManager.getConstants().genericDirectEventTypes = {
-    ...UIManager.getConstants().genericDirectEventTypes,
-    ...customGHEventsConfig,
-  };
-}
-
-// Wrap JS responder calls and notify gesture handler manager
-const {
-  setJSResponder: oldSetJSResponder = () => {},
-  clearJSResponder: oldClearJSResponder = () => {},
-} = UIManager;
-UIManager.setJSResponder = (tag, blockNativeResponder) => {
-  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);
-  oldSetJSResponder(tag, blockNativeResponder);
-};
-UIManager.clearJSResponder = () => {
-  RNGestureHandlerModule.handleClearJSResponder();
-  oldClearJSResponder();
-};
-
-let handlerTag = 1;
-const handlerIDToTag = {};
-
-function isConfigParam(param, name) {
-  // param !== Object(param) returns false if `param` is a function
-  // or an object and returns true if `param` is null
-  return (
-    param !== undefined &&
-    (param !== Object(param) || !('__isNative' in param)) &&
-    name !== 'onHandlerStateChange' &&
-    name !== 'onGestureEvent'
-  );
-}
-
-function filterConfig(props, validProps, defaults = {}) {
-  const res = { ...defaults };
-  Object.keys(validProps).forEach(key => {
-    const value = props[key];
-    if (isConfigParam(value, key)) {
-      let value = props[key];
-      if (key === 'simultaneousHandlers' || key === 'waitFor') {
-        value = transformIntoHandlerTags(props[key]);
-      } else if (key === 'hitSlop') {
-        if (typeof value !== 'object') {
-          value = { top: value, left: value, bottom: value, right: value };
-        }
-      }
-      res[key] = value;
-    }
-  });
-  return res;
-}
-
-function transformIntoHandlerTags(handlerIDs) {
-  if (!Array.isArray(handlerIDs)) {
-    handlerIDs = [handlerIDs];
-  }
-
-  if (Platform.OS === 'web') {
-    return handlerIDs.map(({ current }) => current).filter(handle => handle);
-  }
-  // converts handler string IDs into their numeric tags
-  return handlerIDs
-    .map(
-      handlerID =>
-        handlerIDToTag[handlerID] ||
-        (handlerID.current && handlerID.current._handlerTag) ||
-        -1
-    )
-    .filter(handlerTag => handlerTag > 0);
-}
-
-function hasUnresolvedRefs(props) {
-  const extract = refs => {
-    if (!Array.isArray(refs)) {
-      return refs && refs.current === null;
-    }
-    return refs.some(r => r && r.current === null);
-  };
-  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);
-}
-
-const stateToPropMappings = {
-  [State.BEGAN]: 'onBegan',
-  [State.FAILED]: 'onFailed',
-  [State.CANCELLED]: 'onCancelled',
-  [State.ACTIVE]: 'onActivated',
-  [State.END]: 'onEnded',
-};
-
-export default function createHandler(
-  handlerName,
-  propTypes = {},
-  config = {},
-  transformProps,
-  customNativeProps = {}
-) {
-  class Handler extends React.Component {
-    static displayName = handlerName;
-
-    static propTypes = propTypes;
-
-    constructor(props) {
-      super(props);
-      this._handlerTag = handlerTag++;
-      this._config = {};
-      this._propsRef = React.createRef(props);
-
-      if (props.id) {
-        if (handlerIDToTag[props.id] !== undefined) {
-          throw new Error(`Handler with ID "${props.id}" already registered`);
-        }
-        handlerIDToTag[props.id] = this._handlerTag;
-      }
-    }
-
-    _onGestureHandlerEvent = event => {
-      if (event.nativeEvent.handlerTag === this._handlerTag) {
-        this.props.onGestureEvent && this.props.onGestureEvent(event);
-      } else {
-        this.props.onGestureHandlerEvent &&
-          this.props.onGestureHandlerEvent(event);
-      }
-    };
-
-    _onGestureHandlerStateChange = event => {
-      if (event.nativeEvent.handlerTag === this._handlerTag) {
-        this.props.onHandlerStateChange &&
-          this.props.onHandlerStateChange(event);
-
-        const stateEventName = stateToPropMappings[event.nativeEvent.state];
-        if (typeof this.props[stateEventName] === 'function') {
-          this.props[stateEventName](event);
-        }
-      } else {
-        this.props.onGestureHandlerStateChange &&
-          this.props.onGestureHandlerStateChange(event);
-      }
-    };
-
-    _refHandler = node => {
-      this._viewNode = node;
-
-      const child = React.Children.only(this.props.children);
-      const { ref } = child;
-      if (ref !== null) {
-        if (typeof ref === 'function') {
-          ref(node);
-        } else {
-          ref.current = node;
-        }
-      }
-    };
-
-    _createGestureHandler = newConfig => {
-      this._config = newConfig;
-
-      RNGestureHandlerModule.createGestureHandler(
-        handlerName,
-        this._handlerTag,
-        newConfig
-      );
-    };
-
-    _attachGestureHandler = newViewTag => {
-      this._viewTag = newViewTag;
-
-      if (Platform.OS === 'web') {
-        RNGestureHandlerModule.attachGestureHandler(
-          this._handlerTag,
-          newViewTag,
-          this._propsRef
-        );
-      } else {
-        RNGestureHandlerModule.attachGestureHandler(
-          this._handlerTag,
-          newViewTag
-        );
-      }
-    };
-
-    _updateGestureHandler = newConfig => {
-      this._config = newConfig;
-
-      RNGestureHandlerModule.updateGestureHandler(this._handlerTag, newConfig);
-    };
-
-    componentWillUnmount() {
-      RNGestureHandlerModule.dropGestureHandler(this._handlerTag);
-      if (this._updateEnqueued) {
-        clearImmediate(this._updateEnqueued);
-      }
-      if (this.props.id) {
-        delete handlerIDToTag[this.props.id];
-      }
-    }
-
-    componentDidMount() {
-      if (hasUnresolvedRefs(this.props)) {
-        // If there are unresolved refs (e.g. ".current" has not yet been set)
-        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to
-        // _update method that will try to update native handler props using
-        // setImmediate. This makes it so _update function gets called after all
-        // react components are mounted and we expect the missing ref object to
-        // be resolved by then.
-        this._updateEnqueued = setImmediate(() => {
-          this._updateEnqueued = null;
-          this._update();
-        });
-      }
-
-      this._createGestureHandler(
-        filterConfig(
-          transformProps ? transformProps(this.props) : this.props,
-          {
-            ...(this.constructor.propTypes || propTypes),
-            ...customNativeProps,
-          },
-          config
-        )
-      );
-
-      this._attachGestureHandler(findNodeHandle(this._viewNode));
-    }
-
-    componentDidUpdate() {
-      const viewTag = findNodeHandle(this._viewNode);
-      if (this._viewTag !== viewTag) {
-        this._attachGestureHandler(viewTag);
-      }
-      this._update();
-    }
-
-    _update() {
-      const newConfig = filterConfig(
-        transformProps ? transformProps(this.props) : this.props,
-        { ...(this.constructor.propTypes || propTypes), ...customNativeProps },
-        config
-      );
-      if (!deepEqual(this._config, newConfig)) {
-        this._updateGestureHandler(newConfig);
-      }
-    }
-
-    setNativeProps(updates) {
-      const mergedProps = { ...this.props, ...updates };
-      const newConfig = filterConfig(
-        transformProps ? transformProps(mergedProps) : mergedProps,
-        { ...(this.constructor.propTypes || propTypes), ...customNativeProps },
-        config
-      );
-      this._updateGestureHandler(newConfig);
-    }
-
-    render() {
-      let gestureEventHandler = this._onGestureHandlerEvent;
-      const { onGestureEvent, onGestureHandlerEvent } = this.props;
-      if (onGestureEvent && typeof onGestureEvent !== 'function') {
-        // If it's not a method it should be an native Animated.event
-        // object. We set it directly as the handler for the view
-        // In this case nested handlers are not going to be supported
-        if (onGestureHandlerEvent) {
-          throw new Error(
-            'Nesting touch handlers with native animated driver is not supported yet'
-          );
-        }
-        gestureEventHandler = this.props.onGestureEvent;
-      } else {
-        if (
-          onGestureHandlerEvent &&
-          typeof onGestureHandlerEvent !== 'function'
-        ) {
-          throw new Error(
-            'Nesting touch handlers with native animated driver is not supported yet'
-          );
-        }
-      }
-
-      let gestureStateEventHandler = this._onGestureHandlerStateChange;
-      const { onHandlerStateChange, onGestureHandlerStateChange } = this.props;
-      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {
-        // If it's not a method it should be an native Animated.event
-        // object. We set it directly as the handler for the view
-        // In this case nested handlers are not going to be supported
-        if (onGestureHandlerStateChange) {
-          throw new Error(
-            'Nesting touch handlers with native animated driver is not supported yet'
-          );
-        }
-        gestureStateEventHandler = this.props.onHandlerStateChange;
-      } else {
-        if (
-          onGestureHandlerStateChange &&
-          typeof onGestureHandlerStateChange !== 'function'
-        ) {
-          throw new Error(
-            'Nesting touch handlers with native animated driver is not supported yet'
-          );
-        }
-      }
-      const events = {
-        onGestureHandlerEvent: gestureEventHandler,
-        onGestureHandlerStateChange: gestureStateEventHandler,
-      };
-
-      this._propsRef.current = events;
-
-      const child = React.Children.only(this.props.children);
-      let grandChildren = child.props.children;
-      if (
-        Touchable.TOUCH_TARGET_DEBUG &&
-        child.type &&
-        (child.type === 'RNGestureHandlerButton' ||
-          child.type.name === 'View' ||
-          child.type.displayName === 'View')
-      ) {
-        grandChildren = React.Children.toArray(grandChildren);
-        grandChildren.push(
-          Touchable.renderDebugView({
-            color: 'mediumspringgreen',
-            hitSlop: child.props.hitSlop,
-          })
-        );
-      }
-
-      return React.cloneElement(
-        child,
-        {
-          ref: this._refHandler,
-          collapsable: false,
-          ...events,
-        },
-        grandChildren
-      );
-    }
-  }
-  return Handler;
-}
diff --git a/node_modules/react-native-gesture-handler/createNativeWrapper.js b/node_modules/react-native-gesture-handler/createNativeWrapper.js
deleted file mode 100644
index 2bce140..0000000
--- a/node_modules/react-native-gesture-handler/createNativeWrapper.js
+++ /dev/null
@@ -1,58 +0,0 @@
-import React from 'react';
-
-import NativeViewGestureHandler from './NativeViewGestureHandler';
-
-/*
- * This array should consist of:
- *   - All keys in propTypes from NativeGestureHandler
- *     (and all keys in GestureHandlerPropTypes)
- *   - 'onGestureHandlerEvent'
- *   - 'onGestureHandlerStateChange'
- */
-const NATIVE_WRAPPER_PROPS_FILTER = [
-  'id',
-  'minPointers',
-  'enabled',
-  'waitFor',
-  'simultaneousHandlers',
-  'shouldCancelWhenOutside',
-  'hitSlop',
-  'onGestureEvent',
-  'onHandlerStateChange',
-  'onBegan',
-  'onFailed',
-  'onCancelled',
-  'onActivated',
-  'onEnded',
-  'shouldActivateOnStart',
-  'disallowInterruption',
-  'onGestureHandlerEvent',
-  'onGestureHandlerStateChange',
-];
-
-export default function createNativeWrapper(Component, config = {}) {
-  const ComponentWrapper = React.forwardRef((props, ref) => {
-    // filter out props that should be passed to gesture handler wrapper
-    const gestureHandlerProps = Object.keys(props).reduce(
-      (res, key) => {
-        if (NATIVE_WRAPPER_PROPS_FILTER.indexOf(key) !== -1) {
-          res[key] = props[key];
-        }
-        return res;
-      },
-      { ...config } // watch out not to modify config
-    );
-    return (
-      <NativeViewGestureHandler {...gestureHandlerProps}>
-        <Component {...props} ref={ref} />
-      </NativeViewGestureHandler>
-    );
-  });
-
-  ComponentWrapper.propTypes = {
-    ...Component.propTypes,
-  };
-  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';
-
-  return ComponentWrapper;
-}
diff --git a/node_modules/react-native-gesture-handler/index.js b/node_modules/react-native-gesture-handler/index.js
deleted file mode 100644
index 3314650..0000000
--- a/node_modules/react-native-gesture-handler/index.js
+++ /dev/null
@@ -1,4 +0,0 @@
-export { default as Swipeable } from './Swipeable';
-export { default as DrawerLayout } from './DrawerLayout';
-export * from './GestureHandler';
-export * from './touchables';
diff --git a/node_modules/react-native-gesture-handler/ios/Handlers/RNPanHandler.m b/node_modules/react-native-gesture-handler/ios/Handlers/RNPanHandler.m
index cc3ae3c..12313ab 100644
--- a/node_modules/react-native-gesture-handler/ios/Handlers/RNPanHandler.m
+++ b/node_modules/react-native-gesture-handler/ios/Handlers/RNPanHandler.m
@@ -206,6 +206,7 @@
   APPLY_FLOAT_PROP(failOffsetYStart);
   APPLY_FLOAT_PROP(failOffsetYEnd);
 
+#if !TARGET_OS_TV && __IPHONE_OS_VERSION_MAX_ALLOWED >= 130400
   if (@available(iOS 13.4, *)) {
     bool enableTrackpadTwoFingerGesture = [RCTConvert BOOL:config[@"enableTrackpadTwoFingerGesture"]];
     if(enableTrackpadTwoFingerGesture){
@@ -213,7 +214,6 @@
     }
   }
 
-#if !TARGET_OS_TV
   APPLY_NAMED_INT_PROP(minimumNumberOfTouches, @"minPointers");
   APPLY_NAMED_INT_PROP(maximumNumberOfTouches, @"maxPointers");
 #endif
diff --git a/node_modules/react-native-gesture-handler/ios/RNGestureHandlerManager.m b/node_modules/react-native-gesture-handler/ios/RNGestureHandlerManager.m
index 3a1db65..517c9b9 100644
--- a/node_modules/react-native-gesture-handler/ios/RNGestureHandlerManager.m
+++ b/node_modules/react-native-gesture-handler/ios/RNGestureHandlerManager.m
@@ -40,7 +40,7 @@
 {
     RNGestureHandlerRegistry *_registry;
     RCTUIManager *_uiManager;
-    NSMutableSet<UIView*> *_rootViews;
+    NSHashTable<UIView *> *_rootViews;
     RCTEventDispatcher *_eventDispatcher;
 }
 
@@ -51,7 +51,7 @@
         _uiManager = uiManager;
         _eventDispatcher = eventDispatcher;
         _registry = [RNGestureHandlerRegistry new];
-        _rootViews = [NSMutableSet new];
+        _rootViews = [NSHashTable hashTableWithOptions:NSPointerFunctionsWeakMemory];
     }
     return self;
 }
diff --git a/node_modules/react-native-gesture-handler/jestSetup.js b/node_modules/react-native-gesture-handler/jestSetup.js
index 5811e8d..64b9fab 100644
--- a/node_modules/react-native-gesture-handler/jestSetup.js
+++ b/node_modules/react-native-gesture-handler/jestSetup.js
@@ -1 +1,7 @@
-jest.mock('./RNGestureHandlerModule');
+jest.mock('./src/RNGestureHandlerModule', () => require('./src/mocks'));
+jest.mock('./lib/commonjs/RNGestureHandlerModule', () =>
+  require('./lib/commonjs/mocks')
+);
+jest.mock('./lib/module/RNGestureHandlerModule', () =>
+  require('./lib/module/mocks')
+);
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js b/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js
new file mode 100644
index 0000000..0a648c8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js
@@ -0,0 +1,15 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.Directions = void 0;
+const Directions = {
+  RIGHT: 1,
+  LEFT: 2,
+  UP: 4,
+  DOWN: 8
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+
+exports.Directions = Directions;
+//# sourceMappingURL=Directions.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js.map
new file mode 100644
index 0000000..b2d0f8d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/Directions.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Directions.ts"],"names":["Directions","RIGHT","LEFT","UP","DOWN"],"mappings":";;;;;;AAAO,MAAMA,UAAU,GAAG;AACxBC,EAAAA,KAAK,EAAE,CADiB;AAExBC,EAAAA,IAAI,EAAE,CAFkB;AAGxBC,EAAAA,EAAE,EAAE,CAHoB;AAIxBC,EAAAA,IAAI,EAAE;AAJkB,CAAnB,C,CAOP","sourcesContent":["export const Directions = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type Directions = typeof Directions[keyof typeof Directions];\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js
new file mode 100644
index 0000000..21977d5
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js
@@ -0,0 +1,36 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = GestureHandlerRootView;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+const GestureHandlerRootViewNative = (0, _reactNative.requireNativeComponent)('GestureHandlerRootView');
+const GestureHandlerRootViewContext = /*#__PURE__*/React.createContext(false);
+
+function GestureHandlerRootView({
+  children,
+  ...rest
+}) {
+  return /*#__PURE__*/React.createElement(GestureHandlerRootViewContext.Consumer, null, available => {
+    if (available) {
+      // If we already have a parent wrapped in the gesture handler root view,
+      // We don't need to wrap it again in root view
+      // We still wrap it in a normal view so our styling stays the same
+      return /*#__PURE__*/React.createElement(_reactNative.View, rest, children);
+    }
+
+    return /*#__PURE__*/React.createElement(GestureHandlerRootViewContext.Provider, {
+      value: true
+    }, /*#__PURE__*/React.createElement(GestureHandlerRootViewNative, rest, children));
+  });
+}
+//# sourceMappingURL=GestureHandlerRootView.android.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js.map
new file mode 100644
index 0000000..5bfa550
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.android.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerRootView.android.tsx"],"names":["GestureHandlerRootViewNative","GestureHandlerRootViewContext","React","createContext","GestureHandlerRootView","children","rest","available"],"mappings":";;;;;;;AAAA;;AAEA;;;;;;AAEA,MAAMA,4BAA4B,GAAG,yCACnC,wBADmC,CAArC;AAIA,MAAMC,6BAA6B,gBAAGC,KAAK,CAACC,aAAN,CAAoB,KAApB,CAAtC;;AAIe,SAASC,sBAAT,CAAgC;AAAEC,EAAAA,QAAF;AAAY,KAAGC;AAAf,CAAhC,EAA8D;AAC3E,sBACE,oBAAC,6BAAD,CAA+B,QAA/B,QACIC,SAAD,IAAe;AACd,QAAIA,SAAJ,EAAe;AACb;AACA;AACA;AACA,0BAAO,oBAAC,iBAAD,EAAUD,IAAV,EAAiBD,QAAjB,CAAP;AACD;;AAED,wBACE,oBAAC,6BAAD,CAA+B,QAA/B;AAAwC,MAAA,KAAK;AAA7C,oBACE,oBAAC,4BAAD,EAAkCC,IAAlC,EACGD,QADH,CADF,CADF;AAOD,GAhBH,CADF;AAoBD","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport { View, requireNativeComponent } from 'react-native';\n\nconst GestureHandlerRootViewNative = requireNativeComponent(\n  'GestureHandlerRootView'\n);\n\nconst GestureHandlerRootViewContext = React.createContext(false);\n\ntype Props = PropsWithChildren<Record<string, unknown>>;\n\nexport default function GestureHandlerRootView({ children, ...rest }: Props) {\n  return (\n    <GestureHandlerRootViewContext.Consumer>\n      {(available) => {\n        if (available) {\n          // If we already have a parent wrapped in the gesture handler root view,\n          // We don't need to wrap it again in root view\n          // We still wrap it in a normal view so our styling stays the same\n          return <View {...rest}>{children}</View>;\n        }\n\n        return (\n          <GestureHandlerRootViewContext.Provider value>\n            <GestureHandlerRootViewNative {...rest}>\n              {children}\n            </GestureHandlerRootViewNative>\n          </GestureHandlerRootViewContext.Provider>\n        );\n      }}\n    </GestureHandlerRootViewContext.Consumer>\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js
new file mode 100644
index 0000000..f0d952f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js
@@ -0,0 +1,12 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var _default = _reactNative.View;
+exports.default = _default;
+//# sourceMappingURL=GestureHandlerRootView.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js.map
new file mode 100644
index 0000000..94d90b2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/GestureHandlerRootView.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerRootView.tsx"],"names":["View"],"mappings":";;;;;;;AAAA;;eAEeA,iB","sourcesContent":["import { View } from 'react-native';\n\nexport default View;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js
new file mode 100644
index 0000000..ae71268
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js
@@ -0,0 +1,15 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var _NativeModules$Platfo;
+
+var _default = (_NativeModules$Platfo = _reactNative.NativeModules === null || _reactNative.NativeModules === void 0 ? void 0 : _reactNative.NativeModules.PlatformConstants) !== null && _NativeModules$Platfo !== void 0 ? _NativeModules$Platfo : _reactNative.Platform.constants;
+
+exports.default = _default;
+//# sourceMappingURL=PlatformConstants.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js.map
new file mode 100644
index 0000000..934a9b9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PlatformConstants.ts"],"names":["NativeModules","PlatformConstants","Platform","constants"],"mappings":";;;;;;;AAAA;;;;wCAMgBA,0B,aAAAA,0B,uBAAAA,2BAAeC,iB,yEAC7BC,sBAASC,S","sourcesContent":["import { NativeModules, Platform } from 'react-native';\n\ntype PlatformConstants = {\n  forceTouchAvailable: boolean;\n};\n\nexport default (NativeModules?.PlatformConstants ??\n  Platform.constants) as PlatformConstants;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js
new file mode 100644
index 0000000..d45ae5b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js
@@ -0,0 +1,14 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _default = {
+  get forceTouchAvailable() {
+    return false;
+  }
+
+};
+exports.default = _default;
+//# sourceMappingURL=PlatformConstants.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js.map
new file mode 100644
index 0000000..7d37762
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/PlatformConstants.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PlatformConstants.web.ts"],"names":["forceTouchAvailable"],"mappings":";;;;;;eAAe;AACb,MAAIA,mBAAJ,GAA0B;AACxB,WAAO,KAAP;AACD;;AAHY,C","sourcesContent":["export default {\n  get forceTouchAvailable() {\n    return false;\n  },\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js
new file mode 100644
index 0000000..a0e407f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js
@@ -0,0 +1,20 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+const {
+  RNGestureHandlerModule
+} = _reactNative.NativeModules;
+
+if (RNGestureHandlerModule == null) {
+  console.error("react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).\n\n    For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation".split('\n').map(line => line.trim()).join('\n'));
+}
+
+var _default = RNGestureHandlerModule;
+exports.default = _default;
+//# sourceMappingURL=RNGestureHandlerModule.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js.map
new file mode 100644
index 0000000..1038281
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RNGestureHandlerModule.ts"],"names":["RNGestureHandlerModule","NativeModules","console","error","split","map","line","trim","join"],"mappings":";;;;;;;AAAA;;AACA,MAAM;AAAEA,EAAAA;AAAF,IAA6BC,0BAAnC;;AAEA,IAAID,sBAAsB,IAAI,IAA9B,EAAoC;AAClCE,EAAAA,OAAO,CAACC,KAAR,CACE,kTAGGC,KAHH,CAGS,IAHT,EAIGC,GAJH,CAIQC,IAAD,IAAUA,IAAI,CAACC,IAAL,EAJjB,EAKGC,IALH,CAKQ,IALR,CADF;AAQD;;eAkBcR,sB","sourcesContent":["import { NativeModules } from 'react-native';\nconst { RNGestureHandlerModule } = NativeModules;\n\nif (RNGestureHandlerModule == null) {\n  console.error(\n    `react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).\n\n    For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation`\n      .split('\\n')\n      .map((line) => line.trim())\n      .join('\\n')\n  );\n}\n\nexport type RNGestureHandlerModuleProps = {\n  handleSetJSResponder: (tag: number, blockNativeResponder: boolean) => void;\n  handleClearJSResponder: () => void;\n  createGestureHandler: (\n    handlerName: string,\n    handlerTag: number,\n    config: Readonly<Record<string, unknown>>\n  ) => void;\n  attachGestureHandler: (handlerTag: number, newView: number) => void;\n  updateGestureHandler: (\n    handlerTag: number,\n    newConfig: Readonly<Record<string, unknown>>\n  ) => void;\n  dropGestureHandler: (handlerTag: number) => void;\n};\n\nexport default RNGestureHandlerModule as RNGestureHandlerModuleProps;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js
new file mode 100644
index 0000000..c09ddd5
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js
@@ -0,0 +1,80 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.Gestures = void 0;
+
+var _constants = require("./web/constants");
+
+var _FlingGestureHandler = _interopRequireDefault(require("./web/FlingGestureHandler"));
+
+var _LongPressGestureHandler = _interopRequireDefault(require("./web/LongPressGestureHandler"));
+
+var _NativeViewGestureHandler = _interopRequireDefault(require("./web/NativeViewGestureHandler"));
+
+var NodeManager = _interopRequireWildcard(require("./web/NodeManager"));
+
+var _PanGestureHandler = _interopRequireDefault(require("./web/PanGestureHandler"));
+
+var _PinchGestureHandler = _interopRequireDefault(require("./web/PinchGestureHandler"));
+
+var _RotationGestureHandler = _interopRequireDefault(require("./web/RotationGestureHandler"));
+
+var _TapGestureHandler = _interopRequireDefault(require("./web/TapGestureHandler"));
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+const Gestures = {
+  PanGestureHandler: _PanGestureHandler.default,
+  RotationGestureHandler: _RotationGestureHandler.default,
+  PinchGestureHandler: _PinchGestureHandler.default,
+  TapGestureHandler: _TapGestureHandler.default,
+  NativeViewGestureHandler: _NativeViewGestureHandler.default,
+  LongPressGestureHandler: _LongPressGestureHandler.default,
+  FlingGestureHandler: _FlingGestureHandler.default // ForceTouchGestureHandler,
+
+};
+exports.Gestures = Gestures;
+var _default = {
+  Direction: _constants.Direction,
+
+  handleSetJSResponder(tag, blockNativeResponder) {
+    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);
+  },
+
+  handleClearJSResponder() {
+    console.warn('handleClearJSResponder: ');
+  },
+
+  createGestureHandler(handlerName, handlerTag, config) {
+    //TODO(TS) extends config
+    if (!(handlerName in Gestures)) throw new Error("react-native-gesture-handler: ".concat(handlerName, " is not supported on web."));
+    const GestureClass = Gestures[handlerName];
+    NodeManager.createGestureHandler(handlerTag, new GestureClass());
+    this.updateGestureHandler(handlerTag, config);
+  },
+
+  attachGestureHandler(handlerTag, newView, propsRef) {
+    NodeManager.getHandler(handlerTag).setView(newView, propsRef);
+  },
+
+  updateGestureHandler(handlerTag, newConfig) {
+    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);
+  },
+
+  getGestureHandlerNode(handlerTag) {
+    return NodeManager.getHandler(handlerTag);
+  },
+
+  dropGestureHandler(handlerTag) {
+    NodeManager.dropGestureHandler(handlerTag);
+  }
+
+};
+exports.default = _default;
+//# sourceMappingURL=RNGestureHandlerModule.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js.map
new file mode 100644
index 0000000..83f5d21
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/RNGestureHandlerModule.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RNGestureHandlerModule.web.ts"],"names":["Gestures","PanGestureHandler","RotationGestureHandler","PinchGestureHandler","TapGestureHandler","NativeViewGestureHandler","LongPressGestureHandler","FlingGestureHandler","Direction","handleSetJSResponder","tag","blockNativeResponder","console","warn","handleClearJSResponder","createGestureHandler","handlerName","handlerTag","config","Error","GestureClass","NodeManager","updateGestureHandler","attachGestureHandler","newView","propsRef","getHandler","setView","newConfig","updateGestureConfig","getGestureHandlerNode","dropGestureHandler"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;AAEO,MAAMA,QAAQ,GAAG;AACtBC,EAAAA,iBAAiB,EAAjBA,0BADsB;AAEtBC,EAAAA,sBAAsB,EAAtBA,+BAFsB;AAGtBC,EAAAA,mBAAmB,EAAnBA,4BAHsB;AAItBC,EAAAA,iBAAiB,EAAjBA,0BAJsB;AAKtBC,EAAAA,wBAAwB,EAAxBA,iCALsB;AAMtBC,EAAAA,uBAAuB,EAAvBA,gCANsB;AAOtBC,EAAAA,mBAAmB,EAAnBA,4BAPsB,CAQtB;;AARsB,CAAjB;;eAWQ;AACbC,EAAAA,SAAS,EAATA,oBADa;;AAEbC,EAAAA,oBAAoB,CAACC,GAAD,EAAcC,oBAAd,EAA6C;AAC/DC,IAAAA,OAAO,CAACC,IAAR,CAAa,wBAAb,EAAuCH,GAAvC,EAA4CC,oBAA5C;AACD,GAJY;;AAKbG,EAAAA,sBAAsB,GAAG;AACvBF,IAAAA,OAAO,CAACC,IAAR,CAAa,0BAAb;AACD,GAPY;;AAQbE,EAAAA,oBAAoB,CAClBC,WADkB,EAElBC,UAFkB,EAGlBC,MAHkB,EAIlB;AACA;AACA,QAAI,EAAEF,WAAW,IAAIhB,QAAjB,CAAJ,EACE,MAAM,IAAImB,KAAJ,yCAC6BH,WAD7B,+BAAN;AAGF,UAAMI,YAAY,GAAGpB,QAAQ,CAACgB,WAAD,CAA7B;AACAK,IAAAA,WAAW,CAACN,oBAAZ,CAAiCE,UAAjC,EAA6C,IAAIG,YAAJ,EAA7C;AACA,SAAKE,oBAAL,CAA0BL,UAA1B,EAAsCC,MAAtC;AACD,GArBY;;AAsBbK,EAAAA,oBAAoB,CAClBN,UADkB,EAElBO,OAFkB,EAGlBC,QAHkB,EAIlB;AACAJ,IAAAA,WAAW,CAACK,UAAZ,CAAuBT,UAAvB,EAAmCU,OAAnC,CAA2CH,OAA3C,EAAoDC,QAApD;AACD,GA5BY;;AA6BbH,EAAAA,oBAAoB,CAACL,UAAD,EAAqBW,SAArB,EAAqC;AACvDP,IAAAA,WAAW,CAACK,UAAZ,CAAuBT,UAAvB,EAAmCY,mBAAnC,CAAuDD,SAAvD;AACD,GA/BY;;AAgCbE,EAAAA,qBAAqB,CAACb,UAAD,EAAqB;AACxC,WAAOI,WAAW,CAACK,UAAZ,CAAuBT,UAAvB,CAAP;AACD,GAlCY;;AAmCbc,EAAAA,kBAAkB,CAACd,UAAD,EAAqB;AACrCI,IAAAA,WAAW,CAACU,kBAAZ,CAA+Bd,UAA/B;AACD;;AArCY,C","sourcesContent":["import { Direction } from './web/constants';\nimport FlingGestureHandler from './web/FlingGestureHandler';\nimport LongPressGestureHandler from './web/LongPressGestureHandler';\nimport NativeViewGestureHandler from './web/NativeViewGestureHandler';\nimport * as NodeManager from './web/NodeManager';\nimport PanGestureHandler from './web/PanGestureHandler';\nimport PinchGestureHandler from './web/PinchGestureHandler';\nimport RotationGestureHandler from './web/RotationGestureHandler';\nimport TapGestureHandler from './web/TapGestureHandler';\n\nexport const Gestures = {\n  PanGestureHandler,\n  RotationGestureHandler,\n  PinchGestureHandler,\n  TapGestureHandler,\n  NativeViewGestureHandler,\n  LongPressGestureHandler,\n  FlingGestureHandler,\n  // ForceTouchGestureHandler,\n};\n\nexport default {\n  Direction,\n  handleSetJSResponder(tag: number, blockNativeResponder: boolean) {\n    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);\n  },\n  handleClearJSResponder() {\n    console.warn('handleClearJSResponder: ');\n  },\n  createGestureHandler<T>(\n    handlerName: keyof typeof Gestures,\n    handlerTag: number,\n    config: T\n  ) {\n    //TODO(TS) extends config\n    if (!(handlerName in Gestures))\n      throw new Error(\n        `react-native-gesture-handler: ${handlerName} is not supported on web.`\n      );\n    const GestureClass = Gestures[handlerName];\n    NodeManager.createGestureHandler(handlerTag, new GestureClass());\n    this.updateGestureHandler(handlerTag, config);\n  },\n  attachGestureHandler(\n    handlerTag: number,\n    newView: number,\n    propsRef: React.RefObject<unknown>\n  ) {\n    NodeManager.getHandler(handlerTag).setView(newView, propsRef);\n  },\n  updateGestureHandler(handlerTag: number, newConfig: any) {\n    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);\n  },\n  getGestureHandlerNode(handlerTag: number) {\n    return NodeManager.getHandler(handlerTag);\n  },\n  dropGestureHandler(handlerTag: number) {\n    NodeManager.dropGestureHandler(handlerTag);\n  },\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/State.js b/node_modules/react-native-gesture-handler/lib/commonjs/State.js
new file mode 100644
index 0000000..51e09c2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/State.js
@@ -0,0 +1,18 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.State = void 0;
+// TODO use State from RNModule
+const State = {
+  UNDETERMINED: 0,
+  FAILED: 1,
+  BEGAN: 2,
+  CANCELLED: 3,
+  ACTIVE: 4,
+  END: 5
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+
+exports.State = State;
+//# sourceMappingURL=State.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/State.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/State.js.map
new file mode 100644
index 0000000..5cbd9b0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/State.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["State.ts"],"names":["State","UNDETERMINED","FAILED","BEGAN","CANCELLED","ACTIVE","END"],"mappings":";;;;;;AAAA;AAEO,MAAMA,KAAK,GAAG;AACnBC,EAAAA,YAAY,EAAE,CADK;AAEnBC,EAAAA,MAAM,EAAE,CAFW;AAGnBC,EAAAA,KAAK,EAAE,CAHY;AAInBC,EAAAA,SAAS,EAAE,CAJQ;AAKnBC,EAAAA,MAAM,EAAE,CALW;AAMnBC,EAAAA,GAAG,EAAE;AANc,CAAd,C,CASP","sourcesContent":["// TODO use State from RNModule\n\nexport const State = {\n  UNDETERMINED: 0,\n  FAILED: 1,\n  BEGAN: 2,\n  CANCELLED: 3,\n  ACTIVE: 4,\n  END: 5,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type State = typeof State[keyof typeof State];\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js
new file mode 100644
index 0000000..a17ff1f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js
@@ -0,0 +1,531 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _invariant = _interopRequireDefault(require("invariant"));
+
+var _reactNative = require("react-native");
+
+var _gestureHandlers = require("../handlers/gestureHandlers");
+
+var _State = require("../State");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+const DRAG_TOSS = 0.05;
+const IDLE = 'Idle';
+const DRAGGING = 'Dragging';
+const SETTLING = 'Settling';
+
+class DrawerLayout extends React.Component {
+  constructor(_props) {
+    super(_props);
+
+    _defineProperty(this, "openValue", void 0);
+
+    _defineProperty(this, "onGestureEvent", void 0);
+
+    _defineProperty(this, "accessibilityIsModalView", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "pointerEventsView", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "panGestureHandler", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "drawerShown", false);
+
+    _defineProperty(this, "updateAnimatedEvent", (props, state) => {
+      // Event definition is based on
+      const {
+        drawerPosition,
+        drawerWidth,
+        drawerType
+      } = props;
+      const {
+        dragX: dragXValue,
+        touchX: touchXValue,
+        drawerTranslation,
+        containerWidth
+      } = state;
+      let dragX = dragXValue;
+      let touchX = touchXValue;
+
+      if (drawerPosition !== 'left') {
+        // Most of the code is written in a way to handle left-side drawer.
+        // In order to handle right-side drawer the only thing we need to
+        // do is to reverse events coming from gesture handler in a way they
+        // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and
+        // touchX is calulcated by subtracing real touchX from the width of the
+        // container (such that when touch happens at the right edge the value
+        // is simply 0)
+        dragX = _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragXValue); // TODO(TS): (for all "as" in this file) make sure we can map this
+
+        touchX = _reactNative.Animated.add(new _reactNative.Animated.Value(containerWidth), _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), touchXValue)); // TODO(TS): make sure we can map this;
+
+        touchXValue.setValue(containerWidth);
+      } else {
+        touchXValue.setValue(0);
+      } // While closing the drawer when user starts gesture outside of its area (in greyed
+      // out part of the window), we want the drawer to follow only once finger reaches the
+      // edge of the drawer.
+      // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by
+      // dots. The touch gesture starts at '*' and moves left, touch path is indicated by
+      // an arrow pointing left
+      // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    +---------------+    +---------------+    +---------------+    +---------------+
+      //
+      // For the above to work properly we define animated value that will keep start position
+      // of the gesture. Then we use that value to calculate how much we need to subtract from
+      // the dragX. If the gesture started on the greyed out area we take the distance from the
+      // edge of the drawer to the start position. Otherwise we don't subtract at all and the
+      // drawer be pulled back as soon as you start the pan.
+      //
+      // This is used only when drawerType is "front"
+      //
+
+
+      let translationX = dragX;
+
+      if (drawerType === 'front') {
+        const startPositionX = _reactNative.Animated.add(touchX, _reactNative.Animated.multiply(new _reactNative.Animated.Value(-1), dragX));
+
+        const dragOffsetFromOnStartPosition = startPositionX.interpolate({
+          inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],
+          outputRange: [0, 0, 1]
+        });
+        translationX = _reactNative.Animated.add(dragX, dragOffsetFromOnStartPosition); // TODO: as above
+      }
+
+      this.openValue = _reactNative.Animated.add(translationX, drawerTranslation).interpolate({
+        inputRange: [0, drawerWidth],
+        outputRange: [0, 1],
+        extrapolate: 'clamp'
+      });
+      const gestureOptions = {
+        useNativeDriver: props.useNativeAnimations
+      };
+
+      if (this.props.onDrawerSlide) {
+        gestureOptions.listener = ev => {
+          var _this$props$onDrawerS, _this$props;
+
+          const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));
+          const position = translationX / this.state.containerWidth;
+          (_this$props$onDrawerS = (_this$props = this.props).onDrawerSlide) === null || _this$props$onDrawerS === void 0 ? void 0 : _this$props$onDrawerS.call(_this$props, position);
+        };
+      }
+
+      this.onGestureEvent = _reactNative.Animated.event([{
+        nativeEvent: {
+          translationX: dragXValue,
+          x: touchXValue
+        }
+      }], gestureOptions);
+    });
+
+    _defineProperty(this, "handleContainerLayout", ({
+      nativeEvent
+    }) => {
+      this.setState({
+        containerWidth: nativeEvent.layout.width
+      });
+    });
+
+    _defineProperty(this, "emitStateChanged", (newState, drawerWillShow) => {
+      var _this$props$onDrawerS2, _this$props2;
+
+      (_this$props$onDrawerS2 = (_this$props2 = this.props).onDrawerStateChanged) === null || _this$props$onDrawerS2 === void 0 ? void 0 : _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);
+    });
+
+    _defineProperty(this, "openingHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (nativeEvent.oldState === _State.State.ACTIVE) {
+        this.handleRelease({
+          nativeEvent
+        });
+      } else if (nativeEvent.state === _State.State.ACTIVE) {
+        this.emitStateChanged(DRAGGING, false);
+
+        if (this.props.keyboardDismissMode === 'on-drag') {
+          _reactNative.Keyboard.dismiss();
+        }
+
+        if (this.props.hideStatusBar) {
+          _reactNative.StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');
+        }
+      }
+    });
+
+    _defineProperty(this, "onTapHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (this.drawerShown && nativeEvent.oldState === _State.State.ACTIVE && this.props.drawerLockMode !== 'locked-open') {
+        this.closeDrawer();
+      }
+    });
+
+    _defineProperty(this, "handleRelease", ({
+      nativeEvent
+    }) => {
+      const {
+        drawerWidth,
+        drawerPosition,
+        drawerType
+      } = this.props;
+      const {
+        containerWidth
+      } = this.state;
+      let {
+        translationX: dragX,
+        velocityX,
+        x: touchX
+      } = nativeEvent;
+
+      if (drawerPosition !== 'left') {
+        // See description in _updateAnimatedEvent about why events are flipped
+        // for right-side drawer
+        dragX = -dragX;
+        touchX = containerWidth - touchX;
+        velocityX = -velocityX;
+      }
+
+      const gestureStartX = touchX - dragX;
+      let dragOffsetBasedOnStart = 0;
+
+      if (drawerType === 'front') {
+        dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
+      }
+
+      const startOffsetX = dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth : 0);
+      const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;
+      const shouldOpen = projOffsetX > drawerWidth / 2;
+
+      if (shouldOpen) {
+        this.animateDrawer(startOffsetX, drawerWidth, velocityX);
+      } else {
+        this.animateDrawer(startOffsetX, 0, velocityX);
+      }
+    });
+
+    _defineProperty(this, "updateShowing", showing => {
+      var _this$accessibilityIs, _this$pointerEventsVi, _this$panGestureHandl;
+
+      this.drawerShown = showing;
+      (_this$accessibilityIs = this.accessibilityIsModalView.current) === null || _this$accessibilityIs === void 0 ? void 0 : _this$accessibilityIs.setNativeProps({
+        accessibilityViewIsModal: showing
+      });
+      (_this$pointerEventsVi = this.pointerEventsView.current) === null || _this$pointerEventsVi === void 0 ? void 0 : _this$pointerEventsVi.setNativeProps({
+        pointerEvents: showing ? 'auto' : 'none'
+      });
+      const {
+        drawerPosition,
+        minSwipeDistance,
+        edgeWidth
+      } = this.props;
+      const fromLeft = drawerPosition === 'left'; // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
+      // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
+      // orientation will be 1.
+
+      const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter
+      // than the container size by the value of SLOP. This will make it only
+      // activate when gesture happens not further than SLOP away from the edge
+
+      const hitSlop = fromLeft ? {
+        left: 0,
+        width: showing ? undefined : edgeWidth
+      } : {
+        right: 0,
+        width: showing ? undefined : edgeWidth
+      }; // @ts-ignore internal API, maybe could be fixed in handler types
+
+      (_this$panGestureHandl = this.panGestureHandler.current) === null || _this$panGestureHandl === void 0 ? void 0 : _this$panGestureHandl.setNativeProps({
+        hitSlop,
+        activeOffsetX: gestureOrientation * minSwipeDistance
+      });
+    });
+
+    _defineProperty(this, "animateDrawer", (fromValue, toValue, velocity, speed) => {
+      this.state.dragX.setValue(0);
+      this.state.touchX.setValue(this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth);
+
+      if (fromValue != null) {
+        let nextFramePosition = fromValue;
+
+        if (this.props.useNativeAnimations) {
+          // When using native driver, we predict the next position of the animation
+          // because it takes one frame of a roundtrip to pass RELEASE event from
+          // native driver to JS before we can start animating. Without it, it is more
+          // noticable that the frame is dropped.
+          if (fromValue < toValue && velocity > 0) {
+            nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);
+          } else if (fromValue > toValue && velocity < 0) {
+            nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);
+          }
+        }
+
+        this.state.drawerTranslation.setValue(nextFramePosition);
+      }
+
+      const willShow = toValue !== 0;
+      this.updateShowing(willShow);
+      this.emitStateChanged(SETTLING, willShow);
+
+      if (this.props.hideStatusBar) {
+        _reactNative.StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');
+      }
+
+      _reactNative.Animated.spring(this.state.drawerTranslation, {
+        velocity,
+        bounciness: 0,
+        toValue,
+        useNativeDriver: this.props.useNativeAnimations,
+        speed: speed !== null && speed !== void 0 ? speed : undefined
+      }).start(({
+        finished
+      }) => {
+        if (finished) {
+          this.emitStateChanged(IDLE, willShow);
+
+          if (willShow) {
+            var _this$props$onDrawerO, _this$props3;
+
+            (_this$props$onDrawerO = (_this$props3 = this.props).onDrawerOpen) === null || _this$props$onDrawerO === void 0 ? void 0 : _this$props$onDrawerO.call(_this$props3);
+          } else {
+            var _this$props$onDrawerC, _this$props4;
+
+            (_this$props$onDrawerC = (_this$props4 = this.props).onDrawerClose) === null || _this$props$onDrawerC === void 0 ? void 0 : _this$props$onDrawerC.call(_this$props4);
+          }
+        }
+      });
+    });
+
+    _defineProperty(this, "openDrawer", (options = {}) => {
+      this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value
+      undefined, this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable
+
+      this.forceUpdate();
+    });
+
+    _defineProperty(this, "closeDrawer", (options = {}) => {
+      // TODO: decide if it should be null or undefined is the proper value
+      this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable
+
+      this.forceUpdate();
+    });
+
+    _defineProperty(this, "renderOverlay", () => {
+      /* Overlay styles */
+      (0, _invariant.default)(this.openValue, 'should be set');
+      const overlayOpacity = this.openValue.interpolate({
+        inputRange: [0, 1],
+        outputRange: [0, 1],
+        extrapolate: 'clamp'
+      });
+      const dynamicOverlayStyles = {
+        opacity: overlayOpacity,
+        backgroundColor: this.props.overlayColor
+      };
+      return /*#__PURE__*/React.createElement(_gestureHandlers.TapGestureHandler, {
+        onHandlerStateChange: this.onTapHandlerStateChange
+      }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+        pointerEvents: this.drawerShown ? 'auto' : 'none',
+        ref: this.pointerEventsView,
+        style: [styles.overlay, dynamicOverlayStyles]
+      }));
+    });
+
+    _defineProperty(this, "renderDrawer", () => {
+      const {
+        drawerBackgroundColor,
+        drawerWidth,
+        drawerPosition,
+        drawerType,
+        drawerContainerStyle,
+        contentContainerStyle
+      } = this.props;
+      const fromLeft = drawerPosition === 'left';
+      const drawerSlide = drawerType !== 'back';
+      const containerSlide = drawerType !== 'front'; // we rely on row and row-reverse flex directions to position the drawer
+      // properly. Apparently for RTL these are flipped which requires us to use
+      // the opposite setting for the drawer to appear from left or right according
+      // to the drawerPosition prop
+
+      const reverseContentDirection = _reactNative.I18nManager.isRTL ? fromLeft : !fromLeft;
+      const dynamicDrawerStyles = {
+        backgroundColor: drawerBackgroundColor,
+        width: drawerWidth
+      };
+      const openValue = this.openValue;
+      (0, _invariant.default)(openValue, 'should be set');
+      let containerStyles;
+
+      if (containerSlide) {
+        const containerTranslateX = openValue.interpolate({
+          inputRange: [0, 1],
+          outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],
+          extrapolate: 'clamp'
+        });
+        containerStyles = {
+          transform: [{
+            translateX: containerTranslateX
+          }]
+        };
+      }
+
+      let drawerTranslateX = 0;
+
+      if (drawerSlide) {
+        const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;
+        drawerTranslateX = openValue.interpolate({
+          inputRange: [0, 1],
+          outputRange: [closedDrawerOffset, 0],
+          extrapolate: 'clamp'
+        });
+      }
+
+      const drawerStyles = {
+        transform: [{
+          translateX: drawerTranslateX
+        }],
+        flexDirection: reverseContentDirection ? 'row-reverse' : 'row'
+      };
+      return /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+        style: styles.main,
+        onLayout: this.handleContainerLayout
+      }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+        style: [drawerType === 'front' ? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle],
+        importantForAccessibility: this.drawerShown ? 'no-hide-descendants' : 'yes'
+      }, typeof this.props.children === 'function' ? this.props.children(this.openValue) : this.props.children, this.renderOverlay()), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+        pointerEvents: "box-none",
+        ref: this.accessibilityIsModalView,
+        accessibilityViewIsModal: this.drawerShown,
+        style: [styles.drawerContainer, drawerStyles, drawerContainerStyle]
+      }, /*#__PURE__*/React.createElement(_reactNative.View, {
+        style: dynamicDrawerStyles
+      }, this.props.renderNavigationView(this.openValue))));
+    });
+
+    _defineProperty(this, "setPanGestureRef", ref => {
+      var _this$props$onGesture, _this$props5;
+
+      // TODO(TS): make sure it is OK
+      // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842
+      this.panGestureHandler.current = ref;
+      (_this$props$onGesture = (_this$props5 = this.props).onGestureRef) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props5, ref);
+    });
+
+    const _dragX = new _reactNative.Animated.Value(0);
+
+    const _touchX = new _reactNative.Animated.Value(0);
+
+    const _drawerTranslation = new _reactNative.Animated.Value(0);
+
+    this.state = {
+      dragX: _dragX,
+      touchX: _touchX,
+      drawerTranslation: _drawerTranslation,
+      containerWidth: 0
+    };
+    this.updateAnimatedEvent(_props, this.state);
+  }
+
+  UNSAFE_componentWillUpdate(props, state) {
+    if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {
+      this.updateAnimatedEvent(props, state);
+    }
+  }
+
+  render() {
+    const {
+      drawerPosition,
+      drawerLockMode,
+      edgeWidth,
+      minSwipeDistance
+    } = this.props;
+    const fromLeft = drawerPosition === 'left'; // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
+    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
+    // orientation will be 1.
+
+    const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter
+    // than the container size by the value of SLOP. This will make it only
+    // activate when gesture happens not further than SLOP away from the edge
+
+    const hitSlop = fromLeft ? {
+      left: 0,
+      width: this.drawerShown ? undefined : edgeWidth
+    } : {
+      right: 0,
+      width: this.drawerShown ? undefined : edgeWidth
+    };
+    return /*#__PURE__*/React.createElement(_gestureHandlers.PanGestureHandler // @ts-ignore could be fixed in handler types
+    , {
+      ref: this.setPanGestureRef,
+      hitSlop: hitSlop,
+      activeOffsetX: gestureOrientation * minSwipeDistance,
+      failOffsetY: [-15, 15],
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.openingHandlerStateChange,
+      enableTrackpadTwoFingerGesture: this.props.enableTrackpadTwoFingerGesture,
+      enabled: drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'
+    }, this.renderDrawer());
+  }
+
+}
+
+exports.default = DrawerLayout;
+
+_defineProperty(DrawerLayout, "defaultProps", {
+  drawerWidth: 200,
+  drawerPosition: 'left',
+  useNativeAnimations: true,
+  drawerType: 'front',
+  edgeWidth: 20,
+  minSwipeDistance: 3,
+  overlayColor: 'rgba(0, 0, 0, 0.7)',
+  drawerLockMode: 'unlocked',
+  enableTrackpadTwoFingerGesture: false
+});
+
+_defineProperty(DrawerLayout, "positions", {
+  Left: 'left',
+  Right: 'right'
+});
+
+const styles = _reactNative.StyleSheet.create({
+  drawerContainer: { ..._reactNative.StyleSheet.absoluteFillObject,
+    zIndex: 1001,
+    flexDirection: 'row'
+  },
+  containerInFront: { ..._reactNative.StyleSheet.absoluteFillObject,
+    zIndex: 1002
+  },
+  containerOnBack: { ..._reactNative.StyleSheet.absoluteFillObject
+  },
+  main: {
+    flex: 1,
+    zIndex: 0,
+    overflow: 'hidden'
+  },
+  overlay: { ..._reactNative.StyleSheet.absoluteFillObject,
+    zIndex: 1000
+  }
+});
+//# sourceMappingURL=DrawerLayout.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js.map
new file mode 100644
index 0000000..671d139
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/DrawerLayout.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DrawerLayout.tsx"],"names":["DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","Component","constructor","props","React","createRef","state","drawerPosition","drawerWidth","drawerType","dragX","dragXValue","touchX","touchXValue","drawerTranslation","containerWidth","Animated","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","openValue","extrapolate","gestureOptions","useNativeDriver","useNativeAnimations","onDrawerSlide","listener","ev","Math","floor","abs","nativeEvent","position","onGestureEvent","event","x","setState","layout","width","newState","drawerWillShow","onDrawerStateChanged","oldState","State","ACTIVE","handleRelease","emitStateChanged","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","drawerShown","drawerLockMode","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","animateDrawer","showing","accessibilityIsModalView","current","setNativeProps","accessibilityViewIsModal","pointerEventsView","pointerEvents","minSwipeDistance","edgeWidth","fromLeft","gestureOrientation","hitSlop","left","undefined","right","panGestureHandler","activeOffsetX","fromValue","toValue","velocity","speed","nextFramePosition","min","max","willShow","updateShowing","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","options","forceUpdate","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","onTapHandlerStateChange","styles","overlay","drawerBackgroundColor","drawerContainerStyle","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","I18nManager","isRTL","dynamicDrawerStyles","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","main","handleContainerLayout","containerOnBack","containerInFront","children","renderOverlay","drawerContainer","renderNavigationView","ref","onGestureRef","updateAnimatedEvent","UNSAFE_componentWillUpdate","render","setPanGestureRef","openingHandlerStateChange","enableTrackpadTwoFingerGesture","renderDrawer","Left","Right","StyleSheet","create","absoluteFillObject","zIndex","flex","overflow"],"mappings":"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","sourcesContent":["// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n  StatusBarAnimation,\n  StyleProp,\n  ViewStyle,\n  LayoutChangeEvent,\n  NativeSyntheticEvent,\n} from 'react-native';\n\nimport {\n  GestureEvent,\n  PanGestureHandler,\n  PanGestureHandlerEventPayload,\n  TapGestureHandler,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE: DrawerState = 'Idle';\nconst DRAGGING: DrawerState = 'Dragging';\nconst SETTLING: DrawerState = 'Settling';\n\nexport type DrawerPosition = 'left' | 'right';\n\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\n\nexport type DrawerType = 'front' | 'back' | 'slide';\n\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\n\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\n\nexport interface DrawerLayoutProps {\n  renderNavigationView: (\n    progressAnimatedValue: Animated.Value\n  ) => React.ReactNode;\n  drawerPosition?: DrawerPosition;\n  drawerWidth?: number;\n  drawerBackgroundColor?: string;\n  drawerLockMode?: DrawerLockMode;\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\n  onDrawerClose?: () => void;\n  onDrawerOpen?: () => void;\n  onDrawerStateChanged?: (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => void;\n  useNativeAnimations?: boolean;\n\n  drawerType?: DrawerType;\n  edgeWidth?: number;\n  minSwipeDistance?: number;\n  hideStatusBar?: boolean;\n  statusBarAnimation?: StatusBarAnimation;\n  overlayColor?: string;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  drawerContainerStyle?: StyleProp<ViewStyle>;\n  enableTrackpadTwoFingerGesture?: boolean;\n  onDrawerSlide?: (position: number) => void;\n  onGestureRef?: (ref: PanGestureHandler) => void;\n}\n\nexport type DrawerLayoutState = {\n  dragX: Animated.Value;\n  touchX: Animated.Value;\n  drawerTranslation: Animated.Value;\n  containerWidth: number;\n};\n\nexport type DrawerMovementOption = {\n  velocity?: number;\n  speed?: number;\n};\nexport default class DrawerLayout extends Component<\n  DrawerLayoutProps,\n  DrawerLayoutState\n> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\n    drawerLockMode: 'unlocked',\n    enableTrackpadTwoFingerGesture: false,\n  };\n\n  constructor(props: DrawerLayoutProps) {\n    super(props);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this.updateAnimatedEvent(props, this.state);\n  }\n\n  UNSAFE_componentWillUpdate(\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private openValue?: Animated.AnimatedInterpolation;\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private accessibilityIsModalView = React.createRef<View>();\n  private pointerEventsView = React.createRef<View>();\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\n  private drawerShown = false;\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n\n  private updateAnimatedEvent = (\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(\n        new Animated.Value(-1),\n        dragXValue\n      ) as Animated.Value; // TODO(TS): (for all \"as\" in this file) make sure we can map this\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(\n        dragX,\n        dragOffsetFromOnStartPosition\n      ) as Animated.Value; // TODO: as above\n    }\n\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\n      inputRange: [0, drawerWidth!],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n\n    const gestureOptions: {\n      useNativeDriver: boolean;\n      // TODO: make sure it is correct\n      listener?: (\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\n      ) => void;\n    } = {\n      useNativeDriver: props.useNativeAnimations!,\n    };\n\n    if (this.props.onDrawerSlide) {\n      gestureOptions.listener = (ev) => {\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\n        const position = translationX / this.state.containerWidth;\n\n        this.props.onDrawerSlide?.(position);\n      };\n    }\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      gestureOptions\n    );\n  };\n\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  private emitStateChanged = (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => {\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\n  };\n\n  private openingHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease({ nativeEvent });\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this.emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (\n      this.drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  private handleRelease = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\n\n    if (shouldOpen) {\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\n    } else {\n      this.animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  private updateShowing = (showing: boolean) => {\n    this.drawerShown = showing;\n    this.accessibilityIsModalView.current?.setNativeProps({\n      accessibilityViewIsModal: showing,\n    });\n    this.pointerEventsView.current?.setNativeProps({\n      pointerEvents: showing ? 'auto' : 'none',\n    });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    // @ts-ignore internal API, maybe could be fixed in handler types\n    this.panGestureHandler.current?.setNativeProps({\n      hitSlop,\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\n    });\n  };\n\n  private animateDrawer = (\n    fromValue: number | null | undefined,\n    toValue: number,\n    velocity: number,\n    speed?: number\n  ) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue != null) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this.updateShowing(willShow);\n    this.emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      speed: speed ?? undefined,\n    }).start(({ finished }) => {\n      if (finished) {\n        this.emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen?.();\n        } else {\n          this.props.onDrawerClose?.();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOption = {}) => {\n    this.animateDrawer(\n      // TODO: decide if it should be null or undefined is the proper value\n      undefined,\n      this.props.drawerWidth!,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOption = {}) => {\n    // TODO: decide if it should be null or undefined is the proper value\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  private renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this.openValue, 'should be set');\n    const overlayOpacity = this.openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\n          ref={this.pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  private renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this.openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles: {\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\n      flexDirection: 'row-reverse' | 'row';\n    } = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}\n          importantForAccessibility={\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\n          }>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this.openValue)\n            : this.props.children}\n          {this.renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this.accessibilityIsModalView}\n          accessibilityViewIsModal={this.drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  private setPanGestureRef = (ref: PanGestureHandler) => {\n    // TODO(TS): make sure it is OK\n    // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\n    (this\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\n    this.props.onGestureRef?.(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        // @ts-ignore could be fixed in handler types\n        ref={this.setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.openingHandlerStateChange}\n        enableTrackpadTwoFingerGesture={\n          this.props.enableTrackpadTwoFingerGesture\n        }\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this.renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js
new file mode 100644
index 0000000..fa2cee9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js
@@ -0,0 +1,207 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "PureNativeButton", {
+  enumerable: true,
+  get: function () {
+    return _GestureHandlerButton.default;
+  }
+});
+exports.BorderlessButton = exports.RectButton = exports.BaseButton = exports.RawButton = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _createNativeWrapper = _interopRequireDefault(require("../handlers/createNativeWrapper"));
+
+var _GestureHandlerButton = _interopRequireDefault(require("./GestureHandlerButton"));
+
+var _State = require("../State");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+const RawButton = (0, _createNativeWrapper.default)(_GestureHandlerButton.default, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: false
+});
+exports.RawButton = RawButton;
+
+class BaseButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "lastActive", void 0);
+
+    _defineProperty(this, "handleEvent", ({
+      nativeEvent
+    }) => {
+      const {
+        state,
+        oldState,
+        pointerInside
+      } = nativeEvent;
+      const active = pointerInside && state === _State.State.ACTIVE;
+
+      if (active !== this.lastActive && this.props.onActiveStateChange) {
+        this.props.onActiveStateChange(active);
+      }
+
+      if (oldState === _State.State.ACTIVE && state !== _State.State.CANCELLED && this.lastActive && this.props.onPress) {
+        this.props.onPress(active);
+      }
+
+      this.lastActive = active;
+    });
+
+    _defineProperty(this, "onHandlerStateChange", e => {
+      var _this$props$onHandler, _this$props;
+
+      (_this$props$onHandler = (_this$props = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props, e);
+      this.handleEvent(e);
+    });
+
+    _defineProperty(this, "onGestureEvent", e => {
+      var _this$props$onGesture, _this$props2;
+
+      (_this$props$onGesture = (_this$props2 = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props2, e);
+      this.handleEvent(e); // TODO: maybe it is not correct
+    });
+
+    this.lastActive = false;
+  }
+
+  render() {
+    const {
+      rippleColor,
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(RawButton, _extends({
+      rippleColor: (0, _reactNative.processColor)(rippleColor)
+    }, rest, {
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.onHandlerStateChange
+    }));
+  }
+
+}
+
+exports.BaseButton = BaseButton;
+
+const AnimatedBaseButton = _reactNative.Animated.createAnimatedComponent(BaseButton);
+
+const btnStyles = _reactNative.StyleSheet.create({
+  underlay: {
+    position: 'absolute',
+    left: 0,
+    right: 0,
+    bottom: 0,
+    top: 0
+  }
+});
+
+class RectButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "opacity", void 0);
+
+    _defineProperty(this, "onActiveStateChange", active => {
+      var _this$props$onActiveS, _this$props3;
+
+      if (_reactNative.Platform.OS !== 'android') {
+        this.opacity.setValue(active ? this.props.activeOpacity : 0);
+      }
+
+      (_this$props$onActiveS = (_this$props3 = this.props).onActiveStateChange) === null || _this$props$onActiveS === void 0 ? void 0 : _this$props$onActiveS.call(_this$props3, active);
+    });
+
+    this.opacity = new _reactNative.Animated.Value(0);
+  }
+
+  render() {
+    const {
+      children,
+      style,
+      ...rest
+    } = this.props;
+
+    const resolvedStyle = _reactNative.StyleSheet.flatten(style !== null && style !== void 0 ? style : {});
+
+    return /*#__PURE__*/React.createElement(BaseButton, _extends({}, rest, {
+      style: resolvedStyle,
+      onActiveStateChange: this.onActiveStateChange
+    }), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+      style: [btnStyles.underlay, {
+        opacity: this.opacity,
+        backgroundColor: this.props.underlayColor,
+        borderRadius: resolvedStyle.borderRadius,
+        borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
+        borderTopRightRadius: resolvedStyle.borderTopRightRadius,
+        borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
+        borderBottomRightRadius: resolvedStyle.borderBottomRightRadius
+      }]
+    }), children);
+  }
+
+}
+
+exports.RectButton = RectButton;
+
+_defineProperty(RectButton, "defaultProps", {
+  activeOpacity: 0.105,
+  underlayColor: 'black'
+});
+
+class BorderlessButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "opacity", void 0);
+
+    _defineProperty(this, "onActiveStateChange", active => {
+      var _this$props$onActiveS2, _this$props4;
+
+      if (_reactNative.Platform.OS !== 'android') {
+        this.opacity.setValue(active ? this.props.activeOpacity : 1);
+      }
+
+      (_this$props$onActiveS2 = (_this$props4 = this.props).onActiveStateChange) === null || _this$props$onActiveS2 === void 0 ? void 0 : _this$props$onActiveS2.call(_this$props4, active);
+    });
+
+    this.opacity = new _reactNative.Animated.Value(1);
+  }
+
+  render() {
+    const {
+      children,
+      style,
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(AnimatedBaseButton, _extends({}, rest, {
+      onActiveStateChange: this.onActiveStateChange,
+      style: [style, _reactNative.Platform.OS === 'ios' && {
+        opacity: this.opacity
+      }]
+    }), children);
+  }
+
+}
+
+exports.BorderlessButton = BorderlessButton;
+
+_defineProperty(BorderlessButton, "defaultProps", {
+  activeOpacity: 0.3,
+  borderless: true
+});
+//# sourceMappingURL=GestureButtons.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js.map
new file mode 100644
index 0000000..2604fca
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureButtons.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureButtons.tsx"],"names":["RawButton","GestureHandlerButton","shouldCancelWhenOutside","shouldActivateOnStart","BaseButton","React","Component","constructor","props","nativeEvent","state","oldState","pointerInside","active","State","ACTIVE","lastActive","onActiveStateChange","CANCELLED","onPress","e","onHandlerStateChange","handleEvent","onGestureEvent","render","rippleColor","rest","AnimatedBaseButton","Animated","createAnimatedComponent","btnStyles","StyleSheet","create","underlay","position","left","right","bottom","top","RectButton","Platform","OS","opacity","setValue","activeOpacity","Value","children","style","resolvedStyle","flatten","backgroundColor","underlayColor","borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","BorderlessButton","borderless"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  Platform,\n  processColor,\n  StyleSheet,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\nimport GestureHandlerButton from './GestureHandlerButton';\nimport { State } from '../State';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../handlers/gestureHandlers';\nimport {\n  NativeViewGestureHandlerPayload,\n  NativeViewGestureHandlerProps,\n} from '../handlers/NativeViewGestureHandler';\n\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\n  exclusive?: boolean;\n  // TODO: we should transform props in `createNativeWrapper`\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\n}\n\nexport interface BaseButtonProps extends RawButtonProps {\n  onPress?: (pointerInside: boolean) => void;\n  onActiveStateChange?: (active: boolean) => void;\n  style?: StyleProp<ViewStyle>;\n  testID?: string;\n}\n\nexport interface RectButtonProps extends BaseButtonProps {\n  underlayColor?: string;\n  activeOpacity?: number;\n}\n\nexport interface BorderlessButtonProps extends BaseButtonProps {\n  borderless?: boolean;\n  activeOpacity?: number;\n}\n\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: false,\n});\n\nexport class BaseButton extends React.Component<BaseButtonProps> {\n  private lastActive: boolean;\n\n  constructor(props: BaseButtonProps) {\n    super(props);\n    this.lastActive = false;\n  }\n\n  private handleEvent = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state, oldState, pointerInside } = nativeEvent;\n    const active = pointerInside && state === State.ACTIVE;\n\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\n      this.props.onActiveStateChange(active);\n    }\n\n    if (\n      oldState === State.ACTIVE &&\n      state !== State.CANCELLED &&\n      this.lastActive &&\n      this.props.onPress\n    ) {\n      this.props.onPress(active);\n    }\n\n    this.lastActive = active;\n  };\n\n  // Normally, the parent would execute it's handler first,\n  // then forward the event to listeners. However, here our handler\n  // is virtually only forwarding events to listeners, so we reverse the order\n  // to keep the proper order of the callbacks (from \"raw\" ones to \"processed\").\n  private onHandlerStateChange = (\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onHandlerStateChange?.(e);\n    this.handleEvent(e);\n  };\n\n  private onGestureEvent = (\n    e: GestureEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onGestureEvent?.(e);\n    this.handleEvent(\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n    ); // TODO: maybe it is not correct\n  };\n\n  render() {\n    const { rippleColor, ...rest } = this.props;\n\n    return (\n      <RawButton\n        rippleColor={processColor(rippleColor)}\n        {...rest}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}\n      />\n    );\n  }\n}\n\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\n\nconst btnStyles = StyleSheet.create({\n  underlay: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: 0,\n  },\n});\n\nexport class RectButton extends React.Component<RectButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.105,\n    underlayColor: 'black',\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: RectButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(0);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\n\n    return (\n      <BaseButton\n        {...rest}\n        style={resolvedStyle}\n        onActiveStateChange={this.onActiveStateChange}>\n        <Animated.View\n          style={[\n            btnStyles.underlay,\n            {\n              opacity: this.opacity,\n              backgroundColor: this.props.underlayColor,\n              borderRadius: resolvedStyle.borderRadius,\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\n            },\n          ]}\n        />\n        {children}\n      </BaseButton>\n    );\n  }\n}\n\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.3,\n    borderless: true,\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: BorderlessButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(1);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    return (\n      <AnimatedBaseButton\n        {...rest}\n        onActiveStateChange={this.onActiveStateChange}\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\n        {children}\n      </AnimatedBaseButton>\n    );\n  }\n}\n\nexport { default as PureNativeButton } from './GestureHandlerButton';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js
new file mode 100644
index 0000000..8f2542e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js
@@ -0,0 +1,57 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.FlatList = exports.DrawerLayoutAndroid = exports.TextInput = exports.Switch = exports.ScrollView = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _createNativeWrapper = _interopRequireDefault(require("../handlers/createNativeWrapper"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+const ScrollView = (0, _createNativeWrapper.default)(_reactNative.ScrollView, {
+  disallowInterruption: true,
+  shouldCancelWhenOutside: false
+}); // backward type compatibility with https://github.com/software-mansion/react-native-gesture-handler/blob/db78d3ca7d48e8ba57482d3fe9b0a15aa79d9932/react-native-gesture-handler.d.ts#L440-L457
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+
+exports.ScrollView = ScrollView;
+const Switch = (0, _createNativeWrapper.default)(_reactNative.Switch, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: true,
+  disallowInterruption: true
+}); // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+exports.Switch = Switch;
+const TextInput = (0, _createNativeWrapper.default)(_reactNative.TextInput); // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+exports.TextInput = TextInput;
+const DrawerLayoutAndroid = (0, _createNativeWrapper.default)(_reactNative.DrawerLayoutAndroid, {
+  disallowInterruption: true
+}); // we use literal object since TS gives error when using RN's `positions`
+// @ts-ignore FIXME(TS) maybe this should be removed?
+
+exports.DrawerLayoutAndroid = DrawerLayoutAndroid;
+DrawerLayoutAndroid.positions = {
+  Left: 'left',
+  Right: 'right'
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+const FlatList = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_reactNative.FlatList, _extends({
+  ref: ref
+}, props, {
+  renderScrollComponent: scrollProps => /*#__PURE__*/React.createElement(ScrollView, scrollProps)
+}))); // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+exports.FlatList = FlatList;
+//# sourceMappingURL=GestureComponents.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js.map
new file mode 100644
index 0000000..1ad8fe8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureComponents.tsx"],"names":["ScrollView","RNScrollView","disallowInterruption","shouldCancelWhenOutside","Switch","RNSwitch","shouldActivateOnStart","TextInput","RNTextInput","DrawerLayoutAndroid","RNDrawerLayoutAndroid","positions","Left","Right","FlatList","React","forwardRef","props","ref","scrollProps"],"mappings":";;;;;;;AAAA;;AAEA;;AAaA;;;;;;;;;;AAIO,MAAMA,UAAU,GAAG,kCAExBC,uBAFwB,EAEV;AACdC,EAAAA,oBAAoB,EAAE,IADR;AAEdC,EAAAA,uBAAuB,EAAE;AAFX,CAFU,CAAnB,C,CAMP;AACA;;;AAUO,MAAMC,MAAM,GAAG,kCAAmCC,mBAAnC,EAA6C;AACjEF,EAAAA,uBAAuB,EAAE,KADwC;AAEjEG,EAAAA,qBAAqB,EAAE,IAF0C;AAGjEJ,EAAAA,oBAAoB,EAAE;AAH2C,CAA7C,CAAf,C,CAKP;;;AAGO,MAAMK,SAAS,GAAG,kCAAsCC,sBAAtC,CAAlB,C,CACP;;;AAGO,MAAMC,mBAAmB,GAAG,kCAEjCC,gCAFiC,EAEV;AAAER,EAAAA,oBAAoB,EAAE;AAAxB,CAFU,CAA5B,C,CAGP;AACA;;;AACAO,mBAAmB,CAACE,SAApB,GAAgC;AAAEC,EAAAA,IAAI,EAAE,MAAR;AAAgBC,EAAAA,KAAK,EAAE;AAAvB,CAAhC,C,CACA;;AAGO,MAAMC,QAAQ,gBAAGC,KAAK,CAACC,UAAN,CACtB,CAACC,KAAD,EAAQC,GAAR,kBACE,oBAAC,qBAAD;AACE,EAAA,GAAG,EAAEA;AADP,GAEMD,KAFN;AAGE,EAAA,qBAAqB,EAAGE,WAAD,iBAAiB,oBAAC,UAAD,EAAgBA,WAAhB;AAH1C,GAFoB,CAAjB,C,CASP","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport {\n  ScrollView as RNScrollView,\n  ScrollViewProps as RNScrollViewProps,\n  Switch as RNSwitch,\n  SwitchProps as RNSwitchProps,\n  TextInput as RNTextInput,\n  TextInputProps as RNTextInputProps,\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  DrawerLayoutAndroidProps as RNDrawerLayoutAndroidProps,\n  FlatList as RNFlatList,\n  FlatListProps as RNFlatListProps,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\n\nimport { NativeViewGestureHandlerProps } from '../handlers/NativeViewGestureHandler';\n\nexport const ScrollView = createNativeWrapper<\n  PropsWithChildren<RNScrollViewProps>\n>(RNScrollView, {\n  disallowInterruption: true,\n  shouldCancelWhenOutside: false,\n});\n// backward type compatibility with https://github.com/software-mansion/react-native-gesture-handler/blob/db78d3ca7d48e8ba57482d3fe9b0a15aa79d9932/react-native-gesture-handler.d.ts#L440-L457\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type ScrollView = typeof ScrollView & {\n  scrollTo(\n    y?: number | { x?: number; y?: number; animated?: boolean },\n    x?: number,\n    animated?: boolean\n  ): void;\n  scrollToEnd(options?: { animated: boolean }): void;\n};\n\nexport const Switch = createNativeWrapper<RNSwitchProps>(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type Switch = typeof Switch;\n\nexport const TextInput = createNativeWrapper<RNTextInputProps>(RNTextInput);\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type TextInput = typeof TextInput;\n\nexport const DrawerLayoutAndroid = createNativeWrapper<\n  PropsWithChildren<RNDrawerLayoutAndroidProps>\n>(RNDrawerLayoutAndroid, { disallowInterruption: true });\n// we use literal object since TS gives error when using RN's `positions`\n// @ts-ignore FIXME(TS) maybe this should be removed?\nDrawerLayoutAndroid.positions = { Left: 'left', Right: 'right' };\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type DrawerLayoutAndroid = typeof DrawerLayoutAndroid;\n\nexport const FlatList = React.forwardRef<RNFlatList<any>, RNFlatListProps<any>>(\n  (props, ref) => (\n    <RNFlatList\n      ref={ref}\n      {...props}\n      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}\n    />\n  )\n);\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type FlatList<ItemT> = React.ComponentType<\n  RNFlatListProps<ItemT> &\n    NativeViewGestureHandlerProps &\n    React.RefAttributes<any>\n> & {\n  scrollToEnd: (params?: { animated?: boolean }) => void;\n  scrollToIndex: (params: {\n    animated?: boolean;\n    index: number;\n    viewOffset?: number;\n    viewPosition?: number;\n  }) => void;\n  scrollToItem: (params: {\n    animated?: boolean;\n    item: ItemT;\n    viewPosition?: number;\n  }) => void;\n  scrollToOffset: (params: { animated?: boolean; offset: number }) => void;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js
new file mode 100644
index 0000000..c6feace
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js
@@ -0,0 +1,46 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.FlatList = exports.DrawerLayoutAndroid = exports.TextInput = exports.Switch = exports.ScrollView = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _createNativeWrapper = _interopRequireDefault(require("../handlers/createNativeWrapper"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+const ScrollView = (0, _createNativeWrapper.default)(_reactNative.ScrollView, {
+  disallowInterruption: true
+});
+exports.ScrollView = ScrollView;
+const Switch = (0, _createNativeWrapper.default)(_reactNative.Switch, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: true,
+  disallowInterruption: true
+});
+exports.Switch = Switch;
+const TextInput = (0, _createNativeWrapper.default)(_reactNative.TextInput);
+exports.TextInput = TextInput;
+const DrawerLayoutAndroid = (0, _createNativeWrapper.default)(_reactNative.DrawerLayoutAndroid, {
+  disallowInterruption: true
+}); // @ts-ignore -- TODO(TS) to investigate if it's needed
+
+exports.DrawerLayoutAndroid = DrawerLayoutAndroid;
+DrawerLayoutAndroid.positions = _reactNative.DrawerLayoutAndroid.positions;
+const FlatList = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_reactNative.FlatList, _extends({
+  ref: ref
+}, props, {
+  renderScrollComponent: scrollProps => /*#__PURE__*/React.createElement(ScrollView, scrollProps)
+})));
+exports.FlatList = FlatList;
+//# sourceMappingURL=GestureComponents.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js.map
new file mode 100644
index 0000000..4c28bb2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureComponents.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureComponents.web.tsx"],"names":["ScrollView","RNScrollView","disallowInterruption","Switch","RNSwitch","shouldCancelWhenOutside","shouldActivateOnStart","TextInput","RNTextInput","DrawerLayoutAndroid","RNDrawerLayoutAndroid","positions","FlatList","React","forwardRef","props","ref","scrollProps"],"mappings":";;;;;;;AAAA;;AACA;;AASA;;;;;;;;;;AAEO,MAAMA,UAAU,GAAG,kCAAoBC,uBAApB,EAAkC;AAC1DC,EAAAA,oBAAoB,EAAE;AADoC,CAAlC,CAAnB;;AAIA,MAAMC,MAAM,GAAG,kCAAoBC,mBAApB,EAA8B;AAClDC,EAAAA,uBAAuB,EAAE,KADyB;AAElDC,EAAAA,qBAAqB,EAAE,IAF2B;AAGlDJ,EAAAA,oBAAoB,EAAE;AAH4B,CAA9B,CAAf;;AAKA,MAAMK,SAAS,GAAG,kCAAoBC,sBAApB,CAAlB;;AACA,MAAMC,mBAAmB,GAAG,kCAAoBC,gCAApB,EAA2C;AAC5ER,EAAAA,oBAAoB,EAAE;AADsD,CAA3C,CAA5B,C,CAGP;;;AACAO,mBAAmB,CAACE,SAApB,GAAgCD,iCAAsBC,SAAtD;AAEO,MAAMC,QAAQ,gBAAGC,KAAK,CAACC,UAAN,CACtB,CAAoBC,KAApB,EAAiDC,GAAjD,kBACE,oBAAC,qBAAD;AACE,EAAA,GAAG,EAAEA;AADP,GAEMD,KAFN;AAGE,EAAA,qBAAqB,EAAGE,WAAD,iBAAiB,oBAAC,UAAD,EAAgBA,WAAhB;AAH1C,GAFoB,CAAjB","sourcesContent":["import * as React from 'react';\nimport {\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  FlatList as RNFlatList,\n  Switch as RNSwitch,\n  TextInput as RNTextInput,\n  ScrollView as RNScrollView,\n  FlatListProps,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\n\nexport const ScrollView = createNativeWrapper(RNScrollView, {\n  disallowInterruption: true,\n});\n\nexport const Switch = createNativeWrapper(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\nexport const TextInput = createNativeWrapper(RNTextInput);\nexport const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {\n  disallowInterruption: true,\n});\n// @ts-ignore -- TODO(TS) to investigate if it's needed\nDrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;\n\nexport const FlatList = React.forwardRef(\n  <ItemT extends any>(props: FlatListProps<ItemT>, ref: any) => (\n    <RNFlatList\n      ref={ref}\n      {...props}\n      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}\n    />\n  )\n);\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js
new file mode 100644
index 0000000..623d71d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js
@@ -0,0 +1,13 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+const RNGestureHandlerButton = (0, _reactNative.requireNativeComponent)('RNGestureHandlerButton');
+var _default = RNGestureHandlerButton;
+exports.default = _default;
+//# sourceMappingURL=GestureHandlerButton.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js.map
new file mode 100644
index 0000000..05c90ff
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerButton.tsx"],"names":["RNGestureHandlerButton"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,sBAAqD,GAAG,yCAC5D,wBAD4D,CAA9D;eAIeA,sB","sourcesContent":["import { HostComponent, requireNativeComponent } from 'react-native';\nimport { RawButtonProps } from './GestureButtons';\nconst RNGestureHandlerButton: HostComponent<RawButtonProps> = requireNativeComponent(\n  'RNGestureHandlerButton'\n);\n\nexport default RNGestureHandlerButton;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js
new file mode 100644
index 0000000..d26da0d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js
@@ -0,0 +1,24 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+var _default = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_reactNative.View, _extends({
+  ref: ref,
+  accessibilityRole: "button"
+}, props)));
+
+exports.default = _default;
+//# sourceMappingURL=GestureHandlerButton.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js.map
new file mode 100644
index 0000000..920df0c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/GestureHandlerButton.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerButton.web.tsx"],"names":["React","forwardRef","props","ref"],"mappings":";;;;;;;AAAA;;AACA;;;;;;;;4BAEeA,KAAK,CAACC,UAAN,CAAuB,CAACC,KAAD,EAAQC,GAAR,kBACpC,oBAAC,iBAAD;AAAM,EAAA,GAAG,EAAEA,GAAX;AAAgB,EAAA,iBAAiB,EAAC;AAAlC,GAA+CD,KAA/C,EADa,C","sourcesContent":["import * as React from 'react';\nimport { View } from 'react-native';\n\nexport default React.forwardRef<View>((props, ref) => (\n  <View ref={ref} accessibilityRole=\"button\" {...props} />\n));\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js
new file mode 100644
index 0000000..cf065e3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js
@@ -0,0 +1,361 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _gestureHandlers = require("../handlers/gestureHandlers");
+
+var _State = require("../State");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+const DRAG_TOSS = 0.05;
+
+class Swipeable extends React.Component {
+  constructor(_props) {
+    super(_props);
+
+    _defineProperty(this, "onGestureEvent", void 0);
+
+    _defineProperty(this, "transX", void 0);
+
+    _defineProperty(this, "showLeftAction", void 0);
+
+    _defineProperty(this, "leftActionTranslate", void 0);
+
+    _defineProperty(this, "showRightAction", void 0);
+
+    _defineProperty(this, "rightActionTranslate", void 0);
+
+    _defineProperty(this, "updateAnimatedEvent", (props, state) => {
+      const {
+        friction,
+        overshootFriction
+      } = props;
+      const {
+        dragX,
+        rowTranslation,
+        leftWidth = 0,
+        rowWidth = 0
+      } = state;
+      const {
+        rightOffset = rowWidth
+      } = state;
+      const rightWidth = Math.max(0, rowWidth - rightOffset);
+      const {
+        overshootLeft = leftWidth > 0,
+        overshootRight = rightWidth > 0
+      } = props;
+
+      const transX = _reactNative.Animated.add(rowTranslation, dragX.interpolate({
+        inputRange: [0, friction],
+        outputRange: [0, 1]
+      })).interpolate({
+        inputRange: [-rightWidth - (overshootRight ? 1 : overshootFriction), -rightWidth, leftWidth, leftWidth + (overshootLeft ? 1 : overshootFriction)],
+        outputRange: [-rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0), -rightWidth, leftWidth, leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0)]
+      });
+
+      this.transX = transX;
+      this.showLeftAction = leftWidth > 0 ? transX.interpolate({
+        inputRange: [-1, 0, leftWidth],
+        outputRange: [0, 0, 1]
+      }) : new _reactNative.Animated.Value(0);
+      this.leftActionTranslate = this.showLeftAction.interpolate({
+        inputRange: [0, Number.MIN_VALUE],
+        outputRange: [-10000, 0],
+        extrapolate: 'clamp'
+      });
+      this.showRightAction = rightWidth > 0 ? transX.interpolate({
+        inputRange: [-rightWidth, 0, 1],
+        outputRange: [1, 0, 0]
+      }) : new _reactNative.Animated.Value(0);
+      this.rightActionTranslate = this.showRightAction.interpolate({
+        inputRange: [0, Number.MIN_VALUE],
+        outputRange: [-10000, 0],
+        extrapolate: 'clamp'
+      });
+    });
+
+    _defineProperty(this, "onTapHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (nativeEvent.oldState === _State.State.ACTIVE) {
+        this.close();
+      }
+    });
+
+    _defineProperty(this, "onHandlerStateChange", ev => {
+      if (ev.nativeEvent.oldState === _State.State.ACTIVE) {
+        this.handleRelease(ev);
+      }
+    });
+
+    _defineProperty(this, "handleRelease", ev => {
+      const {
+        velocityX,
+        translationX: dragX
+      } = ev.nativeEvent;
+      const {
+        leftWidth = 0,
+        rowWidth = 0,
+        rowState
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+      const {
+        friction,
+        leftThreshold = leftWidth / 2,
+        rightThreshold = rightWidth / 2
+      } = this.props;
+      const startOffsetX = this.currentOffset() + dragX / friction;
+      const translationX = (dragX + DRAG_TOSS * velocityX) / friction;
+      let toValue = 0;
+
+      if (rowState === 0) {
+        if (translationX > leftThreshold) {
+          toValue = leftWidth;
+        } else if (translationX < -rightThreshold) {
+          toValue = -rightWidth;
+        }
+      } else if (rowState === 1) {
+        // swiped to left
+        if (translationX > -leftThreshold) {
+          toValue = leftWidth;
+        }
+      } else {
+        // swiped to right
+        if (translationX < rightThreshold) {
+          toValue = -rightWidth;
+        }
+      }
+
+      this.animateRow(startOffsetX, toValue, velocityX / friction);
+    });
+
+    _defineProperty(this, "animateRow", (fromValue, toValue, velocityX) => {
+      const {
+        dragX,
+        rowTranslation
+      } = this.state;
+      dragX.setValue(0);
+      rowTranslation.setValue(fromValue);
+      this.setState({
+        rowState: Math.sign(toValue)
+      });
+
+      _reactNative.Animated.spring(rowTranslation, {
+        restSpeedThreshold: 1.7,
+        restDisplacementThreshold: 0.4,
+        velocity: velocityX,
+        bounciness: 0,
+        toValue,
+        useNativeDriver: this.props.useNativeAnimations,
+        ...this.props.animationOptions
+      }).start(({
+        finished
+      }) => {
+        if (finished) {
+          if (toValue > 0 && this.props.onSwipeableLeftOpen) {
+            this.props.onSwipeableLeftOpen();
+          } else if (toValue < 0 && this.props.onSwipeableRightOpen) {
+            this.props.onSwipeableRightOpen();
+          }
+
+          if (toValue === 0) {
+            var _this$props$onSwipeab, _this$props;
+
+            (_this$props$onSwipeab = (_this$props = this.props).onSwipeableClose) === null || _this$props$onSwipeab === void 0 ? void 0 : _this$props$onSwipeab.call(_this$props);
+          } else {
+            var _this$props$onSwipeab2, _this$props2;
+
+            (_this$props$onSwipeab2 = (_this$props2 = this.props).onSwipeableOpen) === null || _this$props$onSwipeab2 === void 0 ? void 0 : _this$props$onSwipeab2.call(_this$props2);
+          }
+        }
+      });
+
+      if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {
+        this.props.onSwipeableLeftWillOpen();
+      } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {
+        this.props.onSwipeableRightWillOpen();
+      }
+
+      if (toValue === 0) {
+        var _this$props$onSwipeab3, _this$props3;
+
+        (_this$props$onSwipeab3 = (_this$props3 = this.props).onSwipeableWillClose) === null || _this$props$onSwipeab3 === void 0 ? void 0 : _this$props$onSwipeab3.call(_this$props3);
+      } else {
+        var _this$props$onSwipeab4, _this$props4;
+
+        (_this$props$onSwipeab4 = (_this$props4 = this.props).onSwipeableWillOpen) === null || _this$props$onSwipeab4 === void 0 ? void 0 : _this$props$onSwipeab4.call(_this$props4);
+      }
+    });
+
+    _defineProperty(this, "onRowLayout", ({
+      nativeEvent
+    }) => {
+      this.setState({
+        rowWidth: nativeEvent.layout.width
+      });
+    });
+
+    _defineProperty(this, "currentOffset", () => {
+      const {
+        leftWidth = 0,
+        rowWidth = 0,
+        rowState
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+
+      if (rowState === 1) {
+        return leftWidth;
+      } else if (rowState === -1) {
+        return -rightWidth;
+      }
+
+      return 0;
+    });
+
+    _defineProperty(this, "close", () => {
+      this.animateRow(this.currentOffset(), 0);
+    });
+
+    _defineProperty(this, "openLeft", () => {
+      const {
+        leftWidth = 0
+      } = this.state;
+      this.animateRow(this.currentOffset(), leftWidth);
+    });
+
+    _defineProperty(this, "openRight", () => {
+      const {
+        rowWidth = 0
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+      this.animateRow(this.currentOffset(), -rightWidth);
+    });
+
+    const _dragX = new _reactNative.Animated.Value(0);
+
+    this.state = {
+      dragX: _dragX,
+      rowTranslation: new _reactNative.Animated.Value(0),
+      rowState: 0,
+      leftWidth: undefined,
+      rightOffset: undefined,
+      rowWidth: undefined
+    };
+    this.updateAnimatedEvent(_props, this.state);
+    this.onGestureEvent = _reactNative.Animated.event([{
+      nativeEvent: {
+        translationX: _dragX
+      }
+    }], {
+      useNativeDriver: _props.useNativeAnimations
+    });
+  }
+
+  UNSAFE_componentWillUpdate(props, state) {
+    if (this.props.friction !== props.friction || this.props.overshootLeft !== props.overshootLeft || this.props.overshootRight !== props.overshootRight || this.props.overshootFriction !== props.overshootFriction || this.state.leftWidth !== state.leftWidth || this.state.rightOffset !== state.rightOffset || this.state.rowWidth !== state.rowWidth) {
+      this.updateAnimatedEvent(props, state);
+    }
+  }
+
+  render() {
+    const {
+      rowState
+    } = this.state;
+    const {
+      children,
+      renderLeftActions,
+      renderRightActions
+    } = this.props;
+    const left = renderLeftActions && /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+      style: [styles.leftActions, // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason
+      {
+        transform: [{
+          translateX: this.leftActionTranslate
+        }]
+      }]
+    }, renderLeftActions(this.showLeftAction, this.transX), /*#__PURE__*/React.createElement(_reactNative.View, {
+      onLayout: ({
+        nativeEvent
+      }) => this.setState({
+        leftWidth: nativeEvent.layout.x
+      })
+    }));
+    const right = renderRightActions && /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+      style: [styles.rightActions, {
+        transform: [{
+          translateX: this.rightActionTranslate
+        }]
+      }]
+    }, renderRightActions(this.showRightAction, this.transX), /*#__PURE__*/React.createElement(_reactNative.View, {
+      onLayout: ({
+        nativeEvent
+      }) => this.setState({
+        rightOffset: nativeEvent.layout.x
+      })
+    }));
+    return /*#__PURE__*/React.createElement(_gestureHandlers.PanGestureHandler, _extends({
+      activeOffsetX: [-10, 10]
+    }, this.props, {
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.onHandlerStateChange
+    }), /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+      onLayout: this.onRowLayout,
+      style: [styles.container, this.props.containerStyle]
+    }, left, right, /*#__PURE__*/React.createElement(_gestureHandlers.TapGestureHandler, {
+      enabled: rowState !== 0,
+      onHandlerStateChange: this.onTapHandlerStateChange
+    }, /*#__PURE__*/React.createElement(_reactNative.Animated.View, {
+      pointerEvents: rowState === 0 ? 'auto' : 'box-only',
+      style: [{
+        transform: [{
+          translateX: this.transX
+        }]
+      }, this.props.childrenContainerStyle]
+    }, children))));
+  }
+
+}
+
+exports.default = Swipeable;
+
+_defineProperty(Swipeable, "defaultProps", {
+  friction: 1,
+  overshootFriction: 1,
+  useNativeAnimations: true
+});
+
+const styles = _reactNative.StyleSheet.create({
+  container: {
+    overflow: 'hidden'
+  },
+  leftActions: { ..._reactNative.StyleSheet.absoluteFillObject,
+    flexDirection: _reactNative.I18nManager.isRTL ? 'row-reverse' : 'row'
+  },
+  rightActions: { ..._reactNative.StyleSheet.absoluteFillObject,
+    flexDirection: _reactNative.I18nManager.isRTL ? 'row' : 'row-reverse'
+  }
+});
+//# sourceMappingURL=Swipeable.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js.map
new file mode 100644
index 0000000..7665b2e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/Swipeable.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Swipeable.tsx"],"names":["DRAG_TOSS","Swipeable","Component","constructor","props","state","friction","overshootFriction","dragX","rowTranslation","leftWidth","rowWidth","rightOffset","rightWidth","Math","max","overshootLeft","overshootRight","transX","Animated","add","interpolate","inputRange","outputRange","showLeftAction","Value","leftActionTranslate","Number","MIN_VALUE","extrapolate","showRightAction","rightActionTranslate","nativeEvent","oldState","State","ACTIVE","close","ev","handleRelease","velocityX","translationX","rowState","leftThreshold","rightThreshold","startOffsetX","currentOffset","toValue","animateRow","fromValue","setValue","setState","sign","spring","restSpeedThreshold","restDisplacementThreshold","velocity","bounciness","useNativeDriver","useNativeAnimations","animationOptions","start","finished","onSwipeableLeftOpen","onSwipeableRightOpen","onSwipeableClose","onSwipeableOpen","onSwipeableLeftWillOpen","onSwipeableRightWillOpen","onSwipeableWillClose","onSwipeableWillOpen","layout","width","undefined","updateAnimatedEvent","onGestureEvent","event","UNSAFE_componentWillUpdate","render","children","renderLeftActions","renderRightActions","left","styles","leftActions","transform","translateX","x","right","rightActions","onHandlerStateChange","onRowLayout","container","containerStyle","onTapHandlerStateChange","childrenContainerStyle","StyleSheet","create","overflow","absoluteFillObject","flexDirection","I18nManager","isRTL"],"mappings":"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","sourcesContent":["// Similarily to the DrawerLayout component this deserves to be put in a\n// separate repo. Although, keeping it here for the time being will allow us\n// to move faster and fix possible issues quicker\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  I18nManager,\n  LayoutChangeEvent,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport {\n  PanGestureHandler,\n  TapGestureHandler,\n  PanGestureHandlerProps,\n  GestureEvent,\n  PanGestureHandlerEventPayload,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\ntype SwipeableExcludes = Exclude<\n  keyof PanGestureHandlerProps,\n  'onGestureEvent' | 'onHandlerStateChange'\n>;\n\ninterface SwipeableProps\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\n  enableTrackpadTwoFingerGesture?: boolean;\n  friction?: number;\n  leftThreshold?: number;\n  rightThreshold?: number;\n  overshootLeft?: boolean;\n  overshootRight?: boolean;\n  overshootFriction?: number;\n  onSwipeableLeftOpen?: () => void;\n  onSwipeableRightOpen?: () => void;\n  onSwipeableOpen?: () => void;\n  onSwipeableClose?: () => void;\n  onSwipeableLeftWillOpen?: () => void;\n  onSwipeableRightWillOpen?: () => void;\n  onSwipeableWillOpen?: () => void;\n  onSwipeableWillClose?: () => void;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, +]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderLeftActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, -]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderRightActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  useNativeAnimations?: boolean;\n  animationOptions?: Record<string, unknown>;\n  containerStyle?: StyleProp<ViewStyle>;\n  childrenContainerStyle?: StyleProp<ViewStyle>;\n}\n\ntype SwipeableState = {\n  dragX: Animated.Value;\n  rowTranslation: Animated.Value;\n  rowState: number;\n  leftWidth?: number;\n  rightOffset?: number;\n  rowWidth?: number;\n};\n\nexport default class Swipeable extends Component<\n  SwipeableProps,\n  SwipeableState\n> {\n  static defaultProps = {\n    friction: 1,\n    overshootFriction: 1,\n    useNativeAnimations: true,\n  };\n\n  constructor(props: SwipeableProps) {\n    super(props);\n    const dragX = new Animated.Value(0);\n    this.state = {\n      dragX,\n      rowTranslation: new Animated.Value(0),\n      rowState: 0,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      rowWidth: undefined,\n    };\n    this.updateAnimatedEvent(props, this.state);\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragX } }],\n      { useNativeDriver: props.useNativeAnimations! }\n    );\n  }\n\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\n    if (\n      this.props.friction !== props.friction ||\n      this.props.overshootLeft !== props.overshootLeft ||\n      this.props.overshootRight !== props.overshootRight ||\n      this.props.overshootFriction !== props.overshootFriction ||\n      this.state.leftWidth !== state.leftWidth ||\n      this.state.rightOffset !== state.rightOffset ||\n      this.state.rowWidth !== state.rowWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private transX?: Animated.AnimatedInterpolation;\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\n\n  private updateAnimatedEvent = (\n    props: SwipeableProps,\n    state: SwipeableState\n  ) => {\n    const { friction, overshootFriction } = props;\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\n    const { rightOffset = rowWidth } = state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n\n    const {\n      overshootLeft = leftWidth > 0,\n      overshootRight = rightWidth > 0,\n    } = props;\n\n    const transX = Animated.add(\n      rowTranslation,\n      dragX.interpolate({\n        inputRange: [0, friction!],\n        outputRange: [0, 1],\n      })\n    ).interpolate({\n      inputRange: [\n        -rightWidth - (overshootRight ? 1 : overshootFriction!),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft ? 1 : overshootFriction!),\n      ],\n      outputRange: [\n        -rightWidth - (overshootRight || overshootFriction! > 1 ? 1 : 0),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft || overshootFriction! > 1 ? 1 : 0),\n      ],\n    });\n    this.transX = transX;\n    this.showLeftAction =\n      leftWidth > 0\n        ? transX.interpolate({\n            inputRange: [-1, 0, leftWidth],\n            outputRange: [0, 0, 1],\n          })\n        : new Animated.Value(0);\n    this.leftActionTranslate = this.showLeftAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n    this.showRightAction =\n      rightWidth > 0\n        ? transX.interpolate({\n            inputRange: [-rightWidth, 0, 1],\n            outputRange: [1, 0, 0],\n          })\n        : new Animated.Value(0);\n    this.rightActionTranslate = this.showRightAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.close();\n    }\n  };\n\n  private onHandlerStateChange = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease(ev);\n    }\n  };\n\n  private handleRelease = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    const {\n      friction,\n      leftThreshold = leftWidth / 2,\n      rightThreshold = rightWidth / 2,\n    } = this.props;\n\n    const startOffsetX = this.currentOffset() + dragX / friction!;\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\n\n    let toValue = 0;\n    if (rowState === 0) {\n      if (translationX > leftThreshold) {\n        toValue = leftWidth;\n      } else if (translationX < -rightThreshold) {\n        toValue = -rightWidth;\n      }\n    } else if (rowState === 1) {\n      // swiped to left\n      if (translationX > -leftThreshold) {\n        toValue = leftWidth;\n      }\n    } else {\n      // swiped to right\n      if (translationX < rightThreshold) {\n        toValue = -rightWidth;\n      }\n    }\n\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\n  };\n\n  private animateRow = (\n    fromValue: number,\n    toValue: number,\n    velocityX?:\n      | number\n      | {\n          x: number;\n          y: number;\n        }\n  ) => {\n    const { dragX, rowTranslation } = this.state;\n    dragX.setValue(0);\n    rowTranslation.setValue(fromValue);\n\n    this.setState({ rowState: Math.sign(toValue) });\n    Animated.spring(rowTranslation, {\n      restSpeedThreshold: 1.7,\n      restDisplacementThreshold: 0.4,\n      velocity: velocityX,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      ...this.props.animationOptions,\n    }).start(({ finished }) => {\n      if (finished) {\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n          this.props.onSwipeableLeftOpen();\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\n          this.props.onSwipeableRightOpen();\n        }\n\n        if (toValue === 0) {\n          this.props.onSwipeableClose?.();\n        } else {\n          this.props.onSwipeableOpen?.();\n        }\n      }\n    });\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\n      this.props.onSwipeableLeftWillOpen();\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\n      this.props.onSwipeableRightWillOpen();\n    }\n\n    if (toValue === 0) {\n      this.props.onSwipeableWillClose?.();\n    } else {\n      this.props.onSwipeableWillOpen?.();\n    }\n  };\n\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ rowWidth: nativeEvent.layout.width });\n  };\n\n  private currentOffset = () => {\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    if (rowState === 1) {\n      return leftWidth;\n    } else if (rowState === -1) {\n      return -rightWidth;\n    }\n    return 0;\n  };\n\n  close = () => {\n    this.animateRow(this.currentOffset(), 0);\n  };\n\n  openLeft = () => {\n    const { leftWidth = 0 } = this.state;\n    this.animateRow(this.currentOffset(), leftWidth);\n  };\n\n  openRight = () => {\n    const { rowWidth = 0 } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    this.animateRow(this.currentOffset(), -rightWidth);\n  };\n\n  render() {\n    const { rowState } = this.state;\n    const { children, renderLeftActions, renderRightActions } = this.props;\n\n    const left = renderLeftActions && (\n      <Animated.View\n        style={[\n          styles.leftActions,\n          // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason\n          { transform: [{ translateX: this.leftActionTranslate! }] },\n        ]}>\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ leftWidth: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    const right = renderRightActions && (\n      <Animated.View\n        style={[\n          styles.rightActions,\n          { transform: [{ translateX: this.rightActionTranslate! }] },\n        ]}>\n        {renderRightActions(this.showRightAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ rightOffset: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    return (\n      <PanGestureHandler\n        activeOffsetX={[-10, 10]}\n        {...this.props}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}>\n        <Animated.View\n          onLayout={this.onRowLayout}\n          style={[styles.container, this.props.containerStyle]}>\n          {left}\n          {right}\n          <TapGestureHandler\n            enabled={rowState !== 0}\n            onHandlerStateChange={this.onTapHandlerStateChange}>\n            <Animated.View\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\n              style={[\n                {\n                  transform: [{ translateX: this.transX! }],\n                },\n                this.props.childrenContainerStyle,\n              ]}>\n              {children}\n            </Animated.View>\n          </TapGestureHandler>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden',\n  },\n  leftActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\n  },\n  rightActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js
new file mode 100644
index 0000000..65886ae
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js
@@ -0,0 +1,277 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.TOUCHABLE_STATE = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _State = require("../../State");
+
+var _GestureButtons = require("../GestureButtons");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * Each touchable is a states' machine which preforms transitions.
+ * On very beginning (and on the very end or recognition) touchable is
+ * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger
+ * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition
+ * finishes in UNDETERMINED state.
+ */
+const TOUCHABLE_STATE = {
+  UNDETERMINED: 0,
+  BEGAN: 1,
+  MOVED_OUTSIDE: 2
+};
+exports.TOUCHABLE_STATE = TOUCHABLE_STATE;
+
+/**
+ * GenericTouchable is not intented to be used as it is.
+ * Should be treated as a source for the rest of touchables
+ */
+class GenericTouchable extends React.Component {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "pressInTimeout", void 0);
+
+    _defineProperty(this, "pressOutTimeout", void 0);
+
+    _defineProperty(this, "longPressTimeout", void 0);
+
+    _defineProperty(this, "longPressDetected", false);
+
+    _defineProperty(this, "pointerInside", true);
+
+    _defineProperty(this, "STATE", TOUCHABLE_STATE.UNDETERMINED);
+
+    _defineProperty(this, "onGestureEvent", ({
+      nativeEvent: {
+        pointerInside
+      }
+    }) => {
+      if (this.pointerInside !== pointerInside) {
+        if (pointerInside) {
+          this.onMoveIn();
+        } else {
+          this.onMoveOut();
+        }
+      }
+
+      this.pointerInside = pointerInside;
+    });
+
+    _defineProperty(this, "onHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      const {
+        state
+      } = nativeEvent;
+
+      if (state === _State.State.CANCELLED || state === _State.State.FAILED) {
+        // Need to handle case with external cancellation (e.g. by ScrollView)
+        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+      } else if ( // This platform check is an implication of slightly different behavior of handlers on different platform.
+      // And Android "Active" state is achieving on first move of a finger, not on press in.
+      // On iOS event on "Began" is not delivered.
+      state === (_reactNative.Platform.OS !== 'android' ? _State.State.ACTIVE : _State.State.BEGAN) && this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+        // Moving inside requires
+        this.handlePressIn();
+      } else if (state === _State.State.END) {
+        const shouldCallOnPress = !this.longPressDetected && this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE && this.pressOutTimeout === null;
+        this.handleGoToUndetermined();
+
+        if (shouldCallOnPress) {
+          var _this$props$onPress, _this$props;
+
+          // Calls only inside component whether no long press was called previously
+          (_this$props$onPress = (_this$props = this.props).onPress) === null || _this$props$onPress === void 0 ? void 0 : _this$props$onPress.call(_this$props);
+        }
+      }
+    });
+
+    _defineProperty(this, "onLongPressDetected", () => {
+      var _this$props$onLongPre, _this$props2;
+
+      this.longPressDetected = true; // checked for in the caller of `onLongPressDetected`, but better to check twice
+
+      (_this$props$onLongPre = (_this$props2 = this.props).onLongPress) === null || _this$props$onLongPre === void 0 ? void 0 : _this$props$onLongPre.call(_this$props2);
+    });
+  }
+
+  // handlePressIn in called on first touch on traveling inside component.
+  // Handles state transition with delay.
+  handlePressIn() {
+    if (this.props.delayPressIn) {
+      this.pressInTimeout = setTimeout(() => {
+        this.moveToState(TOUCHABLE_STATE.BEGAN);
+        this.pressInTimeout = null;
+      }, this.props.delayPressIn);
+    } else {
+      this.moveToState(TOUCHABLE_STATE.BEGAN);
+    }
+
+    if (this.props.onLongPress) {
+      const time = (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);
+      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);
+    }
+  } // handleMoveOutside in called on traveling outside component.
+  // Handles state transition with delay.
+
+
+  handleMoveOutside() {
+    if (this.props.delayPressOut) {
+      this.pressOutTimeout = this.pressOutTimeout || setTimeout(() => {
+        this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
+        this.pressOutTimeout = null;
+      }, this.props.delayPressOut);
+    } else {
+      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
+    }
+  } // handleGoToUndetermined transits to UNDETERMINED state with proper delay
+
+
+  handleGoToUndetermined() {
+    clearTimeout(this.pressOutTimeout); // TODO: maybe it can be undefined
+
+    if (this.props.delayPressOut) {
+      this.pressOutTimeout = setTimeout(() => {
+        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+          this.moveToState(TOUCHABLE_STATE.BEGAN);
+        }
+
+        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+        this.pressOutTimeout = null;
+      }, this.props.delayPressOut);
+    } else {
+      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+        this.moveToState(TOUCHABLE_STATE.BEGAN);
+      }
+
+      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+    }
+  }
+
+  componentDidMount() {
+    this.reset();
+  } // reset timeout to prevent memory leaks.
+
+
+  reset() {
+    this.longPressDetected = false;
+    this.pointerInside = true;
+    clearTimeout(this.pressInTimeout);
+    clearTimeout(this.pressOutTimeout);
+    clearTimeout(this.longPressTimeout);
+    this.pressOutTimeout = null;
+    this.longPressTimeout = null;
+    this.pressInTimeout = null;
+  } // All states' transitions are defined here.
+
+
+  moveToState(newState) {
+    var _this$props$onStateCh, _this$props6;
+
+    if (newState === this.STATE) {
+      // Ignore dummy transitions
+      return;
+    }
+
+    if (newState === TOUCHABLE_STATE.BEGAN) {
+      var _this$props$onPressIn, _this$props3;
+
+      // First touch and moving inside
+      (_this$props$onPressIn = (_this$props3 = this.props).onPressIn) === null || _this$props$onPressIn === void 0 ? void 0 : _this$props$onPressIn.call(_this$props3);
+    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+      var _this$props$onPressOu, _this$props4;
+
+      // Moving outside
+      (_this$props$onPressOu = (_this$props4 = this.props).onPressOut) === null || _this$props$onPressOu === void 0 ? void 0 : _this$props$onPressOu.call(_this$props4);
+    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {
+      // Need to reset each time on transition to UNDETERMINED
+      this.reset();
+
+      if (this.STATE === TOUCHABLE_STATE.BEGAN) {
+        var _this$props$onPressOu2, _this$props5;
+
+        // ... and if it happens inside button.
+        (_this$props$onPressOu2 = (_this$props5 = this.props).onPressOut) === null || _this$props$onPressOu2 === void 0 ? void 0 : _this$props$onPressOu2.call(_this$props5);
+      }
+    } // Finally call lister (used by subclasses)
+
+
+    (_this$props$onStateCh = (_this$props6 = this.props).onStateChange) === null || _this$props$onStateCh === void 0 ? void 0 : _this$props$onStateCh.call(_this$props6, this.STATE, newState); // ... and make transition.
+
+    this.STATE = newState;
+  }
+
+  componentWillUnmount() {
+    // to prevent memory leaks
+    this.reset();
+  }
+
+  onMoveIn() {
+    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+      // This call is not throttled with delays (like in RN's implementation).
+      this.moveToState(TOUCHABLE_STATE.BEGAN);
+    }
+  }
+
+  onMoveOut() {
+    // long press should no longer be detected
+    clearTimeout(this.longPressTimeout);
+    this.longPressTimeout = null;
+
+    if (this.STATE === TOUCHABLE_STATE.BEGAN) {
+      this.handleMoveOutside();
+    }
+  }
+
+  render() {
+    const coreProps = {
+      accessible: this.props.accessible !== false,
+      accessibilityLabel: this.props.accessibilityLabel,
+      accessibilityHint: this.props.accessibilityHint,
+      accessibilityRole: this.props.accessibilityRole,
+      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,
+      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016
+      accessibilityState: this.props.accessibilityState,
+      nativeID: this.props.nativeID,
+      onLayout: this.props.onLayout,
+      hitSlop: this.props.hitSlop
+    };
+    return /*#__PURE__*/React.createElement(_GestureButtons.BaseButton, _extends({
+      style: this.props.containerStyle,
+      onHandlerStateChange: // TODO: not sure if it can be undefined instead of null
+      this.props.disabled ? undefined : this.onHandlerStateChange,
+      onGestureEvent: this.onGestureEvent,
+      hitSlop: this.props.hitSlop,
+      shouldActivateOnStart: this.props.shouldActivateOnStart,
+      disallowInterruption: this.props.disallowInterruption,
+      testID: this.props.testID
+    }, this.props.extraButtonProps), /*#__PURE__*/React.createElement(_reactNative.Animated.View, _extends({}, coreProps, {
+      style: this.props.style
+    }), this.props.children));
+  }
+
+}
+
+exports.default = GenericTouchable;
+
+_defineProperty(GenericTouchable, "defaultProps", {
+  delayLongPress: 600,
+  extraButtonProps: {
+    rippleColor: 'transparent'
+  }
+});
+//# sourceMappingURL=GenericTouchable.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js.map
new file mode 100644
index 0000000..3567cab
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/GenericTouchable.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GenericTouchable.tsx"],"names":["TOUCHABLE_STATE","UNDETERMINED","BEGAN","MOVED_OUTSIDE","GenericTouchable","Component","nativeEvent","pointerInside","onMoveIn","onMoveOut","state","State","CANCELLED","FAILED","moveToState","Platform","OS","ACTIVE","STATE","handlePressIn","END","shouldCallOnPress","longPressDetected","pressOutTimeout","handleGoToUndetermined","props","onPress","onLongPress","delayPressIn","pressInTimeout","setTimeout","time","delayLongPress","longPressTimeout","onLongPressDetected","handleMoveOutside","delayPressOut","clearTimeout","componentDidMount","reset","newState","onPressIn","onPressOut","onStateChange","componentWillUnmount","render","coreProps","accessible","accessibilityLabel","accessibilityHint","accessibilityRole","accessibilityState","nativeID","onLayout","hitSlop","containerStyle","disabled","undefined","onHandlerStateChange","onGestureEvent","shouldActivateOnStart","disallowInterruption","testID","extraButtonProps","style","children","rippleColor"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  Platform,\n  StyleProp,\n  ViewStyle,\n  TouchableWithoutFeedbackProps,\n} from 'react-native';\n\nimport { State } from '../../State';\nimport { BaseButton } from '../GestureButtons';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../../handlers/gestureHandlers';\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\n\n/**\n * Each touchable is a states' machine which preforms transitions.\n * On very beginning (and on the very end or recognition) touchable is\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\n * finishes in UNDETERMINED state.\n */\nexport const TOUCHABLE_STATE = {\n  UNDETERMINED: 0,\n  BEGAN: 1,\n  MOVED_OUTSIDE: 2,\n} as const;\n\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\n\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\n  // Decided to drop not used fields from RN's implementation.\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\n\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\n  onPress?: () => void;\n  onPressIn?: () => void;\n  onPressOut?: () => void;\n  onLongPress?: () => void;\n\n  nativeID?: string;\n  shouldActivateOnStart?: boolean;\n  disallowInterruption?: boolean;\n\n  containerStyle?: StyleProp<ViewStyle>;\n}\n\ninterface InternalProps {\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\n}\n\n// TODO: maybe can be better\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\n\n/**\n * GenericTouchable is not intented to be used as it is.\n * Should be treated as a source for the rest of touchables\n */\n\nexport default class GenericTouchable extends Component<\n  GenericTouchableProps & InternalProps\n> {\n  static defaultProps = {\n    delayLongPress: 600,\n    extraButtonProps: {\n      rippleColor: 'transparent',\n    },\n  };\n\n  // timeout handlers\n  pressInTimeout: Timeout;\n  pressOutTimeout: Timeout;\n  longPressTimeout: Timeout;\n\n  // This flag is required since recognition of longPress implies not-invoking onPress\n  longPressDetected = false;\n\n  pointerInside = true;\n\n  // State of touchable\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\n\n  // handlePressIn in called on first touch on traveling inside component.\n  // Handles state transition with delay.\n  handlePressIn() {\n    if (this.props.delayPressIn) {\n      this.pressInTimeout = setTimeout(() => {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n        this.pressInTimeout = null;\n      }, this.props.delayPressIn);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n    if (this.props.onLongPress) {\n      const time =\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\n    }\n  }\n  // handleMoveOutside in called on traveling outside component.\n  // Handles state transition with delay.\n  handleMoveOutside() {\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout =\n        this.pressOutTimeout ||\n        setTimeout(() => {\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n          this.pressOutTimeout = null;\n        }, this.props.delayPressOut);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n    }\n  }\n\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\n  handleGoToUndetermined() {\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout = setTimeout(() => {\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\n        }\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n        this.pressOutTimeout = null;\n      }, this.props.delayPressOut);\n    } else {\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n      }\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    }\n  }\n\n  componentDidMount() {\n    this.reset();\n  }\n  // reset timeout to prevent memory leaks.\n  reset() {\n    this.longPressDetected = false;\n    this.pointerInside = true;\n    clearTimeout(this.pressInTimeout!);\n    clearTimeout(this.pressOutTimeout!);\n    clearTimeout(this.longPressTimeout!);\n    this.pressOutTimeout = null;\n    this.longPressTimeout = null;\n    this.pressInTimeout = null;\n  }\n\n  // All states' transitions are defined here.\n  moveToState(newState: TouchableState) {\n    if (newState === this.STATE) {\n      // Ignore dummy transitions\n      return;\n    }\n    if (newState === TOUCHABLE_STATE.BEGAN) {\n      // First touch and moving inside\n      this.props.onPressIn?.();\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // Moving outside\n      this.props.onPressOut?.();\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\n      // Need to reset each time on transition to UNDETERMINED\n      this.reset();\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n        // ... and if it happens inside button.\n        this.props.onPressOut?.();\n      }\n    }\n    // Finally call lister (used by subclasses)\n    this.props.onStateChange?.(this.STATE, newState);\n    // ... and make transition.\n    this.STATE = newState;\n  }\n\n  onGestureEvent = ({\n    nativeEvent: { pointerInside },\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\n    if (this.pointerInside !== pointerInside) {\n      if (pointerInside) {\n        this.onMoveIn();\n      } else {\n        this.onMoveOut();\n      }\n    }\n    this.pointerInside = pointerInside;\n  };\n\n  onHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state } = nativeEvent;\n    if (state === State.CANCELLED || state === State.FAILED) {\n      // Need to handle case with external cancellation (e.g. by ScrollView)\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    } else if (\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\n      // And Android \"Active\" state is achieving on first move of a finger, not on press in.\n      // On iOS event on \"Began\" is not delivered.\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\n    ) {\n      // Moving inside requires\n      this.handlePressIn();\n    } else if (state === State.END) {\n      const shouldCallOnPress =\n        !this.longPressDetected &&\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\n        this.pressOutTimeout === null;\n      this.handleGoToUndetermined();\n      if (shouldCallOnPress) {\n        // Calls only inside component whether no long press was called previously\n        this.props.onPress?.();\n      }\n    }\n  };\n\n  onLongPressDetected = () => {\n    this.longPressDetected = true;\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\n    this.props.onLongPress?.();\n  };\n\n  componentWillUnmount() {\n    // to prevent memory leaks\n    this.reset();\n  }\n\n  onMoveIn() {\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // This call is not throttled with delays (like in RN's implementation).\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n  }\n\n  onMoveOut() {\n    // long press should no longer be detected\n    clearTimeout(this.longPressTimeout!);\n    this.longPressTimeout = null;\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n      this.handleMoveOutside();\n    }\n  }\n\n  render() {\n    const coreProps = {\n      accessible: this.props.accessible !== false,\n      accessibilityLabel: this.props.accessibilityLabel,\n      accessibilityHint: this.props.accessibilityHint,\n      accessibilityRole: this.props.accessibilityRole,\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\n      accessibilityState: this.props.accessibilityState,\n      nativeID: this.props.nativeID,\n      onLayout: this.props.onLayout,\n      hitSlop: this.props.hitSlop,\n    };\n\n    return (\n      <BaseButton\n        style={this.props.containerStyle}\n        onHandlerStateChange={\n          // TODO: not sure if it can be undefined instead of null\n          this.props.disabled ? undefined : this.onHandlerStateChange\n        }\n        onGestureEvent={this.onGestureEvent}\n        hitSlop={this.props.hitSlop}\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\n        disallowInterruption={this.props.disallowInterruption}\n        testID={this.props.testID}\n        {...this.props.extraButtonProps}>\n        <Animated.View {...coreProps} style={this.props.style}>\n          {this.props.children}\n        </Animated.View>\n      </BaseButton>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js
new file mode 100644
index 0000000..c792c98
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js
@@ -0,0 +1,109 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _GenericTouchable = _interopRequireWildcard(require("./GenericTouchable"));
+
+var _reactNative = require("react-native");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * TouchableHighlight follows RN's implementation
+ */
+class TouchableHighlight extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "showUnderlay", () => {
+      var _this$props$onShowUnd, _this$props;
+
+      if (!this.hasPressHandler()) {
+        return;
+      }
+
+      this.setState({
+        extraChildStyle: {
+          opacity: this.props.activeOpacity
+        },
+        extraUnderlayStyle: {
+          backgroundColor: this.props.underlayColor
+        }
+      });
+      (_this$props$onShowUnd = (_this$props = this.props).onShowUnderlay) === null || _this$props$onShowUnd === void 0 ? void 0 : _this$props$onShowUnd.call(_this$props);
+    });
+
+    _defineProperty(this, "hasPressHandler", () => this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
+
+    _defineProperty(this, "hideUnderlay", () => {
+      var _this$props$onHideUnd, _this$props2;
+
+      this.setState({
+        extraChildStyle: null,
+        extraUnderlayStyle: null
+      });
+      (_this$props$onHideUnd = (_this$props2 = this.props).onHideUnderlay) === null || _this$props$onHideUnd === void 0 ? void 0 : _this$props$onHideUnd.call(_this$props2);
+    });
+
+    _defineProperty(this, "onStateChange", (_from, to) => {
+      if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
+        this.showUnderlay();
+      } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
+        this.hideUnderlay();
+      }
+    });
+
+    this.state = {
+      extraChildStyle: null,
+      extraUnderlayStyle: null
+    };
+  } // Copied from RN
+
+
+  renderChildren() {
+    if (!this.props.children) {
+      return /*#__PURE__*/React.createElement(_reactNative.View, null);
+    }
+
+    const child = React.Children.only(this.props.children); // TODO: not sure if OK but fixes error
+
+    return /*#__PURE__*/React.cloneElement(child, {
+      style: _reactNative.StyleSheet.compose(child.props.style, this.state.extraChildStyle)
+    });
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    const {
+      extraUnderlayStyle
+    } = this.state;
+    return /*#__PURE__*/React.createElement(_GenericTouchable.default, _extends({}, rest, {
+      style: [style, extraUnderlayStyle],
+      onStateChange: this.onStateChange
+    }), this.renderChildren());
+  }
+
+}
+
+exports.default = TouchableHighlight;
+
+_defineProperty(TouchableHighlight, "defaultProps", { ..._GenericTouchable.default.defaultProps,
+  activeOpacity: 0.85,
+  delayPressOut: 100,
+  underlayColor: 'black'
+});
+//# sourceMappingURL=TouchableHighlight.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js.map
new file mode 100644
index 0000000..d4c47d3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableHighlight.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableHighlight.tsx"],"names":["TouchableHighlight","Component","constructor","props","hasPressHandler","setState","extraChildStyle","opacity","activeOpacity","extraUnderlayStyle","backgroundColor","underlayColor","onShowUnderlay","onPress","onPressIn","onPressOut","onLongPress","onHideUnderlay","_from","to","TOUCHABLE_STATE","BEGAN","showUnderlay","UNDETERMINED","MOVED_OUTSIDE","hideUnderlay","state","renderChildren","children","child","React","Children","only","cloneElement","style","StyleSheet","compose","render","rest","onStateChange","GenericTouchable","defaultProps","delayPressOut"],"mappings":";;;;;;;AAAA;;AAEA;;AAIA;;;;;;;;;;AAiBA;AACA;AACA;AACe,MAAMA,kBAAN,SAAiCC,eAAjC,CAGb;AAQAC,EAAAA,WAAW,CAACC,KAAD,EAAyD;AAClE,UAAMA,KAAN;;AADkE,0CASrD,MAAM;AAAA;;AACnB,UAAI,CAAC,KAAKC,eAAL,EAAL,EAA6B;AAC3B;AACD;;AACD,WAAKC,QAAL,CAAc;AACZC,QAAAA,eAAe,EAAE;AACfC,UAAAA,OAAO,EAAE,KAAKJ,KAAL,CAAWK;AADL,SADL;AAIZC,QAAAA,kBAAkB,EAAE;AAClBC,UAAAA,eAAe,EAAE,KAAKP,KAAL,CAAWQ;AADV;AAJR,OAAd;AAQA,mDAAKR,KAAL,EAAWS,cAAX;AACD,KAtBmE;;AAAA,6CAwBlD,MAChB,KAAKT,KAAL,CAAWU,OAAX,IACA,KAAKV,KAAL,CAAWW,SADX,IAEA,KAAKX,KAAL,CAAWY,UAFX,IAGA,KAAKZ,KAAL,CAAWa,WA5BuD;;AAAA,0CA8BrD,MAAM;AAAA;;AACnB,WAAKX,QAAL,CAAc;AACZC,QAAAA,eAAe,EAAE,IADL;AAEZG,QAAAA,kBAAkB,EAAE;AAFR,OAAd;AAIA,oDAAKN,KAAL,EAAWc,cAAX;AACD,KApCmE;;AAAA,2CAmDpD,CAACC,KAAD,EAAgBC,EAAhB,KAA+B;AAC7C,UAAIA,EAAE,KAAKC,kCAAgBC,KAA3B,EAAkC;AAChC,aAAKC,YAAL;AACD,OAFD,MAEO,IACLH,EAAE,KAAKC,kCAAgBG,YAAvB,IACAJ,EAAE,KAAKC,kCAAgBI,aAFlB,EAGL;AACA,aAAKC,YAAL;AACD;AACF,KA5DmE;;AAElE,SAAKC,KAAL,GAAa;AACXpB,MAAAA,eAAe,EAAE,IADN;AAEXG,MAAAA,kBAAkB,EAAE;AAFT,KAAb;AAID,GAdD,CAgBA;;;AA8BAkB,EAAAA,cAAc,GAAG;AACf,QAAI,CAAC,KAAKxB,KAAL,CAAWyB,QAAhB,EAA0B;AACxB,0BAAO,oBAAC,iBAAD,OAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,KAAK,CAACC,QAAN,CAAeC,IAAf,CACZ,KAAK7B,KAAL,CAAWyB,QADC,CAAd,CALe,CAOqB;;AACpC,wBAAOE,KAAK,CAACG,YAAN,CAAmBJ,KAAnB,EAA0B;AAC/BK,MAAAA,KAAK,EAAEC,wBAAWC,OAAX,CAAmBP,KAAK,CAAC1B,KAAN,CAAY+B,KAA/B,EAAsC,KAAKR,KAAL,CAAWpB,eAAjD;AADwB,KAA1B,CAAP;AAGD;;AAaD+B,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEH,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGI;AAAjB,QAA0B,KAAKnC,KAArC;AACA,UAAM;AAAEM,MAAAA;AAAF,QAAyB,KAAKiB,KAApC;AACA,wBACE,oBAAC,yBAAD,eACMY,IADN;AAEE,MAAA,KAAK,EAAE,CAACJ,KAAD,EAAQzB,kBAAR,CAFT;AAGE,MAAA,aAAa,EAAE,KAAK8B;AAHtB,QAIG,KAAKZ,cAAL,EAJH,CADF;AAQD;;AAjFD;;;;gBAHmB3B,kB,kBAIG,EACpB,GAAGwC,0BAAiBC,YADA;AAEpBjC,EAAAA,aAAa,EAAE,IAFK;AAGpBkC,EAAAA,aAAa,EAAE,GAHK;AAIpB/B,EAAAA,aAAa,EAAE;AAJK,C","sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport GenericTouchable, {\n  GenericTouchableProps,\n  TOUCHABLE_STATE,\n} from './GenericTouchable';\nimport {\n  StyleSheet,\n  View,\n  TouchableHighlightProps,\n  ColorValue,\n  ViewProps,\n} from 'react-native';\n\ninterface State {\n  extraChildStyle: null | {\n    opacity?: number;\n  };\n  extraUnderlayStyle: null | {\n    backgroundColor?: ColorValue;\n  };\n}\n\n/**\n * TouchableHighlight follows RN's implementation\n */\nexport default class TouchableHighlight extends Component<\n  TouchableHighlightProps & GenericTouchableProps,\n  State\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.85,\n    delayPressOut: 100,\n    underlayColor: 'black',\n  };\n\n  constructor(props: TouchableHighlightProps & GenericTouchableProps) {\n    super(props);\n    this.state = {\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    };\n  }\n\n  // Copied from RN\n  showUnderlay = () => {\n    if (!this.hasPressHandler()) {\n      return;\n    }\n    this.setState({\n      extraChildStyle: {\n        opacity: this.props.activeOpacity,\n      },\n      extraUnderlayStyle: {\n        backgroundColor: this.props.underlayColor,\n      },\n    });\n    this.props.onShowUnderlay?.();\n  };\n\n  hasPressHandler = () =>\n    this.props.onPress ||\n    this.props.onPressIn ||\n    this.props.onPressOut ||\n    this.props.onLongPress;\n\n  hideUnderlay = () => {\n    this.setState({\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    });\n    this.props.onHideUnderlay?.();\n  };\n\n  renderChildren() {\n    if (!this.props.children) {\n      return <View />;\n    }\n\n    const child = React.Children.only(\n      this.props.children\n    ) as React.ReactElement<ViewProps>; // TODO: not sure if OK but fixes error\n    return React.cloneElement(child, {\n      style: StyleSheet.compose(child.props.style, this.state.extraChildStyle),\n    });\n  }\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.showUnderlay();\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.hideUnderlay();\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    const { extraUnderlayStyle } = this.state;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[style, extraUnderlayStyle]}\n        onStateChange={this.onStateChange}>\n        {this.renderChildren()}\n      </GenericTouchable>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js
new file mode 100644
index 0000000..c07b4e9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js
@@ -0,0 +1,100 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var React = _interopRequireWildcard(require("react"));
+
+var _GenericTouchable = _interopRequireDefault(require("./GenericTouchable"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.
+ * There's small difference with handling long press ripple since RN's implementation calls
+ * ripple animation via bridge. This solution leaves all animations' handling for native components so
+ * it follows native behaviours.
+ */
+class TouchableNativeFeedback extends React.Component {
+  // could be taken as RNTouchableNativeFeedback.SelectableBackground etc. but the API may change
+  getExtraButtonProps() {
+    const extraProps = {};
+    const {
+      background
+    } = this.props;
+
+    if (background) {
+      // I changed type values to match those used in RN
+      // TODO(TS): check if it works the same as previous implementation - looks like it works the same as RN component, so it should be ok
+      if (background.type === 'RippleAndroid') {
+        extraProps['borderless'] = background.borderless;
+        extraProps['rippleColor'] = background.color;
+      } else if (background.type === 'ThemeAttrAndroid') {
+        extraProps['borderless'] = background.attribute === 'selectableItemBackgroundBorderless';
+      } // I moved it from above since it should be available in all options
+
+
+      extraProps['rippleRadius'] = background.rippleRadius;
+    }
+
+    extraProps['foreground'] = this.props.useForeground;
+    return extraProps;
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(_GenericTouchable.default, _extends({}, rest, {
+      style: style,
+      extraButtonProps: this.getExtraButtonProps()
+    }));
+  }
+
+}
+
+exports.default = TouchableNativeFeedback;
+
+_defineProperty(TouchableNativeFeedback, "defaultProps", { ..._GenericTouchable.default.defaultProps,
+  useForeground: true,
+  extraButtonProps: {
+    // Disable hiding ripple on Android
+    rippleColor: null
+  }
+});
+
+_defineProperty(TouchableNativeFeedback, "SelectableBackground", rippleRadius => ({
+  type: 'ThemeAttrAndroid',
+  // I added `attribute` prop to clone the implementation of RN and be able to use only 2 types
+  attribute: 'selectableItemBackground',
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "SelectableBackgroundBorderless", rippleRadius => ({
+  type: 'ThemeAttrAndroid',
+  attribute: 'selectableItemBackgroundBorderless',
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "Ripple", (color, borderless, rippleRadius) => ({
+  type: 'RippleAndroid',
+  color,
+  borderless,
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "canUseNativeForeground", () => _reactNative.Platform.Version >= 23);
+//# sourceMappingURL=TouchableNativeFeedback.android.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js.map
new file mode 100644
index 0000000..e7a57eb
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.android.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableNativeFeedback.android.tsx"],"names":["TouchableNativeFeedback","Component","getExtraButtonProps","extraProps","background","props","type","borderless","color","attribute","rippleRadius","useForeground","render","style","rest","GenericTouchable","defaultProps","extraButtonProps","rippleColor","Platform","Version"],"mappings":";;;;;;;AAAA;;AAKA;;AAEA;;;;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMA,uBAAN,SAAsCC,eAAtC,CAEb;AAUA;AAyBAC,EAAAA,mBAAmB,GAAG;AACpB,UAAMC,UAA6C,GAAG,EAAtD;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiB,KAAKC,KAA5B;;AACA,QAAID,UAAJ,EAAgB;AACd;AACA;AACA,UAAIA,UAAU,CAACE,IAAX,KAAoB,eAAxB,EAAyC;AACvCH,QAAAA,UAAU,CAAC,YAAD,CAAV,GAA2BC,UAAU,CAACG,UAAtC;AACAJ,QAAAA,UAAU,CAAC,aAAD,CAAV,GAA4BC,UAAU,CAACI,KAAvC;AACD,OAHD,MAGO,IAAIJ,UAAU,CAACE,IAAX,KAAoB,kBAAxB,EAA4C;AACjDH,QAAAA,UAAU,CAAC,YAAD,CAAV,GACEC,UAAU,CAACK,SAAX,KAAyB,oCAD3B;AAED,OATa,CAUd;;;AACAN,MAAAA,UAAU,CAAC,cAAD,CAAV,GAA6BC,UAAU,CAACM,YAAxC;AACD;;AACDP,IAAAA,UAAU,CAAC,YAAD,CAAV,GAA2B,KAAKE,KAAL,CAAWM,aAAtC;AACA,WAAOR,UAAP;AACD;;AACDS,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEC,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGC;AAAjB,QAA0B,KAAKT,KAArC;AACA,wBACE,oBAAC,yBAAD,eACMS,IADN;AAEE,MAAA,KAAK,EAAED,KAFT;AAGE,MAAA,gBAAgB,EAAE,KAAKX,mBAAL;AAHpB,OADF;AAOD;;AA/DD;;;;gBAFmBF,uB,kBAGG,EACpB,GAAGe,0BAAiBC,YADA;AAEpBL,EAAAA,aAAa,EAAE,IAFK;AAGpBM,EAAAA,gBAAgB,EAAE;AAChB;AACAC,IAAAA,WAAW,EAAE;AAFG;AAHE,C;;gBAHHlB,uB,0BAaYU,YAAD,KAA4B;AACxDJ,EAAAA,IAAI,EAAE,kBADkD;AAExD;AACAG,EAAAA,SAAS,EAAE,0BAH6C;AAIxDC,EAAAA;AAJwD,CAA5B,C;;gBAbXV,uB,oCAmBsBU,YAAD,KAA4B;AAClEJ,EAAAA,IAAI,EAAE,kBAD4D;AAElEG,EAAAA,SAAS,EAAE,oCAFuD;AAGlEC,EAAAA;AAHkE,CAA5B,C;;gBAnBrBV,uB,YAwBH,CACdQ,KADc,EAEdD,UAFc,EAGdG,YAHc,MAIV;AACJJ,EAAAA,IAAI,EAAE,eADF;AAEJE,EAAAA,KAFI;AAGJD,EAAAA,UAHI;AAIJG,EAAAA;AAJI,CAJU,C;;gBAxBGV,uB,4BAmCa,MAAMmB,sBAASC,OAAT,IAAoB,E","sourcesContent":["import {\n  Platform,\n  TouchableNativeFeedbackProps,\n  ColorValue,\n} from 'react-native';\nimport * as React from 'react';\nimport { Component } from 'react';\nimport GenericTouchable, { GenericTouchableProps } from './GenericTouchable';\n\nexport type TouchableNativeFeedbackExtraProps = {\n  borderless?: boolean;\n  rippleColor?: number | null;\n  rippleRadius?: number | null;\n  foreground?: boolean;\n};\n\n/**\n * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.\n * There's small difference with handling long press ripple since RN's implementation calls\n * ripple animation via bridge. This solution leaves all animations' handling for native components so\n * it follows native behaviours.\n */\nexport default class TouchableNativeFeedback extends Component<\n  TouchableNativeFeedbackProps & GenericTouchableProps\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    useForeground: true,\n    extraButtonProps: {\n      // Disable hiding ripple on Android\n      rippleColor: null,\n    },\n  };\n\n  // could be taken as RNTouchableNativeFeedback.SelectableBackground etc. but the API may change\n  static SelectableBackground = (rippleRadius?: number) => ({\n    type: 'ThemeAttrAndroid',\n    // I added `attribute` prop to clone the implementation of RN and be able to use only 2 types\n    attribute: 'selectableItemBackground',\n    rippleRadius,\n  });\n  static SelectableBackgroundBorderless = (rippleRadius?: number) => ({\n    type: 'ThemeAttrAndroid',\n    attribute: 'selectableItemBackgroundBorderless',\n    rippleRadius,\n  });\n  static Ripple = (\n    color: ColorValue,\n    borderless: boolean,\n    rippleRadius?: number\n  ) => ({\n    type: 'RippleAndroid',\n    color,\n    borderless,\n    rippleRadius,\n  });\n\n  static canUseNativeForeground = () => Platform.Version >= 23;\n\n  getExtraButtonProps() {\n    const extraProps: TouchableNativeFeedbackExtraProps = {};\n    const { background } = this.props;\n    if (background) {\n      // I changed type values to match those used in RN\n      // TODO(TS): check if it works the same as previous implementation - looks like it works the same as RN component, so it should be ok\n      if (background.type === 'RippleAndroid') {\n        extraProps['borderless'] = background.borderless;\n        extraProps['rippleColor'] = background.color;\n      } else if (background.type === 'ThemeAttrAndroid') {\n        extraProps['borderless'] =\n          background.attribute === 'selectableItemBackgroundBorderless';\n      }\n      // I moved it from above since it should be available in all options\n      extraProps['rippleRadius'] = background.rippleRadius;\n    }\n    extraProps['foreground'] = this.props.useForeground;\n    return extraProps;\n  }\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={style}\n        extraButtonProps={this.getExtraButtonProps()}\n      />\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js
new file mode 100644
index 0000000..419cc6e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js
@@ -0,0 +1,12 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var _default = _reactNative.TouchableNativeFeedback;
+exports.default = _default;
+//# sourceMappingURL=TouchableNativeFeedback.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js.map
new file mode 100644
index 0000000..fb781ea
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableNativeFeedback.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableNativeFeedback.tsx"],"names":["TouchableNativeFeedback"],"mappings":";;;;;;;AAAA;;eAEeA,oC","sourcesContent":["import { TouchableNativeFeedback } from 'react-native';\n\nexport default TouchableNativeFeedback;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js
new file mode 100644
index 0000000..61b2995
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js
@@ -0,0 +1,75 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var _GenericTouchable = _interopRequireWildcard(require("./GenericTouchable"));
+
+var React = _interopRequireWildcard(require("react"));
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/**
+ * TouchableOpacity bases on timing animation which has been used in RN's core
+ */
+class TouchableOpacity extends React.Component {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "getChildStyleOpacityWithDefault", () => {
+      const childStyle = _reactNative.StyleSheet.flatten(this.props.style) || {};
+      return childStyle.opacity == null ? 1 : childStyle.opacity;
+    });
+
+    _defineProperty(this, "opacity", new _reactNative.Animated.Value(this.getChildStyleOpacityWithDefault()));
+
+    _defineProperty(this, "setOpacityTo", (value, duration) => {
+      _reactNative.Animated.timing(this.opacity, {
+        toValue: value,
+        duration: duration,
+        easing: _reactNative.Easing.inOut(_reactNative.Easing.quad),
+        useNativeDriver: true
+      }).start();
+    });
+
+    _defineProperty(this, "onStateChange", (_from, to) => {
+      if (to === _GenericTouchable.TOUCHABLE_STATE.BEGAN) {
+        this.setOpacityTo(this.props.activeOpacity, 0);
+      } else if (to === _GenericTouchable.TOUCHABLE_STATE.UNDETERMINED || to === _GenericTouchable.TOUCHABLE_STATE.MOVED_OUTSIDE) {
+        this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);
+      }
+    });
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(_GenericTouchable.default, _extends({}, rest, {
+      style: [style, {
+        opacity: this.opacity // TODO: fix this
+
+      }],
+      onStateChange: this.onStateChange
+    }), this.props.children ? this.props.children : /*#__PURE__*/React.createElement(_reactNative.View, null));
+  }
+
+}
+
+exports.default = TouchableOpacity;
+
+_defineProperty(TouchableOpacity, "defaultProps", { ..._GenericTouchable.default.defaultProps,
+  activeOpacity: 0.2
+});
+//# sourceMappingURL=TouchableOpacity.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js.map
new file mode 100644
index 0000000..1509ba6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableOpacity.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableOpacity.tsx"],"names":["TouchableOpacity","Component","childStyle","StyleSheet","flatten","props","style","opacity","Animated","Value","getChildStyleOpacityWithDefault","value","duration","timing","toValue","easing","Easing","inOut","quad","useNativeDriver","start","_from","to","TOUCHABLE_STATE","BEGAN","setOpacityTo","activeOpacity","UNDETERMINED","MOVED_OUTSIDE","render","rest","onStateChange","children","GenericTouchable","defaultProps"],"mappings":";;;;;;;AAAA;;AAOA;;AAIA;;;;;;;;;;AAGA;AACA;AACA;AACe,MAAMA,gBAAN,SAA+BC,eAA/B,CAEb;AAAA;AAAA;;AAAA,6DAOkC,MAAM;AACtC,YAAMC,UAAU,GAAGC,wBAAWC,OAAX,CAAmB,KAAKC,KAAL,CAAWC,KAA9B,KAAwC,EAA3D;AACA,aAAOJ,UAAU,CAACK,OAAX,IAAsB,IAAtB,GAA6B,CAA7B,GAAiCL,UAAU,CAACK,OAAnD;AACD,KAVD;;AAAA,qCAYU,IAAIC,sBAASC,KAAb,CAAmB,KAAKC,+BAAL,EAAnB,CAZV;;AAAA,0CAce,CAACC,KAAD,EAAgBC,QAAhB,KAAqC;AAClDJ,4BAASK,MAAT,CAAgB,KAAKN,OAArB,EAA8B;AAC5BO,QAAAA,OAAO,EAAEH,KADmB;AAE5BC,QAAAA,QAAQ,EAAEA,QAFkB;AAG5BG,QAAAA,MAAM,EAAEC,oBAAOC,KAAP,CAAaD,oBAAOE,IAApB,CAHoB;AAI5BC,QAAAA,eAAe,EAAE;AAJW,OAA9B,EAKGC,KALH;AAMD,KArBD;;AAAA,2CAuBgB,CAACC,KAAD,EAAgBC,EAAhB,KAA+B;AAC7C,UAAIA,EAAE,KAAKC,kCAAgBC,KAA3B,EAAkC;AAChC,aAAKC,YAAL,CAAkB,KAAKpB,KAAL,CAAWqB,aAA7B,EAA6C,CAA7C;AACD,OAFD,MAEO,IACLJ,EAAE,KAAKC,kCAAgBI,YAAvB,IACAL,EAAE,KAAKC,kCAAgBK,aAFlB,EAGL;AACA,aAAKH,YAAL,CAAkB,KAAKf,+BAAL,EAAlB,EAA0D,GAA1D;AACD;AACF,KAhCD;AAAA;;AAkCAmB,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEvB,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGwB;AAAjB,QAA0B,KAAKzB,KAArC;AACA,wBACE,oBAAC,yBAAD,eACMyB,IADN;AAEE,MAAA,KAAK,EAAE,CACLxB,KADK,EAEL;AACEC,QAAAA,OAAO,EAAG,KAAKA,OADjB,CACgD;;AADhD,OAFK,CAFT;AAQE,MAAA,aAAa,EAAE,KAAKwB;AARtB,QASG,KAAK1B,KAAL,CAAW2B,QAAX,GAAsB,KAAK3B,KAAL,CAAW2B,QAAjC,gBAA4C,oBAAC,iBAAD,OAT/C,CADF;AAaD;;AAjDD;;;;gBAFmBhC,gB,kBAGG,EACpB,GAAGiC,0BAAiBC,YADA;AAEpBR,EAAAA,aAAa,EAAE;AAFK,C","sourcesContent":["import {\n  Animated,\n  Easing,\n  StyleSheet,\n  View,\n  TouchableOpacityProps,\n} from 'react-native';\nimport GenericTouchable, {\n  TOUCHABLE_STATE,\n  GenericTouchableProps,\n} from './GenericTouchable';\nimport * as React from 'react';\nimport { Component } from 'react';\n\n/**\n * TouchableOpacity bases on timing animation which has been used in RN's core\n */\nexport default class TouchableOpacity extends Component<\n  TouchableOpacityProps & GenericTouchableProps\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.2,\n  };\n\n  // opacity is 1 one by default but could be overwritten\n  getChildStyleOpacityWithDefault = () => {\n    const childStyle = StyleSheet.flatten(this.props.style) || {};\n    return childStyle.opacity == null ? 1 : childStyle.opacity;\n  };\n\n  opacity = new Animated.Value(this.getChildStyleOpacityWithDefault());\n\n  setOpacityTo = (value: number, duration: number) => {\n    Animated.timing(this.opacity, {\n      toValue: value,\n      duration: duration,\n      easing: Easing.inOut(Easing.quad),\n      useNativeDriver: true,\n    }).start();\n  };\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.setOpacityTo(this.props.activeOpacity!, 0);\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[\n          style,\n          {\n            opacity: (this.opacity as unknown) as number, // TODO: fix this\n          },\n        ]}\n        onStateChange={this.onStateChange}>\n        {this.props.children ? this.props.children : <View />}\n      </GenericTouchable>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js
new file mode 100644
index 0000000..f81a088
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js
@@ -0,0 +1,26 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _GenericTouchable = _interopRequireDefault(require("./GenericTouchable"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+const TouchableWithoutFeedback = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(_GenericTouchable.default, _extends({
+  ref: ref
+}, props)));
+TouchableWithoutFeedback.defaultProps = _GenericTouchable.default.defaultProps;
+var _default = TouchableWithoutFeedback;
+exports.default = _default;
+//# sourceMappingURL=TouchableWithoutFeedback.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js.map
new file mode 100644
index 0000000..bc21870
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/TouchableWithoutFeedback.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableWithoutFeedback.tsx"],"names":["TouchableWithoutFeedback","React","forwardRef","props","ref","defaultProps","GenericTouchable"],"mappings":";;;;;;;AAAA;;AAEA;;;;;;;;;;AAEA,MAAMA,wBAAwB,gBAAGC,KAAK,CAACC,UAAN,CAG/B,CAACC,KAAD,EAAQC,GAAR,kBAAgB,oBAAC,yBAAD;AAAkB,EAAA,GAAG,EAAEA;AAAvB,GAAgCD,KAAhC,EAHe,CAAjC;AAKAH,wBAAwB,CAACK,YAAzB,GAAwCC,0BAAiBD,YAAzD;eAEeL,wB","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport GenericTouchable, { GenericTouchableProps } from './GenericTouchable';\n\nconst TouchableWithoutFeedback = React.forwardRef<\n  GenericTouchable,\n  PropsWithChildren<GenericTouchableProps>\n>((props, ref) => <GenericTouchable ref={ref} {...props} />);\n\nTouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;\n\nexport default TouchableWithoutFeedback;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js
new file mode 100644
index 0000000..7ea96ef
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js
@@ -0,0 +1,40 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "TouchableNativeFeedback", {
+  enumerable: true,
+  get: function () {
+    return _TouchableNativeFeedback.default;
+  }
+});
+Object.defineProperty(exports, "TouchableWithoutFeedback", {
+  enumerable: true,
+  get: function () {
+    return _TouchableWithoutFeedback.default;
+  }
+});
+Object.defineProperty(exports, "TouchableOpacity", {
+  enumerable: true,
+  get: function () {
+    return _TouchableOpacity.default;
+  }
+});
+Object.defineProperty(exports, "TouchableHighlight", {
+  enumerable: true,
+  get: function () {
+    return _TouchableHighlight.default;
+  }
+});
+
+var _TouchableNativeFeedback = _interopRequireDefault(require("./TouchableNativeFeedback"));
+
+var _TouchableWithoutFeedback = _interopRequireDefault(require("./TouchableWithoutFeedback"));
+
+var _TouchableOpacity = _interopRequireDefault(require("./TouchableOpacity"));
+
+var _TouchableHighlight = _interopRequireDefault(require("./TouchableHighlight"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js.map
new file mode 100644
index 0000000..215407f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/components/touchables/index.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA","sourcesContent":["export { default as TouchableNativeFeedback } from './TouchableNativeFeedback';\nexport { default as TouchableWithoutFeedback } from './TouchableWithoutFeedback';\nexport { default as TouchableOpacity } from './TouchableOpacity';\nexport { default as TouchableHighlight } from './TouchableHighlight';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js b/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js
new file mode 100644
index 0000000..e543ba5
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = gestureHandlerRootHOC;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _hoistNonReactStatics = _interopRequireDefault(require("hoist-non-react-statics"));
+
+var _GestureHandlerRootView = _interopRequireDefault(require("./GestureHandlerRootView"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function gestureHandlerRootHOC(Component, containerStyles) {
+  function Wrapper(props) {
+    return /*#__PURE__*/React.createElement(_GestureHandlerRootView.default, {
+      style: [styles.container, containerStyles]
+    }, /*#__PURE__*/React.createElement(Component, props));
+  }
+
+  Wrapper.displayName = "gestureHandlerRootHOC(".concat(Component.displayName || Component.name, ")");
+  (0, _hoistNonReactStatics.default)(Wrapper, Component);
+  return Wrapper;
+}
+
+const styles = _reactNative.StyleSheet.create({
+  container: {
+    flex: 1
+  }
+});
+//# sourceMappingURL=gestureHandlerRootHOC.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js.map
new file mode 100644
index 0000000..1184393
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/gestureHandlerRootHOC.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["gestureHandlerRootHOC.tsx"],"names":["gestureHandlerRootHOC","Component","containerStyles","Wrapper","props","styles","container","displayName","name","StyleSheet","create","flex"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;;;;;;;AAEe,SAASA,qBAAT,CACbC,SADa,EAEbC,eAFa,EAGW;AACxB,WAASC,OAAT,CAAiBC,KAAjB,EAA2B;AACzB,wBACE,oBAAC,+BAAD;AAAwB,MAAA,KAAK,EAAE,CAACC,MAAM,CAACC,SAAR,EAAmBJ,eAAnB;AAA/B,oBACE,oBAAC,SAAD,EAAeE,KAAf,CADF,CADF;AAKD;;AAEDD,EAAAA,OAAO,CAACI,WAAR,mCACEN,SAAS,CAACM,WAAV,IAAyBN,SAAS,CAACO,IADrC;AAIA,qCAAqBL,OAArB,EAA8BF,SAA9B;AAEA,SAAOE,OAAP;AACD;;AAED,MAAME,MAAM,GAAGI,wBAAWC,MAAX,CAAkB;AAC/BJ,EAAAA,SAAS,EAAE;AAAEK,IAAAA,IAAI,EAAE;AAAR;AADoB,CAAlB,CAAf","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport GestureHandlerRootView from './GestureHandlerRootView';\n\nexport default function gestureHandlerRootHOC<P>(\n  Component: React.ComponentType<P>,\n  containerStyles?: StyleProp<ViewStyle>\n): React.ComponentType<P> {\n  function Wrapper(props: P) {\n    return (\n      <GestureHandlerRootView style={[styles.container, containerStyles]}>\n        <Component {...props} />\n      </GestureHandlerRootView>\n    );\n  }\n\n  Wrapper.displayName = `gestureHandlerRootHOC(${\n    Component.displayName || Component.name\n  })`;\n\n  hoistNonReactStatics(Wrapper, Component);\n\n  return Wrapper;\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js
new file mode 100644
index 0000000..56c05be
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js
@@ -0,0 +1,23 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.NativeViewGestureHandler = exports.nativeViewProps = void 0;
+
+var _createHandler = _interopRequireDefault(require("./createHandler"));
+
+var _gestureHandlers = require("./gestureHandlers");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+const nativeViewProps = [..._gestureHandlers.baseProps, 'shouldActivateOnStart', 'disallowInterruption'];
+exports.nativeViewProps = nativeViewProps;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlers.ts file
+const NativeViewGestureHandler = (0, _createHandler.default)({
+  name: 'NativeViewGestureHandler',
+  allowedProps: nativeViewProps,
+  config: {}
+});
+exports.NativeViewGestureHandler = NativeViewGestureHandler;
+//# sourceMappingURL=NativeViewGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js.map
new file mode 100644
index 0000000..350f27d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/NativeViewGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NativeViewGestureHandler.ts"],"names":["nativeViewProps","baseProps","NativeViewGestureHandler","name","allowedProps","config"],"mappings":";;;;;;;AAAA;;AACA;;;;AAYO,MAAMA,eAAe,GAAG,CAC7B,GAAGC,0BAD0B,EAE7B,uBAF6B,EAG7B,sBAH6B,CAAxB;;AAOP;AACO,MAAMC,wBAAwB,GAAG,4BAGtC;AACAC,EAAAA,IAAI,EAAE,0BADN;AAEAC,EAAAA,YAAY,EAAEJ,eAFd;AAGAK,EAAAA,MAAM,EAAE;AAHR,CAHsC,CAAjC","sourcesContent":["import createHandler from './createHandler';\nimport { BaseGestureHandlerProps, baseProps } from './gestureHandlers';\n\nexport interface NativeViewGestureHandlerProps\n  extends BaseGestureHandlerProps<NativeViewGestureHandlerPayload> {\n  shouldActivateOnStart?: boolean;\n  disallowInterruption?: boolean;\n}\n\nexport type NativeViewGestureHandlerPayload = {\n  pointerInside: boolean;\n};\n\nexport const nativeViewProps = [\n  ...baseProps,\n  'shouldActivateOnStart',\n  'disallowInterruption',\n] as const;\n\nexport type NativeViewGestureHandler = typeof NativeViewGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlers.ts file\nexport const NativeViewGestureHandler = createHandler<\n  NativeViewGestureHandlerProps,\n  NativeViewGestureHandlerPayload\n>({\n  name: 'NativeViewGestureHandler',\n  allowedProps: nativeViewProps,\n  config: {},\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js
new file mode 100644
index 0000000..1367e6f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js
@@ -0,0 +1,404 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = createHandler;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _reactNative = require("react-native");
+
+var _areEqual = _interopRequireDefault(require("fbjs/lib/areEqual"));
+
+var _RNGestureHandlerModule = _interopRequireDefault(require("../RNGestureHandlerModule"));
+
+var _State = require("../State");
+
+var _UIManager$getViewMan, _UIManager$getViewMan2, _UIManager$getConstan;
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+function findNodeHandle(node) {
+  if (_reactNative.Platform.OS === 'web') return node;
+  return (0, _reactNative.findNodeHandle)(node);
+}
+
+const {
+  UIManager = {}
+} = _reactNative.NativeModules;
+const customGHEventsConfig = {
+  onGestureHandlerEvent: {
+    registrationName: 'onGestureHandlerEvent'
+  },
+  onGestureHandlerStateChange: {
+    registrationName: 'onGestureHandlerStateChange'
+  }
+}; // Add gesture specific events to genericDirectEventTypes object exported from UIManager
+// native module.
+// Once new event types are registered with react it is possible to dispatch these
+// events to all kind of native views.
+
+UIManager.genericDirectEventTypes = { ...UIManager.genericDirectEventTypes,
+  ...customGHEventsConfig
+}; // In newer versions of RN the `genericDirectEventTypes` is located in the object
+// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make
+// it compatible with RN 61+
+
+const UIManagerConstants = (_UIManager$getViewMan = (_UIManager$getViewMan2 = UIManager.getViewManagerConfig) === null || _UIManager$getViewMan2 === void 0 ? void 0 : _UIManager$getViewMan2.call(UIManager, 'getConstants')) !== null && _UIManager$getViewMan !== void 0 ? _UIManager$getViewMan : (_UIManager$getConstan = UIManager.getConstants) === null || _UIManager$getConstan === void 0 ? void 0 : _UIManager$getConstan.call(UIManager);
+
+if (UIManagerConstants) {
+  UIManagerConstants.genericDirectEventTypes = { ...UIManagerConstants.genericDirectEventTypes,
+    ...customGHEventsConfig
+  };
+} // Wrap JS responder calls and notify gesture handler manager
+
+
+const {
+  setJSResponder: oldSetJSResponder = () => {//no operation
+  },
+  clearJSResponder: oldClearJSResponder = () => {//no operation
+  }
+} = UIManager;
+
+UIManager.setJSResponder = (tag, blockNativeResponder) => {
+  _RNGestureHandlerModule.default.handleSetJSResponder(tag, blockNativeResponder);
+
+  oldSetJSResponder(tag, blockNativeResponder);
+};
+
+UIManager.clearJSResponder = () => {
+  _RNGestureHandlerModule.default.handleClearJSResponder();
+
+  oldClearJSResponder();
+};
+
+let handlerTag = 1;
+const handlerIDToTag = {};
+
+function isConfigParam(param, name) {
+  // param !== Object(param) returns false if `param` is a function
+  // or an object and returns true if `param` is null
+  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';
+}
+
+function filterConfig(props, validProps, defaults = {}) {
+  const res = { ...defaults
+  };
+  validProps.forEach(key => {
+    const value = props[key];
+
+    if (isConfigParam(value, key)) {
+      let value = props[key];
+
+      if (key === 'simultaneousHandlers' || key === 'waitFor') {
+        value = transformIntoHandlerTags(props[key]);
+      } else if (key === 'hitSlop') {
+        if (typeof value !== 'object') {
+          value = {
+            top: value,
+            left: value,
+            bottom: value,
+            right: value
+          };
+        }
+      }
+
+      res[key] = value;
+    }
+  });
+  return res;
+}
+
+function transformIntoHandlerTags(handlerIDs) {
+  if (!Array.isArray(handlerIDs)) {
+    handlerIDs = [handlerIDs];
+  }
+
+  if (_reactNative.Platform.OS === 'web') {
+    return handlerIDs.map(({
+      current
+    }) => current).filter(handle => handle);
+  } // converts handler string IDs into their numeric tags
+
+
+  return handlerIDs.map(handlerID => {
+    var _handlerID$current;
+
+    return handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;
+  }).filter(handlerTag => handlerTag > 0);
+}
+
+function hasUnresolvedRefs(props) {
+  // TODO(TS) - add type for extract arg
+  const extract = refs => {
+    if (!Array.isArray(refs)) {
+      return refs && refs.current === null;
+    }
+
+    return refs.some(r => r && r.current === null);
+  };
+
+  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);
+}
+
+const stateToPropMappings = {
+  [_State.State.UNDETERMINED]: undefined,
+  [_State.State.BEGAN]: 'onBegan',
+  [_State.State.FAILED]: 'onFailed',
+  [_State.State.CANCELLED]: 'onCancelled',
+  [_State.State.ACTIVE]: 'onActivated',
+  [_State.State.END]: 'onEnded'
+};
+
+// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.
+function createHandler({
+  name,
+  allowedProps = [],
+  config = {},
+  transformProps,
+  customNativeProps = []
+}) {
+  class Handler extends React.Component {
+    constructor(props) {
+      super(props);
+
+      _defineProperty(this, "handlerTag", void 0);
+
+      _defineProperty(this, "config", void 0);
+
+      _defineProperty(this, "propsRef", void 0);
+
+      _defineProperty(this, "viewNode", void 0);
+
+      _defineProperty(this, "viewTag", void 0);
+
+      _defineProperty(this, "updateEnqueued", null);
+
+      _defineProperty(this, "onGestureHandlerEvent", event => {
+        if (event.nativeEvent.handlerTag === this.handlerTag) {
+          var _this$props$onGesture, _this$props;
+
+          (_this$props$onGesture = (_this$props = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props, event);
+        } else {
+          var _this$props$onGesture2, _this$props2;
+
+          (_this$props$onGesture2 = (_this$props2 = this.props).onGestureHandlerEvent) === null || _this$props$onGesture2 === void 0 ? void 0 : _this$props$onGesture2.call(_this$props2, event);
+        }
+      });
+
+      _defineProperty(this, "onGestureHandlerStateChange", event => {
+        if (event.nativeEvent.handlerTag === this.handlerTag) {
+          var _this$props$onHandler, _this$props3;
+
+          (_this$props$onHandler = (_this$props3 = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props3, event);
+          const state = event.nativeEvent.state;
+          const stateEventName = stateToPropMappings[state];
+          const eventHandler = stateEventName && this.props[stateEventName];
+
+          if (eventHandler && typeof eventHandler === 'function') {
+            eventHandler(event);
+          }
+        } else {
+          var _this$props$onGesture3, _this$props4;
+
+          (_this$props$onGesture3 = (_this$props4 = this.props).onGestureHandlerStateChange) === null || _this$props$onGesture3 === void 0 ? void 0 : _this$props$onGesture3.call(_this$props4, event);
+        }
+      });
+
+      _defineProperty(this, "refHandler", node => {
+        this.viewNode = node;
+        const child = React.Children.only(this.props.children); // TODO(TS) fix ref type
+
+        const {
+          ref
+        } = child;
+
+        if (ref !== null) {
+          if (typeof ref === 'function') {
+            ref(node);
+          } else {
+            ref.current = node;
+          }
+        }
+      });
+
+      _defineProperty(this, "createGestureHandler", newConfig => {
+        this.config = newConfig;
+
+        _RNGestureHandlerModule.default.createGestureHandler(name, this.handlerTag, newConfig);
+      });
+
+      _defineProperty(this, "attachGestureHandler", newViewTag => {
+        this.viewTag = newViewTag;
+
+        if (_reactNative.Platform.OS === 'web') {
+          // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch
+          _RNGestureHandlerModule.default.attachGestureHandler(this.handlerTag, newViewTag, this.propsRef);
+        } else {
+          _RNGestureHandlerModule.default.attachGestureHandler(this.handlerTag, newViewTag);
+        }
+      });
+
+      _defineProperty(this, "updateGestureHandler", newConfig => {
+        this.config = newConfig;
+
+        _RNGestureHandlerModule.default.updateGestureHandler(this.handlerTag, newConfig);
+      });
+
+      this.handlerTag = handlerTag++;
+      this.config = {};
+      this.propsRef = /*#__PURE__*/React.createRef();
+
+      if (props.id) {
+        if (handlerIDToTag[props.id] !== undefined) {
+          throw new Error("Handler with ID \"".concat(props.id, "\" already registered"));
+        }
+
+        handlerIDToTag[props.id] = this.handlerTag;
+      }
+    }
+
+    componentDidMount() {
+      const props = this.props;
+
+      if (hasUnresolvedRefs(props)) {
+        // If there are unresolved refs (e.g. ".current" has not yet been set)
+        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to
+        // _update method that will try to update native handler props using
+        // setImmediate. This makes it so _update function gets called after all
+        // react components are mounted and we expect the missing ref object to
+        // be resolved by then.
+        this.updateEnqueued = setImmediate(() => {
+          this.updateEnqueued = null;
+          this.update();
+        });
+      }
+
+      this.createGestureHandler(filterConfig(transformProps ? transformProps(this.props) : this.props, [...allowedProps, ...customNativeProps], config));
+      this.attachGestureHandler(findNodeHandle(this.viewNode)); // TODO(TS) - check if this can be null
+    }
+
+    componentDidUpdate() {
+      const viewTag = findNodeHandle(this.viewNode);
+
+      if (this.viewTag !== viewTag) {
+        this.attachGestureHandler(viewTag); // TODO(TS) - check interaction between _viewTag & findNodeHandle
+      }
+
+      this.update();
+    }
+
+    componentWillUnmount() {
+      _RNGestureHandlerModule.default.dropGestureHandler(this.handlerTag);
+
+      if (this.updateEnqueued) {
+        clearImmediate(this.updateEnqueued);
+      } // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context
+
+
+      const handlerID = this.props.id;
+
+      if (handlerID) {
+        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+        delete handlerIDToTag[handlerID];
+      }
+    }
+
+    update() {
+      const newConfig = filterConfig(transformProps ? transformProps(this.props) : this.props, [...allowedProps, ...customNativeProps], config);
+
+      if (!(0, _areEqual.default)(this.config, newConfig)) {
+        this.updateGestureHandler(newConfig);
+      }
+    }
+
+    setNativeProps(updates) {
+      const mergedProps = { ...this.props,
+        ...updates
+      };
+      const newConfig = filterConfig(transformProps ? transformProps(mergedProps) : mergedProps, [...allowedProps, ...customNativeProps], config);
+      this.updateGestureHandler(newConfig);
+    }
+
+    render() {
+      let gestureEventHandler = this.onGestureHandlerEvent; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+
+      const {
+        onGestureEvent,
+        onGestureHandlerEvent
+      } = this.props;
+
+      if (onGestureEvent && typeof onGestureEvent !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerEvent) {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+
+        gestureEventHandler = onGestureEvent;
+      } else {
+        if (onGestureHandlerEvent && typeof onGestureHandlerEvent !== 'function') {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+      }
+
+      let gestureStateEventHandler = this.onGestureHandlerStateChange; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+
+      const {
+        onHandlerStateChange,
+        onGestureHandlerStateChange
+      } = this.props;
+
+      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerStateChange) {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+
+        gestureStateEventHandler = onHandlerStateChange;
+      } else {
+        if (onGestureHandlerStateChange && typeof onGestureHandlerStateChange !== 'function') {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+      }
+
+      const events = {
+        onGestureHandlerEvent: gestureEventHandler,
+        onGestureHandlerStateChange: gestureStateEventHandler
+      };
+      this.propsRef.current = events;
+      const child = React.Children.only(this.props.children);
+      let grandChildren = child.props.children;
+
+      if (_reactNative.Touchable.TOUCH_TARGET_DEBUG && child.type && (child.type === 'RNGestureHandlerButton' || child.type.name === 'View' || child.type.displayName === 'View')) {
+        grandChildren = React.Children.toArray(grandChildren);
+        grandChildren.push(_reactNative.Touchable.renderDebugView({
+          color: 'mediumspringgreen',
+          hitSlop: child.props.hitSlop
+        }));
+      }
+
+      return /*#__PURE__*/React.cloneElement(child, {
+        ref: this.refHandler,
+        collapsable: false,
+        ...events
+      }, grandChildren);
+    }
+
+  }
+
+  _defineProperty(Handler, "displayName", name);
+
+  return Handler;
+}
+//# sourceMappingURL=createHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js.map
new file mode 100644
index 0000000..f3d6f3c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["createHandler.ts"],"names":["findNodeHandle","node","Platform","OS","UIManager","NativeModules","customGHEventsConfig","onGestureHandlerEvent","registrationName","onGestureHandlerStateChange","genericDirectEventTypes","UIManagerConstants","getViewManagerConfig","getConstants","setJSResponder","oldSetJSResponder","clearJSResponder","oldClearJSResponder","tag","blockNativeResponder","RNGestureHandlerModule","handleSetJSResponder","handleClearJSResponder","handlerTag","handlerIDToTag","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","res","forEach","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Array","isArray","map","current","filter","handle","handlerID","hasUnresolvedRefs","extract","refs","some","r","stateToPropMappings","State","UNDETERMINED","BEGAN","FAILED","CANCELLED","ACTIVE","END","createHandler","allowedProps","config","transformProps","customNativeProps","Handler","React","Component","constructor","event","nativeEvent","onGestureEvent","onHandlerStateChange","state","stateEventName","eventHandler","viewNode","child","Children","only","children","ref","newConfig","createGestureHandler","newViewTag","viewTag","attachGestureHandler","propsRef","updateGestureHandler","createRef","id","Error","componentDidMount","updateEnqueued","setImmediate","update","componentDidUpdate","componentWillUnmount","dropGestureHandler","clearImmediate","setNativeProps","updates","mergedProps","render","gestureEventHandler","gestureStateEventHandler","events","grandChildren","Touchable","TOUCH_TARGET_DEBUG","type","displayName","toArray","push","renderDebugView","color","hitSlop","cloneElement","refHandler","collapsable"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  findNodeHandle as findNodeHandleRN,\n  NativeModules,\n  Platform,\n  Touchable,\n} from 'react-native';\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\nimport { State } from '../State';\n\nimport {\n  BaseGestureHandlerProps,\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from './gestureHandlers';\nimport { ValueOf } from '../typeUtils';\n\nfunction findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nconst { UIManager = {} } = NativeModules;\n\nconst customGHEventsConfig = {\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange',\n  },\n};\n\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\n// native module.\n// Once new event types are registered with react it is possible to dispatch these\n// events to all kind of native views.\nUIManager.genericDirectEventTypes = {\n  ...UIManager.genericDirectEventTypes,\n  ...customGHEventsConfig,\n};\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\n// it compatible with RN 61+\nconst UIManagerConstants =\n  UIManager.getViewManagerConfig?.('getConstants') ??\n  UIManager.getConstants?.();\n\nif (UIManagerConstants) {\n  UIManagerConstants.genericDirectEventTypes = {\n    ...UIManagerConstants.genericDirectEventTypes,\n    ...customGHEventsConfig,\n  };\n}\n\n// Wrap JS responder calls and notify gesture handler manager\nconst {\n  setJSResponder: oldSetJSResponder = () => {\n    //no operation\n  },\n  clearJSResponder: oldClearJSResponder = () => {\n    //no operation\n  },\n} = UIManager;\nUIManager.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nlet handlerTag = 1;\nconst handlerIDToTag: Record<string, number> = {};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nfunction filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const res = { ...defaults };\n  validProps.forEach((key) => {\n    const value = props[key];\n    if (isConfigParam(value, key)) {\n      let value = props[key];\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof value !== 'object') {\n          value = { top: value, left: value, bottom: value, right: value };\n        }\n      }\n      res[key] = value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\n>;\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\n  props: HandlerProps<T>\n) {\n  // TODO(TS) - add type for extract arg\n  const extract = (refs: any | any[]) => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n    return refs.some((r) => r && r.current === null);\n  };\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nconst stateToPropMappings = {\n  [State.UNDETERMINED]: undefined,\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded',\n} as const;\n\ntype CreateHandlerArgs<\n  HandlerPropsT extends Record<string, unknown>\n> = Readonly<{\n  name: string;\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\n  config: Readonly<Record<string, unknown>>;\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\n  customNativeProps?: Readonly<string[]>;\n}>;\n\n// TODO(TS) fix event types\ntype InternalEventHandlers = {\n  onGestureHandlerEvent?: (event: any) => void;\n  onGestureHandlerStateChange?: (event: any) => void;\n};\n\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\nexport default function createHandler<\n  T extends BaseGestureHandlerProps<U>,\n  U extends Record<string, unknown>\n>({\n  name,\n  allowedProps = [],\n  config = {},\n  transformProps,\n  customNativeProps = [],\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\n  class Handler extends React.Component<T & InternalEventHandlers> {\n    static displayName = name;\n\n    private handlerTag: number;\n    private config: Record<string, unknown>;\n    private propsRef: React.MutableRefObject<unknown>;\n    private viewNode: any;\n    private viewTag?: number;\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\n\n    constructor(props: T & InternalEventHandlers) {\n      super(props);\n      this.handlerTag = handlerTag++;\n      this.config = {};\n      this.propsRef = React.createRef();\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(`Handler with ID \"${props.id}\" already registered`);\n        }\n        handlerIDToTag[props.id] = this.handlerTag;\n      }\n    }\n\n    componentDidMount() {\n      const props: HandlerProps<U> = this.props;\n      if (hasUnresolvedRefs(props)) {\n        // If there are unresolved refs (e.g. \".current\" has not yet been set)\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\n        // _update method that will try to update native handler props using\n        // setImmediate. This makes it so _update function gets called after all\n        // react components are mounted and we expect the missing ref object to\n        // be resolved by then.\n        this.updateEnqueued = setImmediate(() => {\n          this.updateEnqueued = null;\n          this.update();\n        });\n      }\n\n      this.createGestureHandler(\n        filterConfig(\n          transformProps ? transformProps(this.props) : this.props,\n          [...allowedProps, ...customNativeProps],\n          config\n        )\n      );\n\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\n    }\n\n    componentDidUpdate() {\n      const viewTag = findNodeHandle(this.viewNode);\n      if (this.viewTag !== viewTag) {\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\n      }\n      this.update();\n    }\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\n      if (this.updateEnqueued) {\n        clearImmediate(this.updateEnqueued);\n      }\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\n      const handlerID: string | undefined = this.props.id;\n      if (handlerID) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete handlerIDToTag[handlerID];\n      }\n    }\n\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onGestureEvent?.(event);\n      } else {\n        this.props.onGestureHandlerEvent?.(event);\n      }\n    };\n\n    // TODO(TS) - make sure this is right type for event\n    private onGestureHandlerStateChange = (\n      event: HandlerStateChangeEvent<U>\n    ) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onHandlerStateChange?.(event);\n\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\n        const stateEventName = stateToPropMappings[state];\n        const eventHandler = stateEventName && this.props[stateEventName];\n        if (eventHandler && typeof eventHandler === 'function') {\n          eventHandler(event);\n        }\n      } else {\n        this.props.onGestureHandlerStateChange?.(event);\n      }\n    };\n\n    private refHandler = (node: any) => {\n      this.viewNode = node;\n\n      const child = React.Children.only(this.props.children);\n      // TODO(TS) fix ref type\n      const { ref }: any = child;\n      if (ref !== null) {\n        if (typeof ref === 'function') {\n          ref(node);\n        } else {\n          ref.current = node;\n        }\n      }\n    };\n\n    private createGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.createGestureHandler(\n        name,\n        this.handlerTag,\n        newConfig\n      );\n    };\n\n    private attachGestureHandler = (newViewTag: number) => {\n      this.viewTag = newViewTag;\n\n      if (Platform.OS === 'web') {\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n          this.handlerTag,\n          newViewTag,\n          this.propsRef\n        );\n      } else {\n        RNGestureHandlerModule.attachGestureHandler(\n          this.handlerTag,\n          newViewTag\n        );\n      }\n    };\n\n    private updateGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\n    };\n\n    private update() {\n      const newConfig = filterConfig(\n        transformProps ? transformProps(this.props) : this.props,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      if (!deepEqual(this.config, newConfig)) {\n        this.updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates: any) {\n      const mergedProps = { ...this.props, ...updates };\n      const newConfig = filterConfig(\n        transformProps ? transformProps(mergedProps) : mergedProps,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      this.updateGestureHandler(newConfig);\n    }\n\n    render() {\n      let gestureEventHandler = this.onGestureHandlerEvent;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureEventHandlers = {\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\n      };\n      const {\n        onGestureEvent,\n        onGestureHandlerEvent,\n      }: OnGestureEventHandlers = this.props;\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerEvent) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureEventHandler = onGestureEvent;\n      } else {\n        if (\n          onGestureHandlerEvent &&\n          typeof onGestureHandlerEvent !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureStateChangeHandlers = {\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\n      };\n      const {\n        onHandlerStateChange,\n        onGestureHandlerStateChange,\n      }: OnGestureStateChangeHandlers = this.props;\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerStateChange) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureStateEventHandler = onHandlerStateChange;\n      } else {\n        if (\n          onGestureHandlerStateChange &&\n          typeof onGestureHandlerStateChange !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n      const events = {\n        onGestureHandlerEvent: gestureEventHandler,\n        onGestureHandlerStateChange: gestureStateEventHandler,\n      };\n\n      this.propsRef.current = events;\n\n      const child: any = React.Children.only(this.props.children);\n      let grandChildren = child.props.children;\n      if (\n        Touchable.TOUCH_TARGET_DEBUG &&\n        child.type &&\n        (child.type === 'RNGestureHandlerButton' ||\n          child.type.name === 'View' ||\n          child.type.displayName === 'View')\n      ) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(\n          Touchable.renderDebugView({\n            color: 'mediumspringgreen',\n            hitSlop: child.props.hitSlop,\n          })\n        );\n      }\n\n      return React.cloneElement(\n        child,\n        {\n          ref: this.refHandler,\n          collapsable: false,\n          ...events,\n        },\n        grandChildren\n      );\n    }\n  }\n  return Handler;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js
new file mode 100644
index 0000000..29fd09f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js
@@ -0,0 +1,70 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = createNativeWrapper;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _NativeViewGestureHandler = require("./NativeViewGestureHandler");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+/*
+ * This array should consist of:
+ *   - All keys in propTypes from NativeGestureHandler
+ *     (and all keys in GestureHandlerPropTypes)
+ *   - 'onGestureHandlerEvent'
+ *   - 'onGestureHandlerStateChange'
+ */
+const NATIVE_WRAPPER_PROPS_FILTER = [..._NativeViewGestureHandler.nativeViewProps, 'onGestureHandlerEvent', 'onGestureHandlerStateChange'];
+
+function createNativeWrapper(Component, config = {}) {
+  const ComponentWrapper = /*#__PURE__*/React.forwardRef((props, ref) => {
+    // filter out props that should be passed to gesture handler wrapper
+    const gestureHandlerProps = Object.keys(props).reduce((res, key) => {
+      // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info
+      const allowedKeys = NATIVE_WRAPPER_PROPS_FILTER;
+
+      if (allowedKeys.includes(key)) {
+        // @ts-ignore FIXME(TS)
+        res[key] = props[key];
+      }
+
+      return res;
+    }, { ...config
+    } // watch out not to modify config
+    );
+
+    const _ref = (0, React.useRef)();
+
+    const _gestureHandlerRef = (0, React.useRef)();
+
+    (0, React.useImperativeHandle)(ref, // @ts-ignore TODO(TS) decide how nulls work in this context
+    () => {
+      const node = _gestureHandlerRef.current; // add handlerTag for relations config
+
+      if (_ref.current && node) {
+        // @ts-ignore FIXME(TS) think about createHandler return type
+        _ref.current.handlerTag = node.handlerTag;
+        return _ref.current;
+      }
+
+      return null;
+    }, [_ref, _gestureHandlerRef]);
+    return /*#__PURE__*/React.createElement(_NativeViewGestureHandler.NativeViewGestureHandler, _extends({}, gestureHandlerProps, {
+      // @ts-ignore TODO(TS)
+      ref: _gestureHandlerRef
+    }), /*#__PURE__*/React.createElement(Component, _extends({}, props, {
+      ref: _ref
+    })));
+  });
+  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';
+  return ComponentWrapper;
+}
+//# sourceMappingURL=createNativeWrapper.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js.map
new file mode 100644
index 0000000..79a2eff
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/createNativeWrapper.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["createNativeWrapper.tsx"],"names":["NATIVE_WRAPPER_PROPS_FILTER","nativeViewProps","createNativeWrapper","Component","config","ComponentWrapper","React","forwardRef","props","ref","gestureHandlerProps","Object","keys","reduce","res","key","allowedKeys","includes","_ref","_gestureHandlerRef","node","current","handlerTag","displayName"],"mappings":";;;;;;;AAAA;;AAGA;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,2BAA2B,GAAG,CAClC,GAAGC,yCAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;;AAMe,SAASC,mBAAT,CACbC,SADa,EAEbC,MAA+C,GAAG,EAFrC,EAGb;AACA,QAAMC,gBAAgB,gBAAGC,KAAK,CAACC,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGhB,2BAAvC;;AACA,UAAIgB,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGV;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMc,IAAI,GAAG,mBAAb;;AACA,UAAMC,kBAAkB,GAAG,mBAA3B;;AACA,mCACEV,GADF,EAEE;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZH,EAaE,CAACH,IAAD,EAAOC,kBAAP,CAbF;AAeA,wBACE,oBAAC,kDAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAb,EAAAA,gBAAgB,CAACkB,WAAjB,GAA+BpB,SAAS,CAACoB,WAAV,IAAyB,kBAAxD;AAEA,SAAOlB,gBAAP;AACD","sourcesContent":["import * as React from 'react';\nimport { useImperativeHandle, useRef } from 'react';\n\nimport {\n  NativeViewGestureHandler,\n  NativeViewGestureHandlerProps,\n  nativeViewProps,\n} from './NativeViewGestureHandler';\n\n/*\n * This array should consist of:\n *   - All keys in propTypes from NativeGestureHandler\n *     (and all keys in GestureHandlerPropTypes)\n *   - 'onGestureHandlerEvent'\n *   - 'onGestureHandlerStateChange'\n */\nconst NATIVE_WRAPPER_PROPS_FILTER = [\n  ...nativeViewProps,\n  'onGestureHandlerEvent',\n  'onGestureHandlerStateChange',\n] as const;\n\nexport default function createNativeWrapper<P>(\n  Component: React.ComponentType<P>,\n  config: Readonly<NativeViewGestureHandlerProps> = {}\n) {\n  const ComponentWrapper = React.forwardRef<\n    React.ComponentType<any>,\n    P & NativeViewGestureHandlerProps\n  >((props, ref) => {\n    // filter out props that should be passed to gesture handler wrapper\n    const gestureHandlerProps = Object.keys(props).reduce(\n      (res, key) => {\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\n        if (allowedKeys.includes(key)) {\n          // @ts-ignore FIXME(TS)\n          res[key] = props[key];\n        }\n        return res;\n      },\n      { ...config } // watch out not to modify config\n    );\n    const _ref = useRef<React.ComponentType<P>>();\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\n    useImperativeHandle(\n      ref,\n      // @ts-ignore TODO(TS) decide how nulls work in this context\n      () => {\n        const node = _gestureHandlerRef.current;\n        // add handlerTag for relations config\n        if (_ref.current && node) {\n          // @ts-ignore FIXME(TS) think about createHandler return type\n          _ref.current.handlerTag = node.handlerTag;\n          return _ref.current;\n        }\n        return null;\n      },\n      [_ref, _gestureHandlerRef]\n    );\n    return (\n      <NativeViewGestureHandler\n        {...gestureHandlerProps}\n        // @ts-ignore TODO(TS)\n        ref={_gestureHandlerRef}>\n        <Component {...props} ref={_ref} />\n      </NativeViewGestureHandler>\n    );\n  });\n\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\n\n  return ComponentWrapper;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js
new file mode 100644
index 0000000..a82c6d8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js
@@ -0,0 +1,2 @@
+"use strict";
+//# sourceMappingURL=gestureHandlerTypesCompat.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js.map
new file mode 100644
index 0000000..9ffd4b2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlerTypesCompat.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js
new file mode 100644
index 0000000..2d5aa0b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js
@@ -0,0 +1,236 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.RotationGestureHandler = exports.PinchGestureHandler = exports.PanGestureHandler = exports.LongPressGestureHandler = exports.ForceTouchGestureHandler = exports.FlingGestureHandler = exports.TapGestureHandler = exports.baseProps = void 0;
+
+var React = _interopRequireWildcard(require("react"));
+
+var _createHandler = _interopRequireDefault(require("./createHandler"));
+
+var _PlatformConstants = _interopRequireDefault(require("../PlatformConstants"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+const baseProps = ['id', 'enabled', 'minPointers', 'waitFor', 'simultaneousHandlers', 'shouldCancelWhenOutside', 'hitSlop', 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange'];
+exports.baseProps = baseProps;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const TapGestureHandler = (0, _createHandler.default)({
+  name: 'TapGestureHandler',
+  allowedProps: [...baseProps, 'maxDurationMs', 'maxDelayMs', 'numberOfTaps', 'maxDeltaX', 'maxDeltaY', 'maxDist', 'minPointers'],
+  config: {}
+});
+exports.TapGestureHandler = TapGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const FlingGestureHandler = (0, _createHandler.default)({
+  name: 'FlingGestureHandler',
+  allowedProps: [...baseProps, 'numberOfPointers', 'direction'],
+  config: {}
+});
+exports.FlingGestureHandler = FlingGestureHandler;
+
+class ForceTouchFallback extends React.Component {
+  componentDidMount() {
+    console.warn('ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase');
+  }
+
+  render() {
+    return this.props.children;
+  }
+
+}
+
+_defineProperty(ForceTouchFallback, "forceTouchAvailable", false);
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const ForceTouchGestureHandler = _PlatformConstants.default !== null && _PlatformConstants.default !== void 0 && _PlatformConstants.default.forceTouchAvailable ? (0, _createHandler.default)({
+  name: 'ForceTouchGestureHandler',
+  allowedProps: [...baseProps, 'minForce', 'maxForce', 'feedbackOnActivation'],
+  config: {}
+}) : ForceTouchFallback;
+exports.ForceTouchGestureHandler = ForceTouchGestureHandler;
+ForceTouchGestureHandler.forceTouchAvailable = (_PlatformConstants.default === null || _PlatformConstants.default === void 0 ? void 0 : _PlatformConstants.default.forceTouchAvailable) || false;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const LongPressGestureHandler = (0, _createHandler.default)({
+  name: 'LongPressGestureHandler',
+  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'],
+  config: {}
+});
+exports.LongPressGestureHandler = LongPressGestureHandler;
+
+function validatePanGestureHandlerProps(props) {
+  if (props.minDeltaX && props.activeOffsetX) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd");
+  }
+
+  if (props.maxDeltaX && props.failOffsetX) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd");
+  }
+
+  if (props.minDeltaY && props.activeOffsetY) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd");
+  }
+
+  if (props.maxDeltaY && props.failOffsetY) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd");
+  }
+
+  if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {
+    throw new Error("First element of activeOffsetX should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {
+    throw new Error("First element of activeOffsetY should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {
+    throw new Error("First element of failOffsetX should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {
+    throw new Error("First element of failOffsetY should be negative, a the second one should be positive");
+  }
+}
+
+function transformPanGestureHandlerProps(props) {
+  const res = { ...props
+  };
+
+  if (props.minDeltaX !== undefined) {
+    delete res.minDeltaX;
+    res.activeOffsetXStart = -props.minDeltaX;
+    res.activeOffsetXEnd = props.minDeltaX;
+  }
+
+  if (props.maxDeltaX !== undefined) {
+    delete res.maxDeltaX;
+    res.failOffsetXStart = -props.maxDeltaX;
+    res.failOffsetXEnd = props.maxDeltaX;
+  }
+
+  if (props.minOffsetX !== undefined) {
+    delete res.minOffsetX;
+
+    if (props.minOffsetX < 0) {
+      res.activeOffsetXStart = props.minOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.minOffsetX;
+    }
+  }
+
+  if (props.minDeltaY !== undefined) {
+    delete res.minDeltaY;
+    res.activeOffsetYStart = -props.minDeltaY;
+    res.activeOffsetYEnd = props.minDeltaY;
+  }
+
+  if (props.maxDeltaY !== undefined) {
+    delete res.maxDeltaY;
+    res.failOffsetYStart = -props.maxDeltaY;
+    res.failOffsetYEnd = props.maxDeltaY;
+  }
+
+  if (props.minOffsetY !== undefined) {
+    delete res.minOffsetY;
+
+    if (props.minOffsetY < 0) {
+      res.activeOffsetYStart = props.minOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.minOffsetY;
+    }
+  }
+
+  if (props.activeOffsetX !== undefined) {
+    delete res.activeOffsetX;
+
+    if (Array.isArray(props.activeOffsetX)) {
+      res.activeOffsetXStart = props.activeOffsetX[0];
+      res.activeOffsetXEnd = props.activeOffsetX[1];
+    } else if (props.activeOffsetX < 0) {
+      res.activeOffsetXStart = props.activeOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.activeOffsetX;
+    }
+  }
+
+  if (props.activeOffsetY !== undefined) {
+    delete res.activeOffsetY;
+
+    if (Array.isArray(props.activeOffsetY)) {
+      res.activeOffsetYStart = props.activeOffsetY[0];
+      res.activeOffsetYEnd = props.activeOffsetY[1];
+    } else if (props.activeOffsetY < 0) {
+      res.activeOffsetYStart = props.activeOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.activeOffsetY;
+    }
+  }
+
+  if (props.failOffsetX !== undefined) {
+    delete res.failOffsetX;
+
+    if (Array.isArray(props.failOffsetX)) {
+      res.failOffsetXStart = props.failOffsetX[0];
+      res.failOffsetXEnd = props.failOffsetX[1];
+    } else if (props.failOffsetX < 0) {
+      res.failOffsetXStart = props.failOffsetX;
+    } else {
+      res.failOffsetXEnd = props.failOffsetX;
+    }
+  }
+
+  if (props.failOffsetY !== undefined) {
+    delete res.failOffsetY;
+
+    if (Array.isArray(props.failOffsetY)) {
+      res.failOffsetYStart = props.failOffsetY[0];
+      res.failOffsetYEnd = props.failOffsetY[1];
+    } else if (props.failOffsetY < 0) {
+      res.failOffsetYStart = props.failOffsetY;
+    } else {
+      res.failOffsetYEnd = props.failOffsetY;
+    }
+  }
+
+  return res;
+}
+
+function managePanProps(props) {
+  if (__DEV__) {
+    validatePanGestureHandlerProps(props);
+  }
+
+  return transformPanGestureHandlerProps(props);
+}
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const PanGestureHandler = (0, _createHandler.default)({
+  name: 'PanGestureHandler',
+  allowedProps: [...baseProps, 'activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture'],
+  config: {},
+  transformProps: managePanProps,
+  customNativeProps: ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd']
+});
+exports.PanGestureHandler = PanGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const PinchGestureHandler = (0, _createHandler.default)({
+  name: 'PinchGestureHandler',
+  allowedProps: baseProps,
+  config: {}
+});
+exports.PinchGestureHandler = PinchGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+const RotationGestureHandler = (0, _createHandler.default)({
+  name: 'RotationGestureHandler',
+  allowedProps: baseProps,
+  config: {}
+});
+exports.RotationGestureHandler = RotationGestureHandler;
+//# sourceMappingURL=gestureHandlers.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js.map
new file mode 100644
index 0000000..ea84b7e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/handlers/gestureHandlers.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["gestureHandlers.ts"],"names":["baseProps","TapGestureHandler","name","allowedProps","config","FlingGestureHandler","ForceTouchFallback","React","Component","componentDidMount","console","warn","render","props","children","ForceTouchGestureHandler","PlatformConstants","forceTouchAvailable","LongPressGestureHandler","validatePanGestureHandlerProps","minDeltaX","activeOffsetX","Error","maxDeltaX","failOffsetX","minDeltaY","activeOffsetY","maxDeltaY","failOffsetY","Array","isArray","transformPanGestureHandlerProps","res","undefined","activeOffsetXStart","activeOffsetXEnd","failOffsetXStart","failOffsetXEnd","minOffsetX","activeOffsetYStart","activeOffsetYEnd","failOffsetYStart","failOffsetYEnd","minOffsetY","managePanProps","__DEV__","PanGestureHandler","transformProps","customNativeProps","PinchGestureHandler","RotationGestureHandler"],"mappings":";;;;;;;AAIA;;AAEA;;AACA;;;;;;;;;;AAkEO,MAAMA,SAAS,GAAG,CACvB,IADuB,EAEvB,SAFuB,EAGvB,aAHuB,EAIvB,SAJuB,EAKvB,sBALuB,EAMvB,yBANuB,EAOvB,SAPuB,EAQvB,SARuB,EASvB,UATuB,EAUvB,aAVuB,EAWvB,aAXuB,EAYvB,SAZuB,EAavB,gBAbuB,EAcvB,sBAduB,CAAlB;;AAoCP;AACO,MAAMC,iBAAiB,GAAG,4BAG/B;AACAC,EAAAA,IAAI,EAAE,mBADN;AAEAC,EAAAA,YAAY,EAAE,CACZ,GAAGH,SADS,EAEZ,eAFY,EAGZ,YAHY,EAIZ,cAJY,EAKZ,WALY,EAMZ,WANY,EAOZ,SAPY,EAQZ,aARY,CAFd;AAYAI,EAAAA,MAAM,EAAE;AAZR,CAH+B,CAA1B;;AAgCP;AACO,MAAMC,mBAAmB,GAAG,4BAGjC;AACAH,EAAAA,IAAI,EAAE,qBADN;AAEAC,EAAAA,YAAY,EAAE,CAAC,GAAGH,SAAJ,EAAe,kBAAf,EAAmC,WAAnC,CAFd;AAGAI,EAAAA,MAAM,EAAE;AAHR,CAHiC,CAA5B;;;AASP,MAAME,kBAAN,SAAiCC,KAAK,CAACC,SAAvC,CAAiD;AAE/CC,EAAAA,iBAAiB,GAAG;AAClBC,IAAAA,OAAO,CAACC,IAAR,CACE,8NADF;AAGD;;AACDC,EAAAA,MAAM,GAAG;AACP,WAAO,KAAKC,KAAL,CAAWC,QAAlB;AACD;;AAT8C;;gBAA3CR,kB,yBACyB,K;;AA6B/B;AACO,MAAMS,wBAAwB,GAAGC,2GAAmBC,mBAAnB,GACpC,4BAGE;AACAf,EAAAA,IAAI,EAAE,0BADN;AAEAC,EAAAA,YAAY,EAAE,CACZ,GAAGH,SADS,EAEZ,UAFY,EAGZ,UAHY,EAIZ,sBAJY,CAFd;AAQAI,EAAAA,MAAM,EAAE;AARR,CAHF,CADoC,GAcpCE,kBAdG;;AAgBNS,wBAAD,CAAuDE,mBAAvD,GACE,oHAAmBA,mBAAnB,KAA0C,KAD5C;AAiBA;AACO,MAAMC,uBAAuB,GAAG,4BAGrC;AACAhB,EAAAA,IAAI,EAAE,yBADN;AAEAC,EAAAA,YAAY,EAAE,CAAC,GAAGH,SAAJ,EAAe,eAAf,EAAgC,SAAhC,CAFd;AAGAI,EAAAA,MAAM,EAAE;AAHR,CAHqC,CAAhC;;;AASP,SAASe,8BAAT,CAAwCN,KAAxC,EAAuE;AACrE,MAAIA,KAAK,CAACO,SAAN,IAAmBP,KAAK,CAACQ,aAA7B,EAA4C;AAC1C,UAAM,IAAIC,KAAJ,gFAAN;AAGD;;AACD,MAAIT,KAAK,CAACU,SAAN,IAAmBV,KAAK,CAACW,WAA7B,EAA0C;AACxC,UAAM,IAAIF,KAAJ,gFAAN;AAGD;;AACD,MAAIT,KAAK,CAACY,SAAN,IAAmBZ,KAAK,CAACa,aAA7B,EAA4C;AAC1C,UAAM,IAAIJ,KAAJ,gFAAN;AAGD;;AACD,MAAIT,KAAK,CAACc,SAAN,IAAmBd,KAAK,CAACe,WAA7B,EAA0C;AACxC,UAAM,IAAIN,KAAJ,gFAAN;AAGD;;AACD,MACEO,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACQ,aAApB,MACCR,KAAK,CAACQ,aAAN,CAAoB,CAApB,IAAyB,CAAzB,IAA8BR,KAAK,CAACQ,aAAN,CAAoB,CAApB,IAAyB,CADxD,CADF,EAGE;AACA,UAAM,IAAIC,KAAJ,0FAAN;AAGD;;AAED,MACEO,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACa,aAApB,MACCb,KAAK,CAACa,aAAN,CAAoB,CAApB,IAAyB,CAAzB,IAA8Bb,KAAK,CAACa,aAAN,CAAoB,CAApB,IAAyB,CADxD,CADF,EAGE;AACA,UAAM,IAAIJ,KAAJ,0FAAN;AAGD;;AAED,MACEO,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACW,WAApB,MACCX,KAAK,CAACW,WAAN,CAAkB,CAAlB,IAAuB,CAAvB,IAA4BX,KAAK,CAACW,WAAN,CAAkB,CAAlB,IAAuB,CADpD,CADF,EAGE;AACA,UAAM,IAAIF,KAAJ,wFAAN;AAGD;;AAED,MACEO,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACe,WAApB,MACCf,KAAK,CAACe,WAAN,CAAkB,CAAlB,IAAuB,CAAvB,IAA4Bf,KAAK,CAACe,WAAN,CAAkB,CAAlB,IAAuB,CADpD,CADF,EAGE;AACA,UAAM,IAAIN,KAAJ,wFAAN;AAGD;AACF;;AAED,SAASS,+BAAT,CAAyClB,KAAzC,EAAwE;AAatE,QAAMmB,GAAmC,GAAG,EAAE,GAAGnB;AAAL,GAA5C;;AACA,MAAIA,KAAK,CAACO,SAAN,KAAoBa,SAAxB,EAAmC;AACjC,WAAOD,GAAG,CAACZ,SAAX;AACAY,IAAAA,GAAG,CAACE,kBAAJ,GAAyB,CAACrB,KAAK,CAACO,SAAhC;AACAY,IAAAA,GAAG,CAACG,gBAAJ,GAAuBtB,KAAK,CAACO,SAA7B;AACD;;AACD,MAAIP,KAAK,CAACU,SAAN,KAAoBU,SAAxB,EAAmC;AACjC,WAAOD,GAAG,CAACT,SAAX;AACAS,IAAAA,GAAG,CAACI,gBAAJ,GAAuB,CAACvB,KAAK,CAACU,SAA9B;AACAS,IAAAA,GAAG,CAACK,cAAJ,GAAqBxB,KAAK,CAACU,SAA3B;AACD;;AACD,MAAIV,KAAK,CAACyB,UAAN,KAAqBL,SAAzB,EAAoC;AAClC,WAAOD,GAAG,CAACM,UAAX;;AACA,QAAIzB,KAAK,CAACyB,UAAN,GAAmB,CAAvB,EAA0B;AACxBN,MAAAA,GAAG,CAACE,kBAAJ,GAAyBrB,KAAK,CAACyB,UAA/B;AACD,KAFD,MAEO;AACLN,MAAAA,GAAG,CAACG,gBAAJ,GAAuBtB,KAAK,CAACyB,UAA7B;AACD;AACF;;AAED,MAAIzB,KAAK,CAACY,SAAN,KAAoBQ,SAAxB,EAAmC;AACjC,WAAOD,GAAG,CAACP,SAAX;AACAO,IAAAA,GAAG,CAACO,kBAAJ,GAAyB,CAAC1B,KAAK,CAACY,SAAhC;AACAO,IAAAA,GAAG,CAACQ,gBAAJ,GAAuB3B,KAAK,CAACY,SAA7B;AACD;;AACD,MAAIZ,KAAK,CAACc,SAAN,KAAoBM,SAAxB,EAAmC;AACjC,WAAOD,GAAG,CAACL,SAAX;AACAK,IAAAA,GAAG,CAACS,gBAAJ,GAAuB,CAAC5B,KAAK,CAACc,SAA9B;AACAK,IAAAA,GAAG,CAACU,cAAJ,GAAqB7B,KAAK,CAACc,SAA3B;AACD;;AAED,MAAId,KAAK,CAAC8B,UAAN,KAAqBV,SAAzB,EAAoC;AAClC,WAAOD,GAAG,CAACW,UAAX;;AACA,QAAI9B,KAAK,CAAC8B,UAAN,GAAmB,CAAvB,EAA0B;AACxBX,MAAAA,GAAG,CAACO,kBAAJ,GAAyB1B,KAAK,CAAC8B,UAA/B;AACD,KAFD,MAEO;AACLX,MAAAA,GAAG,CAACQ,gBAAJ,GAAuB3B,KAAK,CAAC8B,UAA7B;AACD;AACF;;AAED,MAAI9B,KAAK,CAACQ,aAAN,KAAwBY,SAA5B,EAAuC;AACrC,WAAOD,GAAG,CAACX,aAAX;;AACA,QAAIQ,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACQ,aAApB,CAAJ,EAAwC;AACtCW,MAAAA,GAAG,CAACE,kBAAJ,GAAyBrB,KAAK,CAACQ,aAAN,CAAoB,CAApB,CAAzB;AACAW,MAAAA,GAAG,CAACG,gBAAJ,GAAuBtB,KAAK,CAACQ,aAAN,CAAoB,CAApB,CAAvB;AACD,KAHD,MAGO,IAAIR,KAAK,CAACQ,aAAN,GAAsB,CAA1B,EAA6B;AAClCW,MAAAA,GAAG,CAACE,kBAAJ,GAAyBrB,KAAK,CAACQ,aAA/B;AACD,KAFM,MAEA;AACLW,MAAAA,GAAG,CAACG,gBAAJ,GAAuBtB,KAAK,CAACQ,aAA7B;AACD;AACF;;AAED,MAAIR,KAAK,CAACa,aAAN,KAAwBO,SAA5B,EAAuC;AACrC,WAAOD,GAAG,CAACN,aAAX;;AACA,QAAIG,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACa,aAApB,CAAJ,EAAwC;AACtCM,MAAAA,GAAG,CAACO,kBAAJ,GAAyB1B,KAAK,CAACa,aAAN,CAAoB,CAApB,CAAzB;AACAM,MAAAA,GAAG,CAACQ,gBAAJ,GAAuB3B,KAAK,CAACa,aAAN,CAAoB,CAApB,CAAvB;AACD,KAHD,MAGO,IAAIb,KAAK,CAACa,aAAN,GAAsB,CAA1B,EAA6B;AAClCM,MAAAA,GAAG,CAACO,kBAAJ,GAAyB1B,KAAK,CAACa,aAA/B;AACD,KAFM,MAEA;AACLM,MAAAA,GAAG,CAACQ,gBAAJ,GAAuB3B,KAAK,CAACa,aAA7B;AACD;AACF;;AAED,MAAIb,KAAK,CAACW,WAAN,KAAsBS,SAA1B,EAAqC;AACnC,WAAOD,GAAG,CAACR,WAAX;;AACA,QAAIK,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACW,WAApB,CAAJ,EAAsC;AACpCQ,MAAAA,GAAG,CAACI,gBAAJ,GAAuBvB,KAAK,CAACW,WAAN,CAAkB,CAAlB,CAAvB;AACAQ,MAAAA,GAAG,CAACK,cAAJ,GAAqBxB,KAAK,CAACW,WAAN,CAAkB,CAAlB,CAArB;AACD,KAHD,MAGO,IAAIX,KAAK,CAACW,WAAN,GAAoB,CAAxB,EAA2B;AAChCQ,MAAAA,GAAG,CAACI,gBAAJ,GAAuBvB,KAAK,CAACW,WAA7B;AACD,KAFM,MAEA;AACLQ,MAAAA,GAAG,CAACK,cAAJ,GAAqBxB,KAAK,CAACW,WAA3B;AACD;AACF;;AAED,MAAIX,KAAK,CAACe,WAAN,KAAsBK,SAA1B,EAAqC;AACnC,WAAOD,GAAG,CAACJ,WAAX;;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcjB,KAAK,CAACe,WAApB,CAAJ,EAAsC;AACpCI,MAAAA,GAAG,CAACS,gBAAJ,GAAuB5B,KAAK,CAACe,WAAN,CAAkB,CAAlB,CAAvB;AACAI,MAAAA,GAAG,CAACU,cAAJ,GAAqB7B,KAAK,CAACe,WAAN,CAAkB,CAAlB,CAArB;AACD,KAHD,MAGO,IAAIf,KAAK,CAACe,WAAN,GAAoB,CAAxB,EAA2B;AAChCI,MAAAA,GAAG,CAACS,gBAAJ,GAAuB5B,KAAK,CAACe,WAA7B;AACD,KAFM,MAEA;AACLI,MAAAA,GAAG,CAACU,cAAJ,GAAqB7B,KAAK,CAACe,WAA3B;AACD;AACF;;AAED,SAAOI,GAAP;AACD;;AAED,SAASY,cAAT,CAAwB/B,KAAxB,EAAuD;AACrD,MAAIgC,OAAJ,EAAa;AACX1B,IAAAA,8BAA8B,CAACN,KAAD,CAA9B;AACD;;AACD,SAAOkB,+BAA+B,CAAClB,KAAD,CAAtC;AACD;;AA0CD;AACO,MAAMiC,iBAAiB,GAAG,4BAG/B;AACA5C,EAAAA,IAAI,EAAE,mBADN;AAEAC,EAAAA,YAAY,EAAE,CACZ,GAAGH,SADS,EAEZ,eAFY,EAGZ,eAHY,EAIZ,aAJY,EAKZ,aALY,EAMZ,SANY,EAOZ,aAPY,EAQZ,cARY,EASZ,cATY,EAUZ,aAVY,EAWZ,aAXY,EAYZ,YAZY,EAaZ,gCAbY,CAFd;AAiBAI,EAAAA,MAAM,EAAE,EAjBR;AAkBA2C,EAAAA,cAAc,EAAEH,cAlBhB;AAmBAI,EAAAA,iBAAiB,EAAE,CACjB,oBADiB,EAEjB,kBAFiB,EAGjB,oBAHiB,EAIjB,kBAJiB,EAKjB,kBALiB,EAMjB,gBANiB,EAOjB,kBAPiB,EAQjB,gBARiB;AAnBnB,CAH+B,CAA1B;;AA6CP;AACO,MAAMC,mBAAmB,GAAG,4BAGjC;AACA/C,EAAAA,IAAI,EAAE,qBADN;AAEAC,EAAAA,YAAY,EAAEH,SAFd;AAGAI,EAAAA,MAAM,EAAE;AAHR,CAHiC,CAA5B;;AAoBP;AACO,MAAM8C,sBAAsB,GAAG,4BAGpC;AACAhD,EAAAA,IAAI,EAAE,wBADN;AAEAC,EAAAA,YAAY,EAAEH,SAFd;AAGAI,EAAAA,MAAM,EAAE;AAHR,CAHoC,CAA/B","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\n\nimport createHandler from './createHandler';\nimport PlatformConstants from '../PlatformConstants';\nimport { State } from '../State';\nimport { ValueOf } from '../typeUtils';\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = {\n  id?: string;\n  enabled?: boolean;\n  minPointers?: number;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?:\n    | number\n    // TODO(TS) take into consideration types from GestureHandler#setHitSlop\n    | Partial<\n        Record<\n          'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n          number\n        >\n      >\n    | Record<'width' | 'left', number>\n    | Record<'width' | 'right', number>\n    | Record<'height' | 'top', number>\n    | Record<'height' | 'bottom', number>;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nexport const baseProps = [\n  'id',\n  'enabled',\n  'minPointers',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport type TapGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface TapGestureHandlerProps\n  extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {\n  minPointers?: number;\n  maxDurationMs?: number;\n  maxDelayMs?: number;\n  numberOfTaps?: number;\n  maxDeltaX?: number;\n  maxDeltaY?: number;\n  maxDist?: number;\n}\n\nexport type TapGestureHandler = typeof TapGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const TapGestureHandler = createHandler<\n  TapGestureHandlerProps,\n  TapGestureHandlerEventPayload\n>({\n  name: 'TapGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'maxDurationMs',\n    'maxDelayMs',\n    'numberOfTaps',\n    'maxDeltaX',\n    'maxDeltaY',\n    'maxDist',\n    'minPointers',\n  ] as const,\n  config: {},\n});\n\nexport type FlingGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface FlingGestureHandlerProps\n  extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {\n  direction?: number;\n  numberOfPointers?: number;\n}\n\nexport type FlingGestureHandler = typeof FlingGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const FlingGestureHandler = createHandler<\n  FlingGestureHandlerProps,\n  FlingGestureHandlerEventPayload\n>({\n  name: 'FlingGestureHandler',\n  allowedProps: [...baseProps, 'numberOfPointers', 'direction'] as const,\n  config: {},\n});\n\nclass ForceTouchFallback extends React.Component {\n  static forceTouchAvailable = false;\n  componentDidMount() {\n    console.warn(\n      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'\n    );\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nexport type ForceTouchGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  force: number;\n};\n\nexport interface ForceTouchGestureHandlerProps\n  extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {\n  minForce?: number;\n  maxForce?: number;\n  feedbackOnActivation?: boolean;\n}\n\nexport type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {\n  forceTouchAvailable: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const ForceTouchGestureHandler = PlatformConstants?.forceTouchAvailable\n  ? createHandler<\n      ForceTouchGestureHandlerProps,\n      ForceTouchGestureHandlerEventPayload\n    >({\n      name: 'ForceTouchGestureHandler',\n      allowedProps: [\n        ...baseProps,\n        'minForce',\n        'maxForce',\n        'feedbackOnActivation',\n      ] as const,\n      config: {},\n    })\n  : ForceTouchFallback;\n\n(ForceTouchGestureHandler as ForceTouchGestureHandler).forceTouchAvailable =\n  PlatformConstants?.forceTouchAvailable || false;\n\nexport type LongPressGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface LongPressGestureHandlerProps\n  extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {\n  minDurationMs?: number;\n  maxDist?: number;\n}\n\nexport type LongPressGestureHandler = typeof LongPressGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const LongPressGestureHandler = createHandler<\n  LongPressGestureHandlerProps,\n  LongPressGestureHandlerEventPayload\n>({\n  name: 'LongPressGestureHandler',\n  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'] as const,\n  config: {},\n});\n\nfunction validatePanGestureHandlerProps(props: PanGestureHandlerProps) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props: PanGestureHandlerProps) {\n  type InternalPanGHKeys =\n    | 'activeOffsetXStart'\n    | 'activeOffsetXEnd'\n    | 'failOffsetXStart'\n    | 'failOffsetXEnd'\n    | 'activeOffsetYStart'\n    | 'activeOffsetYEnd'\n    | 'failOffsetYStart'\n    | 'failOffsetYEnd';\n  type PanGestureHandlerInternalProps = PanGestureHandlerProps &\n    Partial<Record<InternalPanGHKeys, number>>;\n\n  const res: PanGestureHandlerInternalProps = { ...props };\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props: PanGestureHandlerProps) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n\nexport type PanGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  translationX: number;\n  translationY: number;\n  velocityX: number;\n  velocityY: number;\n};\n\nexport interface PanGestureHandlerProps\n  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {\n  /** @deprecated  use activeOffsetX*/\n  minDeltaX?: number;\n  /** @deprecated  use activeOffsetY*/\n  minDeltaY?: number;\n  /** @deprecated  use failOffsetX*/\n  maxDeltaX?: number;\n  /** @deprecated  use failOffsetY*/\n  maxDeltaY?: number;\n  /** @deprecated  use activeOffsetX*/\n  minOffsetX?: number;\n  /** @deprecated  use failOffsetY*/\n  minOffsetY?: number;\n  activeOffsetY?: number | number[];\n  activeOffsetX?: number | number[];\n  failOffsetY?: number | number[];\n  failOffsetX?: number | number[];\n  minDist?: number;\n  minVelocity?: number;\n  minVelocityX?: number;\n  minVelocityY?: number;\n  minPointers?: number;\n  maxPointers?: number;\n  avgTouches?: boolean;\n  enableTrackpadTwoFingerGesture?: boolean;\n}\n\nexport type PanGestureHandler = typeof PanGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PanGestureHandler = createHandler<\n  PanGestureHandlerProps,\n  PanGestureHandlerEventPayload\n>({\n  name: 'PanGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'activeOffsetY',\n    'activeOffsetX',\n    'failOffsetY',\n    'failOffsetX',\n    'minDist',\n    'minVelocity',\n    'minVelocityX',\n    'minVelocityY',\n    'minPointers',\n    'maxPointers',\n    'avgTouches',\n    'enableTrackpadTwoFingerGesture',\n  ] as const,\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: [\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'failOffsetYStart',\n    'failOffsetYEnd',\n    'failOffsetXStart',\n    'failOffsetXEnd',\n  ],\n});\n\nexport type PinchGestureHandlerEventPayload = {\n  scale: number;\n  focalX: number;\n  focalY: number;\n  velocity: number;\n};\n\nexport interface PinchGestureHandlerProps\n  extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {}\n\nexport type PinchGestureHandler = typeof PinchGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PinchGestureHandler = createHandler<\n  PinchGestureHandlerProps,\n  PinchGestureHandlerEventPayload\n>({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n\nexport type RotationGestureHandlerEventPayload = {\n  rotation: number;\n  anchorX: number;\n  anchorY: number;\n  velocity: number;\n};\n\nexport interface RotationGestureHandlerProps\n  extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {}\n\nexport type RotationGestureHandler = typeof RotationGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const RotationGestureHandler = createHandler<\n  RotationGestureHandlerProps,\n  RotationGestureHandlerEventPayload\n>({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/index.js b/node_modules/react-native-gesture-handler/lib/commonjs/index.js
new file mode 100644
index 0000000..6daa919
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/index.js
@@ -0,0 +1,200 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "Directions", {
+  enumerable: true,
+  get: function () {
+    return _Directions.Directions;
+  }
+});
+Object.defineProperty(exports, "State", {
+  enumerable: true,
+  get: function () {
+    return _State.State;
+  }
+});
+Object.defineProperty(exports, "gestureHandlerRootHOC", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlerRootHOC.default;
+  }
+});
+Object.defineProperty(exports, "GestureHandlerRootView", {
+  enumerable: true,
+  get: function () {
+    return _GestureHandlerRootView.default;
+  }
+});
+Object.defineProperty(exports, "TapGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.TapGestureHandler;
+  }
+});
+Object.defineProperty(exports, "ForceTouchGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.ForceTouchGestureHandler;
+  }
+});
+Object.defineProperty(exports, "LongPressGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.LongPressGestureHandler;
+  }
+});
+Object.defineProperty(exports, "PanGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.PanGestureHandler;
+  }
+});
+Object.defineProperty(exports, "PinchGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.PinchGestureHandler;
+  }
+});
+Object.defineProperty(exports, "RotationGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.RotationGestureHandler;
+  }
+});
+Object.defineProperty(exports, "FlingGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _gestureHandlers.FlingGestureHandler;
+  }
+});
+Object.defineProperty(exports, "createNativeWrapper", {
+  enumerable: true,
+  get: function () {
+    return _createNativeWrapper.default;
+  }
+});
+Object.defineProperty(exports, "NativeViewGestureHandler", {
+  enumerable: true,
+  get: function () {
+    return _NativeViewGestureHandler.NativeViewGestureHandler;
+  }
+});
+Object.defineProperty(exports, "RawButton", {
+  enumerable: true,
+  get: function () {
+    return _GestureButtons.RawButton;
+  }
+});
+Object.defineProperty(exports, "BaseButton", {
+  enumerable: true,
+  get: function () {
+    return _GestureButtons.BaseButton;
+  }
+});
+Object.defineProperty(exports, "RectButton", {
+  enumerable: true,
+  get: function () {
+    return _GestureButtons.RectButton;
+  }
+});
+Object.defineProperty(exports, "BorderlessButton", {
+  enumerable: true,
+  get: function () {
+    return _GestureButtons.BorderlessButton;
+  }
+});
+Object.defineProperty(exports, "TouchableHighlight", {
+  enumerable: true,
+  get: function () {
+    return _touchables.TouchableHighlight;
+  }
+});
+Object.defineProperty(exports, "TouchableNativeFeedback", {
+  enumerable: true,
+  get: function () {
+    return _touchables.TouchableNativeFeedback;
+  }
+});
+Object.defineProperty(exports, "TouchableOpacity", {
+  enumerable: true,
+  get: function () {
+    return _touchables.TouchableOpacity;
+  }
+});
+Object.defineProperty(exports, "TouchableWithoutFeedback", {
+  enumerable: true,
+  get: function () {
+    return _touchables.TouchableWithoutFeedback;
+  }
+});
+Object.defineProperty(exports, "ScrollView", {
+  enumerable: true,
+  get: function () {
+    return _GestureComponents.ScrollView;
+  }
+});
+Object.defineProperty(exports, "Switch", {
+  enumerable: true,
+  get: function () {
+    return _GestureComponents.Switch;
+  }
+});
+Object.defineProperty(exports, "TextInput", {
+  enumerable: true,
+  get: function () {
+    return _GestureComponents.TextInput;
+  }
+});
+Object.defineProperty(exports, "DrawerLayoutAndroid", {
+  enumerable: true,
+  get: function () {
+    return _GestureComponents.DrawerLayoutAndroid;
+  }
+});
+Object.defineProperty(exports, "FlatList", {
+  enumerable: true,
+  get: function () {
+    return _GestureComponents.FlatList;
+  }
+});
+Object.defineProperty(exports, "Swipeable", {
+  enumerable: true,
+  get: function () {
+    return _Swipeable.default;
+  }
+});
+Object.defineProperty(exports, "DrawerLayout", {
+  enumerable: true,
+  get: function () {
+    return _DrawerLayout.default;
+  }
+});
+
+var _Directions = require("./Directions");
+
+var _State = require("./State");
+
+var _gestureHandlerRootHOC = _interopRequireDefault(require("./gestureHandlerRootHOC"));
+
+var _GestureHandlerRootView = _interopRequireDefault(require("./GestureHandlerRootView"));
+
+var _gestureHandlers = require("./handlers/gestureHandlers");
+
+var _createNativeWrapper = _interopRequireDefault(require("./handlers/createNativeWrapper"));
+
+var _NativeViewGestureHandler = require("./handlers/NativeViewGestureHandler");
+
+var _GestureButtons = require("./components/GestureButtons");
+
+var _touchables = require("./components/touchables");
+
+var _GestureComponents = require("./components/GestureComponents");
+
+var _Swipeable = _interopRequireDefault(require("./components/Swipeable"));
+
+var _DrawerLayout = _interopRequireDefault(require("./components/DrawerLayout"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/index.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/index.js.map
new file mode 100644
index 0000000..5db3e37
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/index.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAwBA;;AASA;;AAKA;;AAOA;;AAMA;;AAMA;;AA8CA;;AASA","sourcesContent":["export { Directions } from './Directions';\nexport { State } from './State';\nexport { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';\nexport { default as GestureHandlerRootView } from './GestureHandlerRootView';\nexport type {\n  // event types\n  GestureEvent,\n  HandlerStateChangeEvent,\n  // event payloads types\n  GestureEventPayload,\n  HandlerStateChangeEventPayload,\n  TapGestureHandlerEventPayload,\n  ForceTouchGestureHandlerEventPayload,\n  LongPressGestureHandlerEventPayload,\n  PanGestureHandlerEventPayload,\n  PinchGestureHandlerEventPayload,\n  RotationGestureHandlerEventPayload,\n  FlingGestureHandlerEventPayload,\n  // gesture handlers props types\n  TapGestureHandlerProps,\n  ForceTouchGestureHandlerProps,\n  LongPressGestureHandlerProps,\n  PanGestureHandlerProps,\n  PinchGestureHandlerProps,\n  RotationGestureHandlerProps,\n  FlingGestureHandlerProps,\n} from './handlers/gestureHandlers';\nexport {\n  TapGestureHandler,\n  ForceTouchGestureHandler,\n  LongPressGestureHandler,\n  PanGestureHandler,\n  PinchGestureHandler,\n  RotationGestureHandler,\n  FlingGestureHandler,\n} from './handlers/gestureHandlers';\nexport { default as createNativeWrapper } from './handlers/createNativeWrapper';\nexport type {\n  NativeViewGestureHandlerPayload,\n  NativeViewGestureHandlerProps,\n} from './handlers/NativeViewGestureHandler';\nexport { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';\nexport type {\n  RawButtonProps,\n  BaseButtonProps,\n  RectButtonProps,\n  BorderlessButtonProps,\n} from './components/GestureButtons';\nexport {\n  RawButton,\n  BaseButton,\n  RectButton,\n  BorderlessButton,\n} from './components/GestureButtons';\nexport {\n  TouchableHighlight,\n  TouchableNativeFeedback,\n  TouchableOpacity,\n  TouchableWithoutFeedback,\n} from './components/touchables';\nexport {\n  ScrollView,\n  Switch,\n  TextInput,\n  DrawerLayoutAndroid,\n  FlatList,\n} from './components/GestureComponents';\nexport type {\n  //events\n  GestureHandlerGestureEvent,\n  GestureHandlerStateChangeEvent,\n  //event payloads\n  GestureHandlerGestureEventNativeEvent,\n  GestureHandlerStateChangeNativeEvent,\n  NativeViewGestureHandlerGestureEvent,\n  NativeViewGestureHandlerStateChangeEvent,\n  TapGestureHandlerGestureEvent,\n  TapGestureHandlerStateChangeEvent,\n  ForceTouchGestureHandlerGestureEvent,\n  ForceTouchGestureHandlerStateChangeEvent,\n  LongPressGestureHandlerGestureEvent,\n  LongPressGestureHandlerStateChangeEvent,\n  PanGestureHandlerGestureEvent,\n  PanGestureHandlerStateChangeEvent,\n  PinchGestureHandlerGestureEvent,\n  PinchGestureHandlerStateChangeEvent,\n  RotationGestureHandlerGestureEvent,\n  RotationGestureHandlerStateChangeEvent,\n  FlingGestureHandlerGestureEvent,\n  FlingGestureHandlerStateChangeEvent,\n  // handlers props\n  NativeViewGestureHandlerProperties,\n  TapGestureHandlerProperties,\n  LongPressGestureHandlerProperties,\n  PanGestureHandlerProperties,\n  PinchGestureHandlerProperties,\n  RotationGestureHandlerProperties,\n  FlingGestureHandlerProperties,\n  ForceTouchGestureHandlerProperties,\n  // buttons props\n  RawButtonProperties,\n  BaseButtonProperties,\n  RectButtonProperties,\n  BorderlessButtonProperties,\n} from './handlers/gestureHandlerTypesCompat';\n\nexport { default as Swipeable } from './components/Swipeable';\nexport type {\n  DrawerLayoutProps,\n  DrawerPosition,\n  DrawerState,\n  DrawerType,\n  DrawerLockMode,\n  DrawerKeyboardDismissMode,\n} from './components/DrawerLayout';\nexport { default as DrawerLayout } from './components/DrawerLayout';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js b/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js
new file mode 100644
index 0000000..f5dfddf
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js
@@ -0,0 +1,35 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _reactNative = require("react-native");
+
+var _State = require("./State");
+
+var _Directions = require("./Directions");
+
+const NOOP = () => {// do nothing
+};
+
+const ScrollView = _reactNative.ScrollView;
+const PanGestureHandler = _reactNative.View;
+const attachGestureHandler = NOOP;
+const createGestureHandler = NOOP;
+const dropGestureHandler = NOOP;
+const updateGestureHandler = NOOP;
+var _default = {
+  ScrollView,
+  PanGestureHandler,
+  attachGestureHandler,
+  createGestureHandler,
+  dropGestureHandler,
+  updateGestureHandler,
+  // probably can be removed
+  Directions: _Directions.Directions,
+  State: _State.State
+};
+exports.default = _default;
+//# sourceMappingURL=mocks.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js.map
new file mode 100644
index 0000000..29afa07
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/mocks.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["mocks.ts"],"names":["NOOP","ScrollView","RNScrollView","PanGestureHandler","View","attachGestureHandler","createGestureHandler","dropGestureHandler","updateGestureHandler","Directions","State"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AAEA,MAAMA,IAAI,GAAG,MAAM,CACjB;AACD,CAFD;;AAGA,MAAMC,UAAU,GAAGC,uBAAnB;AACA,MAAMC,iBAAiB,GAAGC,iBAA1B;AACA,MAAMC,oBAAoB,GAAGL,IAA7B;AACA,MAAMM,oBAAoB,GAAGN,IAA7B;AACA,MAAMO,kBAAkB,GAAGP,IAA3B;AACA,MAAMQ,oBAAoB,GAAGR,IAA7B;eAEe;AACbC,EAAAA,UADa;AAEbE,EAAAA,iBAFa;AAGbE,EAAAA,oBAHa;AAIbC,EAAAA,oBAJa;AAKbC,EAAAA,kBALa;AAMbC,EAAAA,oBANa;AAOb;AACAC,EAAAA,UAAU,EAAVA,sBARa;AASbC,EAAAA,KAAK,EAALA;AATa,C","sourcesContent":["import { View, ScrollView as RNScrollView } from 'react-native';\nimport { State } from './State';\nimport { Directions } from './Directions';\n\nconst NOOP = () => {\n  // do nothing\n};\nconst ScrollView = RNScrollView;\nconst PanGestureHandler = View;\nconst attachGestureHandler = NOOP;\nconst createGestureHandler = NOOP;\nconst dropGestureHandler = NOOP;\nconst updateGestureHandler = NOOP;\n\nexport default {\n  ScrollView,\n  PanGestureHandler,\n  attachGestureHandler,\n  createGestureHandler,\n  dropGestureHandler,\n  updateGestureHandler,\n  // probably can be removed\n  Directions,\n  State,\n} as const;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js b/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js
new file mode 100644
index 0000000..ae0eefb
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js
@@ -0,0 +1,2 @@
+"use strict";
+//# sourceMappingURL=typeUtils.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js.map
new file mode 100644
index 0000000..9ffd4b2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/typeUtils.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js
new file mode 100644
index 0000000..e9cf916
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js
@@ -0,0 +1,105 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _GestureHandler = _interopRequireDefault(require("./GestureHandler"));
+
+var _utils = require("./utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+class DiscreteGestureHandler extends _GestureHandler.default {
+  get isDiscrete() {
+    return true;
+  }
+
+  get shouldEnableGestureOnSetup() {
+    return true;
+  }
+
+  shouldFailUnderCustomCriteria({
+    x,
+    y,
+    deltaX,
+    deltaY
+  }, {
+    maxDeltaX,
+    maxDeltaY,
+    maxDistSq,
+    shouldCancelWhenOutside
+  }) {
+    if (shouldCancelWhenOutside) {
+      if (!this.isPointInView({
+        x,
+        y
+      })) {
+        return true;
+      }
+    }
+
+    return (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaX), maxDeltaX) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY), maxDeltaY) || (0, _utils.TEST_MAX_IF_NOT_NAN)(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);
+  }
+
+  transformNativeEvent({
+    center: {
+      x,
+      y
+    }
+  }) {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view.getBoundingClientRect();
+    return {
+      absoluteX: x,
+      absoluteY: y,
+      x: x - rect.left,
+      y: y - rect.top
+    };
+  }
+
+  isGestureEnabledForEvent({
+    minPointers,
+    maxPointers,
+    maxDeltaX,
+    maxDeltaY,
+    maxDistSq,
+    shouldCancelWhenOutside
+  }, _recognizer, {
+    maxPointers: pointerLength,
+    center,
+    deltaX,
+    deltaY
+  }) {
+    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;
+
+    if (this.shouldFailUnderCustomCriteria({ ...center,
+      deltaX,
+      deltaY
+    }, {
+      maxDeltaX,
+      maxDeltaY,
+      maxDistSq,
+      shouldCancelWhenOutside
+    }) || // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)
+    // but if the gesture is running and the user adds or subtracts another pointer then it should fail.
+    !validPointerCount && this.isGestureRunning) {
+      return {
+        failed: true
+      };
+    }
+
+    return {
+      success: validPointerCount
+    };
+  }
+
+}
+
+var _default = DiscreteGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=DiscreteGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js.map
new file mode 100644
index 0000000..a15efc5
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/DiscreteGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DiscreteGestureHandler.ts"],"names":["DiscreteGestureHandler","GestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","minPointers","maxPointers","_recognizer","pointerLength","validPointerCount","isGestureRunning","failed","success"],"mappings":";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7C,MAAVC,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACE,gCAAoBQ,IAAI,CAACC,GAAL,CAASR,MAAT,CAApB,EAAsCE,SAAtC,KACA,gCAAoBK,IAAI,CAACC,GAAL,CAASP,MAAT,CAApB,EAAsCE,SAAtC,CADA,IAEA,gCACEI,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADF,EAEEI,SAFF,CAHF;AAQD;;AAEDK,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEZ,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AAAV,GAAD,EAA4B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AACEC,IAAAA,WADF;AAEEC,IAAAA,WAFF;AAGElB,IAAAA,SAHF;AAIEC,IAAAA,SAJF;AAKEC,IAAAA,SALF;AAMEC,IAAAA;AANF,GADsB,EAStBgB,WATsB,EAUtB;AAAED,IAAAA,WAAW,EAAEE,aAAf;AAA8BZ,IAAAA,MAA9B;AAAsCV,IAAAA,MAAtC;AAA8CC,IAAAA;AAA9C,GAVsB,EAWtB;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIH,WAAjB,IAAgCG,aAAa,IAAIF,WADnD;;AAGA,QACE,KAAKvB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;eA4E9C9B,sB","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js
new file mode 100644
index 0000000..82a4e21
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js
@@ -0,0 +1,53 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _GestureHandler = _interopRequireDefault(require("./GestureHandler"));
+
+var _reactNative = require("react-native");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+class DraggingGestureHandler extends _GestureHandler.default {
+  get shouldEnableGestureOnSetup() {
+    return true;
+  }
+
+  transformNativeEvent({
+    deltaX,
+    deltaY,
+    velocityX,
+    velocityY,
+    center: {
+      x,
+      y
+    }
+  }) {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view.getBoundingClientRect();
+
+    const ratio = _reactNative.PixelRatio.get();
+
+    return {
+      translationX: deltaX - (this.__initialX || 0),
+      translationY: deltaY - (this.__initialY || 0),
+      absoluteX: x,
+      absoluteY: y,
+      velocityX: velocityX * ratio,
+      velocityY: velocityY * ratio,
+      x: x - rect.left,
+      y: y - rect.top
+    };
+  }
+
+}
+
+var _default = DraggingGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=DraggingGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js.map
new file mode 100644
index 0000000..f2b17a8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/DraggingGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DraggingGestureHandler.ts"],"names":["DraggingGestureHandler","GestureHandler","shouldEnableGestureOnSetup","transformNativeEvent","deltaX","deltaY","velocityX","velocityY","center","x","y","rect","view","getBoundingClientRect","ratio","PixelRatio","get","translationX","__initialX","translationY","__initialY","absoluteX","absoluteY","left","top"],"mappings":";;;;;;;AAEA;;AACA;;;;AAHA;;AACA;AAIA,MAAeA,sBAAf,SAA8CC,uBAA9C,CAA6D;AAC7B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AACnBC,IAAAA,MADmB;AAEnBC,IAAAA,MAFmB;AAGnBC,IAAAA,SAHmB;AAInBC,IAAAA,SAJmB;AAKnBC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AALW,GAAD,EAMD;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;;AACA,UAAMC,KAAK,GAAGC,wBAAWC,GAAX,EAAd;;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEd,MAAM,IAAI,KAAKe,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEZ,CAHN;AAILa,MAAAA,SAAS,EAAEZ,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACY,IAPP;AAQLb,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACa;AARP,KAAP;AAUD;;AAzB0D;;eA4B9CxB,sB","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\nimport { PixelRatio } from 'react-native';\n\nabstract class DraggingGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  transformNativeEvent({\n    deltaX,\n    deltaY,\n    velocityX,\n    velocityY,\n    center: { x, y },\n  }: HammerInputExt) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const ratio = PixelRatio.get();\n    return {\n      translationX: deltaX - (this.__initialX || 0),\n      translationY: deltaY - (this.__initialY || 0),\n      absoluteX: x,\n      absoluteY: y,\n      velocityX: velocityX * ratio,\n      velocityY: velocityY * ratio,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n}\n\nexport default DraggingGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js
new file mode 100644
index 0000000..1c1bf55
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js
@@ -0,0 +1,16 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.GesturePropError = void 0;
+
+class GesturePropError extends Error {
+  constructor(name, value, expectedType) {
+    super("Invalid property `".concat(name, ": ").concat(value, "` expected `").concat(expectedType, "`"));
+  }
+
+}
+
+exports.GesturePropError = GesturePropError;
+//# sourceMappingURL=Errors.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js.map
new file mode 100644
index 0000000..069ee55
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/Errors.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Errors.ts"],"names":["GesturePropError","Error","constructor","name","value","expectedType"],"mappings":";;;;;;;AAAO,MAAMA,gBAAN,SAA+BC,KAA/B,CAAqC;AAC1CC,EAAAA,WAAW,CAACC,IAAD,EAAeC,KAAf,EAA+BC,YAA/B,EAAqD;AAC9D,sCACwBF,IADxB,eACiCC,KADjC,yBACuDC,YADvD;AAGD;;AALyC","sourcesContent":["export class GesturePropError extends Error {\n  constructor(name: string, value: unknown, expectedType: string) {\n    super(\n      `Invalid property \\`${name}: ${value}\\` expected \\`${expectedType}\\``\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js
new file mode 100644
index 0000000..554f5fd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js
@@ -0,0 +1,170 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _constants = require("./constants");
+
+var _Errors = require("./Errors");
+
+var _DraggingGestureHandler = _interopRequireDefault(require("./DraggingGestureHandler"));
+
+var _utils = require("./utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+class FlingGestureHandler extends _DraggingGestureHandler.default {
+  get name() {
+    return 'swipe';
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Swipe;
+  }
+
+  onGestureActivated(event) {
+    this.sendEvent({ ...event,
+      eventType: _hammerjs.default.INPUT_MOVE,
+      isFinal: false,
+      isFirst: true
+    });
+    this.isGestureRunning = false;
+    this.hasGestureFailed = false;
+    this.sendEvent({ ...event,
+      eventType: _hammerjs.default.INPUT_END,
+      isFinal: true
+    });
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (this.hasGestureFailed) {
+      return;
+    } // Hammer doesn't send a `cancel` event for taps.
+    // Manually fail the event.
+
+
+    if (ev.isFinal) {
+      setTimeout(() => {
+        if (this.isGestureRunning) {
+          this.cancelEvent(ev);
+        }
+      });
+    } else if (!this.hasGestureFailed && !this.isGestureRunning) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore FIXME(TS)
+
+      if (gesture.options.enable(gesture, ev)) {
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+  }
+
+  getHammerConfig() {
+    return {
+      // @ts-ignore FIXME(TS)
+      pointers: this.config.numberOfPointers,
+      direction: this.getDirection()
+    };
+  }
+
+  getTargetDirections(direction) {
+    const directions = [];
+
+    if (direction & _constants.Direction.RIGHT) {
+      directions.push(_hammerjs.default.DIRECTION_RIGHT);
+    }
+
+    if (direction & _constants.Direction.LEFT) {
+      directions.push(_hammerjs.default.DIRECTION_LEFT);
+    }
+
+    if (direction & _constants.Direction.UP) {
+      directions.push(_hammerjs.default.DIRECTION_UP);
+    }
+
+    if (direction & _constants.Direction.DOWN) {
+      directions.push(_hammerjs.default.DIRECTION_DOWN);
+    } // const hammerDirection = directions.reduce((a, b) => a | b, 0);
+
+
+    return directions;
+  }
+
+  getDirection() {
+    // @ts-ignore FIXME(TS)
+    const {
+      direction
+    } = this.getConfig();
+    let directions = [];
+
+    if (direction & _constants.Direction.RIGHT) {
+      directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);
+    }
+
+    if (direction & _constants.Direction.LEFT) {
+      directions.push(_hammerjs.default.DIRECTION_HORIZONTAL);
+    }
+
+    if (direction & _constants.Direction.UP) {
+      directions.push(_hammerjs.default.DIRECTION_VERTICAL);
+    }
+
+    if (direction & _constants.Direction.DOWN) {
+      directions.push(_hammerjs.default.DIRECTION_VERTICAL);
+    }
+
+    directions = [...new Set(directions)];
+    if (directions.length === 0) return _hammerjs.default.DIRECTION_NONE;
+    if (directions.length === 1) return directions[0];
+    return _hammerjs.default.DIRECTION_ALL;
+  }
+
+  isGestureEnabledForEvent({
+    numberOfPointers
+  }, _recognizer, {
+    maxPointers: pointerLength
+  }) {
+    const validPointerCount = pointerLength === numberOfPointers;
+
+    if (!validPointerCount && this.isGestureRunning) {
+      return {
+        failed: true
+      };
+    }
+
+    return {
+      success: validPointerCount
+    };
+  }
+
+  updateGestureConfig({
+    numberOfPointers = 1,
+    direction,
+    ...props
+  }) {
+    if ((0, _utils.isnan)(direction) || typeof direction !== 'number') {
+      throw new _Errors.GesturePropError('direction', direction, 'number');
+    }
+
+    return super.updateGestureConfig({
+      numberOfPointers,
+      direction,
+      ...props
+    });
+  }
+
+}
+
+var _default = FlingGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=FlingGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js.map
new file mode 100644
index 0000000..226f114
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/FlingGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["FlingGestureHandler.ts"],"names":["FlingGestureHandler","DraggingGestureHandler","name","NativeGestureClass","Hammer","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","Direction","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props","GesturePropError"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js
new file mode 100644
index 0000000..3b8afe4
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js
@@ -0,0 +1,535 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _reactNative = require("react-native");
+
+var _State = require("../State");
+
+var _constants = require("./constants");
+
+var NodeManager = _interopRequireWildcard(require("./NodeManager"));
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+let gestureInstances = 0;
+
+class GestureHandler {
+  get id() {
+    return "".concat(this.name).concat(this.gestureInstance);
+  }
+
+  get isDiscrete() {
+    return false;
+  }
+
+  get shouldEnableGestureOnSetup() {
+    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');
+  }
+
+  constructor() {
+    _defineProperty(this, "handlerTag", void 0);
+
+    _defineProperty(this, "isGestureRunning", false);
+
+    _defineProperty(this, "view", null);
+
+    _defineProperty(this, "hasCustomActivationCriteria", void 0);
+
+    _defineProperty(this, "hasGestureFailed", false);
+
+    _defineProperty(this, "hammer", null);
+
+    _defineProperty(this, "initialRotation", null);
+
+    _defineProperty(this, "__initialX", void 0);
+
+    _defineProperty(this, "__initialY", void 0);
+
+    _defineProperty(this, "config", {});
+
+    _defineProperty(this, "previousState", _State.State.UNDETERMINED);
+
+    _defineProperty(this, "pendingGestures", {});
+
+    _defineProperty(this, "oldState", _State.State.UNDETERMINED);
+
+    _defineProperty(this, "lastSentState", null);
+
+    _defineProperty(this, "gestureInstance", void 0);
+
+    _defineProperty(this, "_stillWaiting", void 0);
+
+    _defineProperty(this, "propsRef", void 0);
+
+    _defineProperty(this, "ref", void 0);
+
+    _defineProperty(this, "clearSelfAsPending", () => {
+      if (Array.isArray(this.config.waitFor)) {
+        for (const gesture of this.config.waitFor) {
+          gesture.removePendingGesture(this.id);
+        }
+      }
+    });
+
+    _defineProperty(this, "destroy", () => {
+      this.clearSelfAsPending();
+
+      if (this.hammer) {
+        this.hammer.stop(false);
+        this.hammer.destroy();
+      }
+
+      this.hammer = null;
+    });
+
+    _defineProperty(this, "isPointInView", ({
+      x,
+      y
+    }) => {
+      // @ts-ignore FIXME(TS)
+      const rect = this.view.getBoundingClientRect();
+      const pointerInside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
+      return pointerInside;
+    });
+
+    _defineProperty(this, "sendEvent", nativeEvent => {
+      const {
+        onGestureHandlerEvent,
+        onGestureHandlerStateChange
+      } = this.propsRef.current;
+      const event = this.transformEventData(nativeEvent);
+      invokeNullableMethod(onGestureHandlerEvent, event);
+
+      if (this.lastSentState !== event.nativeEvent.state) {
+        this.lastSentState = event.nativeEvent.state;
+        invokeNullableMethod(onGestureHandlerStateChange, event);
+      }
+    });
+
+    _defineProperty(this, "sync", () => {
+      const gesture = this.hammer.get(this.name);
+      if (!gesture) return;
+
+      const enable = (recognizer, inputData) => {
+        if (!this.config.enabled) {
+          this.isGestureRunning = false;
+          this.hasGestureFailed = false;
+          return false;
+        } // Prevent events before the system is ready.
+
+
+        if (!inputData || !recognizer.options || typeof inputData.maxPointers === 'undefined') {
+          return this.shouldEnableGestureOnSetup;
+        }
+
+        if (this.hasGestureFailed) {
+          return false;
+        }
+
+        if (!this.isDiscrete) {
+          if (this.isGestureRunning) {
+            return true;
+          } // The built-in hammer.js "waitFor" doesn't work across multiple views.
+          // Only process if there are views to wait for.
+
+
+          this._stillWaiting = this._getPendingGestures(); // This gesture should continue waiting.
+
+          if (this._stillWaiting.length) {
+            // Check to see if one of the gestures you're waiting for has started.
+            // If it has then the gesture should fail.
+            for (const gesture of this._stillWaiting) {
+              // When the target gesture has started, this gesture must force fail.
+              if (!gesture.isDiscrete && gesture.isGestureRunning) {
+                this.hasGestureFailed = true;
+                this.isGestureRunning = false;
+                return false;
+              }
+            } // This gesture shouldn't start until the others have finished.
+
+
+            return false;
+          }
+        } // Use default behaviour
+
+
+        if (!this.hasCustomActivationCriteria) {
+          return true;
+        }
+
+        const deltaRotation = this.initialRotation == null ? 0 : inputData.rotation - this.initialRotation; // @ts-ignore FIXME(TS)
+
+        const {
+          success,
+          failed
+        } = this.isGestureEnabledForEvent(this.getConfig(), recognizer, { ...inputData,
+          deltaRotation
+        });
+
+        if (failed) {
+          this.simulateCancelEvent(inputData);
+          this.hasGestureFailed = true;
+        }
+
+        return success;
+      };
+
+      const params = this.getHammerConfig(); // @ts-ignore FIXME(TS)
+
+      gesture.set({ ...params,
+        enable
+      });
+    });
+
+    this.gestureInstance = gestureInstances++;
+    this.hasCustomActivationCriteria = false;
+  }
+
+  getConfig() {
+    return this.config;
+  }
+
+  onWaitingEnded(_gesture) {}
+
+  removePendingGesture(id) {
+    delete this.pendingGestures[id];
+  }
+
+  addPendingGesture(gesture) {
+    this.pendingGestures[gesture.id] = gesture;
+  }
+
+  isGestureEnabledForEvent(_config, _recognizer, _event) {
+    return {
+      success: true
+    };
+  }
+
+  get NativeGestureClass() {
+    throw new Error('Must override GestureHandler.NativeGestureClass');
+  }
+
+  updateHasCustomActivationCriteria(_config) {
+    return true;
+  }
+
+  updateGestureConfig({
+    enabled = true,
+    ...props
+  }) {
+    this.clearSelfAsPending();
+    this.config = ensureConfig({
+      enabled,
+      ...props
+    });
+    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(this.config);
+
+    if (Array.isArray(this.config.waitFor)) {
+      for (const gesture of this.config.waitFor) {
+        gesture.addPendingGesture(this);
+      }
+    }
+
+    if (this.hammer) {
+      this.sync();
+    }
+
+    return this.config;
+  }
+
+  getState(type) {
+    // @ts-ignore TODO(TS) check if this is needed
+    if (type == 0) {
+      return 0;
+    }
+
+    return _constants.EventMap[type];
+  }
+
+  transformEventData(event) {
+    const {
+      eventType,
+      maxPointers: numberOfPointers
+    } = event; // const direction = DirectionMap[ev.direction];
+
+    const changedTouch = event.changedPointers[0];
+    const pointerInside = this.isPointInView({
+      x: changedTouch.clientX,
+      y: changedTouch.clientY
+    }); // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.
+
+    const state = this.getState(eventType);
+
+    if (state !== this.previousState) {
+      this.oldState = this.previousState;
+      this.previousState = state;
+    }
+
+    return {
+      nativeEvent: {
+        numberOfPointers,
+        state,
+        pointerInside,
+        ...this.transformNativeEvent(event),
+        // onHandlerStateChange only
+        handlerTag: this.handlerTag,
+        target: this.ref,
+        oldState: this.oldState
+      },
+      timeStamp: Date.now()
+    };
+  }
+
+  transformNativeEvent(_event) {
+    return {};
+  }
+
+  cancelPendingGestures(event) {
+    for (const gesture of Object.values(this.pendingGestures)) {
+      if (gesture && gesture.isGestureRunning) {
+        gesture.hasGestureFailed = true;
+        gesture.cancelEvent(event);
+      }
+    }
+  }
+
+  notifyPendingGestures() {
+    for (const gesture of Object.values(this.pendingGestures)) {
+      if (gesture) {
+        gesture.onWaitingEnded(this);
+      }
+    }
+  } // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input
+
+
+  onGestureEnded(event) {
+    this.isGestureRunning = false;
+    this.cancelPendingGestures(event);
+  }
+
+  forceInvalidate(event) {
+    if (this.isGestureRunning) {
+      this.hasGestureFailed = true;
+      this.cancelEvent(event);
+    }
+  }
+
+  cancelEvent(event) {
+    this.notifyPendingGestures();
+    this.sendEvent({ ...event,
+      eventType: _hammerjs.default.INPUT_CANCEL,
+      isFinal: true
+    });
+    this.onGestureEnded(event);
+  }
+
+  onRawEvent({
+    isFirst
+  }) {
+    if (isFirst) {
+      this.hasGestureFailed = false;
+    }
+  }
+
+  setView(ref, propsRef) {
+    if (ref == null) {
+      this.destroy();
+      this.view = null;
+      return;
+    }
+
+    this.propsRef = propsRef;
+    this.ref = ref;
+    this.view = (0, _reactNative.findNodeHandle)(ref);
+    this.hammer = new _hammerjs.default.Manager(this.view);
+    this.oldState = _State.State.UNDETERMINED;
+    this.previousState = _State.State.UNDETERMINED;
+    this.lastSentState = null;
+    const {
+      NativeGestureClass
+    } = this; // @ts-ignore TODO(TS)
+
+    const gesture = new NativeGestureClass(this.getHammerConfig());
+    this.hammer.add(gesture);
+    this.hammer.on('hammer.input', ev => {
+      if (!this.config.enabled) {
+        this.hasGestureFailed = false;
+        this.isGestureRunning = false;
+        return;
+      }
+
+      this.onRawEvent(ev); // TODO: Bacon: Check against something other than null
+      // The isFirst value is not called when the first rotation is calculated.
+
+      if (this.initialRotation === null && ev.rotation !== 0) {
+        this.initialRotation = ev.rotation;
+      }
+
+      if (ev.isFinal) {
+        // in favor of a willFail otherwise the last frame of the gesture will be captured.
+        setTimeout(() => {
+          this.initialRotation = null;
+          this.hasGestureFailed = false;
+        });
+      }
+    });
+    this.setupEvents();
+    this.sync();
+  }
+
+  setupEvents() {
+    // TODO(TS) Hammer types aren't exactly that what we get in runtime
+    if (!this.isDiscrete) {
+      this.hammer.on("".concat(this.name, "start"), event => this.onStart(event));
+      this.hammer.on("".concat(this.name, "end ").concat(this.name, "cancel"), event => {
+        this.onGestureEnded(event);
+      });
+    }
+
+    this.hammer.on(this.name, ev => this.onGestureActivated(ev)); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged
+  }
+
+  onStart({
+    deltaX,
+    deltaY,
+    rotation
+  }) {
+    // Reset the state for the next gesture
+    this.oldState = _State.State.UNDETERMINED;
+    this.previousState = _State.State.UNDETERMINED;
+    this.lastSentState = null;
+    this.isGestureRunning = true;
+    this.__initialX = deltaX;
+    this.__initialY = deltaY;
+    this.initialRotation = rotation;
+  }
+
+  onGestureActivated(ev) {
+    this.sendEvent(ev);
+  }
+
+  onSuccess() {}
+
+  _getPendingGestures() {
+    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {
+      // Get the list of gestures that this gesture is still waiting for.
+      // Use `=== false` in case a ref that isn't a gesture handler is used.
+      const stillWaiting = this.config.waitFor.filter(({
+        hasGestureFailed
+      }) => hasGestureFailed === false);
+      return stillWaiting;
+    }
+
+    return [];
+  }
+
+  getHammerConfig() {
+    const pointers = this.config.minPointers === this.config.maxPointers ? this.config.minPointers : 0;
+    return {
+      pointers
+    };
+  }
+
+  simulateCancelEvent(_inputData) {}
+
+} // TODO(TS) investigate this method
+// Used for sending data to a callback or AnimatedEvent
+
+
+function invokeNullableMethod(method, event) {
+  if (method) {
+    if (typeof method === 'function') {
+      method(event);
+    } else {
+      // For use with reanimated's AnimatedEvent
+      if ('__getHandler' in method && typeof method.__getHandler === 'function') {
+        const handler = method.__getHandler();
+
+        invokeNullableMethod(handler, event);
+      } else {
+        if ('__nodeConfig' in method) {
+          const {
+            argMapping
+          } = method.__nodeConfig;
+
+          if (Array.isArray(argMapping)) {
+            for (const index in argMapping) {
+              const [key, value] = argMapping[index];
+
+              if (key in event.nativeEvent) {
+                // @ts-ignore fix method type
+                const nativeValue = event.nativeEvent[key];
+
+                if (value && value.setValue) {
+                  // Reanimated API
+                  value.setValue(nativeValue);
+                } else {
+                  // RN Animated API
+                  method.__nodeConfig.argMapping[index] = [key, nativeValue];
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+} // Validate the props
+
+
+function ensureConfig(config) {
+  const props = { ...config
+  }; // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)
+
+  if ('minDist' in config) {
+    props.minDist = config.minDist;
+    props.minDistSq = props.minDist * props.minDist;
+  }
+
+  if ('minVelocity' in config) {
+    props.minVelocity = config.minVelocity;
+    props.minVelocitySq = props.minVelocity * props.minVelocity;
+  }
+
+  if ('maxDist' in config) {
+    props.maxDist = config.maxDist;
+    props.maxDistSq = config.maxDist * config.maxDist;
+  }
+
+  if ('waitFor' in config) {
+    props.waitFor = asArray(config.waitFor).map(({
+      handlerTag
+    }) => NodeManager.getHandler(handlerTag)).filter(v => v);
+  } else {
+    props.waitFor = null;
+  }
+
+  const configProps = ['minPointers', 'maxPointers', 'minDist', 'maxDist', 'maxDistSq', 'minVelocitySq', 'minDistSq', 'minVelocity', 'failOffsetXStart', 'failOffsetYStart', 'failOffsetXEnd', 'failOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'activeOffsetYStart', 'activeOffsetYEnd'];
+  configProps.forEach(prop => {
+    if (typeof props[prop] === 'undefined') {
+      props[prop] = Number.NaN;
+    }
+  });
+  return props; // TODO(TS) how to convince TS that props are filled?
+}
+
+function asArray(value) {
+  // TODO(TS) use config.waitFor type
+  return value == null ? [] : Array.isArray(value) ? value : [value];
+}
+
+var _default = GestureHandler;
+exports.default = _default;
+//# sourceMappingURL=GestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js.map
new file mode 100644
index 0000000..8e808bf
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/GestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandler.ts"],"names":["gestureInstances","GestureHandler","id","name","gestureInstance","isDiscrete","shouldEnableGestureOnSetup","Error","constructor","State","UNDETERMINED","Array","isArray","config","waitFor","gesture","removePendingGesture","clearSelfAsPending","hammer","stop","destroy","x","y","rect","view","getBoundingClientRect","pointerInside","left","right","top","bottom","nativeEvent","onGestureHandlerEvent","onGestureHandlerStateChange","propsRef","current","event","transformEventData","invokeNullableMethod","lastSentState","state","get","enable","recognizer","inputData","enabled","isGestureRunning","hasGestureFailed","options","maxPointers","_stillWaiting","_getPendingGestures","length","hasCustomActivationCriteria","deltaRotation","initialRotation","rotation","success","failed","isGestureEnabledForEvent","getConfig","simulateCancelEvent","params","getHammerConfig","set","onWaitingEnded","_gesture","pendingGestures","addPendingGesture","_config","_recognizer","_event","NativeGestureClass","updateHasCustomActivationCriteria","updateGestureConfig","props","ensureConfig","sync","getState","type","EventMap","eventType","numberOfPointers","changedTouch","changedPointers","isPointInView","clientX","clientY","previousState","oldState","transformNativeEvent","handlerTag","target","ref","timeStamp","Date","now","cancelPendingGestures","Object","values","cancelEvent","notifyPendingGestures","onGestureEnded","forceInvalidate","sendEvent","Hammer","INPUT_CANCEL","isFinal","onRawEvent","isFirst","setView","Manager","add","on","ev","setTimeout","setupEvents","onStart","onGestureActivated","deltaX","deltaY","__initialX","__initialY","onSuccess","stillWaiting","filter","pointers","minPointers","_inputData","method","__getHandler","handler","argMapping","__nodeConfig","index","key","value","nativeValue","setValue","minDist","minDistSq","minVelocity","minVelocitySq","maxDist","maxDistSq","asArray","map","NodeManager","getHandler","v","configProps","forEach","prop","Number","NaN"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport { State } from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\n\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\n\nexport type Config = Partial<{\n  enabled: boolean;\n  minPointers: number;\n  maxPointers: number;\n  minDist: number;\n  minDistSq: number;\n  minVelocity: number;\n  minVelocitySq: number;\n  maxDist: number;\n  maxDistSq: number;\n  failOffsetXStart: number;\n  failOffsetYStart: number;\n  failOffsetXEnd: number;\n  failOffsetYEnd: number;\n  activeOffsetXStart: number;\n  activeOffsetXEnd: number;\n  activeOffsetYStart: number;\n  activeOffsetYEnd: number;\n  waitFor: any[] | null;\n}>;\n\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\n\nlet gestureInstances = 0;\n\nabstract class GestureHandler {\n  public handlerTag: any;\n  public isGestureRunning = false;\n  public view: number | null = null;\n  protected hasCustomActivationCriteria: boolean;\n  protected hasGestureFailed = false;\n  protected hammer: HammerManager | null = null;\n  protected initialRotation: number | null = null;\n  protected __initialX: any;\n  protected __initialY: any;\n  protected config: Config = {};\n  protected previousState: State = State.UNDETERMINED;\n  private pendingGestures: Record<string, this> = {};\n  private oldState: State = State.UNDETERMINED;\n  private lastSentState: State | null = null;\n  private gestureInstance: number;\n  private _stillWaiting: any;\n  private propsRef: any;\n  private ref: any;\n\n  abstract get name(): string;\n\n  get id() {\n    return `${this.name}${this.gestureInstance}`;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this.gestureInstance = gestureInstances++;\n    this.hasCustomActivationCriteria = false;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(_gesture: this) {}\n\n  removePendingGesture(id: string) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture: this) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent(\n    _config: any,\n    _recognizer: any,\n    _event: any\n  ): { failed?: boolean; success?: boolean } {\n    return { success: true };\n  }\n\n  get NativeGestureClass(): RecognizerStatic {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(_config: Config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = ensureConfig({ enabled, ...props });\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop(false);\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type: keyof typeof EventMap): State {\n    // @ts-ignore TODO(TS) check if this is needed\n    if (type == 0) {\n      return 0;\n    }\n    return EventMap[type];\n  }\n\n  transformEventData(event: HammerInputExt) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: this.oldState,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(_event: HammerInputExt) {\n    return {};\n  }\n\n  sendEvent = (nativeEvent: HammerInputExt) => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    } = this.propsRef.current;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod(onGestureHandlerEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state as State;\n      invokeNullableMethod(onGestureHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event: HammerInputExt) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\n  onGestureEnded(event: HammerInputExt) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event: HammerInputExt) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }: HammerInputExt) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n    this.hammer = new Hammer.Manager(this.view as any);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    // @ts-ignore TODO(TS)\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent((ev as unknown) as HammerInputExt);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\n    if (!this.isDiscrete) {\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\n        this.onStart((event as unknown) as HammerInputExt)\n      );\n      this.hammer!.on(\n        `${this.name}end ${this.name}cancel`,\n        (event: HammerInput) => {\n          this.onGestureEnded((event as unknown) as HammerInputExt);\n        }\n      );\n    }\n    this.hammer!.on(this.name, (ev: HammerInput) =>\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n  }\n\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer!.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer: any, inputData: any) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this.hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      // @ts-ignore FIXME(TS)\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    // @ts-ignore FIXME(TS)\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(_inputData: any) {}\n}\n\n// TODO(TS) investigate this method\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(\n  method:\n    | ((event: NativeEvent) => void)\n    | { __getHandler: () => (event: NativeEvent) => void }\n    | { __nodeConfig: { argMapping: any } },\n  event: NativeEvent\n) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const index in argMapping) {\n              const [key, value] = argMapping[index];\n              if (key in event.nativeEvent) {\n                // @ts-ignore fix method type\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Validate the props\nfunction ensureConfig(config: Config): Required<Config> {\n  const props = { ...config };\n\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\n  if ('minDist' in config) {\n    props.minDist = config.minDist;\n    props.minDistSq = props.minDist! * props.minDist!;\n  }\n  if ('minVelocity' in config) {\n    props.minVelocity = config.minVelocity;\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\n  }\n  if ('maxDist' in config) {\n    props.maxDist = config.maxDist;\n    props.maxDistSq = config.maxDist! * config.maxDist!;\n  }\n  if ('waitFor' in config) {\n    props.waitFor = asArray(config.waitFor)\n      .map(({ handlerTag }: { handlerTag: number }) =>\n        NodeManager.getHandler(handlerTag)\n      )\n      .filter((v) => v);\n  } else {\n    props.waitFor = null;\n  }\n\n  const configProps = [\n    'minPointers',\n    'maxPointers',\n    'minDist',\n    'maxDist',\n    'maxDistSq',\n    'minVelocitySq',\n    'minDistSq',\n    'minVelocity',\n    'failOffsetXStart',\n    'failOffsetYStart',\n    'failOffsetXEnd',\n    'failOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n  ] as const;\n  configProps.forEach((prop: typeof configProps[number]) => {\n    if (typeof props[prop] === 'undefined') {\n      props[prop] = Number.NaN;\n    }\n  });\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\n}\n\nfunction asArray<T>(value: T | T[]) {\n  // TODO(TS) use config.waitFor type\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js
new file mode 100644
index 0000000..af2ea46
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js
@@ -0,0 +1,54 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _GestureHandler = _interopRequireDefault(require("./GestureHandler"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+/**
+ * The base class for **Rotation** and **Pinch** gesture handlers.
+ */
+class IndiscreteGestureHandler extends _GestureHandler.default {
+  get shouldEnableGestureOnSetup() {
+    return false;
+  }
+
+  updateGestureConfig({
+    minPointers = 2,
+    maxPointers = 2,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+  isGestureEnabledForEvent({
+    minPointers,
+    maxPointers
+  }, _recognizer, {
+    maxPointers: pointerLength
+  }) {
+    if (pointerLength > maxPointers) {
+      return {
+        failed: true
+      };
+    }
+
+    const validPointerCount = pointerLength >= minPointers;
+    return {
+      success: validPointerCount
+    };
+  }
+
+}
+
+var _default = IndiscreteGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=IndiscreteGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js.map
new file mode 100644
index 0000000..e2d9306
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/IndiscreteGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["IndiscreteGestureHandler.ts"],"names":["IndiscreteGestureHandler","GestureHandler","shouldEnableGestureOnSetup","updateGestureConfig","minPointers","maxPointers","props","isGestureEnabledForEvent","_recognizer","pointerLength","failed","validPointerCount","success"],"mappings":";;;;;;;AAAA;;;;AAEA;AACA;AACA;AACA,MAAeA,wBAAf,SAAgDC,uBAAhD,CAA+D;AAC/B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,CAAC;AAAEC,IAAAA,WAAW,GAAG,CAAhB;AAAmBC,IAAAA,WAAW,GAAG,CAAjC;AAAoC,OAAGC;AAAvC,GAAD,EAAiD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAEH,IAAAA,WAAF;AAAeC,IAAAA;AAAf,GADsB,EAEtBG,WAFsB,EAGtB;AAAEH,IAAAA,WAAW,EAAEI;AAAf,GAHsB,EAItB;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;eA2BhDX,wB","sourcesContent":["import GestureHandler from './GestureHandler';\n\n/**\n * The base class for **Rotation** and **Pinch** gesture handlers.\n */\nabstract class IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\n    return super.updateGestureConfig({\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    if (pointerLength > maxPointers) {\n      return { failed: true };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount,\n    };\n  }\n}\nexport default IndiscreteGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js
new file mode 100644
index 0000000..4b4db63
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js
@@ -0,0 +1,71 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _State = require("../State");
+
+var _PressGestureHandler = _interopRequireDefault(require("./PressGestureHandler"));
+
+var _utils = require("./utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+class LongPressGestureHandler extends _PressGestureHandler.default {
+  get minDurationMs() {
+    // @ts-ignore FIXNE(TS)
+    return (0, _utils.isnan)(this.config.minDurationMs) ? 251 : this.config.minDurationMs;
+  }
+
+  get maxDist() {
+    // @ts-ignore FIXNE(TS)
+    return (0, _utils.isnan)(this.config.maxDist) ? 9 : this.config.maxDist;
+  }
+
+  updateHasCustomActivationCriteria({
+    maxDistSq
+  }) {
+    return !(0, _utils.isValidNumber)(maxDistSq);
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        shouldCancelWhenOutside: true,
+        maxDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      // threshold: this.maxDist,
+      time: this.minDurationMs
+    };
+  }
+
+  getState(type) {
+    return {
+      [_hammerjs.default.INPUT_START]: _State.State.ACTIVE,
+      [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
+      [_hammerjs.default.INPUT_END]: _State.State.END,
+      [_hammerjs.default.INPUT_CANCEL]: _State.State.FAILED
+    }[type];
+  }
+
+}
+
+var _default = LongPressGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=LongPressGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js.map
new file mode 100644
index 0000000..193998a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/LongPressGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["LongPressGestureHandler.ts"],"names":["LongPressGestureHandler","PressGestureHandler","minDurationMs","config","maxDist","updateHasCustomActivationCriteria","maxDistSq","getConfig","hasCustomActivationCriteria","shouldCancelWhenOutside","getHammerConfig","time","getState","type","Hammer","INPUT_START","State","ACTIVE","INPUT_MOVE","INPUT_END","END","INPUT_CANCEL","FAILED"],"mappings":";;;;;;;AAEA;;AAEA;;AACA;;AACA;;;;AANA;;AACA;AASA,MAAMA,uBAAN,SAAsCC,4BAAtC,CAA0D;AACvC,MAAbC,aAAa,GAAW;AAC1B;AACA,WAAO,kBAAM,KAAKC,MAAL,CAAYD,aAAlB,IAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAO,kBAAM,KAAKD,MAAL,CAAYC,OAAlB,IAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAwB;AACvD,WAAO,CAAC,0BAAcA,SAAd,CAAR;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACC,kBAAOC,WAAR,GAAsBC,aAAMC,MADvB;AAEL,OAACH,kBAAOI,UAAR,GAAqBF,aAAMC,MAFtB;AAGL,OAACH,kBAAOK,SAAR,GAAoBH,aAAMI,GAHrB;AAIL,OAACN,kBAAOO,YAAR,GAAuBL,aAAMM;AAJxB,MAKLT,IALK,CAAP;AAMD;;AA1CuD;;eA6C3Cb,uB","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport PressGestureHandler from './PressGestureHandler';\nimport { isnan, isValidNumber } from './utils';\nimport { Config } from './GestureHandler';\nimport { HammerInputNames } from './constants';\n\nclass LongPressGestureHandler extends PressGestureHandler {\n  get minDurationMs(): number {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\n    return !isValidNumber(maxDistSq);\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  getState(type: keyof typeof HammerInputNames) {\n    return {\n      [Hammer.INPUT_START]: State.ACTIVE,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.FAILED,\n    }[type];\n  }\n}\n\nexport default LongPressGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js
new file mode 100644
index 0000000..0bc023b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js
@@ -0,0 +1,62 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _DiscreteGestureHandler = _interopRequireDefault(require("./DiscreteGestureHandler"));
+
+var NodeManager = _interopRequireWildcard(require("./NodeManager"));
+
+var _PressGestureHandler = _interopRequireDefault(require("./PressGestureHandler"));
+
+var _utils = require("./utils");
+
+function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }
+
+function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+class NativeViewGestureHandler extends _PressGestureHandler.default {
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (!ev.isFinal) {
+      // if (this.ref instanceof ScrollView) {
+      if ((0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)({
+        x: ev.deltaX,
+        y: ev.deltaY
+      }), 10)) {
+        // @ts-ignore FIXME(TS) config type
+        if (this.config.disallowInterruption) {
+          const gestures = Object.values(NodeManager.getNodes()).filter(gesture => {
+            const {
+              handlerTag,
+              view,
+              isGestureRunning
+            } = gesture;
+            return (// Check if this gesture isn't self
+              handlerTag !== this.handlerTag && // Ensure the gesture needs to be cancelled
+              isGestureRunning && // ScrollView can cancel discrete gestures like taps and presses
+              gesture instanceof _DiscreteGestureHandler.default && // Ensure a view exists and is a child of the current view
+              view && // @ts-ignore FIXME(TS) view type
+              this.view.contains(view)
+            );
+          }); // Cancel all of the gestures that passed the filter
+
+          for (const gesture of gestures) {
+            // TODO: Bacon: Send some cached event.
+            gesture.forceInvalidate(ev);
+          }
+        }
+      }
+    }
+  }
+
+}
+
+var _default = NativeViewGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=NativeViewGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js.map
new file mode 100644
index 0000000..7d3db53
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/NativeViewGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NativeViewGestureHandler.ts"],"names":["NativeViewGestureHandler","PressGestureHandler","onRawEvent","ev","isFinal","x","deltaX","y","deltaY","config","disallowInterruption","gestures","Object","values","NodeManager","getNodes","filter","gesture","handlerTag","view","isGestureRunning","DiscreteGestureHandler","contains","forceInvalidate"],"mappings":";;;;;;;AAAA;;AAEA;;AACA;;AACA;;;;;;;;AAEA,MAAMA,wBAAN,SAAuCC,4BAAvC,CAA2D;AACzDC,EAAAA,UAAU,CAACC,EAAD,EAAqB;AAC7B,UAAMD,UAAN,CAAiBC,EAAjB;;AACA,QAAI,CAACA,EAAE,CAACC,OAAR,EAAiB;AACf;AACA,UAAI,gCAAoB,uBAAW;AAAEC,QAAAA,CAAC,EAAEF,EAAE,CAACG,MAAR;AAAgBC,QAAAA,CAAC,EAAEJ,EAAE,CAACK;AAAtB,OAAX,CAApB,EAAgE,EAAhE,CAAJ,EAAyE;AACvE;AACA,YAAI,KAAKC,MAAL,CAAYC,oBAAhB,EAAsC;AACpC,gBAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAcC,WAAW,CAACC,QAAZ,EAAd,EAAsCC,MAAtC,CACdC,OAAD,IAAa;AACX,kBAAM;AAAEC,cAAAA,UAAF;AAAcC,cAAAA,IAAd;AAAoBC,cAAAA;AAApB,gBAAyCH,OAA/C;AACA,mBACE;AACAC,cAAAA,UAAU,KAAK,KAAKA,UAApB,IACA;AACAE,cAAAA,gBAFA,IAGA;AACAH,cAAAA,OAAO,YAAYI,+BAJnB,IAKA;AACAF,cAAAA,IANA,IAOA;AACA,mBAAKA,IAAL,CAAUG,QAAV,CAAmBH,IAAnB;AAVF;AAYD,WAfc,CAAjB,CADoC,CAkBpC;;AACA,eAAK,MAAMF,OAAX,IAAsBN,QAAtB,EAAgC;AAC9B;AACAM,YAAAA,OAAO,CAACM,eAAR,CAAwBpB,EAAxB;AACD;AACF;AACF;AACF;AACF;;AAjCwD;;eAoC5CH,wB","sourcesContent":["import DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport * as NodeManager from './NodeManager';\nimport PressGestureHandler from './PressGestureHandler';\nimport { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\n\nclass NativeViewGestureHandler extends PressGestureHandler {\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (!ev.isFinal) {\n      // if (this.ref instanceof ScrollView) {\n      if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({ x: ev.deltaX, y: ev.deltaY }), 10)) {\n        // @ts-ignore FIXME(TS) config type\n        if (this.config.disallowInterruption) {\n          const gestures = Object.values(NodeManager.getNodes()).filter(\n            (gesture) => {\n              const { handlerTag, view, isGestureRunning } = gesture;\n              return (\n                // Check if this gesture isn't self\n                handlerTag !== this.handlerTag &&\n                // Ensure the gesture needs to be cancelled\n                isGestureRunning &&\n                // ScrollView can cancel discrete gestures like taps and presses\n                gesture instanceof DiscreteGestureHandler &&\n                // Ensure a view exists and is a child of the current view\n                view &&\n                // @ts-ignore FIXME(TS) view type\n                this.view.contains(view)\n              );\n            }\n          );\n          // Cancel all of the gestures that passed the filter\n          for (const gesture of gestures) {\n            // TODO: Bacon: Send some cached event.\n            gesture.forceInvalidate(ev);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default NativeViewGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js
new file mode 100644
index 0000000..290fe00
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js
@@ -0,0 +1,37 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getHandler = getHandler;
+exports.createGestureHandler = createGestureHandler;
+exports.dropGestureHandler = dropGestureHandler;
+exports.getNodes = getNodes;
+const gestures = {};
+
+function getHandler(tag) {
+  if (tag in gestures) return gestures[tag];
+  throw new Error("No handler for tag ".concat(tag));
+}
+
+function createGestureHandler(handlerTag, handler) {
+  if (handlerTag in gestures) {
+    throw new Error("Handler with tag ".concat(handlerTag, " already exists"));
+  }
+
+  gestures[handlerTag] = handler; // @ts-ignore no types for web handlers yet
+
+  gestures[handlerTag].handlerTag = handlerTag;
+}
+
+function dropGestureHandler(handlerTag) {
+  getHandler(handlerTag).destroy(); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+
+  delete gestures[handlerTag];
+}
+
+function getNodes() {
+  return { ...gestures
+  };
+}
+//# sourceMappingURL=NodeManager.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js.map
new file mode 100644
index 0000000..f08d87f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/NodeManager.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NodeManager.ts"],"names":["gestures","getHandler","tag","Error","createGestureHandler","handlerTag","handler","dropGestureHandler","destroy","getNodes"],"mappings":";;;;;;;;;AAGA,MAAMA,QAAgE,GAAG,EAAzE;;AAEO,SAASC,UAAT,CAAoBC,GAApB,EAAiC;AACtC,MAAIA,GAAG,IAAIF,QAAX,EAAqB,OAAOA,QAAQ,CAACE,GAAD,CAAf;AAErB,QAAM,IAAIC,KAAJ,8BAAgCD,GAAhC,EAAN;AACD;;AAEM,SAASE,oBAAT,CACLC,UADK,EAELC,OAFK,EAGL;AACA,MAAID,UAAU,IAAIL,QAAlB,EAA4B;AAC1B,UAAM,IAAIG,KAAJ,4BAA8BE,UAA9B,qBAAN;AACD;;AACDL,EAAAA,QAAQ,CAACK,UAAD,CAAR,GAAuBC,OAAvB,CAJA,CAKA;;AACAN,EAAAA,QAAQ,CAACK,UAAD,CAAR,CAAqBA,UAArB,GAAkCA,UAAlC;AACD;;AAEM,SAASE,kBAAT,CAA4BF,UAA5B,EAAgD;AACrDJ,EAAAA,UAAU,CAACI,UAAD,CAAV,CAAuBG,OAAvB,GADqD,CAErD;;AACA,SAAOR,QAAQ,CAACK,UAAD,CAAf;AACD;;AAEM,SAASI,QAAT,GAAoB;AACzB,SAAO,EAAE,GAAGT;AAAL,GAAP;AACD","sourcesContent":["import { ValueOf } from '../typeUtils';\nimport { Gestures } from '../RNGestureHandlerModule.web';\n\nconst gestures: Record<number, InstanceType<ValueOf<typeof Gestures>>> = {};\n\nexport function getHandler(tag: number) {\n  if (tag in gestures) return gestures[tag];\n\n  throw new Error(`No handler for tag ${tag}`);\n}\n\nexport function createGestureHandler(\n  handlerTag: number,\n  handler: InstanceType<ValueOf<typeof Gestures>>\n) {\n  if (handlerTag in gestures) {\n    throw new Error(`Handler with tag ${handlerTag} already exists`);\n  }\n  gestures[handlerTag] = handler;\n  // @ts-ignore no types for web handlers yet\n  gestures[handlerTag].handlerTag = handlerTag;\n}\n\nexport function dropGestureHandler(handlerTag: number) {\n  getHandler(handlerTag).destroy();\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete gestures[handlerTag];\n}\n\nexport function getNodes() {\n  return { ...gestures };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js
new file mode 100644
index 0000000..7d2f929
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js
@@ -0,0 +1,189 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _constants = require("./constants");
+
+var _DraggingGestureHandler = _interopRequireDefault(require("./DraggingGestureHandler"));
+
+var _utils = require("./utils");
+
+var _State = require("../State");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+class PanGestureHandler extends _DraggingGestureHandler.default {
+  get name() {
+    return 'pan';
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Pan;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      direction: this.getDirection()
+    };
+  }
+
+  getState(type) {
+    const nextState = super.getState(type); // Ensure that the first state sent is `BEGAN` and not `ACTIVE`
+
+    if (this.previousState === _State.State.UNDETERMINED && nextState === _State.State.ACTIVE) {
+      return _State.State.BEGAN;
+    }
+
+    return nextState;
+  }
+
+  getDirection() {
+    const config = this.getConfig();
+    const {
+      activeOffsetXStart,
+      activeOffsetXEnd,
+      activeOffsetYStart,
+      activeOffsetYEnd,
+      minDist
+    } = config;
+    let directions = [];
+    let horizontalDirections = [];
+
+    if (!(0, _utils.isnan)(minDist)) {
+      return _hammerjs.default.DIRECTION_ALL;
+    }
+
+    if (!(0, _utils.isnan)(activeOffsetXStart)) horizontalDirections.push(_hammerjs.default.DIRECTION_LEFT);
+    if (!(0, _utils.isnan)(activeOffsetXEnd)) horizontalDirections.push(_hammerjs.default.DIRECTION_RIGHT);
+    if (horizontalDirections.length === 2) horizontalDirections = [_hammerjs.default.DIRECTION_HORIZONTAL];
+    directions = directions.concat(horizontalDirections);
+    let verticalDirections = [];
+    if (!(0, _utils.isnan)(activeOffsetYStart)) verticalDirections.push(_hammerjs.default.DIRECTION_UP);
+    if (!(0, _utils.isnan)(activeOffsetYEnd)) verticalDirections.push(_hammerjs.default.DIRECTION_DOWN);
+    if (verticalDirections.length === 2) verticalDirections = [_hammerjs.default.DIRECTION_VERTICAL];
+    directions = directions.concat(verticalDirections);
+
+    if (!directions.length) {
+      return _hammerjs.default.DIRECTION_NONE;
+    }
+
+    if (directions[0] === _hammerjs.default.DIRECTION_HORIZONTAL && directions[1] === _hammerjs.default.DIRECTION_VERTICAL) {
+      return _hammerjs.default.DIRECTION_ALL;
+    }
+
+    if (horizontalDirections.length && verticalDirections.length) {
+      return _hammerjs.default.DIRECTION_ALL;
+    }
+
+    return directions[0];
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        minDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  shouldFailUnderCustomCriteria({
+    deltaX,
+    deltaY
+  }, criteria) {
+    return !(0, _utils.isnan)(criteria.failOffsetXStart) && deltaX < criteria.failOffsetXStart || !(0, _utils.isnan)(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd || !(0, _utils.isnan)(criteria.failOffsetYStart) && deltaY < criteria.failOffsetYStart || !(0, _utils.isnan)(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd;
+  }
+
+  shouldActivateUnderCustomCriteria({
+    deltaX,
+    deltaY,
+    velocity
+  }, criteria) {
+    return !(0, _utils.isnan)(criteria.activeOffsetXStart) && deltaX < criteria.activeOffsetXStart || !(0, _utils.isnan)(criteria.activeOffsetXEnd) && deltaX > criteria.activeOffsetXEnd || !(0, _utils.isnan)(criteria.activeOffsetYStart) && deltaY < criteria.activeOffsetYStart || !(0, _utils.isnan)(criteria.activeOffsetYEnd) && deltaY > criteria.activeOffsetYEnd || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)({
+      x: deltaX,
+      y: deltaY
+    }), criteria.minDistSq) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.x, criteria.minVelocityX) || (0, _utils.TEST_MIN_IF_NOT_NAN)(velocity.y, criteria.minVelocityY) || (0, _utils.TEST_MIN_IF_NOT_NAN)((0, _utils.VEC_LEN_SQ)(velocity), criteria.minVelocitySq);
+  }
+
+  shouldMultiFingerPanFail({
+    pointerLength,
+    scale,
+    deltaRotation
+  }) {
+    if (pointerLength <= 1) {
+      return false;
+    } // Test if the pan had too much pinching or rotating.
+
+
+    const deltaScale = Math.abs(scale - 1);
+    const absDeltaRotation = Math.abs(deltaRotation);
+
+    if (deltaScale > _constants.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {
+      // > If the threshold doesn't seem right.
+      // You can log the value which it failed at here:
+      return true;
+    }
+
+    if (absDeltaRotation > _constants.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {
+      // > If the threshold doesn't seem right.
+      // You can log the value which it failed at here:
+      return true;
+    }
+
+    return false;
+  }
+
+  updateHasCustomActivationCriteria(criteria) {
+    return (0, _utils.isValidNumber)(criteria.minDistSq) || (0, _utils.isValidNumber)(criteria.minVelocityX) || (0, _utils.isValidNumber)(criteria.minVelocityY) || (0, _utils.isValidNumber)(criteria.minVelocitySq) || (0, _utils.isValidNumber)(criteria.activeOffsetXStart) || (0, _utils.isValidNumber)(criteria.activeOffsetXEnd) || (0, _utils.isValidNumber)(criteria.activeOffsetYStart) || (0, _utils.isValidNumber)(criteria.activeOffsetYEnd);
+  }
+
+  isGestureEnabledForEvent(props, _recognizer, inputData) {
+    if (this.shouldFailUnderCustomCriteria(inputData, props)) {
+      return {
+        failed: true
+      };
+    }
+
+    const velocity = {
+      x: inputData.velocityX,
+      y: inputData.velocityY
+    };
+
+    if (this.hasCustomActivationCriteria && this.shouldActivateUnderCustomCriteria({
+      deltaX: inputData.deltaX,
+      deltaY: inputData.deltaY,
+      velocity
+    }, props)) {
+      if (this.shouldMultiFingerPanFail({
+        pointerLength: inputData.maxPointers,
+        scale: inputData.scale,
+        deltaRotation: inputData.deltaRotation
+      })) {
+        return {
+          failed: true
+        };
+      }
+
+      return {
+        success: true
+      };
+    }
+
+    return {
+      success: false
+    };
+  }
+
+}
+
+var _default = PanGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=PanGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js.map
new file mode 100644
index 0000000..2c21a8c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PanGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PanGestureHandler.ts"],"names":["PanGestureHandler","DraggingGestureHandler","name","NativeGestureClass","Hammer","Pan","getHammerConfig","direction","getDirection","getState","type","nextState","previousState","State","UNDETERMINED","ACTIVE","BEGAN","config","getConfig","activeOffsetXStart","activeOffsetXEnd","activeOffsetYStart","activeOffsetYEnd","minDist","directions","horizontalDirections","DIRECTION_ALL","push","DIRECTION_LEFT","DIRECTION_RIGHT","length","DIRECTION_HORIZONTAL","concat","verticalDirections","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_VERTICAL","DIRECTION_NONE","hasCustomActivationCriteria","minDistSq","shouldFailUnderCustomCriteria","deltaX","deltaY","criteria","failOffsetXStart","failOffsetXEnd","failOffsetYStart","failOffsetYEnd","shouldActivateUnderCustomCriteria","velocity","x","y","minVelocityX","minVelocityY","minVelocitySq","shouldMultiFingerPanFail","pointerLength","scale","deltaRotation","deltaScale","Math","abs","absDeltaRotation","MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD","MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD","updateHasCustomActivationCriteria","isGestureEnabledForEvent","props","_recognizer","inputData","failed","velocityX","velocityY","maxPointers","success"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport {\n  EventMap,\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\n} from './constants';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\nimport { State } from '../State';\n\nimport { Config, HammerInputExt } from './GestureHandler';\nclass PanGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'pan';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pan;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      direction: this.getDirection(),\n    };\n  }\n\n  getState(type: keyof typeof EventMap) {\n    const nextState = super.getState(type);\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\n    if (\n      this.previousState === State.UNDETERMINED &&\n      nextState === State.ACTIVE\n    ) {\n      return State.BEGAN;\n    }\n    return nextState;\n  }\n\n  getDirection() {\n    const config = this.getConfig();\n    const {\n      activeOffsetXStart,\n      activeOffsetXEnd,\n      activeOffsetYStart,\n      activeOffsetYEnd,\n      minDist,\n    } = config;\n    let directions: number[] = [];\n    let horizontalDirections = [];\n\n    if (!isnan(minDist)) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    if (!isnan(activeOffsetXStart))\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\n    if (!isnan(activeOffsetXEnd))\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\n    if (horizontalDirections.length === 2)\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\n\n    directions = directions.concat(horizontalDirections);\n    let verticalDirections = [];\n\n    if (!isnan(activeOffsetYStart))\n      verticalDirections.push(Hammer.DIRECTION_UP);\n    if (!isnan(activeOffsetYEnd))\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\n\n    if (verticalDirections.length === 2)\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\n\n    directions = directions.concat(verticalDirections);\n\n    if (!directions.length) {\n      return Hammer.DIRECTION_NONE;\n    }\n    if (\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\n      directions[1] === Hammer.DIRECTION_VERTICAL\n    ) {\n      return Hammer.DIRECTION_ALL;\n    }\n    if (horizontalDirections.length && verticalDirections.length) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    return directions[0];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        minDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { deltaX, deltaY }: HammerInputExt,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.failOffsetXStart) &&\n        deltaX < criteria.failOffsetXStart) ||\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\n      (!isnan(criteria.failOffsetYStart) &&\n        deltaY < criteria.failOffsetYStart) ||\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\n    );\n  }\n\n  shouldActivateUnderCustomCriteria(\n    { deltaX, deltaY, velocity }: any,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.activeOffsetXStart) &&\n        deltaX < criteria.activeOffsetXStart) ||\n      (!isnan(criteria.activeOffsetXEnd) &&\n        deltaX > criteria.activeOffsetXEnd) ||\n      (!isnan(criteria.activeOffsetYStart) &&\n        deltaY < criteria.activeOffsetYStart) ||\n      (!isnan(criteria.activeOffsetYEnd) &&\n        deltaY > criteria.activeOffsetYEnd) ||\n      TEST_MIN_IF_NOT_NAN(\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\n        criteria.minDistSq\n      ) ||\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\n    );\n  }\n\n  shouldMultiFingerPanFail({\n    pointerLength,\n    scale,\n    deltaRotation,\n  }: {\n    deltaRotation: number;\n    pointerLength: number;\n    scale: number;\n  }) {\n    if (pointerLength <= 1) {\n      return false;\n    }\n\n    // Test if the pan had too much pinching or rotating.\n    const deltaScale = Math.abs(scale - 1);\n    const absDeltaRotation = Math.abs(deltaRotation);\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHasCustomActivationCriteria(\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\n  ) {\n    return (\n      isValidNumber(criteria.minDistSq) ||\n      isValidNumber(criteria.minVelocityX) ||\n      isValidNumber(criteria.minVelocityY) ||\n      isValidNumber(criteria.minVelocitySq) ||\n      isValidNumber(criteria.activeOffsetXStart) ||\n      isValidNumber(criteria.activeOffsetXEnd) ||\n      isValidNumber(criteria.activeOffsetYStart) ||\n      isValidNumber(criteria.activeOffsetYEnd)\n    );\n  }\n\n  isGestureEnabledForEvent(\n    props: any,\n    _recognizer: any,\n    inputData: HammerInputExt & { deltaRotation: number }\n  ) {\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\n      return { failed: true };\n    }\n\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\n    if (\n      this.hasCustomActivationCriteria &&\n      this.shouldActivateUnderCustomCriteria(\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\n        props\n      )\n    ) {\n      if (\n        this.shouldMultiFingerPanFail({\n          pointerLength: inputData.maxPointers,\n          scale: inputData.scale,\n          deltaRotation: inputData.deltaRotation,\n        })\n      ) {\n        return {\n          failed: true,\n        };\n      }\n      return { success: true };\n    }\n    return { success: false };\n  }\n}\n\nexport default PanGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js
new file mode 100644
index 0000000..915f9bd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js
@@ -0,0 +1,40 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _IndiscreteGestureHandler = _interopRequireDefault(require("./IndiscreteGestureHandler"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+class PinchGestureHandler extends _IndiscreteGestureHandler.default {
+  get name() {
+    return 'pinch';
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Pinch;
+  }
+
+  transformNativeEvent({
+    scale,
+    velocity,
+    center
+  }) {
+    return {
+      focalX: center.x,
+      focalY: center.y,
+      velocity,
+      scale
+    };
+  }
+
+}
+
+var _default = PinchGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=PinchGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js.map
new file mode 100644
index 0000000..d4e5c35
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PinchGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PinchGestureHandler.ts"],"names":["PinchGestureHandler","IndiscreteGestureHandler","name","NativeGestureClass","Hammer","Pinch","transformNativeEvent","scale","velocity","center","focalX","x","focalY","y"],"mappings":";;;;;;;AAAA;;AAGA;;;;AAEA,MAAMA,mBAAN,SAAkCC,iCAAlC,CAA2D;AACjD,MAAJC,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA8C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;eAmB5CP,mB","sourcesContent":["import Hammer from '@egjs/hammerjs';\nimport { HammerInputExt } from './GestureHandler';\n\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass PinchGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'pinch';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pinch;\n  }\n\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\n    return {\n      focalX: center.x,\n      focalY: center.y,\n      velocity,\n      scale,\n    };\n  }\n}\n\nexport default PinchGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js
new file mode 100644
index 0000000..28a1007
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js
@@ -0,0 +1,188 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _State = require("../State");
+
+var _constants = require("./constants");
+
+var _DiscreteGestureHandler = _interopRequireDefault(require("./DiscreteGestureHandler"));
+
+var _utils = require("./utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+class PressGestureHandler extends _DiscreteGestureHandler.default {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "visualFeedbackTimer", void 0);
+
+    _defineProperty(this, "initialEvent", null);
+
+    _defineProperty(this, "shouldDelayTouches", true);
+  }
+
+  get name() {
+    return 'press';
+  }
+
+  get minDurationMs() {
+    // @ts-ignore FIXME(TS)
+    return (0, _utils.isnan)(this.config.minDurationMs) ? 5 : this.config.minDurationMs;
+  }
+
+  get maxDist() {
+    return (0, _utils.isnan)(this.config.maxDist) ? 9 : this.config.maxDist;
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Press;
+  }
+
+  simulateCancelEvent(inputData) {
+    // Long press never starts so we can't rely on the running event boolean.
+    this.hasGestureFailed = true;
+    this.cancelEvent(inputData);
+  }
+
+  updateHasCustomActivationCriteria({
+    shouldCancelWhenOutside,
+    maxDistSq
+  }) {
+    return shouldCancelWhenOutside || !(0, _utils.isValidNumber)(maxDistSq);
+  }
+
+  getState(type) {
+    return {
+      [_hammerjs.default.INPUT_START]: _State.State.BEGAN,
+      [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
+      [_hammerjs.default.INPUT_END]: _State.State.END,
+      [_hammerjs.default.INPUT_CANCEL]: _State.State.CANCELLED
+    }[type];
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        shouldCancelWhenOutside: true,
+        maxDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      // threshold: this.maxDist,
+      time: this.minDurationMs
+    };
+  }
+
+  onGestureActivated(ev) {
+    this.onGestureStart(ev);
+  }
+
+  shouldDelayTouchForEvent({
+    pointerType
+  }) {
+    // Don't disable event for mouse input
+    return this.shouldDelayTouches && pointerType === 'touch';
+  }
+
+  onGestureStart(ev) {
+    this.isGestureRunning = true;
+    clearTimeout(this.visualFeedbackTimer);
+    this.initialEvent = ev;
+    this.visualFeedbackTimer = (0, _utils.fireAfterInterval)(() => {
+      this.sendGestureStartedEvent(this.initialEvent);
+      this.initialEvent = null;
+    }, this.shouldDelayTouchForEvent(ev) && _constants.CONTENT_TOUCHES_DELAY);
+  }
+
+  sendGestureStartedEvent(ev) {
+    clearTimeout(this.visualFeedbackTimer);
+    this.visualFeedbackTimer = null;
+    this.sendEvent({ ...ev,
+      eventType: _hammerjs.default.INPUT_MOVE,
+      isFirst: true
+    });
+  }
+
+  forceInvalidate(event) {
+    super.forceInvalidate(event);
+    clearTimeout(this.visualFeedbackTimer);
+    this.visualFeedbackTimer = null;
+    this.initialEvent = null;
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (this.isGestureRunning) {
+      if (ev.isFinal) {
+        let timeout;
+
+        if (this.visualFeedbackTimer) {
+          // Aesthetic timing for a quick tap.
+          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`
+          // Now we must send the initial activation event and wait a set amount of time before firing the end event.
+          timeout = _constants.CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
+          this.sendGestureStartedEvent(this.initialEvent);
+          this.initialEvent = null;
+        }
+
+        (0, _utils.fireAfterInterval)(() => {
+          this.sendEvent({ ...ev,
+            eventType: _hammerjs.default.INPUT_END,
+            isFinal: true
+          }); // @ts-ignore -- this should explicitly support undefined
+
+          this.onGestureEnded();
+        }, timeout);
+      } else {
+        this.sendEvent({ ...ev,
+          eventType: _hammerjs.default.INPUT_MOVE,
+          isFinal: false
+        });
+      }
+    }
+  }
+
+  updateGestureConfig({
+    shouldActivateOnStart = false,
+    disallowInterruption = false,
+    shouldCancelWhenOutside = true,
+    minDurationMs = Number.NaN,
+    maxDist = Number.NaN,
+    minPointers = 1,
+    maxPointers = 1,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      shouldActivateOnStart,
+      disallowInterruption,
+      shouldCancelWhenOutside,
+      minDurationMs,
+      maxDist,
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+}
+
+var _default = PressGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=PressGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js.map
new file mode 100644
index 0000000..0ff9f87
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/PressGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PressGestureHandler.ts"],"names":["PressGestureHandler","DiscreteGestureHandler","name","minDurationMs","config","maxDist","NativeGestureClass","Hammer","Press","simulateCancelEvent","inputData","hasGestureFailed","cancelEvent","updateHasCustomActivationCriteria","shouldCancelWhenOutside","maxDistSq","getState","type","INPUT_START","State","BEGAN","INPUT_MOVE","ACTIVE","INPUT_END","END","INPUT_CANCEL","CANCELLED","getConfig","hasCustomActivationCriteria","getHammerConfig","time","onGestureActivated","ev","onGestureStart","shouldDelayTouchForEvent","pointerType","shouldDelayTouches","isGestureRunning","clearTimeout","visualFeedbackTimer","initialEvent","sendGestureStartedEvent","CONTENT_TOUCHES_DELAY","sendEvent","eventType","isFirst","forceInvalidate","event","onRawEvent","isFinal","timeout","CONTENT_TOUCHES_QUICK_TAP_END_DELAY","onGestureEnded","updateGestureConfig","shouldActivateOnStart","disallowInterruption","Number","NaN","minPointers","maxPointers","props"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport {\n  CONTENT_TOUCHES_DELAY,\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\n  HammerInputNames,\n} from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { Config, HammerInputExt } from './GestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  private visualFeedbackTimer: any;\n  private initialEvent: HammerInputExt | null = null;\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    // @ts-ignore FIXME(TS)\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  shouldDelayTouches = true;\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({\n    shouldCancelWhenOutside,\n    maxDistSq,\n  }: Config & { shouldCancelWhenOutside: boolean }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type: keyof typeof HammerInputNames): State {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\n    }[type];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev: HammerInputExt) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev: HammerInputExt) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({\n      ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true,\n    });\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.isGestureRunning) {\n      if (ev.isFinal) {\n        let timeout;\n        if (this.visualFeedbackTimer) {\n          // Aesthetic timing for a quick tap.\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n          this.initialEvent = null;\n        }\n        fireAfterInterval(() => {\n          this.sendEvent({\n            ...ev,\n            eventType: Hammer.INPUT_END,\n            isFinal: true,\n          });\n          // @ts-ignore -- this should explicitly support undefined\n          this.onGestureEnded();\n        }, timeout);\n      } else {\n        this.sendEvent({\n          ...ev,\n          eventType: Hammer.INPUT_MOVE,\n          isFinal: false,\n        });\n      }\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n}\nexport default PressGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js
new file mode 100644
index 0000000..4d2da4d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js
@@ -0,0 +1,44 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _constants = require("./constants");
+
+var _IndiscreteGestureHandler = _interopRequireDefault(require("./IndiscreteGestureHandler"));
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+class RotationGestureHandler extends _IndiscreteGestureHandler.default {
+  get name() {
+    return 'rotate';
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Rotate;
+  }
+
+  transformNativeEvent({
+    rotation,
+    velocity,
+    center
+  }) {
+    var _this$initialRotation;
+
+    return {
+      rotation: (rotation - ((_this$initialRotation = this.initialRotation) !== null && _this$initialRotation !== void 0 ? _this$initialRotation : 0)) * _constants.DEG_RAD,
+      anchorX: center.x,
+      anchorY: center.y,
+      velocity
+    };
+  }
+
+}
+
+var _default = RotationGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=RotationGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js.map
new file mode 100644
index 0000000..3b08030
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/RotationGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RotationGestureHandler.ts"],"names":["RotationGestureHandler","IndiscreteGestureHandler","name","NativeGestureClass","Hammer","Rotate","transformNativeEvent","rotation","velocity","center","initialRotation","DEG_RAD","anchorX","x","anchorY","y"],"mappings":";;;;;;;AAAA;;AAEA;;AAEA;;;;AAEA,MAAMA,sBAAN,SAAqCC,iCAArC,CAA8D;AACpD,MAAJC,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOC,kBAAOC,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,QAAZ;AAAsBC,IAAAA;AAAtB,GAAD,EAAiD;AAAA;;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CC,kBADhD;AAELC,MAAAA,OAAO,EAAEH,MAAM,CAACI,CAFX;AAGLC,MAAAA,OAAO,EAAEL,MAAM,CAACM,CAHX;AAILP,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;eAkB/CR,sB","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { DEG_RAD } from './constants';\nimport { HammerInputExt } from './GestureHandler';\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass RotationGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'rotate';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Rotate;\n  }\n\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\n    return {\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\n      anchorX: center.x,\n      anchorY: center.y,\n      velocity,\n    };\n  }\n}\nexport default RotationGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js
new file mode 100644
index 0000000..d73a201
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js
@@ -0,0 +1,192 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _DiscreteGestureHandler = _interopRequireDefault(require("./DiscreteGestureHandler"));
+
+var _utils = require("./utils");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+class TapGestureHandler extends _DiscreteGestureHandler.default {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "_shouldFireEndEvent", null);
+
+    _defineProperty(this, "_timer", void 0);
+
+    _defineProperty(this, "_multiTapTimer", void 0);
+
+    _defineProperty(this, "onSuccessfulTap", ev => {
+      if (this._getPendingGestures().length) {
+        this._shouldFireEndEvent = ev;
+        return;
+      }
+
+      if (ev.eventType === _hammerjs.default.INPUT_END) {
+        this.sendEvent({ ...ev,
+          eventType: _hammerjs.default.INPUT_MOVE
+        });
+      } // When handler gets activated it will turn into State.END immediately.
+
+
+      this.sendEvent({ ...ev,
+        isFinal: true
+      });
+      this.onGestureEnded(ev);
+    });
+  }
+
+  // TODO unused?
+  get name() {
+    return 'tap';
+  }
+
+  get NativeGestureClass() {
+    return _hammerjs.default.Tap;
+  }
+
+  get maxDelayMs() {
+    // @ts-ignore TODO(TS) trace down config
+    return (0, _utils.isnan)(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;
+  }
+
+  simulateCancelEvent(inputData) {
+    if (this.isGestureRunning) {
+      this.cancelEvent(inputData);
+    }
+  }
+
+  onGestureActivated(ev) {
+    if (this.isGestureRunning) {
+      this.onSuccessfulTap(ev);
+    }
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev); // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.
+
+    if (!this.hasGestureFailed && !this.isGestureRunning && // Prevent multi-pointer events from misfiring.
+    !ev.isFinal) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
+
+      if (gesture.options.enable(gesture, ev)) {
+        clearTimeout(this._multiTapTimer);
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+
+    if (ev.isFinal && ev.maxPointers > 1) {
+      setTimeout(() => {
+        // Handle case where one finger presses slightly
+        // after the first finger on a multi-tap event
+        if (this.isGestureRunning) {
+          this.cancelEvent(ev);
+        }
+      });
+    }
+
+    if (this.hasGestureFailed) {
+      return;
+    } // Hammer doesn't send a `cancel` event for taps.
+    // Manually fail the event.
+
+
+    if (ev.isFinal) {
+      // Handle case where one finger presses slightly
+      // after the first finger on a multi-tap event
+      if (ev.maxPointers > 1) {
+        setTimeout(() => {
+          if (this.isGestureRunning) {
+            this.cancelEvent(ev);
+          }
+        });
+      } // Clear last timer
+
+
+      clearTimeout(this._timer); // Create time out for multi-taps.
+
+      this._timer = setTimeout(() => {
+        this.hasGestureFailed = true;
+        this.cancelEvent(ev);
+      }, this.maxDelayMs);
+    } else if (!this.hasGestureFailed && !this.isGestureRunning) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
+
+      if (gesture.options.enable(gesture, ev)) {
+        clearTimeout(this._multiTapTimer);
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      event: this.name,
+      // @ts-ignore TODO(TS) trace down config
+      taps: (0, _utils.isnan)(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,
+      interval: this.maxDelayMs,
+      time: // @ts-ignore TODO(TS) trace down config
+      (0, _utils.isnan)(this.config.maxDurationMs) || this.config.maxDurationMs == null ? 250 : // @ts-ignore TODO(TS) trace down config
+      this.config.maxDurationMs
+    };
+  }
+
+  updateGestureConfig({
+    shouldCancelWhenOutside = true,
+    maxDeltaX = Number.NaN,
+    maxDeltaY = Number.NaN,
+    numberOfTaps = 1,
+    minDurationMs = 525,
+    maxDelayMs = Number.NaN,
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?
+    maxDurationMs = Number.NaN,
+    maxDist = 2,
+    minPointers = 1,
+    maxPointers = 1,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      shouldCancelWhenOutside,
+      numberOfTaps,
+      maxDeltaX,
+      maxDeltaY,
+      minDurationMs,
+      maxDelayMs,
+      maxDist,
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+  onGestureEnded(...props) {
+    clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works
+
+    super.onGestureEnded(...props);
+  }
+
+  onWaitingEnded(_gesture) {
+    if (this._shouldFireEndEvent) {
+      this.onSuccessfulTap(this._shouldFireEndEvent);
+      this._shouldFireEndEvent = null;
+    }
+  }
+
+}
+
+var _default = TapGestureHandler;
+exports.default = _default;
+//# sourceMappingURL=TapGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js.map
new file mode 100644
index 0000000..9a87f34
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/TapGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TapGestureHandler.ts"],"names":["TapGestureHandler","DiscreteGestureHandler","ev","_getPendingGestures","length","_shouldFireEndEvent","eventType","Hammer","INPUT_END","sendEvent","INPUT_MOVE","isFinal","onGestureEnded","name","NativeGestureClass","Tap","maxDelayMs","config","simulateCancelEvent","inputData","isGestureRunning","cancelEvent","onGestureActivated","onSuccessfulTap","onRawEvent","hasGestureFailed","gesture","hammer","get","options","enable","clearTimeout","_multiTapTimer","onStart","maxPointers","setTimeout","_timer","getHammerConfig","event","taps","numberOfTaps","interval","time","maxDurationMs","updateGestureConfig","shouldCancelWhenOutside","maxDeltaX","Number","NaN","maxDeltaY","minDurationMs","maxDist","minPointers","props","onWaitingEnded","_gesture"],"mappings":";;;;;;;AAAA;;AAEA;;AAEA;;;;;;AAEA,MAAMA,iBAAN,SAAgCC,+BAAhC,CAAuD;AAAA;AAAA;;AAAA,iDACA,IADA;;AAAA;;AAAA;;AAAA,6CA6BlCC,EAAD,IAAwB;AACxC,UAAI,KAAKC,mBAAL,GAA2BC,MAA/B,EAAuC;AACrC,aAAKC,mBAAL,GAA2BH,EAA3B;AACA;AACD;;AACD,UAAIA,EAAE,CAACI,SAAH,KAAiBC,kBAAOC,SAA5B,EAAuC;AACrC,aAAKC,SAAL,CAAe,EAAE,GAAGP,EAAL;AAASI,UAAAA,SAAS,EAAEC,kBAAOG;AAA3B,SAAf;AACD,OAPuC,CAQxC;;;AACA,WAAKD,SAAL,CAAe,EAAE,GAAGP,EAAL;AAASS,QAAAA,OAAO,EAAE;AAAlB,OAAf;AACA,WAAKC,cAAL,CAAoBV,EAApB;AACD,KAxCoD;AAAA;;AAGxB;AACrB,MAAJW,IAAI,GAAG;AACT,WAAO,KAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOP,kBAAOQ,GAAd;AACD;;AAEa,MAAVC,UAAU,GAAG;AACf;AACA,WAAO,kBAAM,KAAKC,MAAL,CAAYD,UAAlB,IAAgC,GAAhC,GAAsC,KAAKC,MAAL,CAAYD,UAAzD;AACD;;AAEDE,EAAAA,mBAAmB,CAACC,SAAD,EAA4B;AAC7C,QAAI,KAAKC,gBAAT,EAA2B;AACzB,WAAKC,WAAL,CAAiBF,SAAjB;AACD;AACF;;AAEDG,EAAAA,kBAAkB,CAACpB,EAAD,EAAqB;AACrC,QAAI,KAAKkB,gBAAT,EAA2B;AACzB,WAAKG,eAAL,CAAqBrB,EAArB;AACD;AACF;;AAeDsB,EAAAA,UAAU,CAACtB,EAAD,EAAkB;AAC1B,UAAMsB,UAAN,CAAiBtB,EAAjB,EAD0B,CAG1B;;AACA,QACE,CAAC,KAAKuB,gBAAN,IACA,CAAC,KAAKL,gBADN,IAEA;AACA,KAAClB,EAAE,CAACS,OAJN,EAKE;AACA;AACA,YAAMe,OAAO,GAAG,KAAKC,MAAL,CAAaC,GAAb,CAAiB,KAAKf,IAAtB,CAAhB,CAFA,CAGA;;AACA,UAAIa,OAAO,CAACG,OAAR,CAAgBC,MAAhB,CAAuBJ,OAAvB,EAAgCxB,EAAhC,CAAJ,EAAyC;AACvC6B,QAAAA,YAAY,CAAC,KAAKC,cAAN,CAAZ;AAEA,aAAKC,OAAL,CAAa/B,EAAb;AACA,aAAKO,SAAL,CAAeP,EAAf;AACD;AACF;;AACD,QAAIA,EAAE,CAACS,OAAH,IAAcT,EAAE,CAACgC,WAAH,GAAiB,CAAnC,EAAsC;AACpCC,MAAAA,UAAU,CAAC,MAAM;AACf;AACA;AACA,YAAI,KAAKf,gBAAT,EAA2B;AACzB,eAAKC,WAAL,CAAiBnB,EAAjB;AACD;AACF,OANS,CAAV;AAOD;;AAED,QAAI,KAAKuB,gBAAT,EAA2B;AACzB;AACD,KAhCyB,CAiC1B;AACA;;;AACA,QAAIvB,EAAE,CAACS,OAAP,EAAgB;AACd;AACA;AACA,UAAIT,EAAE,CAACgC,WAAH,GAAiB,CAArB,EAAwB;AACtBC,QAAAA,UAAU,CAAC,MAAM;AACf,cAAI,KAAKf,gBAAT,EAA2B;AACzB,iBAAKC,WAAL,CAAiBnB,EAAjB;AACD;AACF,SAJS,CAAV;AAKD,OATa,CAWd;;;AACA6B,MAAAA,YAAY,CAAC,KAAKK,MAAN,CAAZ,CAZc,CAad;;AACA,WAAKA,MAAL,GAAcD,UAAU,CAAC,MAAM;AAC7B,aAAKV,gBAAL,GAAwB,IAAxB;AACA,aAAKJ,WAAL,CAAiBnB,EAAjB;AACD,OAHuB,EAGrB,KAAKc,UAHgB,CAAxB;AAID,KAlBD,MAkBO,IAAI,CAAC,KAAKS,gBAAN,IAA0B,CAAC,KAAKL,gBAApC,EAAsD;AAC3D;AACA,YAAMM,OAAO,GAAG,KAAKC,MAAL,CAAaC,GAAb,CAAiB,KAAKf,IAAtB,CAAhB,CAF2D,CAG3D;;AACA,UAAIa,OAAO,CAACG,OAAR,CAAgBC,MAAhB,CAAuBJ,OAAvB,EAAgCxB,EAAhC,CAAJ,EAAyC;AACvC6B,QAAAA,YAAY,CAAC,KAAKC,cAAN,CAAZ;AAEA,aAAKC,OAAL,CAAa/B,EAAb;AACA,aAAKO,SAAL,CAAeP,EAAf;AACD;AACF;AACF;;AAEDmC,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAELC,MAAAA,KAAK,EAAE,KAAKzB,IAFP;AAGL;AACA0B,MAAAA,IAAI,EAAE,kBAAM,KAAKtB,MAAL,CAAYuB,YAAlB,IAAkC,CAAlC,GAAsC,KAAKvB,MAAL,CAAYuB,YAJnD;AAKLC,MAAAA,QAAQ,EAAE,KAAKzB,UALV;AAML0B,MAAAA,IAAI,EACF;AACA,wBAAM,KAAKzB,MAAL,CAAY0B,aAAlB,KAAoC,KAAK1B,MAAL,CAAY0B,aAAZ,IAA6B,IAAjE,GACI,GADJ,GAEI;AACA,WAAK1B,MAAL,CAAY0B;AAXb,KAAP;AAaD;;AAEDC,EAAAA,mBAAmB,CAAC;AAClBC,IAAAA,uBAAuB,GAAG,IADR;AAElBC,IAAAA,SAAS,GAAGC,MAAM,CAACC,GAFD;AAGlBC,IAAAA,SAAS,GAAGF,MAAM,CAACC,GAHD;AAIlBR,IAAAA,YAAY,GAAG,CAJG;AAKlBU,IAAAA,aAAa,GAAG,GALE;AAMlBlC,IAAAA,UAAU,GAAG+B,MAAM,CAACC,GANF;AAOlB;AACAL,IAAAA,aAAa,GAAGI,MAAM,CAACC,GARL;AASlBG,IAAAA,OAAO,GAAG,CATQ;AAUlBC,IAAAA,WAAW,GAAG,CAVI;AAWlBlB,IAAAA,WAAW,GAAG,CAXI;AAYlB,OAAGmB;AAZe,GAAD,EAahB;AACD,WAAO,MAAMT,mBAAN,CAA0B;AAC/BC,MAAAA,uBAD+B;AAE/BL,MAAAA,YAF+B;AAG/BM,MAAAA,SAH+B;AAI/BG,MAAAA,SAJ+B;AAK/BC,MAAAA,aAL+B;AAM/BlC,MAAAA,UAN+B;AAO/BmC,MAAAA,OAP+B;AAQ/BC,MAAAA,WAR+B;AAS/BlB,MAAAA,WAT+B;AAU/B,SAAGmB;AAV4B,KAA1B,CAAP;AAYD;;AAEDzC,EAAAA,cAAc,CAAC,GAAGyC,KAAJ,EAAgB;AAC5BtB,IAAAA,YAAY,CAAC,KAAKK,MAAN,CAAZ,CAD4B,CAE5B;;AACA,UAAMxB,cAAN,CAAqB,GAAGyC,KAAxB;AACD;;AAEDC,EAAAA,cAAc,CAACC,QAAD,EAAgB;AAC5B,QAAI,KAAKlD,mBAAT,EAA8B;AAC5B,WAAKkB,eAAL,CAAqB,KAAKlB,mBAA1B;AACA,WAAKA,mBAAL,GAA2B,IAA3B;AACD;AACF;;AAnKoD;;eAqKxCL,iB","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  private _shouldFireEndEvent: HammerInputExt | null = null;\n  private _timer: any;\n  private _multiTapTimer: any; // TODO unused?\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    // @ts-ignore TODO(TS) trace down config\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = (ev: HammerInputExt) => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev: HammerInput) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      // @ts-ignore TODO(TS) trace down config\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        // @ts-ignore TODO(TS) trace down config\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : // @ts-ignore TODO(TS) trace down config\n            this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props: any) {\n    clearTimeout(this._timer);\n    // @ts-ignore TODO(TS) check how onGestureEnded works\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(_gesture: any) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js
new file mode 100644
index 0000000..f9ee37a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js
@@ -0,0 +1,64 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.HammerDirectionNames = exports.HammerInputNames = exports.DirectionMap = exports.Direction = exports.EventMap = exports.DEG_RAD = exports.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = exports.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = exports.CONTENT_TOUCHES_QUICK_TAP_END_DELAY = exports.CONTENT_TOUCHES_DELAY = void 0;
+
+var _hammerjs = _interopRequireDefault(require("@egjs/hammerjs"));
+
+var _State = require("../State");
+
+function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
+
+const CONTENT_TOUCHES_DELAY = 240;
+exports.CONTENT_TOUCHES_DELAY = CONTENT_TOUCHES_DELAY;
+const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;
+exports.CONTENT_TOUCHES_QUICK_TAP_END_DELAY = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
+const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;
+exports.MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD;
+const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;
+exports.MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD;
+const DEG_RAD = Math.PI / 180; // Map Hammer values to RNGH
+
+exports.DEG_RAD = DEG_RAD;
+const EventMap = {
+  [_hammerjs.default.INPUT_START]: _State.State.BEGAN,
+  [_hammerjs.default.INPUT_MOVE]: _State.State.ACTIVE,
+  [_hammerjs.default.INPUT_END]: _State.State.END,
+  [_hammerjs.default.INPUT_CANCEL]: _State.State.FAILED
+};
+exports.EventMap = EventMap;
+const Direction = {
+  RIGHT: 1,
+  LEFT: 2,
+  UP: 4,
+  DOWN: 8
+};
+exports.Direction = Direction;
+const DirectionMap = {
+  [_hammerjs.default.DIRECTION_RIGHT]: Direction.RIGHT,
+  [_hammerjs.default.DIRECTION_LEFT]: Direction.LEFT,
+  [_hammerjs.default.DIRECTION_UP]: Direction.UP,
+  [_hammerjs.default.DIRECTION_DOWN]: Direction.DOWN
+};
+exports.DirectionMap = DirectionMap;
+const HammerInputNames = {
+  [_hammerjs.default.INPUT_START]: 'START',
+  [_hammerjs.default.INPUT_MOVE]: 'MOVE',
+  [_hammerjs.default.INPUT_END]: 'END',
+  [_hammerjs.default.INPUT_CANCEL]: 'CANCEL'
+};
+exports.HammerInputNames = HammerInputNames;
+const HammerDirectionNames = {
+  [_hammerjs.default.DIRECTION_HORIZONTAL]: 'HORIZONTAL',
+  [_hammerjs.default.DIRECTION_UP]: 'UP',
+  [_hammerjs.default.DIRECTION_DOWN]: 'DOWN',
+  [_hammerjs.default.DIRECTION_VERTICAL]: 'VERTICAL',
+  [_hammerjs.default.DIRECTION_NONE]: 'NONE',
+  [_hammerjs.default.DIRECTION_ALL]: 'ALL',
+  [_hammerjs.default.DIRECTION_RIGHT]: 'RIGHT',
+  [_hammerjs.default.DIRECTION_LEFT]: 'LEFT'
+};
+exports.HammerDirectionNames = HammerDirectionNames;
+//# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js.map
new file mode 100644
index 0000000..b2bd4f2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/constants.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["constants.ts"],"names":["CONTENT_TOUCHES_DELAY","CONTENT_TOUCHES_QUICK_TAP_END_DELAY","MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD","MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD","DEG_RAD","Math","PI","EventMap","Hammer","INPUT_START","State","BEGAN","INPUT_MOVE","ACTIVE","INPUT_END","END","INPUT_CANCEL","FAILED","Direction","RIGHT","LEFT","UP","DOWN","DirectionMap","DIRECTION_RIGHT","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_DOWN","HammerInputNames","HammerDirectionNames","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_NONE","DIRECTION_ALL"],"mappings":";;;;;;;AAAA;;AAEA;;;;AAEO,MAAMA,qBAAqB,GAAG,GAA9B;;AACA,MAAMC,mCAAmC,GAAG,EAA5C;;AACA,MAAMC,oCAAoC,GAAG,GAA7C;;AACA,MAAMC,uCAAuC,GAAG,CAAhD;;AACA,MAAMC,OAAO,GAAGC,IAAI,CAACC,EAAL,GAAU,GAA1B,C,CAEP;;;AACO,MAAMC,QAAQ,GAAG;AACtB,GAACC,kBAAOC,WAAR,GAAsBC,aAAMC,KADN;AAEtB,GAACH,kBAAOI,UAAR,GAAqBF,aAAMG,MAFL;AAGtB,GAACL,kBAAOM,SAAR,GAAoBJ,aAAMK,GAHJ;AAItB,GAACP,kBAAOQ,YAAR,GAAuBN,aAAMO;AAJP,CAAjB;;AAOA,MAAMC,SAAS,GAAG;AACvBC,EAAAA,KAAK,EAAE,CADgB;AAEvBC,EAAAA,IAAI,EAAE,CAFiB;AAGvBC,EAAAA,EAAE,EAAE,CAHmB;AAIvBC,EAAAA,IAAI,EAAE;AAJiB,CAAlB;;AAOA,MAAMC,YAAY,GAAG;AAC1B,GAACf,kBAAOgB,eAAR,GAA0BN,SAAS,CAACC,KADV;AAE1B,GAACX,kBAAOiB,cAAR,GAAyBP,SAAS,CAACE,IAFT;AAG1B,GAACZ,kBAAOkB,YAAR,GAAuBR,SAAS,CAACG,EAHP;AAI1B,GAACb,kBAAOmB,cAAR,GAAyBT,SAAS,CAACI;AAJT,CAArB;;AAOA,MAAMM,gBAAgB,GAAG;AAC9B,GAACpB,kBAAOC,WAAR,GAAsB,OADQ;AAE9B,GAACD,kBAAOI,UAAR,GAAqB,MAFS;AAG9B,GAACJ,kBAAOM,SAAR,GAAoB,KAHU;AAI9B,GAACN,kBAAOQ,YAAR,GAAuB;AAJO,CAAzB;;AAMA,MAAMa,oBAAoB,GAAG;AAClC,GAACrB,kBAAOsB,oBAAR,GAA+B,YADG;AAElC,GAACtB,kBAAOkB,YAAR,GAAuB,IAFW;AAGlC,GAAClB,kBAAOmB,cAAR,GAAyB,MAHS;AAIlC,GAACnB,kBAAOuB,kBAAR,GAA6B,UAJK;AAKlC,GAACvB,kBAAOwB,cAAR,GAAyB,MALS;AAMlC,GAACxB,kBAAOyB,aAAR,GAAwB,KANU;AAOlC,GAACzB,kBAAOgB,eAAR,GAA0B,OAPQ;AAQlC,GAAChB,kBAAOiB,cAAR,GAAyB;AARS,CAA7B","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\n\nexport const CONTENT_TOUCHES_DELAY = 240;\nexport const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;\nexport const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;\nexport const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;\nexport const DEG_RAD = Math.PI / 180;\n\n// Map Hammer values to RNGH\nexport const EventMap = {\n  [Hammer.INPUT_START]: State.BEGAN,\n  [Hammer.INPUT_MOVE]: State.ACTIVE,\n  [Hammer.INPUT_END]: State.END,\n  [Hammer.INPUT_CANCEL]: State.FAILED,\n} as const;\n\nexport const Direction = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n};\n\nexport const DirectionMap = {\n  [Hammer.DIRECTION_RIGHT]: Direction.RIGHT,\n  [Hammer.DIRECTION_LEFT]: Direction.LEFT,\n  [Hammer.DIRECTION_UP]: Direction.UP,\n  [Hammer.DIRECTION_DOWN]: Direction.DOWN,\n};\n\nexport const HammerInputNames = {\n  [Hammer.INPUT_START]: 'START',\n  [Hammer.INPUT_MOVE]: 'MOVE',\n  [Hammer.INPUT_END]: 'END',\n  [Hammer.INPUT_CANCEL]: 'CANCEL',\n};\nexport const HammerDirectionNames = {\n  [Hammer.DIRECTION_HORIZONTAL]: 'HORIZONTAL',\n  [Hammer.DIRECTION_UP]: 'UP',\n  [Hammer.DIRECTION_DOWN]: 'DOWN',\n  [Hammer.DIRECTION_VERTICAL]: 'VERTICAL',\n  [Hammer.DIRECTION_NONE]: 'NONE',\n  [Hammer.DIRECTION_ALL]: 'ALL',\n  [Hammer.DIRECTION_RIGHT]: 'RIGHT',\n  [Hammer.DIRECTION_LEFT]: 'LEFT',\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js b/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js
new file mode 100644
index 0000000..15f4a5c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js
@@ -0,0 +1,42 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.fireAfterInterval = fireAfterInterval;
+exports.TEST_MAX_IF_NOT_NAN = exports.VEC_LEN_SQ = exports.TEST_MIN_IF_NOT_NAN = exports.isValidNumber = exports.isnan = void 0;
+
+// TODO(TS) remove if not necessary after rewrite
+const isnan = v => Number.isNaN(v); // TODO(TS) remove if not necessary after rewrite
+
+
+exports.isnan = isnan;
+
+const isValidNumber = v => typeof v === 'number' && !Number.isNaN(v);
+
+exports.isValidNumber = isValidNumber;
+
+const TEST_MIN_IF_NOT_NAN = (value, limit) => !isnan(limit) && (limit < 0 && value <= limit || limit >= 0 && value >= limit);
+
+exports.TEST_MIN_IF_NOT_NAN = TEST_MIN_IF_NOT_NAN;
+
+const VEC_LEN_SQ = ({
+  x = 0,
+  y = 0
+} = {}) => x * x + y * y;
+
+exports.VEC_LEN_SQ = VEC_LEN_SQ;
+
+const TEST_MAX_IF_NOT_NAN = (value, max) => !isnan(max) && (max < 0 && value < max || max >= 0 && value > max);
+
+exports.TEST_MAX_IF_NOT_NAN = TEST_MAX_IF_NOT_NAN;
+
+function fireAfterInterval(method, interval) {
+  if (!interval) {
+    method();
+    return null;
+  }
+
+  return setTimeout(() => method(), interval);
+}
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js.map b/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js.map
new file mode 100644
index 0000000..405560a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/commonjs/web/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["utils.ts"],"names":["isnan","v","Number","isNaN","isValidNumber","TEST_MIN_IF_NOT_NAN","value","limit","VEC_LEN_SQ","x","y","TEST_MAX_IF_NOT_NAN","max","fireAfterInterval","method","interval","setTimeout"],"mappings":";;;;;;;;AAAA;AACO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;;;;AACO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;;;;AAGA,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;;;;AAGA,MAAMC,UAAU,GAAG,CAAC;AAAEC,EAAAA,CAAC,GAAG,CAAN;AAASC,EAAAA,CAAC,GAAG;AAAb,IAAmB,EAApB,KAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAA1D;;;;AACA,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;;;;AAGA,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD","sourcesContent":["// TODO(TS) remove if not necessary after rewrite\nexport const isnan = (v: unknown) => Number.isNaN(v);\n\n// TODO(TS) remove if not necessary after rewrite\nexport const isValidNumber = (v: unknown) =>\n  typeof v === 'number' && !Number.isNaN(v);\n\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\n  !isnan(limit) &&\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\n\nexport function fireAfterInterval(\n  method: () => void,\n  interval?: number | boolean\n) {\n  if (!interval) {\n    method();\n    return null;\n  }\n  return setTimeout(() => method(), interval);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/Directions.js b/node_modules/react-native-gesture-handler/lib/module/Directions.js
new file mode 100644
index 0000000..4856fd6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/Directions.js
@@ -0,0 +1,7 @@
+export const Directions = {
+  RIGHT: 1,
+  LEFT: 2,
+  UP: 4,
+  DOWN: 8
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+//# sourceMappingURL=Directions.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/Directions.js.map b/node_modules/react-native-gesture-handler/lib/module/Directions.js.map
new file mode 100644
index 0000000..0d1a3e0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/Directions.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Directions.ts"],"names":["Directions","RIGHT","LEFT","UP","DOWN"],"mappings":"AAAA,OAAO,MAAMA,UAAU,GAAG;AACxBC,EAAAA,KAAK,EAAE,CADiB;AAExBC,EAAAA,IAAI,EAAE,CAFkB;AAGxBC,EAAAA,EAAE,EAAE,CAHoB;AAIxBC,EAAAA,IAAI,EAAE;AAJkB,CAAnB,C,CAOP","sourcesContent":["export const Directions = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type Directions = typeof Directions[keyof typeof Directions];\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js
new file mode 100644
index 0000000..333bc2a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js
@@ -0,0 +1,22 @@
+import * as React from 'react';
+import { View, requireNativeComponent } from 'react-native';
+const GestureHandlerRootViewNative = requireNativeComponent('GestureHandlerRootView');
+const GestureHandlerRootViewContext = /*#__PURE__*/React.createContext(false);
+export default function GestureHandlerRootView({
+  children,
+  ...rest
+}) {
+  return /*#__PURE__*/React.createElement(GestureHandlerRootViewContext.Consumer, null, available => {
+    if (available) {
+      // If we already have a parent wrapped in the gesture handler root view,
+      // We don't need to wrap it again in root view
+      // We still wrap it in a normal view so our styling stays the same
+      return /*#__PURE__*/React.createElement(View, rest, children);
+    }
+
+    return /*#__PURE__*/React.createElement(GestureHandlerRootViewContext.Provider, {
+      value: true
+    }, /*#__PURE__*/React.createElement(GestureHandlerRootViewNative, rest, children));
+  });
+}
+//# sourceMappingURL=GestureHandlerRootView.android.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js.map b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js.map
new file mode 100644
index 0000000..472c7df
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.android.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerRootView.android.tsx"],"names":["React","View","requireNativeComponent","GestureHandlerRootViewNative","GestureHandlerRootViewContext","createContext","GestureHandlerRootView","children","rest","available"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SAASC,IAAT,EAAeC,sBAAf,QAA6C,cAA7C;AAEA,MAAMC,4BAA4B,GAAGD,sBAAsB,CACzD,wBADyD,CAA3D;AAIA,MAAME,6BAA6B,gBAAGJ,KAAK,CAACK,aAAN,CAAoB,KAApB,CAAtC;AAIA,eAAe,SAASC,sBAAT,CAAgC;AAAEC,EAAAA,QAAF;AAAY,KAAGC;AAAf,CAAhC,EAA8D;AAC3E,sBACE,oBAAC,6BAAD,CAA+B,QAA/B,QACIC,SAAD,IAAe;AACd,QAAIA,SAAJ,EAAe;AACb;AACA;AACA;AACA,0BAAO,oBAAC,IAAD,EAAUD,IAAV,EAAiBD,QAAjB,CAAP;AACD;;AAED,wBACE,oBAAC,6BAAD,CAA+B,QAA/B;AAAwC,MAAA,KAAK;AAA7C,oBACE,oBAAC,4BAAD,EAAkCC,IAAlC,EACGD,QADH,CADF,CADF;AAOD,GAhBH,CADF;AAoBD","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport { View, requireNativeComponent } from 'react-native';\n\nconst GestureHandlerRootViewNative = requireNativeComponent(\n  'GestureHandlerRootView'\n);\n\nconst GestureHandlerRootViewContext = React.createContext(false);\n\ntype Props = PropsWithChildren<Record<string, unknown>>;\n\nexport default function GestureHandlerRootView({ children, ...rest }: Props) {\n  return (\n    <GestureHandlerRootViewContext.Consumer>\n      {(available) => {\n        if (available) {\n          // If we already have a parent wrapped in the gesture handler root view,\n          // We don't need to wrap it again in root view\n          // We still wrap it in a normal view so our styling stays the same\n          return <View {...rest}>{children}</View>;\n        }\n\n        return (\n          <GestureHandlerRootViewContext.Provider value>\n            <GestureHandlerRootViewNative {...rest}>\n              {children}\n            </GestureHandlerRootViewNative>\n          </GestureHandlerRootViewContext.Provider>\n        );\n      }}\n    </GestureHandlerRootViewContext.Consumer>\n  );\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js
new file mode 100644
index 0000000..061aaf0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js
@@ -0,0 +1,3 @@
+import { View } from 'react-native';
+export default View;
+//# sourceMappingURL=GestureHandlerRootView.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js.map b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js.map
new file mode 100644
index 0000000..ec9d3d4
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/GestureHandlerRootView.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerRootView.tsx"],"names":["View"],"mappings":"AAAA,SAASA,IAAT,QAAqB,cAArB;AAEA,eAAeA,IAAf","sourcesContent":["import { View } from 'react-native';\n\nexport default View;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js
new file mode 100644
index 0000000..9fc64f2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js
@@ -0,0 +1,5 @@
+var _NativeModules$Platfo;
+
+import { NativeModules, Platform } from 'react-native';
+export default (_NativeModules$Platfo = NativeModules === null || NativeModules === void 0 ? void 0 : NativeModules.PlatformConstants) !== null && _NativeModules$Platfo !== void 0 ? _NativeModules$Platfo : Platform.constants;
+//# sourceMappingURL=PlatformConstants.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js.map b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js.map
new file mode 100644
index 0000000..dab8e80
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PlatformConstants.ts"],"names":["NativeModules","Platform","PlatformConstants","constants"],"mappings":";;AAAA,SAASA,aAAT,EAAwBC,QAAxB,QAAwC,cAAxC;AAMA,wCAAgBD,aAAhB,aAAgBA,aAAhB,uBAAgBA,aAAa,CAAEE,iBAA/B,yEACED,QAAQ,CAACE,SADX","sourcesContent":["import { NativeModules, Platform } from 'react-native';\n\ntype PlatformConstants = {\n  forceTouchAvailable: boolean;\n};\n\nexport default (NativeModules?.PlatformConstants ??\n  Platform.constants) as PlatformConstants;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js
new file mode 100644
index 0000000..d48b0da
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js
@@ -0,0 +1,7 @@
+export default {
+  get forceTouchAvailable() {
+    return false;
+  }
+
+};
+//# sourceMappingURL=PlatformConstants.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js.map b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js.map
new file mode 100644
index 0000000..dd00b47
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/PlatformConstants.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PlatformConstants.web.ts"],"names":["forceTouchAvailable"],"mappings":"AAAA,eAAe;AACb,MAAIA,mBAAJ,GAA0B;AACxB,WAAO,KAAP;AACD;;AAHY,CAAf","sourcesContent":["export default {\n  get forceTouchAvailable() {\n    return false;\n  },\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js
new file mode 100644
index 0000000..39f0ae0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js
@@ -0,0 +1,11 @@
+import { NativeModules } from 'react-native';
+const {
+  RNGestureHandlerModule
+} = NativeModules;
+
+if (RNGestureHandlerModule == null) {
+  console.error("react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).\n\n    For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation".split('\n').map(line => line.trim()).join('\n'));
+}
+
+export default RNGestureHandlerModule;
+//# sourceMappingURL=RNGestureHandlerModule.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js.map b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js.map
new file mode 100644
index 0000000..cc6d4c2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RNGestureHandlerModule.ts"],"names":["NativeModules","RNGestureHandlerModule","console","error","split","map","line","trim","join"],"mappings":"AAAA,SAASA,aAAT,QAA8B,cAA9B;AACA,MAAM;AAAEC,EAAAA;AAAF,IAA6BD,aAAnC;;AAEA,IAAIC,sBAAsB,IAAI,IAA9B,EAAoC;AAClCC,EAAAA,OAAO,CAACC,KAAR,CACE,kTAGGC,KAHH,CAGS,IAHT,EAIGC,GAJH,CAIQC,IAAD,IAAUA,IAAI,CAACC,IAAL,EAJjB,EAKGC,IALH,CAKQ,IALR,CADF;AAQD;;AAkBD,eAAeP,sBAAf","sourcesContent":["import { NativeModules } from 'react-native';\nconst { RNGestureHandlerModule } = NativeModules;\n\nif (RNGestureHandlerModule == null) {\n  console.error(\n    `react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).\n\n    For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation`\n      .split('\\n')\n      .map((line) => line.trim())\n      .join('\\n')\n  );\n}\n\nexport type RNGestureHandlerModuleProps = {\n  handleSetJSResponder: (tag: number, blockNativeResponder: boolean) => void;\n  handleClearJSResponder: () => void;\n  createGestureHandler: (\n    handlerName: string,\n    handlerTag: number,\n    config: Readonly<Record<string, unknown>>\n  ) => void;\n  attachGestureHandler: (handlerTag: number, newView: number) => void;\n  updateGestureHandler: (\n    handlerTag: number,\n    newConfig: Readonly<Record<string, unknown>>\n  ) => void;\n  dropGestureHandler: (handlerTag: number) => void;\n};\n\nexport default RNGestureHandlerModule as RNGestureHandlerModuleProps;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/RNGestureHandlerModule.web.js b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js
similarity index 83%
rename from node_modules/react-native-gesture-handler/RNGestureHandlerModule.web.js
rename to node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js
index f2131fd..6781392 100644
--- a/node_modules/react-native-gesture-handler/RNGestureHandlerModule.web.js
+++ b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js
@@ -7,45 +7,50 @@ import PanGestureHandler from './web/PanGestureHandler';
 import PinchGestureHandler from './web/PinchGestureHandler';
 import RotationGestureHandler from './web/RotationGestureHandler';
 import TapGestureHandler from './web/TapGestureHandler';
-
-const Gestures = {
+export const Gestures = {
   PanGestureHandler,
   RotationGestureHandler,
   PinchGestureHandler,
   TapGestureHandler,
   NativeViewGestureHandler,
   LongPressGestureHandler,
-  FlingGestureHandler,
-  // ForceTouchGestureHandler,
-};
+  FlingGestureHandler // ForceTouchGestureHandler,
 
+};
 export default {
   Direction,
+
   handleSetJSResponder(tag, blockNativeResponder) {
     console.warn('handleSetJSResponder: ', tag, blockNativeResponder);
   },
+
   handleClearJSResponder() {
     console.warn('handleClearJSResponder: ');
   },
+
   createGestureHandler(handlerName, handlerTag, config) {
-    if (!(handlerName in Gestures))
-      throw new Error(
-        `react-native-gesture-handler: ${handlerName} is not supported on web.`
-      );
+    //TODO(TS) extends config
+    if (!(handlerName in Gestures)) throw new Error("react-native-gesture-handler: ".concat(handlerName, " is not supported on web."));
     const GestureClass = Gestures[handlerName];
     NodeManager.createGestureHandler(handlerTag, new GestureClass());
     this.updateGestureHandler(handlerTag, config);
   },
+
   attachGestureHandler(handlerTag, newView, propsRef) {
     NodeManager.getHandler(handlerTag).setView(newView, propsRef);
   },
+
   updateGestureHandler(handlerTag, newConfig) {
     NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);
   },
+
   getGestureHandlerNode(handlerTag) {
     return NodeManager.getHandler(handlerTag);
   },
+
   dropGestureHandler(handlerTag) {
     NodeManager.dropGestureHandler(handlerTag);
-  },
+  }
+
 };
+//# sourceMappingURL=RNGestureHandlerModule.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js.map b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js.map
new file mode 100644
index 0000000..135ba06
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/RNGestureHandlerModule.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RNGestureHandlerModule.web.ts"],"names":["Direction","FlingGestureHandler","LongPressGestureHandler","NativeViewGestureHandler","NodeManager","PanGestureHandler","PinchGestureHandler","RotationGestureHandler","TapGestureHandler","Gestures","handleSetJSResponder","tag","blockNativeResponder","console","warn","handleClearJSResponder","createGestureHandler","handlerName","handlerTag","config","Error","GestureClass","updateGestureHandler","attachGestureHandler","newView","propsRef","getHandler","setView","newConfig","updateGestureConfig","getGestureHandlerNode","dropGestureHandler"],"mappings":"AAAA,SAASA,SAAT,QAA0B,iBAA1B;AACA,OAAOC,mBAAP,MAAgC,2BAAhC;AACA,OAAOC,uBAAP,MAAoC,+BAApC;AACA,OAAOC,wBAAP,MAAqC,gCAArC;AACA,OAAO,KAAKC,WAAZ,MAA6B,mBAA7B;AACA,OAAOC,iBAAP,MAA8B,yBAA9B;AACA,OAAOC,mBAAP,MAAgC,2BAAhC;AACA,OAAOC,sBAAP,MAAmC,8BAAnC;AACA,OAAOC,iBAAP,MAA8B,yBAA9B;AAEA,OAAO,MAAMC,QAAQ,GAAG;AACtBJ,EAAAA,iBADsB;AAEtBE,EAAAA,sBAFsB;AAGtBD,EAAAA,mBAHsB;AAItBE,EAAAA,iBAJsB;AAKtBL,EAAAA,wBALsB;AAMtBD,EAAAA,uBANsB;AAOtBD,EAAAA,mBAPsB,CAQtB;;AARsB,CAAjB;AAWP,eAAe;AACbD,EAAAA,SADa;;AAEbU,EAAAA,oBAAoB,CAACC,GAAD,EAAcC,oBAAd,EAA6C;AAC/DC,IAAAA,OAAO,CAACC,IAAR,CAAa,wBAAb,EAAuCH,GAAvC,EAA4CC,oBAA5C;AACD,GAJY;;AAKbG,EAAAA,sBAAsB,GAAG;AACvBF,IAAAA,OAAO,CAACC,IAAR,CAAa,0BAAb;AACD,GAPY;;AAQbE,EAAAA,oBAAoB,CAClBC,WADkB,EAElBC,UAFkB,EAGlBC,MAHkB,EAIlB;AACA;AACA,QAAI,EAAEF,WAAW,IAAIR,QAAjB,CAAJ,EACE,MAAM,IAAIW,KAAJ,yCAC6BH,WAD7B,+BAAN;AAGF,UAAMI,YAAY,GAAGZ,QAAQ,CAACQ,WAAD,CAA7B;AACAb,IAAAA,WAAW,CAACY,oBAAZ,CAAiCE,UAAjC,EAA6C,IAAIG,YAAJ,EAA7C;AACA,SAAKC,oBAAL,CAA0BJ,UAA1B,EAAsCC,MAAtC;AACD,GArBY;;AAsBbI,EAAAA,oBAAoB,CAClBL,UADkB,EAElBM,OAFkB,EAGlBC,QAHkB,EAIlB;AACArB,IAAAA,WAAW,CAACsB,UAAZ,CAAuBR,UAAvB,EAAmCS,OAAnC,CAA2CH,OAA3C,EAAoDC,QAApD;AACD,GA5BY;;AA6BbH,EAAAA,oBAAoB,CAACJ,UAAD,EAAqBU,SAArB,EAAqC;AACvDxB,IAAAA,WAAW,CAACsB,UAAZ,CAAuBR,UAAvB,EAAmCW,mBAAnC,CAAuDD,SAAvD;AACD,GA/BY;;AAgCbE,EAAAA,qBAAqB,CAACZ,UAAD,EAAqB;AACxC,WAAOd,WAAW,CAACsB,UAAZ,CAAuBR,UAAvB,CAAP;AACD,GAlCY;;AAmCba,EAAAA,kBAAkB,CAACb,UAAD,EAAqB;AACrCd,IAAAA,WAAW,CAAC2B,kBAAZ,CAA+Bb,UAA/B;AACD;;AArCY,CAAf","sourcesContent":["import { Direction } from './web/constants';\nimport FlingGestureHandler from './web/FlingGestureHandler';\nimport LongPressGestureHandler from './web/LongPressGestureHandler';\nimport NativeViewGestureHandler from './web/NativeViewGestureHandler';\nimport * as NodeManager from './web/NodeManager';\nimport PanGestureHandler from './web/PanGestureHandler';\nimport PinchGestureHandler from './web/PinchGestureHandler';\nimport RotationGestureHandler from './web/RotationGestureHandler';\nimport TapGestureHandler from './web/TapGestureHandler';\n\nexport const Gestures = {\n  PanGestureHandler,\n  RotationGestureHandler,\n  PinchGestureHandler,\n  TapGestureHandler,\n  NativeViewGestureHandler,\n  LongPressGestureHandler,\n  FlingGestureHandler,\n  // ForceTouchGestureHandler,\n};\n\nexport default {\n  Direction,\n  handleSetJSResponder(tag: number, blockNativeResponder: boolean) {\n    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);\n  },\n  handleClearJSResponder() {\n    console.warn('handleClearJSResponder: ');\n  },\n  createGestureHandler<T>(\n    handlerName: keyof typeof Gestures,\n    handlerTag: number,\n    config: T\n  ) {\n    //TODO(TS) extends config\n    if (!(handlerName in Gestures))\n      throw new Error(\n        `react-native-gesture-handler: ${handlerName} is not supported on web.`\n      );\n    const GestureClass = Gestures[handlerName];\n    NodeManager.createGestureHandler(handlerTag, new GestureClass());\n    this.updateGestureHandler(handlerTag, config);\n  },\n  attachGestureHandler(\n    handlerTag: number,\n    newView: number,\n    propsRef: React.RefObject<unknown>\n  ) {\n    NodeManager.getHandler(handlerTag).setView(newView, propsRef);\n  },\n  updateGestureHandler(handlerTag: number, newConfig: any) {\n    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);\n  },\n  getGestureHandlerNode(handlerTag: number) {\n    return NodeManager.getHandler(handlerTag);\n  },\n  dropGestureHandler(handlerTag: number) {\n    NodeManager.dropGestureHandler(handlerTag);\n  },\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/State.js b/node_modules/react-native-gesture-handler/lib/module/State.js
new file mode 100644
index 0000000..3b1605d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/State.js
@@ -0,0 +1,10 @@
+// TODO use State from RNModule
+export const State = {
+  UNDETERMINED: 0,
+  FAILED: 1,
+  BEGAN: 2,
+  CANCELLED: 3,
+  ACTIVE: 4,
+  END: 5
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+//# sourceMappingURL=State.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/State.js.map b/node_modules/react-native-gesture-handler/lib/module/State.js.map
new file mode 100644
index 0000000..26d79d3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/State.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["State.ts"],"names":["State","UNDETERMINED","FAILED","BEGAN","CANCELLED","ACTIVE","END"],"mappings":"AAAA;AAEA,OAAO,MAAMA,KAAK,GAAG;AACnBC,EAAAA,YAAY,EAAE,CADK;AAEnBC,EAAAA,MAAM,EAAE,CAFW;AAGnBC,EAAAA,KAAK,EAAE,CAHY;AAInBC,EAAAA,SAAS,EAAE,CAJQ;AAKnBC,EAAAA,MAAM,EAAE,CALW;AAMnBC,EAAAA,GAAG,EAAE;AANc,CAAd,C,CASP","sourcesContent":["// TODO use State from RNModule\n\nexport const State = {\n  UNDETERMINED: 0,\n  FAILED: 1,\n  BEGAN: 2,\n  CANCELLED: 3,\n  ACTIVE: 4,\n  END: 5,\n} as const;\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value\nexport type State = typeof State[keyof typeof State];\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js b/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js
new file mode 100644
index 0000000..c142a12
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js
@@ -0,0 +1,517 @@
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// This component is based on RN's DrawerLayoutAndroid API
+//
+// It perhaps deserves to be put in a separate repo, but since it relies
+// on react-native-gesture-handler library which isn't very popular at the
+// moment I decided to keep it here for the time being. It will allow us
+// to move faster and fix issues that may arise in gesture handler library
+// that could be found when using the drawer component
+import * as React from 'react';
+import { Component } from 'react';
+import invariant from 'invariant';
+import { Animated, StyleSheet, View, Keyboard, StatusBar, I18nManager } from 'react-native';
+import { PanGestureHandler, TapGestureHandler } from '../handlers/gestureHandlers';
+import { State } from '../State';
+const DRAG_TOSS = 0.05;
+const IDLE = 'Idle';
+const DRAGGING = 'Dragging';
+const SETTLING = 'Settling';
+export default class DrawerLayout extends Component {
+  constructor(_props) {
+    super(_props);
+
+    _defineProperty(this, "openValue", void 0);
+
+    _defineProperty(this, "onGestureEvent", void 0);
+
+    _defineProperty(this, "accessibilityIsModalView", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "pointerEventsView", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "panGestureHandler", /*#__PURE__*/React.createRef());
+
+    _defineProperty(this, "drawerShown", false);
+
+    _defineProperty(this, "updateAnimatedEvent", (props, state) => {
+      // Event definition is based on
+      const {
+        drawerPosition,
+        drawerWidth,
+        drawerType
+      } = props;
+      const {
+        dragX: dragXValue,
+        touchX: touchXValue,
+        drawerTranslation,
+        containerWidth
+      } = state;
+      let dragX = dragXValue;
+      let touchX = touchXValue;
+
+      if (drawerPosition !== 'left') {
+        // Most of the code is written in a way to handle left-side drawer.
+        // In order to handle right-side drawer the only thing we need to
+        // do is to reverse events coming from gesture handler in a way they
+        // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and
+        // touchX is calulcated by subtracing real touchX from the width of the
+        // container (such that when touch happens at the right edge the value
+        // is simply 0)
+        dragX = Animated.multiply(new Animated.Value(-1), dragXValue); // TODO(TS): (for all "as" in this file) make sure we can map this
+
+        touchX = Animated.add(new Animated.Value(containerWidth), Animated.multiply(new Animated.Value(-1), touchXValue)); // TODO(TS): make sure we can map this;
+
+        touchXValue.setValue(containerWidth);
+      } else {
+        touchXValue.setValue(0);
+      } // While closing the drawer when user starts gesture outside of its area (in greyed
+      // out part of the window), we want the drawer to follow only once finger reaches the
+      // edge of the drawer.
+      // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by
+      // dots. The touch gesture starts at '*' and moves left, touch path is indicated by
+      // an arrow pointing left
+      // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|
+      //    +---------------+    +---------------+    +---------------+    +---------------+
+      //
+      // For the above to work properly we define animated value that will keep start position
+      // of the gesture. Then we use that value to calculate how much we need to subtract from
+      // the dragX. If the gesture started on the greyed out area we take the distance from the
+      // edge of the drawer to the start position. Otherwise we don't subtract at all and the
+      // drawer be pulled back as soon as you start the pan.
+      //
+      // This is used only when drawerType is "front"
+      //
+
+
+      let translationX = dragX;
+
+      if (drawerType === 'front') {
+        const startPositionX = Animated.add(touchX, Animated.multiply(new Animated.Value(-1), dragX));
+        const dragOffsetFromOnStartPosition = startPositionX.interpolate({
+          inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],
+          outputRange: [0, 0, 1]
+        });
+        translationX = Animated.add(dragX, dragOffsetFromOnStartPosition); // TODO: as above
+      }
+
+      this.openValue = Animated.add(translationX, drawerTranslation).interpolate({
+        inputRange: [0, drawerWidth],
+        outputRange: [0, 1],
+        extrapolate: 'clamp'
+      });
+      const gestureOptions = {
+        useNativeDriver: props.useNativeAnimations
+      };
+
+      if (this.props.onDrawerSlide) {
+        gestureOptions.listener = ev => {
+          var _this$props$onDrawerS, _this$props;
+
+          const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));
+          const position = translationX / this.state.containerWidth;
+          (_this$props$onDrawerS = (_this$props = this.props).onDrawerSlide) === null || _this$props$onDrawerS === void 0 ? void 0 : _this$props$onDrawerS.call(_this$props, position);
+        };
+      }
+
+      this.onGestureEvent = Animated.event([{
+        nativeEvent: {
+          translationX: dragXValue,
+          x: touchXValue
+        }
+      }], gestureOptions);
+    });
+
+    _defineProperty(this, "handleContainerLayout", ({
+      nativeEvent
+    }) => {
+      this.setState({
+        containerWidth: nativeEvent.layout.width
+      });
+    });
+
+    _defineProperty(this, "emitStateChanged", (newState, drawerWillShow) => {
+      var _this$props$onDrawerS2, _this$props2;
+
+      (_this$props$onDrawerS2 = (_this$props2 = this.props).onDrawerStateChanged) === null || _this$props$onDrawerS2 === void 0 ? void 0 : _this$props$onDrawerS2.call(_this$props2, newState, drawerWillShow);
+    });
+
+    _defineProperty(this, "openingHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (nativeEvent.oldState === State.ACTIVE) {
+        this.handleRelease({
+          nativeEvent
+        });
+      } else if (nativeEvent.state === State.ACTIVE) {
+        this.emitStateChanged(DRAGGING, false);
+
+        if (this.props.keyboardDismissMode === 'on-drag') {
+          Keyboard.dismiss();
+        }
+
+        if (this.props.hideStatusBar) {
+          StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');
+        }
+      }
+    });
+
+    _defineProperty(this, "onTapHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (this.drawerShown && nativeEvent.oldState === State.ACTIVE && this.props.drawerLockMode !== 'locked-open') {
+        this.closeDrawer();
+      }
+    });
+
+    _defineProperty(this, "handleRelease", ({
+      nativeEvent
+    }) => {
+      const {
+        drawerWidth,
+        drawerPosition,
+        drawerType
+      } = this.props;
+      const {
+        containerWidth
+      } = this.state;
+      let {
+        translationX: dragX,
+        velocityX,
+        x: touchX
+      } = nativeEvent;
+
+      if (drawerPosition !== 'left') {
+        // See description in _updateAnimatedEvent about why events are flipped
+        // for right-side drawer
+        dragX = -dragX;
+        touchX = containerWidth - touchX;
+        velocityX = -velocityX;
+      }
+
+      const gestureStartX = touchX - dragX;
+      let dragOffsetBasedOnStart = 0;
+
+      if (drawerType === 'front') {
+        dragOffsetBasedOnStart = gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
+      }
+
+      const startOffsetX = dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth : 0);
+      const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;
+      const shouldOpen = projOffsetX > drawerWidth / 2;
+
+      if (shouldOpen) {
+        this.animateDrawer(startOffsetX, drawerWidth, velocityX);
+      } else {
+        this.animateDrawer(startOffsetX, 0, velocityX);
+      }
+    });
+
+    _defineProperty(this, "updateShowing", showing => {
+      var _this$accessibilityIs, _this$pointerEventsVi, _this$panGestureHandl;
+
+      this.drawerShown = showing;
+      (_this$accessibilityIs = this.accessibilityIsModalView.current) === null || _this$accessibilityIs === void 0 ? void 0 : _this$accessibilityIs.setNativeProps({
+        accessibilityViewIsModal: showing
+      });
+      (_this$pointerEventsVi = this.pointerEventsView.current) === null || _this$pointerEventsVi === void 0 ? void 0 : _this$pointerEventsVi.setNativeProps({
+        pointerEvents: showing ? 'auto' : 'none'
+      });
+      const {
+        drawerPosition,
+        minSwipeDistance,
+        edgeWidth
+      } = this.props;
+      const fromLeft = drawerPosition === 'left'; // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
+      // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
+      // orientation will be 1.
+
+      const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter
+      // than the container size by the value of SLOP. This will make it only
+      // activate when gesture happens not further than SLOP away from the edge
+
+      const hitSlop = fromLeft ? {
+        left: 0,
+        width: showing ? undefined : edgeWidth
+      } : {
+        right: 0,
+        width: showing ? undefined : edgeWidth
+      }; // @ts-ignore internal API, maybe could be fixed in handler types
+
+      (_this$panGestureHandl = this.panGestureHandler.current) === null || _this$panGestureHandl === void 0 ? void 0 : _this$panGestureHandl.setNativeProps({
+        hitSlop,
+        activeOffsetX: gestureOrientation * minSwipeDistance
+      });
+    });
+
+    _defineProperty(this, "animateDrawer", (fromValue, toValue, velocity, speed) => {
+      this.state.dragX.setValue(0);
+      this.state.touchX.setValue(this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth);
+
+      if (fromValue != null) {
+        let nextFramePosition = fromValue;
+
+        if (this.props.useNativeAnimations) {
+          // When using native driver, we predict the next position of the animation
+          // because it takes one frame of a roundtrip to pass RELEASE event from
+          // native driver to JS before we can start animating. Without it, it is more
+          // noticable that the frame is dropped.
+          if (fromValue < toValue && velocity > 0) {
+            nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);
+          } else if (fromValue > toValue && velocity < 0) {
+            nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);
+          }
+        }
+
+        this.state.drawerTranslation.setValue(nextFramePosition);
+      }
+
+      const willShow = toValue !== 0;
+      this.updateShowing(willShow);
+      this.emitStateChanged(SETTLING, willShow);
+
+      if (this.props.hideStatusBar) {
+        StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');
+      }
+
+      Animated.spring(this.state.drawerTranslation, {
+        velocity,
+        bounciness: 0,
+        toValue,
+        useNativeDriver: this.props.useNativeAnimations,
+        speed: speed !== null && speed !== void 0 ? speed : undefined
+      }).start(({
+        finished
+      }) => {
+        if (finished) {
+          this.emitStateChanged(IDLE, willShow);
+
+          if (willShow) {
+            var _this$props$onDrawerO, _this$props3;
+
+            (_this$props$onDrawerO = (_this$props3 = this.props).onDrawerOpen) === null || _this$props$onDrawerO === void 0 ? void 0 : _this$props$onDrawerO.call(_this$props3);
+          } else {
+            var _this$props$onDrawerC, _this$props4;
+
+            (_this$props$onDrawerC = (_this$props4 = this.props).onDrawerClose) === null || _this$props$onDrawerC === void 0 ? void 0 : _this$props$onDrawerC.call(_this$props4);
+          }
+        }
+      });
+    });
+
+    _defineProperty(this, "openDrawer", (options = {}) => {
+      this.animateDrawer( // TODO: decide if it should be null or undefined is the proper value
+      undefined, this.props.drawerWidth, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable
+
+      this.forceUpdate();
+    });
+
+    _defineProperty(this, "closeDrawer", (options = {}) => {
+      // TODO: decide if it should be null or undefined is the proper value
+      this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0); // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable
+
+      this.forceUpdate();
+    });
+
+    _defineProperty(this, "renderOverlay", () => {
+      /* Overlay styles */
+      invariant(this.openValue, 'should be set');
+      const overlayOpacity = this.openValue.interpolate({
+        inputRange: [0, 1],
+        outputRange: [0, 1],
+        extrapolate: 'clamp'
+      });
+      const dynamicOverlayStyles = {
+        opacity: overlayOpacity,
+        backgroundColor: this.props.overlayColor
+      };
+      return /*#__PURE__*/React.createElement(TapGestureHandler, {
+        onHandlerStateChange: this.onTapHandlerStateChange
+      }, /*#__PURE__*/React.createElement(Animated.View, {
+        pointerEvents: this.drawerShown ? 'auto' : 'none',
+        ref: this.pointerEventsView,
+        style: [styles.overlay, dynamicOverlayStyles]
+      }));
+    });
+
+    _defineProperty(this, "renderDrawer", () => {
+      const {
+        drawerBackgroundColor,
+        drawerWidth,
+        drawerPosition,
+        drawerType,
+        drawerContainerStyle,
+        contentContainerStyle
+      } = this.props;
+      const fromLeft = drawerPosition === 'left';
+      const drawerSlide = drawerType !== 'back';
+      const containerSlide = drawerType !== 'front'; // we rely on row and row-reverse flex directions to position the drawer
+      // properly. Apparently for RTL these are flipped which requires us to use
+      // the opposite setting for the drawer to appear from left or right according
+      // to the drawerPosition prop
+
+      const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;
+      const dynamicDrawerStyles = {
+        backgroundColor: drawerBackgroundColor,
+        width: drawerWidth
+      };
+      const openValue = this.openValue;
+      invariant(openValue, 'should be set');
+      let containerStyles;
+
+      if (containerSlide) {
+        const containerTranslateX = openValue.interpolate({
+          inputRange: [0, 1],
+          outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],
+          extrapolate: 'clamp'
+        });
+        containerStyles = {
+          transform: [{
+            translateX: containerTranslateX
+          }]
+        };
+      }
+
+      let drawerTranslateX = 0;
+
+      if (drawerSlide) {
+        const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;
+        drawerTranslateX = openValue.interpolate({
+          inputRange: [0, 1],
+          outputRange: [closedDrawerOffset, 0],
+          extrapolate: 'clamp'
+        });
+      }
+
+      const drawerStyles = {
+        transform: [{
+          translateX: drawerTranslateX
+        }],
+        flexDirection: reverseContentDirection ? 'row-reverse' : 'row'
+      };
+      return /*#__PURE__*/React.createElement(Animated.View, {
+        style: styles.main,
+        onLayout: this.handleContainerLayout
+      }, /*#__PURE__*/React.createElement(Animated.View, {
+        style: [drawerType === 'front' ? styles.containerOnBack : styles.containerInFront, containerStyles, contentContainerStyle],
+        importantForAccessibility: this.drawerShown ? 'no-hide-descendants' : 'yes'
+      }, typeof this.props.children === 'function' ? this.props.children(this.openValue) : this.props.children, this.renderOverlay()), /*#__PURE__*/React.createElement(Animated.View, {
+        pointerEvents: "box-none",
+        ref: this.accessibilityIsModalView,
+        accessibilityViewIsModal: this.drawerShown,
+        style: [styles.drawerContainer, drawerStyles, drawerContainerStyle]
+      }, /*#__PURE__*/React.createElement(View, {
+        style: dynamicDrawerStyles
+      }, this.props.renderNavigationView(this.openValue))));
+    });
+
+    _defineProperty(this, "setPanGestureRef", ref => {
+      var _this$props$onGesture, _this$props5;
+
+      // TODO(TS): make sure it is OK
+      // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842
+      this.panGestureHandler.current = ref;
+      (_this$props$onGesture = (_this$props5 = this.props).onGestureRef) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props5, ref);
+    });
+
+    const _dragX = new Animated.Value(0);
+
+    const _touchX = new Animated.Value(0);
+
+    const _drawerTranslation = new Animated.Value(0);
+
+    this.state = {
+      dragX: _dragX,
+      touchX: _touchX,
+      drawerTranslation: _drawerTranslation,
+      containerWidth: 0
+    };
+    this.updateAnimatedEvent(_props, this.state);
+  }
+
+  UNSAFE_componentWillUpdate(props, state) {
+    if (this.props.drawerPosition !== props.drawerPosition || this.props.drawerWidth !== props.drawerWidth || this.props.drawerType !== props.drawerType || this.state.containerWidth !== state.containerWidth) {
+      this.updateAnimatedEvent(props, state);
+    }
+  }
+
+  render() {
+    const {
+      drawerPosition,
+      drawerLockMode,
+      edgeWidth,
+      minSwipeDistance
+    } = this.props;
+    const fromLeft = drawerPosition === 'left'; // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
+    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
+    // orientation will be 1.
+
+    const gestureOrientation = (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1); // When drawer is closed we want the hitSlop to be horizontally shorter
+    // than the container size by the value of SLOP. This will make it only
+    // activate when gesture happens not further than SLOP away from the edge
+
+    const hitSlop = fromLeft ? {
+      left: 0,
+      width: this.drawerShown ? undefined : edgeWidth
+    } : {
+      right: 0,
+      width: this.drawerShown ? undefined : edgeWidth
+    };
+    return /*#__PURE__*/React.createElement(PanGestureHandler // @ts-ignore could be fixed in handler types
+    , {
+      ref: this.setPanGestureRef,
+      hitSlop: hitSlop,
+      activeOffsetX: gestureOrientation * minSwipeDistance,
+      failOffsetY: [-15, 15],
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.openingHandlerStateChange,
+      enableTrackpadTwoFingerGesture: this.props.enableTrackpadTwoFingerGesture,
+      enabled: drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'
+    }, this.renderDrawer());
+  }
+
+}
+
+_defineProperty(DrawerLayout, "defaultProps", {
+  drawerWidth: 200,
+  drawerPosition: 'left',
+  useNativeAnimations: true,
+  drawerType: 'front',
+  edgeWidth: 20,
+  minSwipeDistance: 3,
+  overlayColor: 'rgba(0, 0, 0, 0.7)',
+  drawerLockMode: 'unlocked',
+  enableTrackpadTwoFingerGesture: false
+});
+
+_defineProperty(DrawerLayout, "positions", {
+  Left: 'left',
+  Right: 'right'
+});
+
+const styles = StyleSheet.create({
+  drawerContainer: { ...StyleSheet.absoluteFillObject,
+    zIndex: 1001,
+    flexDirection: 'row'
+  },
+  containerInFront: { ...StyleSheet.absoluteFillObject,
+    zIndex: 1002
+  },
+  containerOnBack: { ...StyleSheet.absoluteFillObject
+  },
+  main: {
+    flex: 1,
+    zIndex: 0,
+    overflow: 'hidden'
+  },
+  overlay: { ...StyleSheet.absoluteFillObject,
+    zIndex: 1000
+  }
+});
+//# sourceMappingURL=DrawerLayout.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js.map b/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js.map
new file mode 100644
index 0000000..e27601f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/DrawerLayout.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DrawerLayout.tsx"],"names":["React","Component","invariant","Animated","StyleSheet","View","Keyboard","StatusBar","I18nManager","PanGestureHandler","TapGestureHandler","State","DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","constructor","props","createRef","state","drawerPosition","drawerWidth","drawerType","dragX","dragXValue","touchX","touchXValue","drawerTranslation","containerWidth","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","openValue","extrapolate","gestureOptions","useNativeDriver","useNativeAnimations","onDrawerSlide","listener","ev","Math","floor","abs","nativeEvent","position","onGestureEvent","event","x","setState","layout","width","newState","drawerWillShow","onDrawerStateChanged","oldState","ACTIVE","handleRelease","emitStateChanged","keyboardDismissMode","dismiss","hideStatusBar","setHidden","statusBarAnimation","drawerShown","drawerLockMode","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","animateDrawer","showing","accessibilityIsModalView","current","setNativeProps","accessibilityViewIsModal","pointerEventsView","pointerEvents","minSwipeDistance","edgeWidth","fromLeft","gestureOrientation","hitSlop","left","undefined","right","panGestureHandler","activeOffsetX","fromValue","toValue","velocity","speed","nextFramePosition","min","max","willShow","updateShowing","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","options","forceUpdate","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","onTapHandlerStateChange","styles","overlay","drawerBackgroundColor","drawerContainerStyle","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","isRTL","dynamicDrawerStyles","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","main","handleContainerLayout","containerOnBack","containerInFront","children","renderOverlay","drawerContainer","renderNavigationView","ref","onGestureRef","updateAnimatedEvent","UNSAFE_componentWillUpdate","render","setPanGestureRef","openingHandlerStateChange","enableTrackpadTwoFingerGesture","renderDrawer","Left","Right","create","absoluteFillObject","zIndex","flex","overflow"],"mappings":"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","sourcesContent":["// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n  StatusBarAnimation,\n  StyleProp,\n  ViewStyle,\n  LayoutChangeEvent,\n  NativeSyntheticEvent,\n} from 'react-native';\n\nimport {\n  GestureEvent,\n  PanGestureHandler,\n  PanGestureHandlerEventPayload,\n  TapGestureHandler,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE: DrawerState = 'Idle';\nconst DRAGGING: DrawerState = 'Dragging';\nconst SETTLING: DrawerState = 'Settling';\n\nexport type DrawerPosition = 'left' | 'right';\n\nexport type DrawerState = 'Idle' | 'Dragging' | 'Settling';\n\nexport type DrawerType = 'front' | 'back' | 'slide';\n\nexport type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';\n\nexport type DrawerKeyboardDismissMode = 'none' | 'on-drag';\n\nexport interface DrawerLayoutProps {\n  renderNavigationView: (\n    progressAnimatedValue: Animated.Value\n  ) => React.ReactNode;\n  drawerPosition?: DrawerPosition;\n  drawerWidth?: number;\n  drawerBackgroundColor?: string;\n  drawerLockMode?: DrawerLockMode;\n  keyboardDismissMode?: DrawerKeyboardDismissMode;\n  onDrawerClose?: () => void;\n  onDrawerOpen?: () => void;\n  onDrawerStateChanged?: (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => void;\n  useNativeAnimations?: boolean;\n\n  drawerType?: DrawerType;\n  edgeWidth?: number;\n  minSwipeDistance?: number;\n  hideStatusBar?: boolean;\n  statusBarAnimation?: StatusBarAnimation;\n  overlayColor?: string;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  drawerContainerStyle?: StyleProp<ViewStyle>;\n  enableTrackpadTwoFingerGesture?: boolean;\n  onDrawerSlide?: (position: number) => void;\n  onGestureRef?: (ref: PanGestureHandler) => void;\n}\n\nexport type DrawerLayoutState = {\n  dragX: Animated.Value;\n  touchX: Animated.Value;\n  drawerTranslation: Animated.Value;\n  containerWidth: number;\n};\n\nexport type DrawerMovementOption = {\n  velocity?: number;\n  speed?: number;\n};\nexport default class DrawerLayout extends Component<\n  DrawerLayoutProps,\n  DrawerLayoutState\n> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\n    drawerLockMode: 'unlocked',\n    enableTrackpadTwoFingerGesture: false,\n  };\n\n  constructor(props: DrawerLayoutProps) {\n    super(props);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this.updateAnimatedEvent(props, this.state);\n  }\n\n  UNSAFE_componentWillUpdate(\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private openValue?: Animated.AnimatedInterpolation;\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private accessibilityIsModalView = React.createRef<View>();\n  private pointerEventsView = React.createRef<View>();\n  private panGestureHandler = React.createRef<PanGestureHandler | null>();\n  private drawerShown = false;\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n\n  private updateAnimatedEvent = (\n    props: DrawerLayoutProps,\n    state: DrawerLayoutState\n  ) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(\n        new Animated.Value(-1),\n        dragXValue\n      ) as Animated.Value; // TODO(TS): (for all \"as\" in this file) make sure we can map this\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      ) as Animated.Value; // TODO(TS): make sure we can map this;\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(\n        dragX,\n        dragOffsetFromOnStartPosition\n      ) as Animated.Value; // TODO: as above\n    }\n\n    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({\n      inputRange: [0, drawerWidth!],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n\n    const gestureOptions: {\n      useNativeDriver: boolean;\n      // TODO: make sure it is correct\n      listener?: (\n        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>\n      ) => void;\n    } = {\n      useNativeDriver: props.useNativeAnimations!,\n    };\n\n    if (this.props.onDrawerSlide) {\n      gestureOptions.listener = (ev) => {\n        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));\n        const position = translationX / this.state.containerWidth;\n\n        this.props.onDrawerSlide?.(position);\n      };\n    }\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      gestureOptions\n    );\n  };\n\n  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  private emitStateChanged = (\n    newState: DrawerState,\n    drawerWillShow: boolean\n  ) => {\n    this.props.onDrawerStateChanged?.(newState, drawerWillShow);\n  };\n\n  private openingHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease({ nativeEvent });\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this.emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (\n      this.drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  private handleRelease = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth! / 2;\n\n    if (shouldOpen) {\n      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);\n    } else {\n      this.animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  private updateShowing = (showing: boolean) => {\n    this.drawerShown = showing;\n    this.accessibilityIsModalView.current?.setNativeProps({\n      accessibilityViewIsModal: showing,\n    });\n    this.pointerEventsView.current?.setNativeProps({\n      pointerEvents: showing ? 'auto' : 'none',\n    });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    // @ts-ignore internal API, maybe could be fixed in handler types\n    this.panGestureHandler.current?.setNativeProps({\n      hitSlop,\n      activeOffsetX: gestureOrientation * minSwipeDistance!,\n    });\n  };\n\n  private animateDrawer = (\n    fromValue: number | null | undefined,\n    toValue: number,\n    velocity: number,\n    speed?: number\n  ) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue != null) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this.updateShowing(willShow);\n    this.emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      speed: speed ?? undefined,\n    }).start(({ finished }) => {\n      if (finished) {\n        this.emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen?.();\n        } else {\n          this.props.onDrawerClose?.();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOption = {}) => {\n    this.animateDrawer(\n      // TODO: decide if it should be null or undefined is the proper value\n      undefined,\n      this.props.drawerWidth!,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOption = {}) => {\n    // TODO: decide if it should be null or undefined is the proper value\n    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  private renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this.openValue, 'should be set');\n    const overlayOpacity = this.openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this.drawerShown ? 'auto' : 'none'}\n          ref={this.pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  private renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this.openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles: {\n      transform: { translateX: number | Animated.AnimatedInterpolation }[];\n      flexDirection: 'row-reverse' | 'row';\n    } = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}\n          importantForAccessibility={\n            this.drawerShown ? 'no-hide-descendants' : 'yes'\n          }>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this.openValue)\n            : this.props.children}\n          {this.renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this.accessibilityIsModalView}\n          accessibilityViewIsModal={this.drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this.openValue as Animated.Value)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  private setPanGestureRef = (ref: PanGestureHandler) => {\n    // TODO(TS): make sure it is OK\n    // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842\n    (this\n      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;\n    this.props.onGestureRef?.(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        // @ts-ignore could be fixed in handler types\n        ref={this.setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance!}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.openingHandlerStateChange}\n        enableTrackpadTwoFingerGesture={\n          this.props.enableTrackpadTwoFingerGesture\n        }\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this.renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js b/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js
new file mode 100644
index 0000000..a806bcd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js
@@ -0,0 +1,172 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import * as React from 'react';
+import { Animated, Platform, processColor, StyleSheet } from 'react-native';
+import createNativeWrapper from '../handlers/createNativeWrapper';
+import GestureHandlerButton from './GestureHandlerButton';
+import { State } from '../State';
+export const RawButton = createNativeWrapper(GestureHandlerButton, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: false
+});
+export class BaseButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "lastActive", void 0);
+
+    _defineProperty(this, "handleEvent", ({
+      nativeEvent
+    }) => {
+      const {
+        state,
+        oldState,
+        pointerInside
+      } = nativeEvent;
+      const active = pointerInside && state === State.ACTIVE;
+
+      if (active !== this.lastActive && this.props.onActiveStateChange) {
+        this.props.onActiveStateChange(active);
+      }
+
+      if (oldState === State.ACTIVE && state !== State.CANCELLED && this.lastActive && this.props.onPress) {
+        this.props.onPress(active);
+      }
+
+      this.lastActive = active;
+    });
+
+    _defineProperty(this, "onHandlerStateChange", e => {
+      var _this$props$onHandler, _this$props;
+
+      (_this$props$onHandler = (_this$props = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props, e);
+      this.handleEvent(e);
+    });
+
+    _defineProperty(this, "onGestureEvent", e => {
+      var _this$props$onGesture, _this$props2;
+
+      (_this$props$onGesture = (_this$props2 = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props2, e);
+      this.handleEvent(e); // TODO: maybe it is not correct
+    });
+
+    this.lastActive = false;
+  }
+
+  render() {
+    const {
+      rippleColor,
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(RawButton, _extends({
+      rippleColor: processColor(rippleColor)
+    }, rest, {
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.onHandlerStateChange
+    }));
+  }
+
+}
+const AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);
+const btnStyles = StyleSheet.create({
+  underlay: {
+    position: 'absolute',
+    left: 0,
+    right: 0,
+    bottom: 0,
+    top: 0
+  }
+});
+export class RectButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "opacity", void 0);
+
+    _defineProperty(this, "onActiveStateChange", active => {
+      var _this$props$onActiveS, _this$props3;
+
+      if (Platform.OS !== 'android') {
+        this.opacity.setValue(active ? this.props.activeOpacity : 0);
+      }
+
+      (_this$props$onActiveS = (_this$props3 = this.props).onActiveStateChange) === null || _this$props$onActiveS === void 0 ? void 0 : _this$props$onActiveS.call(_this$props3, active);
+    });
+
+    this.opacity = new Animated.Value(0);
+  }
+
+  render() {
+    const {
+      children,
+      style,
+      ...rest
+    } = this.props;
+    const resolvedStyle = StyleSheet.flatten(style !== null && style !== void 0 ? style : {});
+    return /*#__PURE__*/React.createElement(BaseButton, _extends({}, rest, {
+      style: resolvedStyle,
+      onActiveStateChange: this.onActiveStateChange
+    }), /*#__PURE__*/React.createElement(Animated.View, {
+      style: [btnStyles.underlay, {
+        opacity: this.opacity,
+        backgroundColor: this.props.underlayColor,
+        borderRadius: resolvedStyle.borderRadius,
+        borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
+        borderTopRightRadius: resolvedStyle.borderTopRightRadius,
+        borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
+        borderBottomRightRadius: resolvedStyle.borderBottomRightRadius
+      }]
+    }), children);
+  }
+
+}
+
+_defineProperty(RectButton, "defaultProps", {
+  activeOpacity: 0.105,
+  underlayColor: 'black'
+});
+
+export class BorderlessButton extends React.Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "opacity", void 0);
+
+    _defineProperty(this, "onActiveStateChange", active => {
+      var _this$props$onActiveS2, _this$props4;
+
+      if (Platform.OS !== 'android') {
+        this.opacity.setValue(active ? this.props.activeOpacity : 1);
+      }
+
+      (_this$props$onActiveS2 = (_this$props4 = this.props).onActiveStateChange) === null || _this$props$onActiveS2 === void 0 ? void 0 : _this$props$onActiveS2.call(_this$props4, active);
+    });
+
+    this.opacity = new Animated.Value(1);
+  }
+
+  render() {
+    const {
+      children,
+      style,
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(AnimatedBaseButton, _extends({}, rest, {
+      onActiveStateChange: this.onActiveStateChange,
+      style: [style, Platform.OS === 'ios' && {
+        opacity: this.opacity
+      }]
+    }), children);
+  }
+
+}
+
+_defineProperty(BorderlessButton, "defaultProps", {
+  activeOpacity: 0.3,
+  borderless: true
+});
+
+export { default as PureNativeButton } from './GestureHandlerButton';
+//# sourceMappingURL=GestureButtons.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js.map b/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js.map
new file mode 100644
index 0000000..c39cbb0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureButtons.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureButtons.tsx"],"names":["React","Animated","Platform","processColor","StyleSheet","createNativeWrapper","GestureHandlerButton","State","RawButton","shouldCancelWhenOutside","shouldActivateOnStart","BaseButton","Component","constructor","props","nativeEvent","state","oldState","pointerInside","active","ACTIVE","lastActive","onActiveStateChange","CANCELLED","onPress","e","onHandlerStateChange","handleEvent","onGestureEvent","render","rippleColor","rest","AnimatedBaseButton","createAnimatedComponent","btnStyles","create","underlay","position","left","right","bottom","top","RectButton","OS","opacity","setValue","activeOpacity","Value","children","style","resolvedStyle","flatten","backgroundColor","underlayColor","borderRadius","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","BorderlessButton","borderless","default","PureNativeButton"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Animated,\n  Platform,\n  processColor,\n  StyleSheet,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\nimport GestureHandlerButton from './GestureHandlerButton';\nimport { State } from '../State';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../handlers/gestureHandlers';\nimport {\n  NativeViewGestureHandlerPayload,\n  NativeViewGestureHandlerProps,\n} from '../handlers/NativeViewGestureHandler';\n\nexport interface RawButtonProps extends NativeViewGestureHandlerProps {\n  exclusive?: boolean;\n  // TODO: we should transform props in `createNativeWrapper`\n  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code\n}\n\nexport interface BaseButtonProps extends RawButtonProps {\n  onPress?: (pointerInside: boolean) => void;\n  onActiveStateChange?: (active: boolean) => void;\n  style?: StyleProp<ViewStyle>;\n  testID?: string;\n}\n\nexport interface RectButtonProps extends BaseButtonProps {\n  underlayColor?: string;\n  activeOpacity?: number;\n}\n\nexport interface BorderlessButtonProps extends BaseButtonProps {\n  borderless?: boolean;\n  activeOpacity?: number;\n}\n\nexport const RawButton = createNativeWrapper(GestureHandlerButton, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: false,\n});\n\nexport class BaseButton extends React.Component<BaseButtonProps> {\n  private lastActive: boolean;\n\n  constructor(props: BaseButtonProps) {\n    super(props);\n    this.lastActive = false;\n  }\n\n  private handleEvent = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state, oldState, pointerInside } = nativeEvent;\n    const active = pointerInside && state === State.ACTIVE;\n\n    if (active !== this.lastActive && this.props.onActiveStateChange) {\n      this.props.onActiveStateChange(active);\n    }\n\n    if (\n      oldState === State.ACTIVE &&\n      state !== State.CANCELLED &&\n      this.lastActive &&\n      this.props.onPress\n    ) {\n      this.props.onPress(active);\n    }\n\n    this.lastActive = active;\n  };\n\n  // Normally, the parent would execute it's handler first,\n  // then forward the event to listeners. However, here our handler\n  // is virtually only forwarding events to listeners, so we reverse the order\n  // to keep the proper order of the callbacks (from \"raw\" ones to \"processed\").\n  private onHandlerStateChange = (\n    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onHandlerStateChange?.(e);\n    this.handleEvent(e);\n  };\n\n  private onGestureEvent = (\n    e: GestureEvent<NativeViewGestureHandlerPayload>\n  ) => {\n    this.props.onGestureEvent?.(e);\n    this.handleEvent(\n      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>\n    ); // TODO: maybe it is not correct\n  };\n\n  render() {\n    const { rippleColor, ...rest } = this.props;\n\n    return (\n      <RawButton\n        rippleColor={processColor(rippleColor)}\n        {...rest}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}\n      />\n    );\n  }\n}\n\nconst AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);\n\nconst btnStyles = StyleSheet.create({\n  underlay: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: 0,\n  },\n});\n\nexport class RectButton extends React.Component<RectButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.105,\n    underlayColor: 'black',\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: RectButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(0);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 0);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    const resolvedStyle = StyleSheet.flatten(style ?? {});\n\n    return (\n      <BaseButton\n        {...rest}\n        style={resolvedStyle}\n        onActiveStateChange={this.onActiveStateChange}>\n        <Animated.View\n          style={[\n            btnStyles.underlay,\n            {\n              opacity: this.opacity,\n              backgroundColor: this.props.underlayColor,\n              borderRadius: resolvedStyle.borderRadius,\n              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,\n              borderTopRightRadius: resolvedStyle.borderTopRightRadius,\n              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,\n              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,\n            },\n          ]}\n        />\n        {children}\n      </BaseButton>\n    );\n  }\n}\n\nexport class BorderlessButton extends React.Component<BorderlessButtonProps> {\n  static defaultProps = {\n    activeOpacity: 0.3,\n    borderless: true,\n  };\n\n  private opacity: Animated.Value;\n\n  constructor(props: BorderlessButtonProps) {\n    super(props);\n    this.opacity = new Animated.Value(1);\n  }\n\n  private onActiveStateChange = (active: boolean) => {\n    if (Platform.OS !== 'android') {\n      this.opacity.setValue(active ? this.props.activeOpacity! : 1);\n    }\n\n    this.props.onActiveStateChange?.(active);\n  };\n\n  render() {\n    const { children, style, ...rest } = this.props;\n\n    return (\n      <AnimatedBaseButton\n        {...rest}\n        onActiveStateChange={this.onActiveStateChange}\n        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>\n        {children}\n      </AnimatedBaseButton>\n    );\n  }\n}\n\nexport { default as PureNativeButton } from './GestureHandlerButton';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js
new file mode 100644
index 0000000..fea7e6f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js
@@ -0,0 +1,35 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+import * as React from 'react';
+import { ScrollView as RNScrollView, Switch as RNSwitch, TextInput as RNTextInput, DrawerLayoutAndroid as RNDrawerLayoutAndroid, FlatList as RNFlatList } from 'react-native';
+import createNativeWrapper from '../handlers/createNativeWrapper';
+export const ScrollView = createNativeWrapper(RNScrollView, {
+  disallowInterruption: true,
+  shouldCancelWhenOutside: false
+}); // backward type compatibility with https://github.com/software-mansion/react-native-gesture-handler/blob/db78d3ca7d48e8ba57482d3fe9b0a15aa79d9932/react-native-gesture-handler.d.ts#L440-L457
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+
+export const Switch = createNativeWrapper(RNSwitch, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: true,
+  disallowInterruption: true
+}); // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+export const TextInput = createNativeWrapper(RNTextInput); // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+export const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {
+  disallowInterruption: true
+}); // we use literal object since TS gives error when using RN's `positions`
+// @ts-ignore FIXME(TS) maybe this should be removed?
+
+DrawerLayoutAndroid.positions = {
+  Left: 'left',
+  Right: 'right'
+}; // eslint-disable-next-line @typescript-eslint/no-redeclare
+
+export const FlatList = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(RNFlatList, _extends({
+  ref: ref
+}, props, {
+  renderScrollComponent: scrollProps => /*#__PURE__*/React.createElement(ScrollView, scrollProps)
+}))); // eslint-disable-next-line @typescript-eslint/no-redeclare
+//# sourceMappingURL=GestureComponents.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js.map b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js.map
new file mode 100644
index 0000000..e80e0ba
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureComponents.tsx"],"names":["React","ScrollView","RNScrollView","Switch","RNSwitch","TextInput","RNTextInput","DrawerLayoutAndroid","RNDrawerLayoutAndroid","FlatList","RNFlatList","createNativeWrapper","disallowInterruption","shouldCancelWhenOutside","shouldActivateOnStart","positions","Left","Right","forwardRef","props","ref","scrollProps"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,SACEC,UAAU,IAAIC,YADhB,EAGEC,MAAM,IAAIC,QAHZ,EAKEC,SAAS,IAAIC,WALf,EAOEC,mBAAmB,IAAIC,qBAPzB,EASEC,QAAQ,IAAIC,UATd,QAWO,cAXP;AAaA,OAAOC,mBAAP,MAAgC,iCAAhC;AAIA,OAAO,MAAMV,UAAU,GAAGU,mBAAmB,CAE3CT,YAF2C,EAE7B;AACdU,EAAAA,oBAAoB,EAAE,IADR;AAEdC,EAAAA,uBAAuB,EAAE;AAFX,CAF6B,CAAtC,C,CAMP;AACA;;AAUA,OAAO,MAAMV,MAAM,GAAGQ,mBAAmB,CAAgBP,QAAhB,EAA0B;AACjES,EAAAA,uBAAuB,EAAE,KADwC;AAEjEC,EAAAA,qBAAqB,EAAE,IAF0C;AAGjEF,EAAAA,oBAAoB,EAAE;AAH2C,CAA1B,CAAlC,C,CAKP;;AAGA,OAAO,MAAMP,SAAS,GAAGM,mBAAmB,CAAmBL,WAAnB,CAArC,C,CACP;;AAGA,OAAO,MAAMC,mBAAmB,GAAGI,mBAAmB,CAEpDH,qBAFoD,EAE7B;AAAEI,EAAAA,oBAAoB,EAAE;AAAxB,CAF6B,CAA/C,C,CAGP;AACA;;AACAL,mBAAmB,CAACQ,SAApB,GAAgC;AAAEC,EAAAA,IAAI,EAAE,MAAR;AAAgBC,EAAAA,KAAK,EAAE;AAAvB,CAAhC,C,CACA;;AAGA,OAAO,MAAMR,QAAQ,gBAAGT,KAAK,CAACkB,UAAN,CACtB,CAACC,KAAD,EAAQC,GAAR,kBACE,oBAAC,UAAD;AACE,EAAA,GAAG,EAAEA;AADP,GAEMD,KAFN;AAGE,EAAA,qBAAqB,EAAGE,WAAD,iBAAiB,oBAAC,UAAD,EAAgBA,WAAhB;AAH1C,GAFoB,CAAjB,C,CASP","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport {\n  ScrollView as RNScrollView,\n  ScrollViewProps as RNScrollViewProps,\n  Switch as RNSwitch,\n  SwitchProps as RNSwitchProps,\n  TextInput as RNTextInput,\n  TextInputProps as RNTextInputProps,\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  DrawerLayoutAndroidProps as RNDrawerLayoutAndroidProps,\n  FlatList as RNFlatList,\n  FlatListProps as RNFlatListProps,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\n\nimport { NativeViewGestureHandlerProps } from '../handlers/NativeViewGestureHandler';\n\nexport const ScrollView = createNativeWrapper<\n  PropsWithChildren<RNScrollViewProps>\n>(RNScrollView, {\n  disallowInterruption: true,\n  shouldCancelWhenOutside: false,\n});\n// backward type compatibility with https://github.com/software-mansion/react-native-gesture-handler/blob/db78d3ca7d48e8ba57482d3fe9b0a15aa79d9932/react-native-gesture-handler.d.ts#L440-L457\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type ScrollView = typeof ScrollView & {\n  scrollTo(\n    y?: number | { x?: number; y?: number; animated?: boolean },\n    x?: number,\n    animated?: boolean\n  ): void;\n  scrollToEnd(options?: { animated: boolean }): void;\n};\n\nexport const Switch = createNativeWrapper<RNSwitchProps>(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type Switch = typeof Switch;\n\nexport const TextInput = createNativeWrapper<RNTextInputProps>(RNTextInput);\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type TextInput = typeof TextInput;\n\nexport const DrawerLayoutAndroid = createNativeWrapper<\n  PropsWithChildren<RNDrawerLayoutAndroidProps>\n>(RNDrawerLayoutAndroid, { disallowInterruption: true });\n// we use literal object since TS gives error when using RN's `positions`\n// @ts-ignore FIXME(TS) maybe this should be removed?\nDrawerLayoutAndroid.positions = { Left: 'left', Right: 'right' };\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type DrawerLayoutAndroid = typeof DrawerLayoutAndroid;\n\nexport const FlatList = React.forwardRef<RNFlatList<any>, RNFlatListProps<any>>(\n  (props, ref) => (\n    <RNFlatList\n      ref={ref}\n      {...props}\n      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}\n    />\n  )\n);\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type FlatList<ItemT> = React.ComponentType<\n  RNFlatListProps<ItemT> &\n    NativeViewGestureHandlerProps &\n    React.RefAttributes<any>\n> & {\n  scrollToEnd: (params?: { animated?: boolean }) => void;\n  scrollToIndex: (params: {\n    animated?: boolean;\n    index: number;\n    viewOffset?: number;\n    viewPosition?: number;\n  }) => void;\n  scrollToItem: (params: {\n    animated?: boolean;\n    item: ItemT;\n    viewPosition?: number;\n  }) => void;\n  scrollToOffset: (params: { animated?: boolean; offset: number }) => void;\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js
new file mode 100644
index 0000000..1d1b06a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js
@@ -0,0 +1,25 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+import * as React from 'react';
+import { DrawerLayoutAndroid as RNDrawerLayoutAndroid, FlatList as RNFlatList, Switch as RNSwitch, TextInput as RNTextInput, ScrollView as RNScrollView } from 'react-native';
+import createNativeWrapper from '../handlers/createNativeWrapper';
+export const ScrollView = createNativeWrapper(RNScrollView, {
+  disallowInterruption: true
+});
+export const Switch = createNativeWrapper(RNSwitch, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: true,
+  disallowInterruption: true
+});
+export const TextInput = createNativeWrapper(RNTextInput);
+export const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {
+  disallowInterruption: true
+}); // @ts-ignore -- TODO(TS) to investigate if it's needed
+
+DrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;
+export const FlatList = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(RNFlatList, _extends({
+  ref: ref
+}, props, {
+  renderScrollComponent: scrollProps => /*#__PURE__*/React.createElement(ScrollView, scrollProps)
+})));
+//# sourceMappingURL=GestureComponents.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js.map b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js.map
new file mode 100644
index 0000000..535b691
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureComponents.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureComponents.web.tsx"],"names":["React","DrawerLayoutAndroid","RNDrawerLayoutAndroid","FlatList","RNFlatList","Switch","RNSwitch","TextInput","RNTextInput","ScrollView","RNScrollView","createNativeWrapper","disallowInterruption","shouldCancelWhenOutside","shouldActivateOnStart","positions","forwardRef","props","ref","scrollProps"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SACEC,mBAAmB,IAAIC,qBADzB,EAEEC,QAAQ,IAAIC,UAFd,EAGEC,MAAM,IAAIC,QAHZ,EAIEC,SAAS,IAAIC,WAJf,EAKEC,UAAU,IAAIC,YALhB,QAOO,cAPP;AASA,OAAOC,mBAAP,MAAgC,iCAAhC;AAEA,OAAO,MAAMF,UAAU,GAAGE,mBAAmB,CAACD,YAAD,EAAe;AAC1DE,EAAAA,oBAAoB,EAAE;AADoC,CAAf,CAAtC;AAIP,OAAO,MAAMP,MAAM,GAAGM,mBAAmB,CAACL,QAAD,EAAW;AAClDO,EAAAA,uBAAuB,EAAE,KADyB;AAElDC,EAAAA,qBAAqB,EAAE,IAF2B;AAGlDF,EAAAA,oBAAoB,EAAE;AAH4B,CAAX,CAAlC;AAKP,OAAO,MAAML,SAAS,GAAGI,mBAAmB,CAACH,WAAD,CAArC;AACP,OAAO,MAAMP,mBAAmB,GAAGU,mBAAmB,CAACT,qBAAD,EAAwB;AAC5EU,EAAAA,oBAAoB,EAAE;AADsD,CAAxB,CAA/C,C,CAGP;;AACAX,mBAAmB,CAACc,SAApB,GAAgCb,qBAAqB,CAACa,SAAtD;AAEA,OAAO,MAAMZ,QAAQ,gBAAGH,KAAK,CAACgB,UAAN,CACtB,CAAoBC,KAApB,EAAiDC,GAAjD,kBACE,oBAAC,UAAD;AACE,EAAA,GAAG,EAAEA;AADP,GAEMD,KAFN;AAGE,EAAA,qBAAqB,EAAGE,WAAD,iBAAiB,oBAAC,UAAD,EAAgBA,WAAhB;AAH1C,GAFoB,CAAjB","sourcesContent":["import * as React from 'react';\nimport {\n  DrawerLayoutAndroid as RNDrawerLayoutAndroid,\n  FlatList as RNFlatList,\n  Switch as RNSwitch,\n  TextInput as RNTextInput,\n  ScrollView as RNScrollView,\n  FlatListProps,\n} from 'react-native';\n\nimport createNativeWrapper from '../handlers/createNativeWrapper';\n\nexport const ScrollView = createNativeWrapper(RNScrollView, {\n  disallowInterruption: true,\n});\n\nexport const Switch = createNativeWrapper(RNSwitch, {\n  shouldCancelWhenOutside: false,\n  shouldActivateOnStart: true,\n  disallowInterruption: true,\n});\nexport const TextInput = createNativeWrapper(RNTextInput);\nexport const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {\n  disallowInterruption: true,\n});\n// @ts-ignore -- TODO(TS) to investigate if it's needed\nDrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;\n\nexport const FlatList = React.forwardRef(\n  <ItemT extends any>(props: FlatListProps<ItemT>, ref: any) => (\n    <RNFlatList\n      ref={ref}\n      {...props}\n      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}\n    />\n  )\n);\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js
new file mode 100644
index 0000000..a0af96b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js
@@ -0,0 +1,4 @@
+import { requireNativeComponent } from 'react-native';
+const RNGestureHandlerButton = requireNativeComponent('RNGestureHandlerButton');
+export default RNGestureHandlerButton;
+//# sourceMappingURL=GestureHandlerButton.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js.map b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js.map
new file mode 100644
index 0000000..1bc9f58
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerButton.tsx"],"names":["requireNativeComponent","RNGestureHandlerButton"],"mappings":"AAAA,SAAwBA,sBAAxB,QAAsD,cAAtD;AAEA,MAAMC,sBAAqD,GAAGD,sBAAsB,CAClF,wBADkF,CAApF;AAIA,eAAeC,sBAAf","sourcesContent":["import { HostComponent, requireNativeComponent } from 'react-native';\nimport { RawButtonProps } from './GestureButtons';\nconst RNGestureHandlerButton: HostComponent<RawButtonProps> = requireNativeComponent(\n  'RNGestureHandlerButton'\n);\n\nexport default RNGestureHandlerButton;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js
new file mode 100644
index 0000000..59099ba
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js
@@ -0,0 +1,9 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+import * as React from 'react';
+import { View } from 'react-native';
+export default /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(View, _extends({
+  ref: ref,
+  accessibilityRole: "button"
+}, props)));
+//# sourceMappingURL=GestureHandlerButton.web.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js.map b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js.map
new file mode 100644
index 0000000..0ad4288
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/GestureHandlerButton.web.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandlerButton.web.tsx"],"names":["React","View","forwardRef","props","ref"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,IAAT,QAAqB,cAArB;AAEA,4BAAeD,KAAK,CAACE,UAAN,CAAuB,CAACC,KAAD,EAAQC,GAAR,kBACpC,oBAAC,IAAD;AAAM,EAAA,GAAG,EAAEA,GAAX;AAAgB,EAAA,iBAAiB,EAAC;AAAlC,GAA+CD,KAA/C,EADa,CAAf","sourcesContent":["import * as React from 'react';\nimport { View } from 'react-native';\n\nexport default React.forwardRef<View>((props, ref) => (\n  <View ref={ref} accessibilityRole=\"button\" {...props} />\n));\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js b/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js
new file mode 100644
index 0000000..175c7ea
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js
@@ -0,0 +1,344 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// Similarily to the DrawerLayout component this deserves to be put in a
+// separate repo. Although, keeping it here for the time being will allow us
+// to move faster and fix possible issues quicker
+import * as React from 'react';
+import { Component } from 'react';
+import { Animated, StyleSheet, View, I18nManager } from 'react-native';
+import { PanGestureHandler, TapGestureHandler } from '../handlers/gestureHandlers';
+import { State } from '../State';
+const DRAG_TOSS = 0.05;
+export default class Swipeable extends Component {
+  constructor(_props) {
+    super(_props);
+
+    _defineProperty(this, "onGestureEvent", void 0);
+
+    _defineProperty(this, "transX", void 0);
+
+    _defineProperty(this, "showLeftAction", void 0);
+
+    _defineProperty(this, "leftActionTranslate", void 0);
+
+    _defineProperty(this, "showRightAction", void 0);
+
+    _defineProperty(this, "rightActionTranslate", void 0);
+
+    _defineProperty(this, "updateAnimatedEvent", (props, state) => {
+      const {
+        friction,
+        overshootFriction
+      } = props;
+      const {
+        dragX,
+        rowTranslation,
+        leftWidth = 0,
+        rowWidth = 0
+      } = state;
+      const {
+        rightOffset = rowWidth
+      } = state;
+      const rightWidth = Math.max(0, rowWidth - rightOffset);
+      const {
+        overshootLeft = leftWidth > 0,
+        overshootRight = rightWidth > 0
+      } = props;
+      const transX = Animated.add(rowTranslation, dragX.interpolate({
+        inputRange: [0, friction],
+        outputRange: [0, 1]
+      })).interpolate({
+        inputRange: [-rightWidth - (overshootRight ? 1 : overshootFriction), -rightWidth, leftWidth, leftWidth + (overshootLeft ? 1 : overshootFriction)],
+        outputRange: [-rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0), -rightWidth, leftWidth, leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0)]
+      });
+      this.transX = transX;
+      this.showLeftAction = leftWidth > 0 ? transX.interpolate({
+        inputRange: [-1, 0, leftWidth],
+        outputRange: [0, 0, 1]
+      }) : new Animated.Value(0);
+      this.leftActionTranslate = this.showLeftAction.interpolate({
+        inputRange: [0, Number.MIN_VALUE],
+        outputRange: [-10000, 0],
+        extrapolate: 'clamp'
+      });
+      this.showRightAction = rightWidth > 0 ? transX.interpolate({
+        inputRange: [-rightWidth, 0, 1],
+        outputRange: [1, 0, 0]
+      }) : new Animated.Value(0);
+      this.rightActionTranslate = this.showRightAction.interpolate({
+        inputRange: [0, Number.MIN_VALUE],
+        outputRange: [-10000, 0],
+        extrapolate: 'clamp'
+      });
+    });
+
+    _defineProperty(this, "onTapHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      if (nativeEvent.oldState === State.ACTIVE) {
+        this.close();
+      }
+    });
+
+    _defineProperty(this, "onHandlerStateChange", ev => {
+      if (ev.nativeEvent.oldState === State.ACTIVE) {
+        this.handleRelease(ev);
+      }
+    });
+
+    _defineProperty(this, "handleRelease", ev => {
+      const {
+        velocityX,
+        translationX: dragX
+      } = ev.nativeEvent;
+      const {
+        leftWidth = 0,
+        rowWidth = 0,
+        rowState
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+      const {
+        friction,
+        leftThreshold = leftWidth / 2,
+        rightThreshold = rightWidth / 2
+      } = this.props;
+      const startOffsetX = this.currentOffset() + dragX / friction;
+      const translationX = (dragX + DRAG_TOSS * velocityX) / friction;
+      let toValue = 0;
+
+      if (rowState === 0) {
+        if (translationX > leftThreshold) {
+          toValue = leftWidth;
+        } else if (translationX < -rightThreshold) {
+          toValue = -rightWidth;
+        }
+      } else if (rowState === 1) {
+        // swiped to left
+        if (translationX > -leftThreshold) {
+          toValue = leftWidth;
+        }
+      } else {
+        // swiped to right
+        if (translationX < rightThreshold) {
+          toValue = -rightWidth;
+        }
+      }
+
+      this.animateRow(startOffsetX, toValue, velocityX / friction);
+    });
+
+    _defineProperty(this, "animateRow", (fromValue, toValue, velocityX) => {
+      const {
+        dragX,
+        rowTranslation
+      } = this.state;
+      dragX.setValue(0);
+      rowTranslation.setValue(fromValue);
+      this.setState({
+        rowState: Math.sign(toValue)
+      });
+      Animated.spring(rowTranslation, {
+        restSpeedThreshold: 1.7,
+        restDisplacementThreshold: 0.4,
+        velocity: velocityX,
+        bounciness: 0,
+        toValue,
+        useNativeDriver: this.props.useNativeAnimations,
+        ...this.props.animationOptions
+      }).start(({
+        finished
+      }) => {
+        if (finished) {
+          if (toValue > 0 && this.props.onSwipeableLeftOpen) {
+            this.props.onSwipeableLeftOpen();
+          } else if (toValue < 0 && this.props.onSwipeableRightOpen) {
+            this.props.onSwipeableRightOpen();
+          }
+
+          if (toValue === 0) {
+            var _this$props$onSwipeab, _this$props;
+
+            (_this$props$onSwipeab = (_this$props = this.props).onSwipeableClose) === null || _this$props$onSwipeab === void 0 ? void 0 : _this$props$onSwipeab.call(_this$props);
+          } else {
+            var _this$props$onSwipeab2, _this$props2;
+
+            (_this$props$onSwipeab2 = (_this$props2 = this.props).onSwipeableOpen) === null || _this$props$onSwipeab2 === void 0 ? void 0 : _this$props$onSwipeab2.call(_this$props2);
+          }
+        }
+      });
+
+      if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {
+        this.props.onSwipeableLeftWillOpen();
+      } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {
+        this.props.onSwipeableRightWillOpen();
+      }
+
+      if (toValue === 0) {
+        var _this$props$onSwipeab3, _this$props3;
+
+        (_this$props$onSwipeab3 = (_this$props3 = this.props).onSwipeableWillClose) === null || _this$props$onSwipeab3 === void 0 ? void 0 : _this$props$onSwipeab3.call(_this$props3);
+      } else {
+        var _this$props$onSwipeab4, _this$props4;
+
+        (_this$props$onSwipeab4 = (_this$props4 = this.props).onSwipeableWillOpen) === null || _this$props$onSwipeab4 === void 0 ? void 0 : _this$props$onSwipeab4.call(_this$props4);
+      }
+    });
+
+    _defineProperty(this, "onRowLayout", ({
+      nativeEvent
+    }) => {
+      this.setState({
+        rowWidth: nativeEvent.layout.width
+      });
+    });
+
+    _defineProperty(this, "currentOffset", () => {
+      const {
+        leftWidth = 0,
+        rowWidth = 0,
+        rowState
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+
+      if (rowState === 1) {
+        return leftWidth;
+      } else if (rowState === -1) {
+        return -rightWidth;
+      }
+
+      return 0;
+    });
+
+    _defineProperty(this, "close", () => {
+      this.animateRow(this.currentOffset(), 0);
+    });
+
+    _defineProperty(this, "openLeft", () => {
+      const {
+        leftWidth = 0
+      } = this.state;
+      this.animateRow(this.currentOffset(), leftWidth);
+    });
+
+    _defineProperty(this, "openRight", () => {
+      const {
+        rowWidth = 0
+      } = this.state;
+      const {
+        rightOffset = rowWidth
+      } = this.state;
+      const rightWidth = rowWidth - rightOffset;
+      this.animateRow(this.currentOffset(), -rightWidth);
+    });
+
+    const _dragX = new Animated.Value(0);
+
+    this.state = {
+      dragX: _dragX,
+      rowTranslation: new Animated.Value(0),
+      rowState: 0,
+      leftWidth: undefined,
+      rightOffset: undefined,
+      rowWidth: undefined
+    };
+    this.updateAnimatedEvent(_props, this.state);
+    this.onGestureEvent = Animated.event([{
+      nativeEvent: {
+        translationX: _dragX
+      }
+    }], {
+      useNativeDriver: _props.useNativeAnimations
+    });
+  }
+
+  UNSAFE_componentWillUpdate(props, state) {
+    if (this.props.friction !== props.friction || this.props.overshootLeft !== props.overshootLeft || this.props.overshootRight !== props.overshootRight || this.props.overshootFriction !== props.overshootFriction || this.state.leftWidth !== state.leftWidth || this.state.rightOffset !== state.rightOffset || this.state.rowWidth !== state.rowWidth) {
+      this.updateAnimatedEvent(props, state);
+    }
+  }
+
+  render() {
+    const {
+      rowState
+    } = this.state;
+    const {
+      children,
+      renderLeftActions,
+      renderRightActions
+    } = this.props;
+    const left = renderLeftActions && /*#__PURE__*/React.createElement(Animated.View, {
+      style: [styles.leftActions, // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason
+      {
+        transform: [{
+          translateX: this.leftActionTranslate
+        }]
+      }]
+    }, renderLeftActions(this.showLeftAction, this.transX), /*#__PURE__*/React.createElement(View, {
+      onLayout: ({
+        nativeEvent
+      }) => this.setState({
+        leftWidth: nativeEvent.layout.x
+      })
+    }));
+    const right = renderRightActions && /*#__PURE__*/React.createElement(Animated.View, {
+      style: [styles.rightActions, {
+        transform: [{
+          translateX: this.rightActionTranslate
+        }]
+      }]
+    }, renderRightActions(this.showRightAction, this.transX), /*#__PURE__*/React.createElement(View, {
+      onLayout: ({
+        nativeEvent
+      }) => this.setState({
+        rightOffset: nativeEvent.layout.x
+      })
+    }));
+    return /*#__PURE__*/React.createElement(PanGestureHandler, _extends({
+      activeOffsetX: [-10, 10]
+    }, this.props, {
+      onGestureEvent: this.onGestureEvent,
+      onHandlerStateChange: this.onHandlerStateChange
+    }), /*#__PURE__*/React.createElement(Animated.View, {
+      onLayout: this.onRowLayout,
+      style: [styles.container, this.props.containerStyle]
+    }, left, right, /*#__PURE__*/React.createElement(TapGestureHandler, {
+      enabled: rowState !== 0,
+      onHandlerStateChange: this.onTapHandlerStateChange
+    }, /*#__PURE__*/React.createElement(Animated.View, {
+      pointerEvents: rowState === 0 ? 'auto' : 'box-only',
+      style: [{
+        transform: [{
+          translateX: this.transX
+        }]
+      }, this.props.childrenContainerStyle]
+    }, children))));
+  }
+
+}
+
+_defineProperty(Swipeable, "defaultProps", {
+  friction: 1,
+  overshootFriction: 1,
+  useNativeAnimations: true
+});
+
+const styles = StyleSheet.create({
+  container: {
+    overflow: 'hidden'
+  },
+  leftActions: { ...StyleSheet.absoluteFillObject,
+    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row'
+  },
+  rightActions: { ...StyleSheet.absoluteFillObject,
+    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse'
+  }
+});
+//# sourceMappingURL=Swipeable.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js.map b/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js.map
new file mode 100644
index 0000000..cd29778
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/Swipeable.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Swipeable.tsx"],"names":["React","Component","Animated","StyleSheet","View","I18nManager","PanGestureHandler","TapGestureHandler","State","DRAG_TOSS","Swipeable","constructor","props","state","friction","overshootFriction","dragX","rowTranslation","leftWidth","rowWidth","rightOffset","rightWidth","Math","max","overshootLeft","overshootRight","transX","add","interpolate","inputRange","outputRange","showLeftAction","Value","leftActionTranslate","Number","MIN_VALUE","extrapolate","showRightAction","rightActionTranslate","nativeEvent","oldState","ACTIVE","close","ev","handleRelease","velocityX","translationX","rowState","leftThreshold","rightThreshold","startOffsetX","currentOffset","toValue","animateRow","fromValue","setValue","setState","sign","spring","restSpeedThreshold","restDisplacementThreshold","velocity","bounciness","useNativeDriver","useNativeAnimations","animationOptions","start","finished","onSwipeableLeftOpen","onSwipeableRightOpen","onSwipeableClose","onSwipeableOpen","onSwipeableLeftWillOpen","onSwipeableRightWillOpen","onSwipeableWillClose","onSwipeableWillOpen","layout","width","undefined","updateAnimatedEvent","onGestureEvent","event","UNSAFE_componentWillUpdate","render","children","renderLeftActions","renderRightActions","left","styles","leftActions","transform","translateX","x","right","rightActions","onHandlerStateChange","onRowLayout","container","containerStyle","onTapHandlerStateChange","childrenContainerStyle","create","overflow","absoluteFillObject","flexDirection","isRTL"],"mappings":"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","sourcesContent":["// Similarily to the DrawerLayout component this deserves to be put in a\n// separate repo. Although, keeping it here for the time being will allow us\n// to move faster and fix possible issues quicker\n\nimport * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  I18nManager,\n  LayoutChangeEvent,\n  StyleProp,\n  ViewStyle,\n} from 'react-native';\n\nimport {\n  PanGestureHandler,\n  TapGestureHandler,\n  PanGestureHandlerProps,\n  GestureEvent,\n  PanGestureHandlerEventPayload,\n  HandlerStateChangeEvent,\n  TapGestureHandlerEventPayload,\n} from '../handlers/gestureHandlers';\nimport { State } from '../State';\n\nconst DRAG_TOSS = 0.05;\n\ntype SwipeableExcludes = Exclude<\n  keyof PanGestureHandlerProps,\n  'onGestureEvent' | 'onHandlerStateChange'\n>;\n\ninterface SwipeableProps\n  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {\n  enableTrackpadTwoFingerGesture?: boolean;\n  friction?: number;\n  leftThreshold?: number;\n  rightThreshold?: number;\n  overshootLeft?: boolean;\n  overshootRight?: boolean;\n  overshootFriction?: number;\n  onSwipeableLeftOpen?: () => void;\n  onSwipeableRightOpen?: () => void;\n  onSwipeableOpen?: () => void;\n  onSwipeableClose?: () => void;\n  onSwipeableLeftWillOpen?: () => void;\n  onSwipeableRightWillOpen?: () => void;\n  onSwipeableWillOpen?: () => void;\n  onSwipeableWillClose?: () => void;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, +]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderLeftActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  /**\n   *\n   * This map describes the values to use as inputRange for extra interpolation:\n   * AnimatedValue: [startValue, endValue]\n   *\n   * progressAnimatedValue: [0, 1]\n   * dragAnimatedValue: [0, -]\n   *\n   * To support `rtl` flexbox layouts use `flexDirection` styling.\n   * */\n  renderRightActions?: (\n    progressAnimatedValue: Animated.AnimatedInterpolation,\n    dragAnimatedValue: Animated.AnimatedInterpolation\n  ) => React.ReactNode;\n  useNativeAnimations?: boolean;\n  animationOptions?: Record<string, unknown>;\n  containerStyle?: StyleProp<ViewStyle>;\n  childrenContainerStyle?: StyleProp<ViewStyle>;\n}\n\ntype SwipeableState = {\n  dragX: Animated.Value;\n  rowTranslation: Animated.Value;\n  rowState: number;\n  leftWidth?: number;\n  rightOffset?: number;\n  rowWidth?: number;\n};\n\nexport default class Swipeable extends Component<\n  SwipeableProps,\n  SwipeableState\n> {\n  static defaultProps = {\n    friction: 1,\n    overshootFriction: 1,\n    useNativeAnimations: true,\n  };\n\n  constructor(props: SwipeableProps) {\n    super(props);\n    const dragX = new Animated.Value(0);\n    this.state = {\n      dragX,\n      rowTranslation: new Animated.Value(0),\n      rowState: 0,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      rowWidth: undefined,\n    };\n    this.updateAnimatedEvent(props, this.state);\n\n    this.onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragX } }],\n      { useNativeDriver: props.useNativeAnimations! }\n    );\n  }\n\n  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {\n    if (\n      this.props.friction !== props.friction ||\n      this.props.overshootLeft !== props.overshootLeft ||\n      this.props.overshootRight !== props.overshootRight ||\n      this.props.overshootFriction !== props.overshootFriction ||\n      this.state.leftWidth !== state.leftWidth ||\n      this.state.rightOffset !== state.rightOffset ||\n      this.state.rowWidth !== state.rowWidth\n    ) {\n      this.updateAnimatedEvent(props, state);\n    }\n  }\n\n  private onGestureEvent?: (\n    event: GestureEvent<PanGestureHandlerEventPayload>\n  ) => void;\n  private transX?: Animated.AnimatedInterpolation;\n  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private leftActionTranslate?: Animated.AnimatedInterpolation;\n  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;\n  private rightActionTranslate?: Animated.AnimatedInterpolation;\n\n  private updateAnimatedEvent = (\n    props: SwipeableProps,\n    state: SwipeableState\n  ) => {\n    const { friction, overshootFriction } = props;\n    const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;\n    const { rightOffset = rowWidth } = state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n\n    const {\n      overshootLeft = leftWidth > 0,\n      overshootRight = rightWidth > 0,\n    } = props;\n\n    const transX = Animated.add(\n      rowTranslation,\n      dragX.interpolate({\n        inputRange: [0, friction!],\n        outputRange: [0, 1],\n      })\n    ).interpolate({\n      inputRange: [\n        -rightWidth - (overshootRight ? 1 : overshootFriction!),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft ? 1 : overshootFriction!),\n      ],\n      outputRange: [\n        -rightWidth - (overshootRight || overshootFriction! > 1 ? 1 : 0),\n        -rightWidth,\n        leftWidth,\n        leftWidth + (overshootLeft || overshootFriction! > 1 ? 1 : 0),\n      ],\n    });\n    this.transX = transX;\n    this.showLeftAction =\n      leftWidth > 0\n        ? transX.interpolate({\n            inputRange: [-1, 0, leftWidth],\n            outputRange: [0, 0, 1],\n          })\n        : new Animated.Value(0);\n    this.leftActionTranslate = this.showLeftAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n    this.showRightAction =\n      rightWidth > 0\n        ? transX.interpolate({\n            inputRange: [-rightWidth, 0, 1],\n            outputRange: [1, 0, 0],\n          })\n        : new Animated.Value(0);\n    this.rightActionTranslate = this.showRightAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp',\n    });\n  };\n\n  private onTapHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this.close();\n    }\n  };\n\n  private onHandlerStateChange = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    if (ev.nativeEvent.oldState === State.ACTIVE) {\n      this.handleRelease(ev);\n    }\n  };\n\n  private handleRelease = (\n    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>\n  ) => {\n    const { velocityX, translationX: dragX } = ev.nativeEvent;\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    const {\n      friction,\n      leftThreshold = leftWidth / 2,\n      rightThreshold = rightWidth / 2,\n    } = this.props;\n\n    const startOffsetX = this.currentOffset() + dragX / friction!;\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;\n\n    let toValue = 0;\n    if (rowState === 0) {\n      if (translationX > leftThreshold) {\n        toValue = leftWidth;\n      } else if (translationX < -rightThreshold) {\n        toValue = -rightWidth;\n      }\n    } else if (rowState === 1) {\n      // swiped to left\n      if (translationX > -leftThreshold) {\n        toValue = leftWidth;\n      }\n    } else {\n      // swiped to right\n      if (translationX < rightThreshold) {\n        toValue = -rightWidth;\n      }\n    }\n\n    this.animateRow(startOffsetX, toValue, velocityX / friction!);\n  };\n\n  private animateRow = (\n    fromValue: number,\n    toValue: number,\n    velocityX?:\n      | number\n      | {\n          x: number;\n          y: number;\n        }\n  ) => {\n    const { dragX, rowTranslation } = this.state;\n    dragX.setValue(0);\n    rowTranslation.setValue(fromValue);\n\n    this.setState({ rowState: Math.sign(toValue) });\n    Animated.spring(rowTranslation, {\n      restSpeedThreshold: 1.7,\n      restDisplacementThreshold: 0.4,\n      velocity: velocityX,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations!,\n      ...this.props.animationOptions,\n    }).start(({ finished }) => {\n      if (finished) {\n        if (toValue > 0 && this.props.onSwipeableLeftOpen) {\n          this.props.onSwipeableLeftOpen();\n        } else if (toValue < 0 && this.props.onSwipeableRightOpen) {\n          this.props.onSwipeableRightOpen();\n        }\n\n        if (toValue === 0) {\n          this.props.onSwipeableClose?.();\n        } else {\n          this.props.onSwipeableOpen?.();\n        }\n      }\n    });\n    if (toValue > 0 && this.props.onSwipeableLeftWillOpen) {\n      this.props.onSwipeableLeftWillOpen();\n    } else if (toValue < 0 && this.props.onSwipeableRightWillOpen) {\n      this.props.onSwipeableRightWillOpen();\n    }\n\n    if (toValue === 0) {\n      this.props.onSwipeableWillClose?.();\n    } else {\n      this.props.onSwipeableWillOpen?.();\n    }\n  };\n\n  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {\n    this.setState({ rowWidth: nativeEvent.layout.width });\n  };\n\n  private currentOffset = () => {\n    const { leftWidth = 0, rowWidth = 0, rowState } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    if (rowState === 1) {\n      return leftWidth;\n    } else if (rowState === -1) {\n      return -rightWidth;\n    }\n    return 0;\n  };\n\n  close = () => {\n    this.animateRow(this.currentOffset(), 0);\n  };\n\n  openLeft = () => {\n    const { leftWidth = 0 } = this.state;\n    this.animateRow(this.currentOffset(), leftWidth);\n  };\n\n  openRight = () => {\n    const { rowWidth = 0 } = this.state;\n    const { rightOffset = rowWidth } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    this.animateRow(this.currentOffset(), -rightWidth);\n  };\n\n  render() {\n    const { rowState } = this.state;\n    const { children, renderLeftActions, renderRightActions } = this.props;\n\n    const left = renderLeftActions && (\n      <Animated.View\n        style={[\n          styles.leftActions,\n          // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason\n          { transform: [{ translateX: this.leftActionTranslate! }] },\n        ]}>\n        {renderLeftActions(this.showLeftAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ leftWidth: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    const right = renderRightActions && (\n      <Animated.View\n        style={[\n          styles.rightActions,\n          { transform: [{ translateX: this.rightActionTranslate! }] },\n        ]}>\n        {renderRightActions(this.showRightAction!, this.transX!)}\n        <View\n          onLayout={({ nativeEvent }) =>\n            this.setState({ rightOffset: nativeEvent.layout.x })\n          }\n        />\n      </Animated.View>\n    );\n\n    return (\n      <PanGestureHandler\n        activeOffsetX={[-10, 10]}\n        {...this.props}\n        onGestureEvent={this.onGestureEvent}\n        onHandlerStateChange={this.onHandlerStateChange}>\n        <Animated.View\n          onLayout={this.onRowLayout}\n          style={[styles.container, this.props.containerStyle]}>\n          {left}\n          {right}\n          <TapGestureHandler\n            enabled={rowState !== 0}\n            onHandlerStateChange={this.onTapHandlerStateChange}>\n            <Animated.View\n              pointerEvents={rowState === 0 ? 'auto' : 'box-only'}\n              style={[\n                {\n                  transform: [{ translateX: this.transX! }],\n                },\n                this.props.childrenContainerStyle,\n              ]}>\n              {children}\n            </Animated.View>\n          </TapGestureHandler>\n        </Animated.View>\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden',\n  },\n  leftActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',\n  },\n  rightActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse',\n  },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js
new file mode 100644
index 0000000..4b91069
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js
@@ -0,0 +1,261 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import * as React from 'react';
+import { Component } from 'react';
+import { Animated, Platform } from 'react-native';
+import { State } from '../../State';
+import { BaseButton } from '../GestureButtons';
+
+/**
+ * Each touchable is a states' machine which preforms transitions.
+ * On very beginning (and on the very end or recognition) touchable is
+ * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger
+ * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition
+ * finishes in UNDETERMINED state.
+ */
+export const TOUCHABLE_STATE = {
+  UNDETERMINED: 0,
+  BEGAN: 1,
+  MOVED_OUTSIDE: 2
+};
+
+/**
+ * GenericTouchable is not intented to be used as it is.
+ * Should be treated as a source for the rest of touchables
+ */
+export default class GenericTouchable extends Component {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "pressInTimeout", void 0);
+
+    _defineProperty(this, "pressOutTimeout", void 0);
+
+    _defineProperty(this, "longPressTimeout", void 0);
+
+    _defineProperty(this, "longPressDetected", false);
+
+    _defineProperty(this, "pointerInside", true);
+
+    _defineProperty(this, "STATE", TOUCHABLE_STATE.UNDETERMINED);
+
+    _defineProperty(this, "onGestureEvent", ({
+      nativeEvent: {
+        pointerInside
+      }
+    }) => {
+      if (this.pointerInside !== pointerInside) {
+        if (pointerInside) {
+          this.onMoveIn();
+        } else {
+          this.onMoveOut();
+        }
+      }
+
+      this.pointerInside = pointerInside;
+    });
+
+    _defineProperty(this, "onHandlerStateChange", ({
+      nativeEvent
+    }) => {
+      const {
+        state
+      } = nativeEvent;
+
+      if (state === State.CANCELLED || state === State.FAILED) {
+        // Need to handle case with external cancellation (e.g. by ScrollView)
+        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+      } else if ( // This platform check is an implication of slightly different behavior of handlers on different platform.
+      // And Android "Active" state is achieving on first move of a finger, not on press in.
+      // On iOS event on "Began" is not delivered.
+      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) && this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+        // Moving inside requires
+        this.handlePressIn();
+      } else if (state === State.END) {
+        const shouldCallOnPress = !this.longPressDetected && this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE && this.pressOutTimeout === null;
+        this.handleGoToUndetermined();
+
+        if (shouldCallOnPress) {
+          var _this$props$onPress, _this$props;
+
+          // Calls only inside component whether no long press was called previously
+          (_this$props$onPress = (_this$props = this.props).onPress) === null || _this$props$onPress === void 0 ? void 0 : _this$props$onPress.call(_this$props);
+        }
+      }
+    });
+
+    _defineProperty(this, "onLongPressDetected", () => {
+      var _this$props$onLongPre, _this$props2;
+
+      this.longPressDetected = true; // checked for in the caller of `onLongPressDetected`, but better to check twice
+
+      (_this$props$onLongPre = (_this$props2 = this.props).onLongPress) === null || _this$props$onLongPre === void 0 ? void 0 : _this$props$onLongPre.call(_this$props2);
+    });
+  }
+
+  // handlePressIn in called on first touch on traveling inside component.
+  // Handles state transition with delay.
+  handlePressIn() {
+    if (this.props.delayPressIn) {
+      this.pressInTimeout = setTimeout(() => {
+        this.moveToState(TOUCHABLE_STATE.BEGAN);
+        this.pressInTimeout = null;
+      }, this.props.delayPressIn);
+    } else {
+      this.moveToState(TOUCHABLE_STATE.BEGAN);
+    }
+
+    if (this.props.onLongPress) {
+      const time = (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);
+      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);
+    }
+  } // handleMoveOutside in called on traveling outside component.
+  // Handles state transition with delay.
+
+
+  handleMoveOutside() {
+    if (this.props.delayPressOut) {
+      this.pressOutTimeout = this.pressOutTimeout || setTimeout(() => {
+        this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
+        this.pressOutTimeout = null;
+      }, this.props.delayPressOut);
+    } else {
+      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);
+    }
+  } // handleGoToUndetermined transits to UNDETERMINED state with proper delay
+
+
+  handleGoToUndetermined() {
+    clearTimeout(this.pressOutTimeout); // TODO: maybe it can be undefined
+
+    if (this.props.delayPressOut) {
+      this.pressOutTimeout = setTimeout(() => {
+        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+          this.moveToState(TOUCHABLE_STATE.BEGAN);
+        }
+
+        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+        this.pressOutTimeout = null;
+      }, this.props.delayPressOut);
+    } else {
+      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
+        this.moveToState(TOUCHABLE_STATE.BEGAN);
+      }
+
+      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);
+    }
+  }
+
+  componentDidMount() {
+    this.reset();
+  } // reset timeout to prevent memory leaks.
+
+
+  reset() {
+    this.longPressDetected = false;
+    this.pointerInside = true;
+    clearTimeout(this.pressInTimeout);
+    clearTimeout(this.pressOutTimeout);
+    clearTimeout(this.longPressTimeout);
+    this.pressOutTimeout = null;
+    this.longPressTimeout = null;
+    this.pressInTimeout = null;
+  } // All states' transitions are defined here.
+
+
+  moveToState(newState) {
+    var _this$props$onStateCh, _this$props6;
+
+    if (newState === this.STATE) {
+      // Ignore dummy transitions
+      return;
+    }
+
+    if (newState === TOUCHABLE_STATE.BEGAN) {
+      var _this$props$onPressIn, _this$props3;
+
+      // First touch and moving inside
+      (_this$props$onPressIn = (_this$props3 = this.props).onPressIn) === null || _this$props$onPressIn === void 0 ? void 0 : _this$props$onPressIn.call(_this$props3);
+    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+      var _this$props$onPressOu, _this$props4;
+
+      // Moving outside
+      (_this$props$onPressOu = (_this$props4 = this.props).onPressOut) === null || _this$props$onPressOu === void 0 ? void 0 : _this$props$onPressOu.call(_this$props4);
+    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {
+      // Need to reset each time on transition to UNDETERMINED
+      this.reset();
+
+      if (this.STATE === TOUCHABLE_STATE.BEGAN) {
+        var _this$props$onPressOu2, _this$props5;
+
+        // ... and if it happens inside button.
+        (_this$props$onPressOu2 = (_this$props5 = this.props).onPressOut) === null || _this$props$onPressOu2 === void 0 ? void 0 : _this$props$onPressOu2.call(_this$props5);
+      }
+    } // Finally call lister (used by subclasses)
+
+
+    (_this$props$onStateCh = (_this$props6 = this.props).onStateChange) === null || _this$props$onStateCh === void 0 ? void 0 : _this$props$onStateCh.call(_this$props6, this.STATE, newState); // ... and make transition.
+
+    this.STATE = newState;
+  }
+
+  componentWillUnmount() {
+    // to prevent memory leaks
+    this.reset();
+  }
+
+  onMoveIn() {
+    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+      // This call is not throttled with delays (like in RN's implementation).
+      this.moveToState(TOUCHABLE_STATE.BEGAN);
+    }
+  }
+
+  onMoveOut() {
+    // long press should no longer be detected
+    clearTimeout(this.longPressTimeout);
+    this.longPressTimeout = null;
+
+    if (this.STATE === TOUCHABLE_STATE.BEGAN) {
+      this.handleMoveOutside();
+    }
+  }
+
+  render() {
+    const coreProps = {
+      accessible: this.props.accessible !== false,
+      accessibilityLabel: this.props.accessibilityLabel,
+      accessibilityHint: this.props.accessibilityHint,
+      accessibilityRole: this.props.accessibilityRole,
+      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,
+      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016
+      accessibilityState: this.props.accessibilityState,
+      nativeID: this.props.nativeID,
+      onLayout: this.props.onLayout,
+      hitSlop: this.props.hitSlop
+    };
+    return /*#__PURE__*/React.createElement(BaseButton, _extends({
+      style: this.props.containerStyle,
+      onHandlerStateChange: // TODO: not sure if it can be undefined instead of null
+      this.props.disabled ? undefined : this.onHandlerStateChange,
+      onGestureEvent: this.onGestureEvent,
+      hitSlop: this.props.hitSlop,
+      shouldActivateOnStart: this.props.shouldActivateOnStart,
+      disallowInterruption: this.props.disallowInterruption,
+      testID: this.props.testID
+    }, this.props.extraButtonProps), /*#__PURE__*/React.createElement(Animated.View, _extends({}, coreProps, {
+      style: this.props.style
+    }), this.props.children));
+  }
+
+}
+
+_defineProperty(GenericTouchable, "defaultProps", {
+  delayLongPress: 600,
+  extraButtonProps: {
+    rippleColor: 'transparent'
+  }
+});
+//# sourceMappingURL=GenericTouchable.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js.map
new file mode 100644
index 0000000..77f6132
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/GenericTouchable.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GenericTouchable.tsx"],"names":["React","Component","Animated","Platform","State","BaseButton","TOUCHABLE_STATE","UNDETERMINED","BEGAN","MOVED_OUTSIDE","GenericTouchable","nativeEvent","pointerInside","onMoveIn","onMoveOut","state","CANCELLED","FAILED","moveToState","OS","ACTIVE","STATE","handlePressIn","END","shouldCallOnPress","longPressDetected","pressOutTimeout","handleGoToUndetermined","props","onPress","onLongPress","delayPressIn","pressInTimeout","setTimeout","time","delayLongPress","longPressTimeout","onLongPressDetected","handleMoveOutside","delayPressOut","clearTimeout","componentDidMount","reset","newState","onPressIn","onPressOut","onStateChange","componentWillUnmount","render","coreProps","accessible","accessibilityLabel","accessibilityHint","accessibilityRole","accessibilityState","nativeID","onLayout","hitSlop","containerStyle","disabled","undefined","onHandlerStateChange","onGestureEvent","shouldActivateOnStart","disallowInterruption","testID","extraButtonProps","style","children","rippleColor"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport {\n  Animated,\n  Platform,\n  StyleProp,\n  ViewStyle,\n  TouchableWithoutFeedbackProps,\n} from 'react-native';\n\nimport { State } from '../../State';\nimport { BaseButton } from '../GestureButtons';\n\nimport {\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from '../../handlers/gestureHandlers';\nimport { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';\nimport { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';\n\n/**\n * Each touchable is a states' machine which preforms transitions.\n * On very beginning (and on the very end or recognition) touchable is\n * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger\n * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition\n * finishes in UNDETERMINED state.\n */\nexport const TOUCHABLE_STATE = {\n  UNDETERMINED: 0,\n  BEGAN: 1,\n  MOVED_OUTSIDE: 2,\n} as const;\n\ntype TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];\n\nexport interface GenericTouchableProps extends TouchableWithoutFeedbackProps {\n  // Decided to drop not used fields from RN's implementation.\n  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment\n\n  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too\n  onPress?: () => void;\n  onPressIn?: () => void;\n  onPressOut?: () => void;\n  onLongPress?: () => void;\n\n  nativeID?: string;\n  shouldActivateOnStart?: boolean;\n  disallowInterruption?: boolean;\n\n  containerStyle?: StyleProp<ViewStyle>;\n}\n\ninterface InternalProps {\n  extraButtonProps: TouchableNativeFeedbackExtraProps;\n  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;\n}\n\n// TODO: maybe can be better\n// TODO: all clearTimeout have ! added, maybe they shouldn't ?\ntype Timeout = ReturnType<typeof setTimeout> | null | undefined;\n\n/**\n * GenericTouchable is not intented to be used as it is.\n * Should be treated as a source for the rest of touchables\n */\n\nexport default class GenericTouchable extends Component<\n  GenericTouchableProps & InternalProps\n> {\n  static defaultProps = {\n    delayLongPress: 600,\n    extraButtonProps: {\n      rippleColor: 'transparent',\n    },\n  };\n\n  // timeout handlers\n  pressInTimeout: Timeout;\n  pressOutTimeout: Timeout;\n  longPressTimeout: Timeout;\n\n  // This flag is required since recognition of longPress implies not-invoking onPress\n  longPressDetected = false;\n\n  pointerInside = true;\n\n  // State of touchable\n  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;\n\n  // handlePressIn in called on first touch on traveling inside component.\n  // Handles state transition with delay.\n  handlePressIn() {\n    if (this.props.delayPressIn) {\n      this.pressInTimeout = setTimeout(() => {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n        this.pressInTimeout = null;\n      }, this.props.delayPressIn);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n    if (this.props.onLongPress) {\n      const time =\n        (this.props.delayPressIn || 0) + (this.props.delayLongPress || 0);\n      this.longPressTimeout = setTimeout(this.onLongPressDetected, time);\n    }\n  }\n  // handleMoveOutside in called on traveling outside component.\n  // Handles state transition with delay.\n  handleMoveOutside() {\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout =\n        this.pressOutTimeout ||\n        setTimeout(() => {\n          this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n          this.pressOutTimeout = null;\n        }, this.props.delayPressOut);\n    } else {\n      this.moveToState(TOUCHABLE_STATE.MOVED_OUTSIDE);\n    }\n  }\n\n  // handleGoToUndetermined transits to UNDETERMINED state with proper delay\n  handleGoToUndetermined() {\n    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined\n    if (this.props.delayPressOut) {\n      this.pressOutTimeout = setTimeout(() => {\n        if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n          this.moveToState(TOUCHABLE_STATE.BEGAN);\n        }\n        this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n        this.pressOutTimeout = null;\n      }, this.props.delayPressOut);\n    } else {\n      if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {\n        this.moveToState(TOUCHABLE_STATE.BEGAN);\n      }\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    }\n  }\n\n  componentDidMount() {\n    this.reset();\n  }\n  // reset timeout to prevent memory leaks.\n  reset() {\n    this.longPressDetected = false;\n    this.pointerInside = true;\n    clearTimeout(this.pressInTimeout!);\n    clearTimeout(this.pressOutTimeout!);\n    clearTimeout(this.longPressTimeout!);\n    this.pressOutTimeout = null;\n    this.longPressTimeout = null;\n    this.pressInTimeout = null;\n  }\n\n  // All states' transitions are defined here.\n  moveToState(newState: TouchableState) {\n    if (newState === this.STATE) {\n      // Ignore dummy transitions\n      return;\n    }\n    if (newState === TOUCHABLE_STATE.BEGAN) {\n      // First touch and moving inside\n      this.props.onPressIn?.();\n    } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // Moving outside\n      this.props.onPressOut?.();\n    } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {\n      // Need to reset each time on transition to UNDETERMINED\n      this.reset();\n      if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n        // ... and if it happens inside button.\n        this.props.onPressOut?.();\n      }\n    }\n    // Finally call lister (used by subclasses)\n    this.props.onStateChange?.(this.STATE, newState);\n    // ... and make transition.\n    this.STATE = newState;\n  }\n\n  onGestureEvent = ({\n    nativeEvent: { pointerInside },\n  }: GestureEvent<NativeViewGestureHandlerPayload>) => {\n    if (this.pointerInside !== pointerInside) {\n      if (pointerInside) {\n        this.onMoveIn();\n      } else {\n        this.onMoveOut();\n      }\n    }\n    this.pointerInside = pointerInside;\n  };\n\n  onHandlerStateChange = ({\n    nativeEvent,\n  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {\n    const { state } = nativeEvent;\n    if (state === State.CANCELLED || state === State.FAILED) {\n      // Need to handle case with external cancellation (e.g. by ScrollView)\n      this.moveToState(TOUCHABLE_STATE.UNDETERMINED);\n    } else if (\n      // This platform check is an implication of slightly different behavior of handlers on different platform.\n      // And Android \"Active\" state is achieving on first move of a finger, not on press in.\n      // On iOS event on \"Began\" is not delivered.\n      state === (Platform.OS !== 'android' ? State.ACTIVE : State.BEGAN) &&\n      this.STATE === TOUCHABLE_STATE.UNDETERMINED\n    ) {\n      // Moving inside requires\n      this.handlePressIn();\n    } else if (state === State.END) {\n      const shouldCallOnPress =\n        !this.longPressDetected &&\n        this.STATE !== TOUCHABLE_STATE.MOVED_OUTSIDE &&\n        this.pressOutTimeout === null;\n      this.handleGoToUndetermined();\n      if (shouldCallOnPress) {\n        // Calls only inside component whether no long press was called previously\n        this.props.onPress?.();\n      }\n    }\n  };\n\n  onLongPressDetected = () => {\n    this.longPressDetected = true;\n    // checked for in the caller of `onLongPressDetected`, but better to check twice\n    this.props.onLongPress?.();\n  };\n\n  componentWillUnmount() {\n    // to prevent memory leaks\n    this.reset();\n  }\n\n  onMoveIn() {\n    if (this.STATE === TOUCHABLE_STATE.MOVED_OUTSIDE) {\n      // This call is not throttled with delays (like in RN's implementation).\n      this.moveToState(TOUCHABLE_STATE.BEGAN);\n    }\n  }\n\n  onMoveOut() {\n    // long press should no longer be detected\n    clearTimeout(this.longPressTimeout!);\n    this.longPressTimeout = null;\n    if (this.STATE === TOUCHABLE_STATE.BEGAN) {\n      this.handleMoveOutside();\n    }\n  }\n\n  render() {\n    const coreProps = {\n      accessible: this.props.accessible !== false,\n      accessibilityLabel: this.props.accessibilityLabel,\n      accessibilityHint: this.props.accessibilityHint,\n      accessibilityRole: this.props.accessibilityRole,\n      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,\n      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016\n      accessibilityState: this.props.accessibilityState,\n      nativeID: this.props.nativeID,\n      onLayout: this.props.onLayout,\n      hitSlop: this.props.hitSlop,\n    };\n\n    return (\n      <BaseButton\n        style={this.props.containerStyle}\n        onHandlerStateChange={\n          // TODO: not sure if it can be undefined instead of null\n          this.props.disabled ? undefined : this.onHandlerStateChange\n        }\n        onGestureEvent={this.onGestureEvent}\n        hitSlop={this.props.hitSlop}\n        shouldActivateOnStart={this.props.shouldActivateOnStart}\n        disallowInterruption={this.props.disallowInterruption}\n        testID={this.props.testID}\n        {...this.props.extraButtonProps}>\n        <Animated.View {...coreProps} style={this.props.style}>\n          {this.props.children}\n        </Animated.View>\n      </BaseButton>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js
new file mode 100644
index 0000000..746af45
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js
@@ -0,0 +1,95 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import * as React from 'react';
+import { Component } from 'react';
+import GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';
+import { StyleSheet, View } from 'react-native';
+
+/**
+ * TouchableHighlight follows RN's implementation
+ */
+export default class TouchableHighlight extends Component {
+  constructor(props) {
+    super(props);
+
+    _defineProperty(this, "showUnderlay", () => {
+      var _this$props$onShowUnd, _this$props;
+
+      if (!this.hasPressHandler()) {
+        return;
+      }
+
+      this.setState({
+        extraChildStyle: {
+          opacity: this.props.activeOpacity
+        },
+        extraUnderlayStyle: {
+          backgroundColor: this.props.underlayColor
+        }
+      });
+      (_this$props$onShowUnd = (_this$props = this.props).onShowUnderlay) === null || _this$props$onShowUnd === void 0 ? void 0 : _this$props$onShowUnd.call(_this$props);
+    });
+
+    _defineProperty(this, "hasPressHandler", () => this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
+
+    _defineProperty(this, "hideUnderlay", () => {
+      var _this$props$onHideUnd, _this$props2;
+
+      this.setState({
+        extraChildStyle: null,
+        extraUnderlayStyle: null
+      });
+      (_this$props$onHideUnd = (_this$props2 = this.props).onHideUnderlay) === null || _this$props$onHideUnd === void 0 ? void 0 : _this$props$onHideUnd.call(_this$props2);
+    });
+
+    _defineProperty(this, "onStateChange", (_from, to) => {
+      if (to === TOUCHABLE_STATE.BEGAN) {
+        this.showUnderlay();
+      } else if (to === TOUCHABLE_STATE.UNDETERMINED || to === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+        this.hideUnderlay();
+      }
+    });
+
+    this.state = {
+      extraChildStyle: null,
+      extraUnderlayStyle: null
+    };
+  } // Copied from RN
+
+
+  renderChildren() {
+    if (!this.props.children) {
+      return /*#__PURE__*/React.createElement(View, null);
+    }
+
+    const child = React.Children.only(this.props.children); // TODO: not sure if OK but fixes error
+
+    return /*#__PURE__*/React.cloneElement(child, {
+      style: StyleSheet.compose(child.props.style, this.state.extraChildStyle)
+    });
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    const {
+      extraUnderlayStyle
+    } = this.state;
+    return /*#__PURE__*/React.createElement(GenericTouchable, _extends({}, rest, {
+      style: [style, extraUnderlayStyle],
+      onStateChange: this.onStateChange
+    }), this.renderChildren());
+  }
+
+}
+
+_defineProperty(TouchableHighlight, "defaultProps", { ...GenericTouchable.defaultProps,
+  activeOpacity: 0.85,
+  delayPressOut: 100,
+  underlayColor: 'black'
+});
+//# sourceMappingURL=TouchableHighlight.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js.map
new file mode 100644
index 0000000..7a5fed8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableHighlight.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableHighlight.tsx"],"names":["React","Component","GenericTouchable","TOUCHABLE_STATE","StyleSheet","View","TouchableHighlight","constructor","props","hasPressHandler","setState","extraChildStyle","opacity","activeOpacity","extraUnderlayStyle","backgroundColor","underlayColor","onShowUnderlay","onPress","onPressIn","onPressOut","onLongPress","onHideUnderlay","_from","to","BEGAN","showUnderlay","UNDETERMINED","MOVED_OUTSIDE","hideUnderlay","state","renderChildren","children","child","Children","only","cloneElement","style","compose","render","rest","onStateChange","defaultProps","delayPressOut"],"mappings":";;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,OAAOC,gBAAP,IAEEC,eAFF,QAGO,oBAHP;AAIA,SACEC,UADF,EAEEC,IAFF,QAMO,cANP;;AAiBA;AACA;AACA;AACA,eAAe,MAAMC,kBAAN,SAAiCL,SAAjC,CAGb;AAQAM,EAAAA,WAAW,CAACC,KAAD,EAAyD;AAClE,UAAMA,KAAN;;AADkE,0CASrD,MAAM;AAAA;;AACnB,UAAI,CAAC,KAAKC,eAAL,EAAL,EAA6B;AAC3B;AACD;;AACD,WAAKC,QAAL,CAAc;AACZC,QAAAA,eAAe,EAAE;AACfC,UAAAA,OAAO,EAAE,KAAKJ,KAAL,CAAWK;AADL,SADL;AAIZC,QAAAA,kBAAkB,EAAE;AAClBC,UAAAA,eAAe,EAAE,KAAKP,KAAL,CAAWQ;AADV;AAJR,OAAd;AAQA,mDAAKR,KAAL,EAAWS,cAAX;AACD,KAtBmE;;AAAA,6CAwBlD,MAChB,KAAKT,KAAL,CAAWU,OAAX,IACA,KAAKV,KAAL,CAAWW,SADX,IAEA,KAAKX,KAAL,CAAWY,UAFX,IAGA,KAAKZ,KAAL,CAAWa,WA5BuD;;AAAA,0CA8BrD,MAAM;AAAA;;AACnB,WAAKX,QAAL,CAAc;AACZC,QAAAA,eAAe,EAAE,IADL;AAEZG,QAAAA,kBAAkB,EAAE;AAFR,OAAd;AAIA,oDAAKN,KAAL,EAAWc,cAAX;AACD,KApCmE;;AAAA,2CAmDpD,CAACC,KAAD,EAAgBC,EAAhB,KAA+B;AAC7C,UAAIA,EAAE,KAAKrB,eAAe,CAACsB,KAA3B,EAAkC;AAChC,aAAKC,YAAL;AACD,OAFD,MAEO,IACLF,EAAE,KAAKrB,eAAe,CAACwB,YAAvB,IACAH,EAAE,KAAKrB,eAAe,CAACyB,aAFlB,EAGL;AACA,aAAKC,YAAL;AACD;AACF,KA5DmE;;AAElE,SAAKC,KAAL,GAAa;AACXnB,MAAAA,eAAe,EAAE,IADN;AAEXG,MAAAA,kBAAkB,EAAE;AAFT,KAAb;AAID,GAdD,CAgBA;;;AA8BAiB,EAAAA,cAAc,GAAG;AACf,QAAI,CAAC,KAAKvB,KAAL,CAAWwB,QAAhB,EAA0B;AACxB,0BAAO,oBAAC,IAAD,OAAP;AACD;;AAED,UAAMC,KAAK,GAAGjC,KAAK,CAACkC,QAAN,CAAeC,IAAf,CACZ,KAAK3B,KAAL,CAAWwB,QADC,CAAd,CALe,CAOqB;;AACpC,wBAAOhC,KAAK,CAACoC,YAAN,CAAmBH,KAAnB,EAA0B;AAC/BI,MAAAA,KAAK,EAAEjC,UAAU,CAACkC,OAAX,CAAmBL,KAAK,CAACzB,KAAN,CAAY6B,KAA/B,EAAsC,KAAKP,KAAL,CAAWnB,eAAjD;AADwB,KAA1B,CAAP;AAGD;;AAaD4B,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEF,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGG;AAAjB,QAA0B,KAAKhC,KAArC;AACA,UAAM;AAAEM,MAAAA;AAAF,QAAyB,KAAKgB,KAApC;AACA,wBACE,oBAAC,gBAAD,eACMU,IADN;AAEE,MAAA,KAAK,EAAE,CAACH,KAAD,EAAQvB,kBAAR,CAFT;AAGE,MAAA,aAAa,EAAE,KAAK2B;AAHtB,QAIG,KAAKV,cAAL,EAJH,CADF;AAQD;;AAjFD;;gBAHmBzB,kB,kBAIG,EACpB,GAAGJ,gBAAgB,CAACwC,YADA;AAEpB7B,EAAAA,aAAa,EAAE,IAFK;AAGpB8B,EAAAA,aAAa,EAAE,GAHK;AAIpB3B,EAAAA,aAAa,EAAE;AAJK,C","sourcesContent":["import * as React from 'react';\nimport { Component } from 'react';\nimport GenericTouchable, {\n  GenericTouchableProps,\n  TOUCHABLE_STATE,\n} from './GenericTouchable';\nimport {\n  StyleSheet,\n  View,\n  TouchableHighlightProps,\n  ColorValue,\n  ViewProps,\n} from 'react-native';\n\ninterface State {\n  extraChildStyle: null | {\n    opacity?: number;\n  };\n  extraUnderlayStyle: null | {\n    backgroundColor?: ColorValue;\n  };\n}\n\n/**\n * TouchableHighlight follows RN's implementation\n */\nexport default class TouchableHighlight extends Component<\n  TouchableHighlightProps & GenericTouchableProps,\n  State\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.85,\n    delayPressOut: 100,\n    underlayColor: 'black',\n  };\n\n  constructor(props: TouchableHighlightProps & GenericTouchableProps) {\n    super(props);\n    this.state = {\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    };\n  }\n\n  // Copied from RN\n  showUnderlay = () => {\n    if (!this.hasPressHandler()) {\n      return;\n    }\n    this.setState({\n      extraChildStyle: {\n        opacity: this.props.activeOpacity,\n      },\n      extraUnderlayStyle: {\n        backgroundColor: this.props.underlayColor,\n      },\n    });\n    this.props.onShowUnderlay?.();\n  };\n\n  hasPressHandler = () =>\n    this.props.onPress ||\n    this.props.onPressIn ||\n    this.props.onPressOut ||\n    this.props.onLongPress;\n\n  hideUnderlay = () => {\n    this.setState({\n      extraChildStyle: null,\n      extraUnderlayStyle: null,\n    });\n    this.props.onHideUnderlay?.();\n  };\n\n  renderChildren() {\n    if (!this.props.children) {\n      return <View />;\n    }\n\n    const child = React.Children.only(\n      this.props.children\n    ) as React.ReactElement<ViewProps>; // TODO: not sure if OK but fixes error\n    return React.cloneElement(child, {\n      style: StyleSheet.compose(child.props.style, this.state.extraChildStyle),\n    });\n  }\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.showUnderlay();\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.hideUnderlay();\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    const { extraUnderlayStyle } = this.state;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[style, extraUnderlayStyle]}\n        onStateChange={this.onStateChange}>\n        {this.renderChildren()}\n      </GenericTouchable>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js
new file mode 100644
index 0000000..8922c64
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js
@@ -0,0 +1,84 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { Platform } from 'react-native';
+import * as React from 'react';
+import { Component } from 'react';
+import GenericTouchable from './GenericTouchable';
+
+/**
+ * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.
+ * There's small difference with handling long press ripple since RN's implementation calls
+ * ripple animation via bridge. This solution leaves all animations' handling for native components so
+ * it follows native behaviours.
+ */
+export default class TouchableNativeFeedback extends Component {
+  // could be taken as RNTouchableNativeFeedback.SelectableBackground etc. but the API may change
+  getExtraButtonProps() {
+    const extraProps = {};
+    const {
+      background
+    } = this.props;
+
+    if (background) {
+      // I changed type values to match those used in RN
+      // TODO(TS): check if it works the same as previous implementation - looks like it works the same as RN component, so it should be ok
+      if (background.type === 'RippleAndroid') {
+        extraProps['borderless'] = background.borderless;
+        extraProps['rippleColor'] = background.color;
+      } else if (background.type === 'ThemeAttrAndroid') {
+        extraProps['borderless'] = background.attribute === 'selectableItemBackgroundBorderless';
+      } // I moved it from above since it should be available in all options
+
+
+      extraProps['rippleRadius'] = background.rippleRadius;
+    }
+
+    extraProps['foreground'] = this.props.useForeground;
+    return extraProps;
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(GenericTouchable, _extends({}, rest, {
+      style: style,
+      extraButtonProps: this.getExtraButtonProps()
+    }));
+  }
+
+}
+
+_defineProperty(TouchableNativeFeedback, "defaultProps", { ...GenericTouchable.defaultProps,
+  useForeground: true,
+  extraButtonProps: {
+    // Disable hiding ripple on Android
+    rippleColor: null
+  }
+});
+
+_defineProperty(TouchableNativeFeedback, "SelectableBackground", rippleRadius => ({
+  type: 'ThemeAttrAndroid',
+  // I added `attribute` prop to clone the implementation of RN and be able to use only 2 types
+  attribute: 'selectableItemBackground',
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "SelectableBackgroundBorderless", rippleRadius => ({
+  type: 'ThemeAttrAndroid',
+  attribute: 'selectableItemBackgroundBorderless',
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "Ripple", (color, borderless, rippleRadius) => ({
+  type: 'RippleAndroid',
+  color,
+  borderless,
+  rippleRadius
+}));
+
+_defineProperty(TouchableNativeFeedback, "canUseNativeForeground", () => Platform.Version >= 23);
+//# sourceMappingURL=TouchableNativeFeedback.android.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js.map
new file mode 100644
index 0000000..b5cb68b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.android.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableNativeFeedback.android.tsx"],"names":["Platform","React","Component","GenericTouchable","TouchableNativeFeedback","getExtraButtonProps","extraProps","background","props","type","borderless","color","attribute","rippleRadius","useForeground","render","style","rest","defaultProps","extraButtonProps","rippleColor","Version"],"mappings":";;;;AAAA,SACEA,QADF,QAIO,cAJP;AAKA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,OAAOC,gBAAP,MAAwD,oBAAxD;;AASA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAMC,uBAAN,SAAsCF,SAAtC,CAEb;AAUA;AAyBAG,EAAAA,mBAAmB,GAAG;AACpB,UAAMC,UAA6C,GAAG,EAAtD;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAiB,KAAKC,KAA5B;;AACA,QAAID,UAAJ,EAAgB;AACd;AACA;AACA,UAAIA,UAAU,CAACE,IAAX,KAAoB,eAAxB,EAAyC;AACvCH,QAAAA,UAAU,CAAC,YAAD,CAAV,GAA2BC,UAAU,CAACG,UAAtC;AACAJ,QAAAA,UAAU,CAAC,aAAD,CAAV,GAA4BC,UAAU,CAACI,KAAvC;AACD,OAHD,MAGO,IAAIJ,UAAU,CAACE,IAAX,KAAoB,kBAAxB,EAA4C;AACjDH,QAAAA,UAAU,CAAC,YAAD,CAAV,GACEC,UAAU,CAACK,SAAX,KAAyB,oCAD3B;AAED,OATa,CAUd;;;AACAN,MAAAA,UAAU,CAAC,cAAD,CAAV,GAA6BC,UAAU,CAACM,YAAxC;AACD;;AACDP,IAAAA,UAAU,CAAC,YAAD,CAAV,GAA2B,KAAKE,KAAL,CAAWM,aAAtC;AACA,WAAOR,UAAP;AACD;;AACDS,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEC,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGC;AAAjB,QAA0B,KAAKT,KAArC;AACA,wBACE,oBAAC,gBAAD,eACMS,IADN;AAEE,MAAA,KAAK,EAAED,KAFT;AAGE,MAAA,gBAAgB,EAAE,KAAKX,mBAAL;AAHpB,OADF;AAOD;;AA/DD;;gBAFmBD,uB,kBAGG,EACpB,GAAGD,gBAAgB,CAACe,YADA;AAEpBJ,EAAAA,aAAa,EAAE,IAFK;AAGpBK,EAAAA,gBAAgB,EAAE;AAChB;AACAC,IAAAA,WAAW,EAAE;AAFG;AAHE,C;;gBAHHhB,uB,0BAaYS,YAAD,KAA4B;AACxDJ,EAAAA,IAAI,EAAE,kBADkD;AAExD;AACAG,EAAAA,SAAS,EAAE,0BAH6C;AAIxDC,EAAAA;AAJwD,CAA5B,C;;gBAbXT,uB,oCAmBsBS,YAAD,KAA4B;AAClEJ,EAAAA,IAAI,EAAE,kBAD4D;AAElEG,EAAAA,SAAS,EAAE,oCAFuD;AAGlEC,EAAAA;AAHkE,CAA5B,C;;gBAnBrBT,uB,YAwBH,CACdO,KADc,EAEdD,UAFc,EAGdG,YAHc,MAIV;AACJJ,EAAAA,IAAI,EAAE,eADF;AAEJE,EAAAA,KAFI;AAGJD,EAAAA,UAHI;AAIJG,EAAAA;AAJI,CAJU,C;;gBAxBGT,uB,4BAmCa,MAAMJ,QAAQ,CAACqB,OAAT,IAAoB,E","sourcesContent":["import {\n  Platform,\n  TouchableNativeFeedbackProps,\n  ColorValue,\n} from 'react-native';\nimport * as React from 'react';\nimport { Component } from 'react';\nimport GenericTouchable, { GenericTouchableProps } from './GenericTouchable';\n\nexport type TouchableNativeFeedbackExtraProps = {\n  borderless?: boolean;\n  rippleColor?: number | null;\n  rippleRadius?: number | null;\n  foreground?: boolean;\n};\n\n/**\n * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.\n * There's small difference with handling long press ripple since RN's implementation calls\n * ripple animation via bridge. This solution leaves all animations' handling for native components so\n * it follows native behaviours.\n */\nexport default class TouchableNativeFeedback extends Component<\n  TouchableNativeFeedbackProps & GenericTouchableProps\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    useForeground: true,\n    extraButtonProps: {\n      // Disable hiding ripple on Android\n      rippleColor: null,\n    },\n  };\n\n  // could be taken as RNTouchableNativeFeedback.SelectableBackground etc. but the API may change\n  static SelectableBackground = (rippleRadius?: number) => ({\n    type: 'ThemeAttrAndroid',\n    // I added `attribute` prop to clone the implementation of RN and be able to use only 2 types\n    attribute: 'selectableItemBackground',\n    rippleRadius,\n  });\n  static SelectableBackgroundBorderless = (rippleRadius?: number) => ({\n    type: 'ThemeAttrAndroid',\n    attribute: 'selectableItemBackgroundBorderless',\n    rippleRadius,\n  });\n  static Ripple = (\n    color: ColorValue,\n    borderless: boolean,\n    rippleRadius?: number\n  ) => ({\n    type: 'RippleAndroid',\n    color,\n    borderless,\n    rippleRadius,\n  });\n\n  static canUseNativeForeground = () => Platform.Version >= 23;\n\n  getExtraButtonProps() {\n    const extraProps: TouchableNativeFeedbackExtraProps = {};\n    const { background } = this.props;\n    if (background) {\n      // I changed type values to match those used in RN\n      // TODO(TS): check if it works the same as previous implementation - looks like it works the same as RN component, so it should be ok\n      if (background.type === 'RippleAndroid') {\n        extraProps['borderless'] = background.borderless;\n        extraProps['rippleColor'] = background.color;\n      } else if (background.type === 'ThemeAttrAndroid') {\n        extraProps['borderless'] =\n          background.attribute === 'selectableItemBackgroundBorderless';\n      }\n      // I moved it from above since it should be available in all options\n      extraProps['rippleRadius'] = background.rippleRadius;\n    }\n    extraProps['foreground'] = this.props.useForeground;\n    return extraProps;\n  }\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={style}\n        extraButtonProps={this.getExtraButtonProps()}\n      />\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js
new file mode 100644
index 0000000..d75a3e2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js
@@ -0,0 +1,3 @@
+import { TouchableNativeFeedback } from 'react-native';
+export default TouchableNativeFeedback;
+//# sourceMappingURL=TouchableNativeFeedback.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js.map
new file mode 100644
index 0000000..aaa81ba
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableNativeFeedback.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableNativeFeedback.tsx"],"names":["TouchableNativeFeedback"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,cAAxC;AAEA,eAAeA,uBAAf","sourcesContent":["import { TouchableNativeFeedback } from 'react-native';\n\nexport default TouchableNativeFeedback;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js
new file mode 100644
index 0000000..c580f03
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js
@@ -0,0 +1,61 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import { Animated, Easing, StyleSheet, View } from 'react-native';
+import GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';
+import * as React from 'react';
+import { Component } from 'react';
+/**
+ * TouchableOpacity bases on timing animation which has been used in RN's core
+ */
+
+export default class TouchableOpacity extends Component {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "getChildStyleOpacityWithDefault", () => {
+      const childStyle = StyleSheet.flatten(this.props.style) || {};
+      return childStyle.opacity == null ? 1 : childStyle.opacity;
+    });
+
+    _defineProperty(this, "opacity", new Animated.Value(this.getChildStyleOpacityWithDefault()));
+
+    _defineProperty(this, "setOpacityTo", (value, duration) => {
+      Animated.timing(this.opacity, {
+        toValue: value,
+        duration: duration,
+        easing: Easing.inOut(Easing.quad),
+        useNativeDriver: true
+      }).start();
+    });
+
+    _defineProperty(this, "onStateChange", (_from, to) => {
+      if (to === TOUCHABLE_STATE.BEGAN) {
+        this.setOpacityTo(this.props.activeOpacity, 0);
+      } else if (to === TOUCHABLE_STATE.UNDETERMINED || to === TOUCHABLE_STATE.MOVED_OUTSIDE) {
+        this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);
+      }
+    });
+  }
+
+  render() {
+    const {
+      style = {},
+      ...rest
+    } = this.props;
+    return /*#__PURE__*/React.createElement(GenericTouchable, _extends({}, rest, {
+      style: [style, {
+        opacity: this.opacity // TODO: fix this
+
+      }],
+      onStateChange: this.onStateChange
+    }), this.props.children ? this.props.children : /*#__PURE__*/React.createElement(View, null));
+  }
+
+}
+
+_defineProperty(TouchableOpacity, "defaultProps", { ...GenericTouchable.defaultProps,
+  activeOpacity: 0.2
+});
+//# sourceMappingURL=TouchableOpacity.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js.map
new file mode 100644
index 0000000..00f4c91
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableOpacity.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableOpacity.tsx"],"names":["Animated","Easing","StyleSheet","View","GenericTouchable","TOUCHABLE_STATE","React","Component","TouchableOpacity","childStyle","flatten","props","style","opacity","Value","getChildStyleOpacityWithDefault","value","duration","timing","toValue","easing","inOut","quad","useNativeDriver","start","_from","to","BEGAN","setOpacityTo","activeOpacity","UNDETERMINED","MOVED_OUTSIDE","render","rest","onStateChange","children","defaultProps"],"mappings":";;;;AAAA,SACEA,QADF,EAEEC,MAFF,EAGEC,UAHF,EAIEC,IAJF,QAMO,cANP;AAOA,OAAOC,gBAAP,IACEC,eADF,QAGO,oBAHP;AAIA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA;AACA;AACA;;AACA,eAAe,MAAMC,gBAAN,SAA+BD,SAA/B,CAEb;AAAA;AAAA;;AAAA,6DAOkC,MAAM;AACtC,YAAME,UAAU,GAAGP,UAAU,CAACQ,OAAX,CAAmB,KAAKC,KAAL,CAAWC,KAA9B,KAAwC,EAA3D;AACA,aAAOH,UAAU,CAACI,OAAX,IAAsB,IAAtB,GAA6B,CAA7B,GAAiCJ,UAAU,CAACI,OAAnD;AACD,KAVD;;AAAA,qCAYU,IAAIb,QAAQ,CAACc,KAAb,CAAmB,KAAKC,+BAAL,EAAnB,CAZV;;AAAA,0CAce,CAACC,KAAD,EAAgBC,QAAhB,KAAqC;AAClDjB,MAAAA,QAAQ,CAACkB,MAAT,CAAgB,KAAKL,OAArB,EAA8B;AAC5BM,QAAAA,OAAO,EAAEH,KADmB;AAE5BC,QAAAA,QAAQ,EAAEA,QAFkB;AAG5BG,QAAAA,MAAM,EAAEnB,MAAM,CAACoB,KAAP,CAAapB,MAAM,CAACqB,IAApB,CAHoB;AAI5BC,QAAAA,eAAe,EAAE;AAJW,OAA9B,EAKGC,KALH;AAMD,KArBD;;AAAA,2CAuBgB,CAACC,KAAD,EAAgBC,EAAhB,KAA+B;AAC7C,UAAIA,EAAE,KAAKrB,eAAe,CAACsB,KAA3B,EAAkC;AAChC,aAAKC,YAAL,CAAkB,KAAKjB,KAAL,CAAWkB,aAA7B,EAA6C,CAA7C;AACD,OAFD,MAEO,IACLH,EAAE,KAAKrB,eAAe,CAACyB,YAAvB,IACAJ,EAAE,KAAKrB,eAAe,CAAC0B,aAFlB,EAGL;AACA,aAAKH,YAAL,CAAkB,KAAKb,+BAAL,EAAlB,EAA0D,GAA1D;AACD;AACF,KAhCD;AAAA;;AAkCAiB,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEpB,MAAAA,KAAK,GAAG,EAAV;AAAc,SAAGqB;AAAjB,QAA0B,KAAKtB,KAArC;AACA,wBACE,oBAAC,gBAAD,eACMsB,IADN;AAEE,MAAA,KAAK,EAAE,CACLrB,KADK,EAEL;AACEC,QAAAA,OAAO,EAAG,KAAKA,OADjB,CACgD;;AADhD,OAFK,CAFT;AAQE,MAAA,aAAa,EAAE,KAAKqB;AARtB,QASG,KAAKvB,KAAL,CAAWwB,QAAX,GAAsB,KAAKxB,KAAL,CAAWwB,QAAjC,gBAA4C,oBAAC,IAAD,OAT/C,CADF;AAaD;;AAjDD;;gBAFmB3B,gB,kBAGG,EACpB,GAAGJ,gBAAgB,CAACgC,YADA;AAEpBP,EAAAA,aAAa,EAAE;AAFK,C","sourcesContent":["import {\n  Animated,\n  Easing,\n  StyleSheet,\n  View,\n  TouchableOpacityProps,\n} from 'react-native';\nimport GenericTouchable, {\n  TOUCHABLE_STATE,\n  GenericTouchableProps,\n} from './GenericTouchable';\nimport * as React from 'react';\nimport { Component } from 'react';\n\n/**\n * TouchableOpacity bases on timing animation which has been used in RN's core\n */\nexport default class TouchableOpacity extends Component<\n  TouchableOpacityProps & GenericTouchableProps\n> {\n  static defaultProps = {\n    ...GenericTouchable.defaultProps,\n    activeOpacity: 0.2,\n  };\n\n  // opacity is 1 one by default but could be overwritten\n  getChildStyleOpacityWithDefault = () => {\n    const childStyle = StyleSheet.flatten(this.props.style) || {};\n    return childStyle.opacity == null ? 1 : childStyle.opacity;\n  };\n\n  opacity = new Animated.Value(this.getChildStyleOpacityWithDefault());\n\n  setOpacityTo = (value: number, duration: number) => {\n    Animated.timing(this.opacity, {\n      toValue: value,\n      duration: duration,\n      easing: Easing.inOut(Easing.quad),\n      useNativeDriver: true,\n    }).start();\n  };\n\n  onStateChange = (_from: number, to: number) => {\n    if (to === TOUCHABLE_STATE.BEGAN) {\n      this.setOpacityTo(this.props.activeOpacity!, 0);\n    } else if (\n      to === TOUCHABLE_STATE.UNDETERMINED ||\n      to === TOUCHABLE_STATE.MOVED_OUTSIDE\n    ) {\n      this.setOpacityTo(this.getChildStyleOpacityWithDefault(), 150);\n    }\n  };\n\n  render() {\n    const { style = {}, ...rest } = this.props;\n    return (\n      <GenericTouchable\n        {...rest}\n        style={[\n          style,\n          {\n            opacity: (this.opacity as unknown) as number, // TODO: fix this\n          },\n        ]}\n        onStateChange={this.onStateChange}>\n        {this.props.children ? this.props.children : <View />}\n      </GenericTouchable>\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js
new file mode 100644
index 0000000..163396a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js
@@ -0,0 +1,10 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+import * as React from 'react';
+import GenericTouchable from './GenericTouchable';
+const TouchableWithoutFeedback = /*#__PURE__*/React.forwardRef((props, ref) => /*#__PURE__*/React.createElement(GenericTouchable, _extends({
+  ref: ref
+}, props)));
+TouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;
+export default TouchableWithoutFeedback;
+//# sourceMappingURL=TouchableWithoutFeedback.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js.map
new file mode 100644
index 0000000..082ee5e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/TouchableWithoutFeedback.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TouchableWithoutFeedback.tsx"],"names":["React","GenericTouchable","TouchableWithoutFeedback","forwardRef","props","ref","defaultProps"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,OAAOC,gBAAP,MAAwD,oBAAxD;AAEA,MAAMC,wBAAwB,gBAAGF,KAAK,CAACG,UAAN,CAG/B,CAACC,KAAD,EAAQC,GAAR,kBAAgB,oBAAC,gBAAD;AAAkB,EAAA,GAAG,EAAEA;AAAvB,GAAgCD,KAAhC,EAHe,CAAjC;AAKAF,wBAAwB,CAACI,YAAzB,GAAwCL,gBAAgB,CAACK,YAAzD;AAEA,eAAeJ,wBAAf","sourcesContent":["import * as React from 'react';\nimport { PropsWithChildren } from 'react';\nimport GenericTouchable, { GenericTouchableProps } from './GenericTouchable';\n\nconst TouchableWithoutFeedback = React.forwardRef<\n  GenericTouchable,\n  PropsWithChildren<GenericTouchableProps>\n>((props, ref) => <GenericTouchable ref={ref} {...props} />);\n\nTouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;\n\nexport default TouchableWithoutFeedback;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js b/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js
new file mode 100644
index 0000000..cd5165e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js
@@ -0,0 +1,5 @@
+export { default as TouchableNativeFeedback } from './TouchableNativeFeedback';
+export { default as TouchableWithoutFeedback } from './TouchableWithoutFeedback';
+export { default as TouchableOpacity } from './TouchableOpacity';
+export { default as TouchableHighlight } from './TouchableHighlight';
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js.map b/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js.map
new file mode 100644
index 0000000..9e6c56c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/components/touchables/index.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["index.ts"],"names":["default","TouchableNativeFeedback","TouchableWithoutFeedback","TouchableOpacity","TouchableHighlight"],"mappings":"AAAA,SAASA,OAAO,IAAIC,uBAApB,QAAmD,2BAAnD;AACA,SAASD,OAAO,IAAIE,wBAApB,QAAoD,4BAApD;AACA,SAASF,OAAO,IAAIG,gBAApB,QAA4C,oBAA5C;AACA,SAASH,OAAO,IAAII,kBAApB,QAA8C,sBAA9C","sourcesContent":["export { default as TouchableNativeFeedback } from './TouchableNativeFeedback';\nexport { default as TouchableWithoutFeedback } from './TouchableWithoutFeedback';\nexport { default as TouchableOpacity } from './TouchableOpacity';\nexport { default as TouchableHighlight } from './TouchableHighlight';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js b/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js
new file mode 100644
index 0000000..26c6c04
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js
@@ -0,0 +1,21 @@
+import * as React from 'react';
+import { StyleSheet } from 'react-native';
+import hoistNonReactStatics from 'hoist-non-react-statics';
+import GestureHandlerRootView from './GestureHandlerRootView';
+export default function gestureHandlerRootHOC(Component, containerStyles) {
+  function Wrapper(props) {
+    return /*#__PURE__*/React.createElement(GestureHandlerRootView, {
+      style: [styles.container, containerStyles]
+    }, /*#__PURE__*/React.createElement(Component, props));
+  }
+
+  Wrapper.displayName = "gestureHandlerRootHOC(".concat(Component.displayName || Component.name, ")");
+  hoistNonReactStatics(Wrapper, Component);
+  return Wrapper;
+}
+const styles = StyleSheet.create({
+  container: {
+    flex: 1
+  }
+});
+//# sourceMappingURL=gestureHandlerRootHOC.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js.map b/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js.map
new file mode 100644
index 0000000..7af4224
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/gestureHandlerRootHOC.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["gestureHandlerRootHOC.tsx"],"names":["React","StyleSheet","hoistNonReactStatics","GestureHandlerRootView","gestureHandlerRootHOC","Component","containerStyles","Wrapper","props","styles","container","displayName","name","create","flex"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,UAAT,QAAiD,cAAjD;AACA,OAAOC,oBAAP,MAAiC,yBAAjC;AACA,OAAOC,sBAAP,MAAmC,0BAAnC;AAEA,eAAe,SAASC,qBAAT,CACbC,SADa,EAEbC,eAFa,EAGW;AACxB,WAASC,OAAT,CAAiBC,KAAjB,EAA2B;AACzB,wBACE,oBAAC,sBAAD;AAAwB,MAAA,KAAK,EAAE,CAACC,MAAM,CAACC,SAAR,EAAmBJ,eAAnB;AAA/B,oBACE,oBAAC,SAAD,EAAeE,KAAf,CADF,CADF;AAKD;;AAEDD,EAAAA,OAAO,CAACI,WAAR,mCACEN,SAAS,CAACM,WAAV,IAAyBN,SAAS,CAACO,IADrC;AAIAV,EAAAA,oBAAoB,CAACK,OAAD,EAAUF,SAAV,CAApB;AAEA,SAAOE,OAAP;AACD;AAED,MAAME,MAAM,GAAGR,UAAU,CAACY,MAAX,CAAkB;AAC/BH,EAAAA,SAAS,EAAE;AAAEI,IAAAA,IAAI,EAAE;AAAR;AADoB,CAAlB,CAAf","sourcesContent":["import * as React from 'react';\nimport { StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport GestureHandlerRootView from './GestureHandlerRootView';\n\nexport default function gestureHandlerRootHOC<P>(\n  Component: React.ComponentType<P>,\n  containerStyles?: StyleProp<ViewStyle>\n): React.ComponentType<P> {\n  function Wrapper(props: P) {\n    return (\n      <GestureHandlerRootView style={[styles.container, containerStyles]}>\n        <Component {...props} />\n      </GestureHandlerRootView>\n    );\n  }\n\n  Wrapper.displayName = `gestureHandlerRootHOC(${\n    Component.displayName || Component.name\n  })`;\n\n  hoistNonReactStatics(Wrapper, Component);\n\n  return Wrapper;\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 },\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js
new file mode 100644
index 0000000..b9ba945
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js
@@ -0,0 +1,10 @@
+import createHandler from './createHandler';
+import { baseProps } from './gestureHandlers';
+export const nativeViewProps = [...baseProps, 'shouldActivateOnStart', 'disallowInterruption'];
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlers.ts file
+export const NativeViewGestureHandler = createHandler({
+  name: 'NativeViewGestureHandler',
+  allowedProps: nativeViewProps,
+  config: {}
+});
+//# sourceMappingURL=NativeViewGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js.map
new file mode 100644
index 0000000..aa0e4e1
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/NativeViewGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NativeViewGestureHandler.ts"],"names":["createHandler","baseProps","nativeViewProps","NativeViewGestureHandler","name","allowedProps","config"],"mappings":"AAAA,OAAOA,aAAP,MAA0B,iBAA1B;AACA,SAAkCC,SAAlC,QAAmD,mBAAnD;AAYA,OAAO,MAAMC,eAAe,GAAG,CAC7B,GAAGD,SAD0B,EAE7B,uBAF6B,EAG7B,sBAH6B,CAAxB;AAOP;AACA,OAAO,MAAME,wBAAwB,GAAGH,aAAa,CAGnD;AACAI,EAAAA,IAAI,EAAE,0BADN;AAEAC,EAAAA,YAAY,EAAEH,eAFd;AAGAI,EAAAA,MAAM,EAAE;AAHR,CAHmD,CAA9C","sourcesContent":["import createHandler from './createHandler';\nimport { BaseGestureHandlerProps, baseProps } from './gestureHandlers';\n\nexport interface NativeViewGestureHandlerProps\n  extends BaseGestureHandlerProps<NativeViewGestureHandlerPayload> {\n  shouldActivateOnStart?: boolean;\n  disallowInterruption?: boolean;\n}\n\nexport type NativeViewGestureHandlerPayload = {\n  pointerInside: boolean;\n};\n\nexport const nativeViewProps = [\n  ...baseProps,\n  'shouldActivateOnStart',\n  'disallowInterruption',\n] as const;\n\nexport type NativeViewGestureHandler = typeof NativeViewGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlers.ts file\nexport const NativeViewGestureHandler = createHandler<\n  NativeViewGestureHandlerProps,\n  NativeViewGestureHandlerPayload\n>({\n  name: 'NativeViewGestureHandler',\n  allowedProps: nativeViewProps,\n  config: {},\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js b/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js
new file mode 100644
index 0000000..f59640b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js
@@ -0,0 +1,383 @@
+var _UIManager$getViewMan, _UIManager$getViewMan2, _UIManager$getConstan;
+
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import * as React from 'react';
+import { findNodeHandle as findNodeHandleRN, NativeModules, Platform, Touchable } from 'react-native'; // @ts-ignore - it isn't typed by TS & don't have definitelyTyped types
+
+import deepEqual from 'fbjs/lib/areEqual';
+import RNGestureHandlerModule from '../RNGestureHandlerModule';
+import { State } from '../State';
+
+function findNodeHandle(node) {
+  if (Platform.OS === 'web') return node;
+  return findNodeHandleRN(node);
+}
+
+const {
+  UIManager = {}
+} = NativeModules;
+const customGHEventsConfig = {
+  onGestureHandlerEvent: {
+    registrationName: 'onGestureHandlerEvent'
+  },
+  onGestureHandlerStateChange: {
+    registrationName: 'onGestureHandlerStateChange'
+  }
+}; // Add gesture specific events to genericDirectEventTypes object exported from UIManager
+// native module.
+// Once new event types are registered with react it is possible to dispatch these
+// events to all kind of native views.
+
+UIManager.genericDirectEventTypes = { ...UIManager.genericDirectEventTypes,
+  ...customGHEventsConfig
+}; // In newer versions of RN the `genericDirectEventTypes` is located in the object
+// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make
+// it compatible with RN 61+
+
+const UIManagerConstants = (_UIManager$getViewMan = (_UIManager$getViewMan2 = UIManager.getViewManagerConfig) === null || _UIManager$getViewMan2 === void 0 ? void 0 : _UIManager$getViewMan2.call(UIManager, 'getConstants')) !== null && _UIManager$getViewMan !== void 0 ? _UIManager$getViewMan : (_UIManager$getConstan = UIManager.getConstants) === null || _UIManager$getConstan === void 0 ? void 0 : _UIManager$getConstan.call(UIManager);
+
+if (UIManagerConstants) {
+  UIManagerConstants.genericDirectEventTypes = { ...UIManagerConstants.genericDirectEventTypes,
+    ...customGHEventsConfig
+  };
+} // Wrap JS responder calls and notify gesture handler manager
+
+
+const {
+  setJSResponder: oldSetJSResponder = () => {//no operation
+  },
+  clearJSResponder: oldClearJSResponder = () => {//no operation
+  }
+} = UIManager;
+
+UIManager.setJSResponder = (tag, blockNativeResponder) => {
+  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);
+  oldSetJSResponder(tag, blockNativeResponder);
+};
+
+UIManager.clearJSResponder = () => {
+  RNGestureHandlerModule.handleClearJSResponder();
+  oldClearJSResponder();
+};
+
+let handlerTag = 1;
+const handlerIDToTag = {};
+
+function isConfigParam(param, name) {
+  // param !== Object(param) returns false if `param` is a function
+  // or an object and returns true if `param` is null
+  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';
+}
+
+function filterConfig(props, validProps, defaults = {}) {
+  const res = { ...defaults
+  };
+  validProps.forEach(key => {
+    const value = props[key];
+
+    if (isConfigParam(value, key)) {
+      let value = props[key];
+
+      if (key === 'simultaneousHandlers' || key === 'waitFor') {
+        value = transformIntoHandlerTags(props[key]);
+      } else if (key === 'hitSlop') {
+        if (typeof value !== 'object') {
+          value = {
+            top: value,
+            left: value,
+            bottom: value,
+            right: value
+          };
+        }
+      }
+
+      res[key] = value;
+    }
+  });
+  return res;
+}
+
+function transformIntoHandlerTags(handlerIDs) {
+  if (!Array.isArray(handlerIDs)) {
+    handlerIDs = [handlerIDs];
+  }
+
+  if (Platform.OS === 'web') {
+    return handlerIDs.map(({
+      current
+    }) => current).filter(handle => handle);
+  } // converts handler string IDs into their numeric tags
+
+
+  return handlerIDs.map(handlerID => {
+    var _handlerID$current;
+
+    return handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;
+  }).filter(handlerTag => handlerTag > 0);
+}
+
+function hasUnresolvedRefs(props) {
+  // TODO(TS) - add type for extract arg
+  const extract = refs => {
+    if (!Array.isArray(refs)) {
+      return refs && refs.current === null;
+    }
+
+    return refs.some(r => r && r.current === null);
+  };
+
+  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);
+}
+
+const stateToPropMappings = {
+  [State.UNDETERMINED]: undefined,
+  [State.BEGAN]: 'onBegan',
+  [State.FAILED]: 'onFailed',
+  [State.CANCELLED]: 'onCancelled',
+  [State.ACTIVE]: 'onActivated',
+  [State.END]: 'onEnded'
+};
+// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.
+export default function createHandler({
+  name,
+  allowedProps = [],
+  config = {},
+  transformProps,
+  customNativeProps = []
+}) {
+  class Handler extends React.Component {
+    constructor(props) {
+      super(props);
+
+      _defineProperty(this, "handlerTag", void 0);
+
+      _defineProperty(this, "config", void 0);
+
+      _defineProperty(this, "propsRef", void 0);
+
+      _defineProperty(this, "viewNode", void 0);
+
+      _defineProperty(this, "viewTag", void 0);
+
+      _defineProperty(this, "updateEnqueued", null);
+
+      _defineProperty(this, "onGestureHandlerEvent", event => {
+        if (event.nativeEvent.handlerTag === this.handlerTag) {
+          var _this$props$onGesture, _this$props;
+
+          (_this$props$onGesture = (_this$props = this.props).onGestureEvent) === null || _this$props$onGesture === void 0 ? void 0 : _this$props$onGesture.call(_this$props, event);
+        } else {
+          var _this$props$onGesture2, _this$props2;
+
+          (_this$props$onGesture2 = (_this$props2 = this.props).onGestureHandlerEvent) === null || _this$props$onGesture2 === void 0 ? void 0 : _this$props$onGesture2.call(_this$props2, event);
+        }
+      });
+
+      _defineProperty(this, "onGestureHandlerStateChange", event => {
+        if (event.nativeEvent.handlerTag === this.handlerTag) {
+          var _this$props$onHandler, _this$props3;
+
+          (_this$props$onHandler = (_this$props3 = this.props).onHandlerStateChange) === null || _this$props$onHandler === void 0 ? void 0 : _this$props$onHandler.call(_this$props3, event);
+          const state = event.nativeEvent.state;
+          const stateEventName = stateToPropMappings[state];
+          const eventHandler = stateEventName && this.props[stateEventName];
+
+          if (eventHandler && typeof eventHandler === 'function') {
+            eventHandler(event);
+          }
+        } else {
+          var _this$props$onGesture3, _this$props4;
+
+          (_this$props$onGesture3 = (_this$props4 = this.props).onGestureHandlerStateChange) === null || _this$props$onGesture3 === void 0 ? void 0 : _this$props$onGesture3.call(_this$props4, event);
+        }
+      });
+
+      _defineProperty(this, "refHandler", node => {
+        this.viewNode = node;
+        const child = React.Children.only(this.props.children); // TODO(TS) fix ref type
+
+        const {
+          ref
+        } = child;
+
+        if (ref !== null) {
+          if (typeof ref === 'function') {
+            ref(node);
+          } else {
+            ref.current = node;
+          }
+        }
+      });
+
+      _defineProperty(this, "createGestureHandler", newConfig => {
+        this.config = newConfig;
+        RNGestureHandlerModule.createGestureHandler(name, this.handlerTag, newConfig);
+      });
+
+      _defineProperty(this, "attachGestureHandler", newViewTag => {
+        this.viewTag = newViewTag;
+
+        if (Platform.OS === 'web') {
+          // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch
+          RNGestureHandlerModule.attachGestureHandler(this.handlerTag, newViewTag, this.propsRef);
+        } else {
+          RNGestureHandlerModule.attachGestureHandler(this.handlerTag, newViewTag);
+        }
+      });
+
+      _defineProperty(this, "updateGestureHandler", newConfig => {
+        this.config = newConfig;
+        RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);
+      });
+
+      this.handlerTag = handlerTag++;
+      this.config = {};
+      this.propsRef = /*#__PURE__*/React.createRef();
+
+      if (props.id) {
+        if (handlerIDToTag[props.id] !== undefined) {
+          throw new Error("Handler with ID \"".concat(props.id, "\" already registered"));
+        }
+
+        handlerIDToTag[props.id] = this.handlerTag;
+      }
+    }
+
+    componentDidMount() {
+      const props = this.props;
+
+      if (hasUnresolvedRefs(props)) {
+        // If there are unresolved refs (e.g. ".current" has not yet been set)
+        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to
+        // _update method that will try to update native handler props using
+        // setImmediate. This makes it so _update function gets called after all
+        // react components are mounted and we expect the missing ref object to
+        // be resolved by then.
+        this.updateEnqueued = setImmediate(() => {
+          this.updateEnqueued = null;
+          this.update();
+        });
+      }
+
+      this.createGestureHandler(filterConfig(transformProps ? transformProps(this.props) : this.props, [...allowedProps, ...customNativeProps], config));
+      this.attachGestureHandler(findNodeHandle(this.viewNode)); // TODO(TS) - check if this can be null
+    }
+
+    componentDidUpdate() {
+      const viewTag = findNodeHandle(this.viewNode);
+
+      if (this.viewTag !== viewTag) {
+        this.attachGestureHandler(viewTag); // TODO(TS) - check interaction between _viewTag & findNodeHandle
+      }
+
+      this.update();
+    }
+
+    componentWillUnmount() {
+      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);
+
+      if (this.updateEnqueued) {
+        clearImmediate(this.updateEnqueued);
+      } // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context
+
+
+      const handlerID = this.props.id;
+
+      if (handlerID) {
+        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+        delete handlerIDToTag[handlerID];
+      }
+    }
+
+    update() {
+      const newConfig = filterConfig(transformProps ? transformProps(this.props) : this.props, [...allowedProps, ...customNativeProps], config);
+
+      if (!deepEqual(this.config, newConfig)) {
+        this.updateGestureHandler(newConfig);
+      }
+    }
+
+    setNativeProps(updates) {
+      const mergedProps = { ...this.props,
+        ...updates
+      };
+      const newConfig = filterConfig(transformProps ? transformProps(mergedProps) : mergedProps, [...allowedProps, ...customNativeProps], config);
+      this.updateGestureHandler(newConfig);
+    }
+
+    render() {
+      let gestureEventHandler = this.onGestureHandlerEvent; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+
+      const {
+        onGestureEvent,
+        onGestureHandlerEvent
+      } = this.props;
+
+      if (onGestureEvent && typeof onGestureEvent !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerEvent) {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+
+        gestureEventHandler = onGestureEvent;
+      } else {
+        if (onGestureHandlerEvent && typeof onGestureHandlerEvent !== 'function') {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+      }
+
+      let gestureStateEventHandler = this.onGestureHandlerStateChange; // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+
+      const {
+        onHandlerStateChange,
+        onGestureHandlerStateChange
+      } = this.props;
+
+      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerStateChange) {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+
+        gestureStateEventHandler = onHandlerStateChange;
+      } else {
+        if (onGestureHandlerStateChange && typeof onGestureHandlerStateChange !== 'function') {
+          throw new Error('Nesting touch handlers with native animated driver is not supported yet');
+        }
+      }
+
+      const events = {
+        onGestureHandlerEvent: gestureEventHandler,
+        onGestureHandlerStateChange: gestureStateEventHandler
+      };
+      this.propsRef.current = events;
+      const child = React.Children.only(this.props.children);
+      let grandChildren = child.props.children;
+
+      if (Touchable.TOUCH_TARGET_DEBUG && child.type && (child.type === 'RNGestureHandlerButton' || child.type.name === 'View' || child.type.displayName === 'View')) {
+        grandChildren = React.Children.toArray(grandChildren);
+        grandChildren.push(Touchable.renderDebugView({
+          color: 'mediumspringgreen',
+          hitSlop: child.props.hitSlop
+        }));
+      }
+
+      return /*#__PURE__*/React.cloneElement(child, {
+        ref: this.refHandler,
+        collapsable: false,
+        ...events
+      }, grandChildren);
+    }
+
+  }
+
+  _defineProperty(Handler, "displayName", name);
+
+  return Handler;
+}
+//# sourceMappingURL=createHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js.map
new file mode 100644
index 0000000..55cd6f9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/createHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["createHandler.ts"],"names":["React","findNodeHandle","findNodeHandleRN","NativeModules","Platform","Touchable","deepEqual","RNGestureHandlerModule","State","node","OS","UIManager","customGHEventsConfig","onGestureHandlerEvent","registrationName","onGestureHandlerStateChange","genericDirectEventTypes","UIManagerConstants","getViewManagerConfig","getConstants","setJSResponder","oldSetJSResponder","clearJSResponder","oldClearJSResponder","tag","blockNativeResponder","handleSetJSResponder","handleClearJSResponder","handlerTag","handlerIDToTag","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","res","forEach","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","Array","isArray","map","current","filter","handle","handlerID","hasUnresolvedRefs","extract","refs","some","r","stateToPropMappings","UNDETERMINED","BEGAN","FAILED","CANCELLED","ACTIVE","END","createHandler","allowedProps","config","transformProps","customNativeProps","Handler","Component","constructor","event","nativeEvent","onGestureEvent","onHandlerStateChange","state","stateEventName","eventHandler","viewNode","child","Children","only","children","ref","newConfig","createGestureHandler","newViewTag","viewTag","attachGestureHandler","propsRef","updateGestureHandler","createRef","id","Error","componentDidMount","updateEnqueued","setImmediate","update","componentDidUpdate","componentWillUnmount","dropGestureHandler","clearImmediate","setNativeProps","updates","mergedProps","render","gestureEventHandler","gestureStateEventHandler","events","grandChildren","TOUCH_TARGET_DEBUG","type","displayName","toArray","push","renderDebugView","color","hitSlop","cloneElement","refHandler","collapsable"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  findNodeHandle as findNodeHandleRN,\n  NativeModules,\n  Platform,\n  Touchable,\n} from 'react-native';\n// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types\nimport deepEqual from 'fbjs/lib/areEqual';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\nimport type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';\nimport { State } from '../State';\n\nimport {\n  BaseGestureHandlerProps,\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from './gestureHandlers';\nimport { ValueOf } from '../typeUtils';\n\nfunction findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nconst { UIManager = {} } = NativeModules;\n\nconst customGHEventsConfig = {\n  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },\n  onGestureHandlerStateChange: {\n    registrationName: 'onGestureHandlerStateChange',\n  },\n};\n\n// Add gesture specific events to genericDirectEventTypes object exported from UIManager\n// native module.\n// Once new event types are registered with react it is possible to dispatch these\n// events to all kind of native views.\nUIManager.genericDirectEventTypes = {\n  ...UIManager.genericDirectEventTypes,\n  ...customGHEventsConfig,\n};\n// In newer versions of RN the `genericDirectEventTypes` is located in the object\n// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make\n// it compatible with RN 61+\nconst UIManagerConstants =\n  UIManager.getViewManagerConfig?.('getConstants') ??\n  UIManager.getConstants?.();\n\nif (UIManagerConstants) {\n  UIManagerConstants.genericDirectEventTypes = {\n    ...UIManagerConstants.genericDirectEventTypes,\n    ...customGHEventsConfig,\n  };\n}\n\n// Wrap JS responder calls and notify gesture handler manager\nconst {\n  setJSResponder: oldSetJSResponder = () => {\n    //no operation\n  },\n  clearJSResponder: oldClearJSResponder = () => {\n    //no operation\n  },\n} = UIManager;\nUIManager.setJSResponder = (tag: number, blockNativeResponder: boolean) => {\n  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);\n  oldSetJSResponder(tag, blockNativeResponder);\n};\nUIManager.clearJSResponder = () => {\n  RNGestureHandlerModule.handleClearJSResponder();\n  oldClearJSResponder();\n};\n\nlet handlerTag = 1;\nconst handlerIDToTag: Record<string, number> = {};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nfunction filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const res = { ...defaults };\n  validProps.forEach((key) => {\n    const value = props[key];\n    if (isConfigParam(value, key)) {\n      let value = props[key];\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop') {\n        if (typeof value !== 'object') {\n          value = { top: value, left: value, bottom: value, right: value };\n        }\n      }\n      res[key] = value;\n    }\n  });\n  return res;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  if (!Array.isArray(handlerIDs)) {\n    handlerIDs = [handlerIDs];\n  }\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\ntype HandlerProps<T extends Record<string, unknown>> = Readonly<\n  React.PropsWithChildren<BaseGestureHandlerProps<T>>\n>;\nfunction hasUnresolvedRefs<T extends Record<string, unknown>>(\n  props: HandlerProps<T>\n) {\n  // TODO(TS) - add type for extract arg\n  const extract = (refs: any | any[]) => {\n    if (!Array.isArray(refs)) {\n      return refs && refs.current === null;\n    }\n    return refs.some((r) => r && r.current === null);\n  };\n  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);\n}\n\nconst stateToPropMappings = {\n  [State.UNDETERMINED]: undefined,\n  [State.BEGAN]: 'onBegan',\n  [State.FAILED]: 'onFailed',\n  [State.CANCELLED]: 'onCancelled',\n  [State.ACTIVE]: 'onActivated',\n  [State.END]: 'onEnded',\n} as const;\n\ntype CreateHandlerArgs<\n  HandlerPropsT extends Record<string, unknown>\n> = Readonly<{\n  name: string;\n  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;\n  config: Readonly<Record<string, unknown>>;\n  transformProps?: (props: HandlerPropsT) => HandlerPropsT;\n  customNativeProps?: Readonly<string[]>;\n}>;\n\n// TODO(TS) fix event types\ntype InternalEventHandlers = {\n  onGestureHandlerEvent?: (event: any) => void;\n  onGestureHandlerStateChange?: (event: any) => void;\n};\n\n// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.\nexport default function createHandler<\n  T extends BaseGestureHandlerProps<U>,\n  U extends Record<string, unknown>\n>({\n  name,\n  allowedProps = [],\n  config = {},\n  transformProps,\n  customNativeProps = [],\n}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {\n  class Handler extends React.Component<T & InternalEventHandlers> {\n    static displayName = name;\n\n    private handlerTag: number;\n    private config: Record<string, unknown>;\n    private propsRef: React.MutableRefObject<unknown>;\n    private viewNode: any;\n    private viewTag?: number;\n    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;\n\n    constructor(props: T & InternalEventHandlers) {\n      super(props);\n      this.handlerTag = handlerTag++;\n      this.config = {};\n      this.propsRef = React.createRef();\n      if (props.id) {\n        if (handlerIDToTag[props.id] !== undefined) {\n          throw new Error(`Handler with ID \"${props.id}\" already registered`);\n        }\n        handlerIDToTag[props.id] = this.handlerTag;\n      }\n    }\n\n    componentDidMount() {\n      const props: HandlerProps<U> = this.props;\n      if (hasUnresolvedRefs(props)) {\n        // If there are unresolved refs (e.g. \".current\" has not yet been set)\n        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to\n        // _update method that will try to update native handler props using\n        // setImmediate. This makes it so _update function gets called after all\n        // react components are mounted and we expect the missing ref object to\n        // be resolved by then.\n        this.updateEnqueued = setImmediate(() => {\n          this.updateEnqueued = null;\n          this.update();\n        });\n      }\n\n      this.createGestureHandler(\n        filterConfig(\n          transformProps ? transformProps(this.props) : this.props,\n          [...allowedProps, ...customNativeProps],\n          config\n        )\n      );\n\n      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null\n    }\n\n    componentDidUpdate() {\n      const viewTag = findNodeHandle(this.viewNode);\n      if (this.viewTag !== viewTag) {\n        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle\n      }\n      this.update();\n    }\n\n    componentWillUnmount() {\n      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);\n      if (this.updateEnqueued) {\n        clearImmediate(this.updateEnqueued);\n      }\n      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context\n      const handlerID: string | undefined = this.props.id;\n      if (handlerID) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete handlerIDToTag[handlerID];\n      }\n    }\n\n    private onGestureHandlerEvent = (event: GestureEvent<U>) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onGestureEvent?.(event);\n      } else {\n        this.props.onGestureHandlerEvent?.(event);\n      }\n    };\n\n    // TODO(TS) - make sure this is right type for event\n    private onGestureHandlerStateChange = (\n      event: HandlerStateChangeEvent<U>\n    ) => {\n      if (event.nativeEvent.handlerTag === this.handlerTag) {\n        this.props.onHandlerStateChange?.(event);\n\n        const state: ValueOf<typeof State> = event.nativeEvent.state;\n        const stateEventName = stateToPropMappings[state];\n        const eventHandler = stateEventName && this.props[stateEventName];\n        if (eventHandler && typeof eventHandler === 'function') {\n          eventHandler(event);\n        }\n      } else {\n        this.props.onGestureHandlerStateChange?.(event);\n      }\n    };\n\n    private refHandler = (node: any) => {\n      this.viewNode = node;\n\n      const child = React.Children.only(this.props.children);\n      // TODO(TS) fix ref type\n      const { ref }: any = child;\n      if (ref !== null) {\n        if (typeof ref === 'function') {\n          ref(node);\n        } else {\n          ref.current = node;\n        }\n      }\n    };\n\n    private createGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.createGestureHandler(\n        name,\n        this.handlerTag,\n        newConfig\n      );\n    };\n\n    private attachGestureHandler = (newViewTag: number) => {\n      this.viewTag = newViewTag;\n\n      if (Platform.OS === 'web') {\n        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch\n        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(\n          this.handlerTag,\n          newViewTag,\n          this.propsRef\n        );\n      } else {\n        RNGestureHandlerModule.attachGestureHandler(\n          this.handlerTag,\n          newViewTag\n        );\n      }\n    };\n\n    private updateGestureHandler = (\n      newConfig: Readonly<Record<string, unknown>>\n    ) => {\n      this.config = newConfig;\n\n      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);\n    };\n\n    private update() {\n      const newConfig = filterConfig(\n        transformProps ? transformProps(this.props) : this.props,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      if (!deepEqual(this.config, newConfig)) {\n        this.updateGestureHandler(newConfig);\n      }\n    }\n\n    setNativeProps(updates: any) {\n      const mergedProps = { ...this.props, ...updates };\n      const newConfig = filterConfig(\n        transformProps ? transformProps(mergedProps) : mergedProps,\n        [...allowedProps, ...customNativeProps],\n        config\n      );\n      this.updateGestureHandler(newConfig);\n    }\n\n    render() {\n      let gestureEventHandler = this.onGestureHandlerEvent;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureEventHandlers = {\n        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];\n        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];\n      };\n      const {\n        onGestureEvent,\n        onGestureHandlerEvent,\n      }: OnGestureEventHandlers = this.props;\n      if (onGestureEvent && typeof onGestureEvent !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerEvent) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureEventHandler = onGestureEvent;\n      } else {\n        if (\n          onGestureHandlerEvent &&\n          typeof onGestureHandlerEvent !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n\n      let gestureStateEventHandler = this.onGestureHandlerStateChange;\n      // Another instance of https://github.com/microsoft/TypeScript/issues/13995\n      type OnGestureStateChangeHandlers = {\n        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];\n        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];\n      };\n      const {\n        onHandlerStateChange,\n        onGestureHandlerStateChange,\n      }: OnGestureStateChangeHandlers = this.props;\n      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {\n        // If it's not a method it should be an native Animated.event\n        // object. We set it directly as the handler for the view\n        // In this case nested handlers are not going to be supported\n        if (onGestureHandlerStateChange) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n        gestureStateEventHandler = onHandlerStateChange;\n      } else {\n        if (\n          onGestureHandlerStateChange &&\n          typeof onGestureHandlerStateChange !== 'function'\n        ) {\n          throw new Error(\n            'Nesting touch handlers with native animated driver is not supported yet'\n          );\n        }\n      }\n      const events = {\n        onGestureHandlerEvent: gestureEventHandler,\n        onGestureHandlerStateChange: gestureStateEventHandler,\n      };\n\n      this.propsRef.current = events;\n\n      const child: any = React.Children.only(this.props.children);\n      let grandChildren = child.props.children;\n      if (\n        Touchable.TOUCH_TARGET_DEBUG &&\n        child.type &&\n        (child.type === 'RNGestureHandlerButton' ||\n          child.type.name === 'View' ||\n          child.type.displayName === 'View')\n      ) {\n        grandChildren = React.Children.toArray(grandChildren);\n        grandChildren.push(\n          Touchable.renderDebugView({\n            color: 'mediumspringgreen',\n            hitSlop: child.props.hitSlop,\n          })\n        );\n      }\n\n      return React.cloneElement(\n        child,\n        {\n          ref: this.refHandler,\n          collapsable: false,\n          ...events,\n        },\n        grandChildren\n      );\n    }\n  }\n  return Handler;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js b/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js
new file mode 100644
index 0000000..ae34b12
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js
@@ -0,0 +1,58 @@
+function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
+
+import * as React from 'react';
+import { useImperativeHandle, useRef } from 'react';
+import { NativeViewGestureHandler, nativeViewProps } from './NativeViewGestureHandler';
+/*
+ * This array should consist of:
+ *   - All keys in propTypes from NativeGestureHandler
+ *     (and all keys in GestureHandlerPropTypes)
+ *   - 'onGestureHandlerEvent'
+ *   - 'onGestureHandlerStateChange'
+ */
+
+const NATIVE_WRAPPER_PROPS_FILTER = [...nativeViewProps, 'onGestureHandlerEvent', 'onGestureHandlerStateChange'];
+export default function createNativeWrapper(Component, config = {}) {
+  const ComponentWrapper = /*#__PURE__*/React.forwardRef((props, ref) => {
+    // filter out props that should be passed to gesture handler wrapper
+    const gestureHandlerProps = Object.keys(props).reduce((res, key) => {
+      // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info
+      const allowedKeys = NATIVE_WRAPPER_PROPS_FILTER;
+
+      if (allowedKeys.includes(key)) {
+        // @ts-ignore FIXME(TS)
+        res[key] = props[key];
+      }
+
+      return res;
+    }, { ...config
+    } // watch out not to modify config
+    );
+
+    const _ref = useRef();
+
+    const _gestureHandlerRef = useRef();
+
+    useImperativeHandle(ref, // @ts-ignore TODO(TS) decide how nulls work in this context
+    () => {
+      const node = _gestureHandlerRef.current; // add handlerTag for relations config
+
+      if (_ref.current && node) {
+        // @ts-ignore FIXME(TS) think about createHandler return type
+        _ref.current.handlerTag = node.handlerTag;
+        return _ref.current;
+      }
+
+      return null;
+    }, [_ref, _gestureHandlerRef]);
+    return /*#__PURE__*/React.createElement(NativeViewGestureHandler, _extends({}, gestureHandlerProps, {
+      // @ts-ignore TODO(TS)
+      ref: _gestureHandlerRef
+    }), /*#__PURE__*/React.createElement(Component, _extends({}, props, {
+      ref: _ref
+    })));
+  });
+  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';
+  return ComponentWrapper;
+}
+//# sourceMappingURL=createNativeWrapper.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js.map b/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js.map
new file mode 100644
index 0000000..83d5949
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/createNativeWrapper.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["createNativeWrapper.tsx"],"names":["React","useImperativeHandle","useRef","NativeViewGestureHandler","nativeViewProps","NATIVE_WRAPPER_PROPS_FILTER","createNativeWrapper","Component","config","ComponentWrapper","forwardRef","props","ref","gestureHandlerProps","Object","keys","reduce","res","key","allowedKeys","includes","_ref","_gestureHandlerRef","node","current","handlerTag","displayName"],"mappings":";;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,mBAAT,EAA8BC,MAA9B,QAA4C,OAA5C;AAEA,SACEC,wBADF,EAGEC,eAHF,QAIO,4BAJP;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,2BAA2B,GAAG,CAClC,GAAGD,eAD+B,EAElC,uBAFkC,EAGlC,6BAHkC,CAApC;AAMA,eAAe,SAASE,mBAAT,CACbC,SADa,EAEbC,MAA+C,GAAG,EAFrC,EAGb;AACA,QAAMC,gBAAgB,gBAAGT,KAAK,CAACU,UAAN,CAGvB,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChB;AACA,UAAMC,mBAAmB,GAAGC,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,MAAnB,CAC1B,CAACC,GAAD,EAAMC,GAAN,KAAc;AACZ;AACA,YAAMC,WAA8B,GAAGd,2BAAvC;;AACA,UAAIc,WAAW,CAACC,QAAZ,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B;AACAD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWP,KAAK,CAACO,GAAD,CAAhB;AACD;;AACD,aAAOD,GAAP;AACD,KATyB,EAU1B,EAAE,GAAGT;AAAL,KAV0B,CAUZ;AAVY,KAA5B;;AAYA,UAAMa,IAAI,GAAGnB,MAAM,EAAnB;;AACA,UAAMoB,kBAAkB,GAAGpB,MAAM,EAAjC;;AACAD,IAAAA,mBAAmB,CACjBW,GADiB,EAEjB;AACA,UAAM;AACJ,YAAMW,IAAI,GAAGD,kBAAkB,CAACE,OAAhC,CADI,CAEJ;;AACA,UAAIH,IAAI,CAACG,OAAL,IAAgBD,IAApB,EAA0B;AACxB;AACAF,QAAAA,IAAI,CAACG,OAAL,CAAaC,UAAb,GAA0BF,IAAI,CAACE,UAA/B;AACA,eAAOJ,IAAI,CAACG,OAAZ;AACD;;AACD,aAAO,IAAP;AACD,KAZgB,EAajB,CAACH,IAAD,EAAOC,kBAAP,CAbiB,CAAnB;AAeA,wBACE,oBAAC,wBAAD,eACMT,mBADN;AAEE;AACA,MAAA,GAAG,EAAES;AAHP,qBAIE,oBAAC,SAAD,eAAeX,KAAf;AAAsB,MAAA,GAAG,EAAEU;AAA3B,OAJF,CADF;AAQD,GA1CwB,CAAzB;AA4CAZ,EAAAA,gBAAgB,CAACiB,WAAjB,GAA+BnB,SAAS,CAACmB,WAAV,IAAyB,kBAAxD;AAEA,SAAOjB,gBAAP;AACD","sourcesContent":["import * as React from 'react';\nimport { useImperativeHandle, useRef } from 'react';\n\nimport {\n  NativeViewGestureHandler,\n  NativeViewGestureHandlerProps,\n  nativeViewProps,\n} from './NativeViewGestureHandler';\n\n/*\n * This array should consist of:\n *   - All keys in propTypes from NativeGestureHandler\n *     (and all keys in GestureHandlerPropTypes)\n *   - 'onGestureHandlerEvent'\n *   - 'onGestureHandlerStateChange'\n */\nconst NATIVE_WRAPPER_PROPS_FILTER = [\n  ...nativeViewProps,\n  'onGestureHandlerEvent',\n  'onGestureHandlerStateChange',\n] as const;\n\nexport default function createNativeWrapper<P>(\n  Component: React.ComponentType<P>,\n  config: Readonly<NativeViewGestureHandlerProps> = {}\n) {\n  const ComponentWrapper = React.forwardRef<\n    React.ComponentType<any>,\n    P & NativeViewGestureHandlerProps\n  >((props, ref) => {\n    // filter out props that should be passed to gesture handler wrapper\n    const gestureHandlerProps = Object.keys(props).reduce(\n      (res, key) => {\n        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info\n        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;\n        if (allowedKeys.includes(key)) {\n          // @ts-ignore FIXME(TS)\n          res[key] = props[key];\n        }\n        return res;\n      },\n      { ...config } // watch out not to modify config\n    );\n    const _ref = useRef<React.ComponentType<P>>();\n    const _gestureHandlerRef = useRef<React.ComponentType<P>>();\n    useImperativeHandle(\n      ref,\n      // @ts-ignore TODO(TS) decide how nulls work in this context\n      () => {\n        const node = _gestureHandlerRef.current;\n        // add handlerTag for relations config\n        if (_ref.current && node) {\n          // @ts-ignore FIXME(TS) think about createHandler return type\n          _ref.current.handlerTag = node.handlerTag;\n          return _ref.current;\n        }\n        return null;\n      },\n      [_ref, _gestureHandlerRef]\n    );\n    return (\n      <NativeViewGestureHandler\n        {...gestureHandlerProps}\n        // @ts-ignore TODO(TS)\n        ref={_gestureHandlerRef}>\n        <Component {...props} ref={_ref} />\n      </NativeViewGestureHandler>\n    );\n  });\n\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\n\n  return ComponentWrapper;\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js
new file mode 100644
index 0000000..31a5362
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js
@@ -0,0 +1,2 @@
+
+//# sourceMappingURL=gestureHandlerTypesCompat.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js.map b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js.map
new file mode 100644
index 0000000..9ffd4b2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlerTypesCompat.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js
new file mode 100644
index 0000000..076f8a1
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js
@@ -0,0 +1,216 @@
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.
+// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof
+// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.
+// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.
+import * as React from 'react';
+import createHandler from './createHandler';
+import PlatformConstants from '../PlatformConstants';
+export const baseProps = ['id', 'enabled', 'minPointers', 'waitFor', 'simultaneousHandlers', 'shouldCancelWhenOutside', 'hitSlop', 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange'];
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const TapGestureHandler = createHandler({
+  name: 'TapGestureHandler',
+  allowedProps: [...baseProps, 'maxDurationMs', 'maxDelayMs', 'numberOfTaps', 'maxDeltaX', 'maxDeltaY', 'maxDist', 'minPointers'],
+  config: {}
+});
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const FlingGestureHandler = createHandler({
+  name: 'FlingGestureHandler',
+  allowedProps: [...baseProps, 'numberOfPointers', 'direction'],
+  config: {}
+});
+
+class ForceTouchFallback extends React.Component {
+  componentDidMount() {
+    console.warn('ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase');
+  }
+
+  render() {
+    return this.props.children;
+  }
+
+}
+
+_defineProperty(ForceTouchFallback, "forceTouchAvailable", false);
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const ForceTouchGestureHandler = PlatformConstants !== null && PlatformConstants !== void 0 && PlatformConstants.forceTouchAvailable ? createHandler({
+  name: 'ForceTouchGestureHandler',
+  allowedProps: [...baseProps, 'minForce', 'maxForce', 'feedbackOnActivation'],
+  config: {}
+}) : ForceTouchFallback;
+ForceTouchGestureHandler.forceTouchAvailable = (PlatformConstants === null || PlatformConstants === void 0 ? void 0 : PlatformConstants.forceTouchAvailable) || false;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const LongPressGestureHandler = createHandler({
+  name: 'LongPressGestureHandler',
+  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'],
+  config: {}
+});
+
+function validatePanGestureHandlerProps(props) {
+  if (props.minDeltaX && props.activeOffsetX) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd");
+  }
+
+  if (props.maxDeltaX && props.failOffsetX) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd");
+  }
+
+  if (props.minDeltaY && props.activeOffsetY) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd");
+  }
+
+  if (props.maxDeltaY && props.failOffsetY) {
+    throw new Error("It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd");
+  }
+
+  if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {
+    throw new Error("First element of activeOffsetX should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {
+    throw new Error("First element of activeOffsetY should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {
+    throw new Error("First element of failOffsetX should be negative, a the second one should be positive");
+  }
+
+  if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {
+    throw new Error("First element of failOffsetY should be negative, a the second one should be positive");
+  }
+}
+
+function transformPanGestureHandlerProps(props) {
+  const res = { ...props
+  };
+
+  if (props.minDeltaX !== undefined) {
+    delete res.minDeltaX;
+    res.activeOffsetXStart = -props.minDeltaX;
+    res.activeOffsetXEnd = props.minDeltaX;
+  }
+
+  if (props.maxDeltaX !== undefined) {
+    delete res.maxDeltaX;
+    res.failOffsetXStart = -props.maxDeltaX;
+    res.failOffsetXEnd = props.maxDeltaX;
+  }
+
+  if (props.minOffsetX !== undefined) {
+    delete res.minOffsetX;
+
+    if (props.minOffsetX < 0) {
+      res.activeOffsetXStart = props.minOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.minOffsetX;
+    }
+  }
+
+  if (props.minDeltaY !== undefined) {
+    delete res.minDeltaY;
+    res.activeOffsetYStart = -props.minDeltaY;
+    res.activeOffsetYEnd = props.minDeltaY;
+  }
+
+  if (props.maxDeltaY !== undefined) {
+    delete res.maxDeltaY;
+    res.failOffsetYStart = -props.maxDeltaY;
+    res.failOffsetYEnd = props.maxDeltaY;
+  }
+
+  if (props.minOffsetY !== undefined) {
+    delete res.minOffsetY;
+
+    if (props.minOffsetY < 0) {
+      res.activeOffsetYStart = props.minOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.minOffsetY;
+    }
+  }
+
+  if (props.activeOffsetX !== undefined) {
+    delete res.activeOffsetX;
+
+    if (Array.isArray(props.activeOffsetX)) {
+      res.activeOffsetXStart = props.activeOffsetX[0];
+      res.activeOffsetXEnd = props.activeOffsetX[1];
+    } else if (props.activeOffsetX < 0) {
+      res.activeOffsetXStart = props.activeOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.activeOffsetX;
+    }
+  }
+
+  if (props.activeOffsetY !== undefined) {
+    delete res.activeOffsetY;
+
+    if (Array.isArray(props.activeOffsetY)) {
+      res.activeOffsetYStart = props.activeOffsetY[0];
+      res.activeOffsetYEnd = props.activeOffsetY[1];
+    } else if (props.activeOffsetY < 0) {
+      res.activeOffsetYStart = props.activeOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.activeOffsetY;
+    }
+  }
+
+  if (props.failOffsetX !== undefined) {
+    delete res.failOffsetX;
+
+    if (Array.isArray(props.failOffsetX)) {
+      res.failOffsetXStart = props.failOffsetX[0];
+      res.failOffsetXEnd = props.failOffsetX[1];
+    } else if (props.failOffsetX < 0) {
+      res.failOffsetXStart = props.failOffsetX;
+    } else {
+      res.failOffsetXEnd = props.failOffsetX;
+    }
+  }
+
+  if (props.failOffsetY !== undefined) {
+    delete res.failOffsetY;
+
+    if (Array.isArray(props.failOffsetY)) {
+      res.failOffsetYStart = props.failOffsetY[0];
+      res.failOffsetYEnd = props.failOffsetY[1];
+    } else if (props.failOffsetY < 0) {
+      res.failOffsetYStart = props.failOffsetY;
+    } else {
+      res.failOffsetYEnd = props.failOffsetY;
+    }
+  }
+
+  return res;
+}
+
+function managePanProps(props) {
+  if (__DEV__) {
+    validatePanGestureHandlerProps(props);
+  }
+
+  return transformPanGestureHandlerProps(props);
+}
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const PanGestureHandler = createHandler({
+  name: 'PanGestureHandler',
+  allowedProps: [...baseProps, 'activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture'],
+  config: {},
+  transformProps: managePanProps,
+  customNativeProps: ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd']
+});
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const PinchGestureHandler = createHandler({
+  name: 'PinchGestureHandler',
+  allowedProps: baseProps,
+  config: {}
+});
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const RotationGestureHandler = createHandler({
+  name: 'RotationGestureHandler',
+  allowedProps: baseProps,
+  config: {}
+});
+//# sourceMappingURL=gestureHandlers.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js.map b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js.map
new file mode 100644
index 0000000..21b4071
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/handlers/gestureHandlers.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["gestureHandlers.ts"],"names":["React","createHandler","PlatformConstants","baseProps","TapGestureHandler","name","allowedProps","config","FlingGestureHandler","ForceTouchFallback","Component","componentDidMount","console","warn","render","props","children","ForceTouchGestureHandler","forceTouchAvailable","LongPressGestureHandler","validatePanGestureHandlerProps","minDeltaX","activeOffsetX","Error","maxDeltaX","failOffsetX","minDeltaY","activeOffsetY","maxDeltaY","failOffsetY","Array","isArray","transformPanGestureHandlerProps","res","undefined","activeOffsetXStart","activeOffsetXEnd","failOffsetXStart","failOffsetXEnd","minOffsetX","activeOffsetYStart","activeOffsetYEnd","failOffsetYStart","failOffsetYEnd","minOffsetY","managePanProps","__DEV__","PanGestureHandler","transformProps","customNativeProps","PinchGestureHandler","RotationGestureHandler"],"mappings":"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","sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\n\nimport createHandler from './createHandler';\nimport PlatformConstants from '../PlatformConstants';\nimport { State } from '../State';\nimport { ValueOf } from '../typeUtils';\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\n\nexport interface HandlerStateChangeEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n  oldState: ValueOf<typeof State>;\n}\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = {\n  id?: string;\n  enabled?: boolean;\n  minPointers?: number;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?:\n    | number\n    // TODO(TS) take into consideration types from GestureHandler#setHitSlop\n    | Partial<\n        Record<\n          'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n          number\n        >\n      >\n    | Record<'width' | 'left', number>\n    | Record<'width' | 'right', number>\n    | Record<'height' | 'top', number>\n    | Record<'height' | 'bottom', number>;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n};\n\nexport const baseProps = [\n  'id',\n  'enabled',\n  'minPointers',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport type TapGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface TapGestureHandlerProps\n  extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {\n  minPointers?: number;\n  maxDurationMs?: number;\n  maxDelayMs?: number;\n  numberOfTaps?: number;\n  maxDeltaX?: number;\n  maxDeltaY?: number;\n  maxDist?: number;\n}\n\nexport type TapGestureHandler = typeof TapGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const TapGestureHandler = createHandler<\n  TapGestureHandlerProps,\n  TapGestureHandlerEventPayload\n>({\n  name: 'TapGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'maxDurationMs',\n    'maxDelayMs',\n    'numberOfTaps',\n    'maxDeltaX',\n    'maxDeltaY',\n    'maxDist',\n    'minPointers',\n  ] as const,\n  config: {},\n});\n\nexport type FlingGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface FlingGestureHandlerProps\n  extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {\n  direction?: number;\n  numberOfPointers?: number;\n}\n\nexport type FlingGestureHandler = typeof FlingGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const FlingGestureHandler = createHandler<\n  FlingGestureHandlerProps,\n  FlingGestureHandlerEventPayload\n>({\n  name: 'FlingGestureHandler',\n  allowedProps: [...baseProps, 'numberOfPointers', 'direction'] as const,\n  config: {},\n});\n\nclass ForceTouchFallback extends React.Component {\n  static forceTouchAvailable = false;\n  componentDidMount() {\n    console.warn(\n      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'\n    );\n  }\n  render() {\n    return this.props.children;\n  }\n}\n\nexport type ForceTouchGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  force: number;\n};\n\nexport interface ForceTouchGestureHandlerProps\n  extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {\n  minForce?: number;\n  maxForce?: number;\n  feedbackOnActivation?: boolean;\n}\n\nexport type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {\n  forceTouchAvailable: boolean;\n};\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const ForceTouchGestureHandler = PlatformConstants?.forceTouchAvailable\n  ? createHandler<\n      ForceTouchGestureHandlerProps,\n      ForceTouchGestureHandlerEventPayload\n    >({\n      name: 'ForceTouchGestureHandler',\n      allowedProps: [\n        ...baseProps,\n        'minForce',\n        'maxForce',\n        'feedbackOnActivation',\n      ] as const,\n      config: {},\n    })\n  : ForceTouchFallback;\n\n(ForceTouchGestureHandler as ForceTouchGestureHandler).forceTouchAvailable =\n  PlatformConstants?.forceTouchAvailable || false;\n\nexport type LongPressGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport interface LongPressGestureHandlerProps\n  extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {\n  minDurationMs?: number;\n  maxDist?: number;\n}\n\nexport type LongPressGestureHandler = typeof LongPressGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const LongPressGestureHandler = createHandler<\n  LongPressGestureHandlerProps,\n  LongPressGestureHandlerEventPayload\n>({\n  name: 'LongPressGestureHandler',\n  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'] as const,\n  config: {},\n});\n\nfunction validatePanGestureHandlerProps(props: PanGestureHandlerProps) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`\n    );\n  }\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\n      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`\n    );\n  }\n  if (\n    Array.isArray(props.activeOffsetX) &&\n    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.activeOffsetY) &&\n    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of activeOffsetY should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetX) &&\n    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetX should be negative, a the second one should be positive`\n    );\n  }\n\n  if (\n    Array.isArray(props.failOffsetY) &&\n    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)\n  ) {\n    throw new Error(\n      `First element of failOffsetY should be negative, a the second one should be positive`\n    );\n  }\n}\n\nfunction transformPanGestureHandlerProps(props: PanGestureHandlerProps) {\n  type InternalPanGHKeys =\n    | 'activeOffsetXStart'\n    | 'activeOffsetXEnd'\n    | 'failOffsetXStart'\n    | 'failOffsetXEnd'\n    | 'activeOffsetYStart'\n    | 'activeOffsetYEnd'\n    | 'failOffsetYStart'\n    | 'failOffsetYEnd';\n  type PanGestureHandlerInternalProps = PanGestureHandlerProps &\n    Partial<Record<InternalPanGHKeys, number>>;\n\n  const res: PanGestureHandlerInternalProps = { ...props };\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props: PanGestureHandlerProps) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n  return transformPanGestureHandlerProps(props);\n}\n\nexport type PanGestureHandlerEventPayload = {\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n  translationX: number;\n  translationY: number;\n  velocityX: number;\n  velocityY: number;\n};\n\nexport interface PanGestureHandlerProps\n  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {\n  /** @deprecated  use activeOffsetX*/\n  minDeltaX?: number;\n  /** @deprecated  use activeOffsetY*/\n  minDeltaY?: number;\n  /** @deprecated  use failOffsetX*/\n  maxDeltaX?: number;\n  /** @deprecated  use failOffsetY*/\n  maxDeltaY?: number;\n  /** @deprecated  use activeOffsetX*/\n  minOffsetX?: number;\n  /** @deprecated  use failOffsetY*/\n  minOffsetY?: number;\n  activeOffsetY?: number | number[];\n  activeOffsetX?: number | number[];\n  failOffsetY?: number | number[];\n  failOffsetX?: number | number[];\n  minDist?: number;\n  minVelocity?: number;\n  minVelocityX?: number;\n  minVelocityY?: number;\n  minPointers?: number;\n  maxPointers?: number;\n  avgTouches?: boolean;\n  enableTrackpadTwoFingerGesture?: boolean;\n}\n\nexport type PanGestureHandler = typeof PanGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PanGestureHandler = createHandler<\n  PanGestureHandlerProps,\n  PanGestureHandlerEventPayload\n>({\n  name: 'PanGestureHandler',\n  allowedProps: [\n    ...baseProps,\n    'activeOffsetY',\n    'activeOffsetX',\n    'failOffsetY',\n    'failOffsetX',\n    'minDist',\n    'minVelocity',\n    'minVelocityX',\n    'minVelocityY',\n    'minPointers',\n    'maxPointers',\n    'avgTouches',\n    'enableTrackpadTwoFingerGesture',\n  ] as const,\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: [\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'failOffsetYStart',\n    'failOffsetYEnd',\n    'failOffsetXStart',\n    'failOffsetXEnd',\n  ],\n});\n\nexport type PinchGestureHandlerEventPayload = {\n  scale: number;\n  focalX: number;\n  focalY: number;\n  velocity: number;\n};\n\nexport interface PinchGestureHandlerProps\n  extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {}\n\nexport type PinchGestureHandler = typeof PinchGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const PinchGestureHandler = createHandler<\n  PinchGestureHandlerProps,\n  PinchGestureHandlerEventPayload\n>({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n\nexport type RotationGestureHandlerEventPayload = {\n  rotation: number;\n  anchorX: number;\n  anchorY: number;\n  velocity: number;\n};\n\nexport interface RotationGestureHandlerProps\n  extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {}\n\nexport type RotationGestureHandler = typeof RotationGestureHandler;\n// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file\nexport const RotationGestureHandler = createHandler<\n  RotationGestureHandlerProps,\n  RotationGestureHandlerEventPayload\n>({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {},\n});\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/index.js b/node_modules/react-native-gesture-handler/lib/module/index.js
new file mode 100644
index 0000000..0129f89
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/index.js
@@ -0,0 +1,13 @@
+export { Directions } from './Directions';
+export { State } from './State';
+export { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';
+export { default as GestureHandlerRootView } from './GestureHandlerRootView';
+export { TapGestureHandler, ForceTouchGestureHandler, LongPressGestureHandler, PanGestureHandler, PinchGestureHandler, RotationGestureHandler, FlingGestureHandler } from './handlers/gestureHandlers';
+export { default as createNativeWrapper } from './handlers/createNativeWrapper';
+export { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';
+export { RawButton, BaseButton, RectButton, BorderlessButton } from './components/GestureButtons';
+export { TouchableHighlight, TouchableNativeFeedback, TouchableOpacity, TouchableWithoutFeedback } from './components/touchables';
+export { ScrollView, Switch, TextInput, DrawerLayoutAndroid, FlatList } from './components/GestureComponents';
+export { default as Swipeable } from './components/Swipeable';
+export { default as DrawerLayout } from './components/DrawerLayout';
+//# sourceMappingURL=index.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/index.js.map b/node_modules/react-native-gesture-handler/lib/module/index.js.map
new file mode 100644
index 0000000..03d7826
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/index.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["index.ts"],"names":["Directions","State","default","gestureHandlerRootHOC","GestureHandlerRootView","TapGestureHandler","ForceTouchGestureHandler","LongPressGestureHandler","PanGestureHandler","PinchGestureHandler","RotationGestureHandler","FlingGestureHandler","createNativeWrapper","NativeViewGestureHandler","RawButton","BaseButton","RectButton","BorderlessButton","TouchableHighlight","TouchableNativeFeedback","TouchableOpacity","TouchableWithoutFeedback","ScrollView","Switch","TextInput","DrawerLayoutAndroid","FlatList","Swipeable","DrawerLayout"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,OAAO,IAAIC,qBAApB,QAAiD,yBAAjD;AACA,SAASD,OAAO,IAAIE,sBAApB,QAAkD,0BAAlD;AAwBA,SACEC,iBADF,EAEEC,wBAFF,EAGEC,uBAHF,EAIEC,iBAJF,EAKEC,mBALF,EAMEC,sBANF,EAOEC,mBAPF,QAQO,4BARP;AASA,SAAST,OAAO,IAAIU,mBAApB,QAA+C,gCAA/C;AAKA,SAASC,wBAAT,QAAyC,qCAAzC;AAOA,SACEC,SADF,EAEEC,UAFF,EAGEC,UAHF,EAIEC,gBAJF,QAKO,6BALP;AAMA,SACEC,kBADF,EAEEC,uBAFF,EAGEC,gBAHF,EAIEC,wBAJF,QAKO,yBALP;AAMA,SACEC,UADF,EAEEC,MAFF,EAGEC,SAHF,EAIEC,mBAJF,EAKEC,QALF,QAMO,gCANP;AA8CA,SAASxB,OAAO,IAAIyB,SAApB,QAAqC,wBAArC;AASA,SAASzB,OAAO,IAAI0B,YAApB,QAAwC,2BAAxC","sourcesContent":["export { Directions } from './Directions';\nexport { State } from './State';\nexport { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';\nexport { default as GestureHandlerRootView } from './GestureHandlerRootView';\nexport type {\n  // event types\n  GestureEvent,\n  HandlerStateChangeEvent,\n  // event payloads types\n  GestureEventPayload,\n  HandlerStateChangeEventPayload,\n  TapGestureHandlerEventPayload,\n  ForceTouchGestureHandlerEventPayload,\n  LongPressGestureHandlerEventPayload,\n  PanGestureHandlerEventPayload,\n  PinchGestureHandlerEventPayload,\n  RotationGestureHandlerEventPayload,\n  FlingGestureHandlerEventPayload,\n  // gesture handlers props types\n  TapGestureHandlerProps,\n  ForceTouchGestureHandlerProps,\n  LongPressGestureHandlerProps,\n  PanGestureHandlerProps,\n  PinchGestureHandlerProps,\n  RotationGestureHandlerProps,\n  FlingGestureHandlerProps,\n} from './handlers/gestureHandlers';\nexport {\n  TapGestureHandler,\n  ForceTouchGestureHandler,\n  LongPressGestureHandler,\n  PanGestureHandler,\n  PinchGestureHandler,\n  RotationGestureHandler,\n  FlingGestureHandler,\n} from './handlers/gestureHandlers';\nexport { default as createNativeWrapper } from './handlers/createNativeWrapper';\nexport type {\n  NativeViewGestureHandlerPayload,\n  NativeViewGestureHandlerProps,\n} from './handlers/NativeViewGestureHandler';\nexport { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';\nexport type {\n  RawButtonProps,\n  BaseButtonProps,\n  RectButtonProps,\n  BorderlessButtonProps,\n} from './components/GestureButtons';\nexport {\n  RawButton,\n  BaseButton,\n  RectButton,\n  BorderlessButton,\n} from './components/GestureButtons';\nexport {\n  TouchableHighlight,\n  TouchableNativeFeedback,\n  TouchableOpacity,\n  TouchableWithoutFeedback,\n} from './components/touchables';\nexport {\n  ScrollView,\n  Switch,\n  TextInput,\n  DrawerLayoutAndroid,\n  FlatList,\n} from './components/GestureComponents';\nexport type {\n  //events\n  GestureHandlerGestureEvent,\n  GestureHandlerStateChangeEvent,\n  //event payloads\n  GestureHandlerGestureEventNativeEvent,\n  GestureHandlerStateChangeNativeEvent,\n  NativeViewGestureHandlerGestureEvent,\n  NativeViewGestureHandlerStateChangeEvent,\n  TapGestureHandlerGestureEvent,\n  TapGestureHandlerStateChangeEvent,\n  ForceTouchGestureHandlerGestureEvent,\n  ForceTouchGestureHandlerStateChangeEvent,\n  LongPressGestureHandlerGestureEvent,\n  LongPressGestureHandlerStateChangeEvent,\n  PanGestureHandlerGestureEvent,\n  PanGestureHandlerStateChangeEvent,\n  PinchGestureHandlerGestureEvent,\n  PinchGestureHandlerStateChangeEvent,\n  RotationGestureHandlerGestureEvent,\n  RotationGestureHandlerStateChangeEvent,\n  FlingGestureHandlerGestureEvent,\n  FlingGestureHandlerStateChangeEvent,\n  // handlers props\n  NativeViewGestureHandlerProperties,\n  TapGestureHandlerProperties,\n  LongPressGestureHandlerProperties,\n  PanGestureHandlerProperties,\n  PinchGestureHandlerProperties,\n  RotationGestureHandlerProperties,\n  FlingGestureHandlerProperties,\n  ForceTouchGestureHandlerProperties,\n  // buttons props\n  RawButtonProperties,\n  BaseButtonProperties,\n  RectButtonProperties,\n  BorderlessButtonProperties,\n} from './handlers/gestureHandlerTypesCompat';\n\nexport { default as Swipeable } from './components/Swipeable';\nexport type {\n  DrawerLayoutProps,\n  DrawerPosition,\n  DrawerState,\n  DrawerType,\n  DrawerLockMode,\n  DrawerKeyboardDismissMode,\n} from './components/DrawerLayout';\nexport { default as DrawerLayout } from './components/DrawerLayout';\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/mocks.js b/node_modules/react-native-gesture-handler/lib/module/mocks.js
new file mode 100644
index 0000000..3db61ca
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/mocks.js
@@ -0,0 +1,25 @@
+import { View, ScrollView as RNScrollView } from 'react-native';
+import { State } from './State';
+import { Directions } from './Directions';
+
+const NOOP = () => {// do nothing
+};
+
+const ScrollView = RNScrollView;
+const PanGestureHandler = View;
+const attachGestureHandler = NOOP;
+const createGestureHandler = NOOP;
+const dropGestureHandler = NOOP;
+const updateGestureHandler = NOOP;
+export default {
+  ScrollView,
+  PanGestureHandler,
+  attachGestureHandler,
+  createGestureHandler,
+  dropGestureHandler,
+  updateGestureHandler,
+  // probably can be removed
+  Directions,
+  State
+};
+//# sourceMappingURL=mocks.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/mocks.js.map b/node_modules/react-native-gesture-handler/lib/module/mocks.js.map
new file mode 100644
index 0000000..84cd28b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/mocks.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["mocks.ts"],"names":["View","ScrollView","RNScrollView","State","Directions","NOOP","PanGestureHandler","attachGestureHandler","createGestureHandler","dropGestureHandler","updateGestureHandler"],"mappings":"AAAA,SAASA,IAAT,EAAeC,UAAU,IAAIC,YAA7B,QAAiD,cAAjD;AACA,SAASC,KAAT,QAAsB,SAAtB;AACA,SAASC,UAAT,QAA2B,cAA3B;;AAEA,MAAMC,IAAI,GAAG,MAAM,CACjB;AACD,CAFD;;AAGA,MAAMJ,UAAU,GAAGC,YAAnB;AACA,MAAMI,iBAAiB,GAAGN,IAA1B;AACA,MAAMO,oBAAoB,GAAGF,IAA7B;AACA,MAAMG,oBAAoB,GAAGH,IAA7B;AACA,MAAMI,kBAAkB,GAAGJ,IAA3B;AACA,MAAMK,oBAAoB,GAAGL,IAA7B;AAEA,eAAe;AACbJ,EAAAA,UADa;AAEbK,EAAAA,iBAFa;AAGbC,EAAAA,oBAHa;AAIbC,EAAAA,oBAJa;AAKbC,EAAAA,kBALa;AAMbC,EAAAA,oBANa;AAOb;AACAN,EAAAA,UARa;AASbD,EAAAA;AATa,CAAf","sourcesContent":["import { View, ScrollView as RNScrollView } from 'react-native';\nimport { State } from './State';\nimport { Directions } from './Directions';\n\nconst NOOP = () => {\n  // do nothing\n};\nconst ScrollView = RNScrollView;\nconst PanGestureHandler = View;\nconst attachGestureHandler = NOOP;\nconst createGestureHandler = NOOP;\nconst dropGestureHandler = NOOP;\nconst updateGestureHandler = NOOP;\n\nexport default {\n  ScrollView,\n  PanGestureHandler,\n  attachGestureHandler,\n  createGestureHandler,\n  dropGestureHandler,\n  updateGestureHandler,\n  // probably can be removed\n  Directions,\n  State,\n} as const;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/typeUtils.js b/node_modules/react-native-gesture-handler/lib/module/typeUtils.js
new file mode 100644
index 0000000..28039a8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/typeUtils.js
@@ -0,0 +1,2 @@
+
+//# sourceMappingURL=typeUtils.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/typeUtils.js.map b/node_modules/react-native-gesture-handler/lib/module/typeUtils.js.map
new file mode 100644
index 0000000..9ffd4b2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/typeUtils.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":[],"names":[],"mappings":"","sourcesContent":[]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js
new file mode 100644
index 0000000..57c405e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js
@@ -0,0 +1,94 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+import GestureHandler from './GestureHandler';
+import { TEST_MAX_IF_NOT_NAN } from './utils';
+
+class DiscreteGestureHandler extends GestureHandler {
+  get isDiscrete() {
+    return true;
+  }
+
+  get shouldEnableGestureOnSetup() {
+    return true;
+  }
+
+  shouldFailUnderCustomCriteria({
+    x,
+    y,
+    deltaX,
+    deltaY
+  }, {
+    maxDeltaX,
+    maxDeltaY,
+    maxDistSq,
+    shouldCancelWhenOutside
+  }) {
+    if (shouldCancelWhenOutside) {
+      if (!this.isPointInView({
+        x,
+        y
+      })) {
+        return true;
+      }
+    }
+
+    return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);
+  }
+
+  transformNativeEvent({
+    center: {
+      x,
+      y
+    }
+  }) {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view.getBoundingClientRect();
+    return {
+      absoluteX: x,
+      absoluteY: y,
+      x: x - rect.left,
+      y: y - rect.top
+    };
+  }
+
+  isGestureEnabledForEvent({
+    minPointers,
+    maxPointers,
+    maxDeltaX,
+    maxDeltaY,
+    maxDistSq,
+    shouldCancelWhenOutside
+  }, _recognizer, {
+    maxPointers: pointerLength,
+    center,
+    deltaX,
+    deltaY
+  }) {
+    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;
+
+    if (this.shouldFailUnderCustomCriteria({ ...center,
+      deltaX,
+      deltaY
+    }, {
+      maxDeltaX,
+      maxDeltaY,
+      maxDistSq,
+      shouldCancelWhenOutside
+    }) || // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)
+    // but if the gesture is running and the user adds or subtracts another pointer then it should fail.
+    !validPointerCount && this.isGestureRunning) {
+      return {
+        failed: true
+      };
+    }
+
+    return {
+      success: validPointerCount
+    };
+  }
+
+}
+
+export default DiscreteGestureHandler;
+//# sourceMappingURL=DiscreteGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js.map
new file mode 100644
index 0000000..25d1d75
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/DiscreteGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DiscreteGestureHandler.ts"],"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","isDiscrete","shouldEnableGestureOnSetup","shouldFailUnderCustomCriteria","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","transformNativeEvent","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","isGestureEnabledForEvent","minPointers","maxPointers","_recognizer","pointerLength","validPointerCount","isGestureRunning","failed","success"],"mappings":"AAAA;;AACA;AACA,OAAOA,cAAP,MAA2B,kBAA3B;AACA,SAASC,mBAAT,QAAoC,SAApC;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7C,MAAVG,UAAU,GAAG;AACf,WAAO,IAAP;AACD;;AAE6B,MAA1BC,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,6BAA6B,CAC3B;AAAEC,IAAAA,CAAF;AAAKC,IAAAA,CAAL;AAAQC,IAAAA,MAAR;AAAgBC,IAAAA;AAAhB,GAD2B,EAE3B;AAAEC,IAAAA,SAAF;AAAaC,IAAAA,SAAb;AAAwBC,IAAAA,SAAxB;AAAmCC,IAAAA;AAAnC,GAF2B,EAG3B;AACA,QAAIA,uBAAJ,EAA6B;AAC3B,UAAI,CAAC,KAAKC,aAAL,CAAmB;AAAER,QAAAA,CAAF;AAAKC,QAAAA;AAAL,OAAnB,CAAL,EAAmC;AACjC,eAAO,IAAP;AACD;AACF;;AACD,WACEN,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACAT,mBAAmB,CAACc,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADnB,IAEAV,mBAAmB,CACjBc,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CADiB,EAEjBI,SAFiB,CAHrB;AAQD;;AAEDK,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAE;AAAEZ,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AAAV,GAAD,EAA4B;AAC9C;AACA,UAAMY,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AAEA,WAAO;AACLC,MAAAA,SAAS,EAAEhB,CADN;AAELiB,MAAAA,SAAS,EAAEhB,CAFN;AAGLD,MAAAA,CAAC,EAAEA,CAAC,GAAGa,IAAI,CAACK,IAHP;AAILjB,MAAAA,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACM;AAJP,KAAP;AAMD;;AAEDC,EAAAA,wBAAwB,CACtB;AACEC,IAAAA,WADF;AAEEC,IAAAA,WAFF;AAGElB,IAAAA,SAHF;AAIEC,IAAAA,SAJF;AAKEC,IAAAA,SALF;AAMEC,IAAAA;AANF,GADsB,EAStBgB,WATsB,EAUtB;AAAED,IAAAA,WAAW,EAAEE,aAAf;AAA8BZ,IAAAA,MAA9B;AAAsCV,IAAAA,MAAtC;AAA8CC,IAAAA;AAA9C,GAVsB,EAWtB;AACA,UAAMsB,iBAAiB,GACrBD,aAAa,IAAIH,WAAjB,IAAgCG,aAAa,IAAIF,WADnD;;AAGA,QACE,KAAKvB,6BAAL,CACE,EAAE,GAAGa,MAAL;AAAaV,MAAAA,MAAb;AAAqBC,MAAAA;AAArB,KADF,EAEE;AACEC,MAAAA,SADF;AAEEC,MAAAA,SAFF;AAGEC,MAAAA,SAHF;AAIEC,MAAAA;AAJF,KAFF,KASA;AACA;AACC,KAACkB,iBAAD,IAAsB,KAAKC,gBAZ9B,EAaE;AACA,aAAO;AAAEC,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AAED,WAAO;AAAEC,MAAAA,OAAO,EAAEH;AAAX,KAAP;AACD;;AAzE0D;;AA4E7D,eAAe7B,sBAAf","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\n\nabstract class DiscreteGestureHandler extends GestureHandler {\n  get isDiscrete() {\n    return true;\n  }\n\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { x, y, deltaX, deltaY }: any,\n    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any\n  ) {\n    if (shouldCancelWhenOutside) {\n      if (!this.isPointInView({ x, y })) {\n        return true;\n      }\n    }\n    return (\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n      TEST_MAX_IF_NOT_NAN(\n        Math.abs(deltaY * deltaY + deltaX * deltaX),\n        maxDistSq\n      )\n    );\n  }\n\n  transformNativeEvent({ center: { x, y } }: any) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n\n    return {\n      absoluteX: x,\n      absoluteY: y,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n\n  isGestureEnabledForEvent(\n    {\n      minPointers,\n      maxPointers,\n      maxDeltaX,\n      maxDeltaY,\n      maxDistSq,\n      shouldCancelWhenOutside,\n    }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength, center, deltaX, deltaY }: any\n  ) {\n    const validPointerCount =\n      pointerLength >= minPointers && pointerLength <= maxPointers;\n\n    if (\n      this.shouldFailUnderCustomCriteria(\n        { ...center, deltaX, deltaY },\n        {\n          maxDeltaX,\n          maxDeltaY,\n          maxDistSq,\n          shouldCancelWhenOutside,\n        }\n      ) ||\n      // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n      // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n      (!validPointerCount && this.isGestureRunning)\n    ) {\n      return { failed: true };\n    }\n\n    return { success: validPointerCount };\n  }\n}\n\nexport default DiscreteGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/web/DraggingGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js
similarity index 75%
rename from node_modules/react-native-gesture-handler/web/DraggingGestureHandler.js
rename to node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js
index ec0bd67..a652f1d 100644
--- a/node_modules/react-native-gesture-handler/web/DraggingGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js
@@ -1,3 +1,6 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
 import GestureHandler from './GestureHandler';
 import { PixelRatio } from 'react-native';
 
@@ -11,8 +14,12 @@ class DraggingGestureHandler extends GestureHandler {
     deltaY,
     velocityX,
     velocityY,
-    center: { x, y },
+    center: {
+      x,
+      y
+    }
   }) {
+    // @ts-ignore FIXME(TS)
     const rect = this.view.getBoundingClientRect();
     const ratio = PixelRatio.get();
     return {
@@ -23,9 +30,11 @@ class DraggingGestureHandler extends GestureHandler {
       velocityX: velocityX * ratio,
       velocityY: velocityY * ratio,
       x: x - rect.left,
-      y: y - rect.top,
+      y: y - rect.top
     };
   }
+
 }
 
 export default DraggingGestureHandler;
+//# sourceMappingURL=DraggingGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js.map
new file mode 100644
index 0000000..3a9ce9b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/DraggingGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["DraggingGestureHandler.ts"],"names":["GestureHandler","PixelRatio","DraggingGestureHandler","shouldEnableGestureOnSetup","transformNativeEvent","deltaX","deltaY","velocityX","velocityY","center","x","y","rect","view","getBoundingClientRect","ratio","get","translationX","__initialX","translationY","__initialY","absoluteX","absoluteY","left","top"],"mappings":"AAAA;;AACA;AACA,OAAOA,cAAP,MAA+C,kBAA/C;AACA,SAASC,UAAT,QAA2B,cAA3B;;AAEA,MAAeC,sBAAf,SAA8CF,cAA9C,CAA6D;AAC7B,MAA1BG,0BAA0B,GAAG;AAC/B,WAAO,IAAP;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AACnBC,IAAAA,MADmB;AAEnBC,IAAAA,MAFmB;AAGnBC,IAAAA,SAHmB;AAInBC,IAAAA,SAJmB;AAKnBC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,CAAF;AAAKC,MAAAA;AAAL;AALW,GAAD,EAMD;AACjB;AACA,UAAMC,IAAI,GAAG,KAAKC,IAAL,CAAWC,qBAAX,EAAb;AACA,UAAMC,KAAK,GAAGd,UAAU,CAACe,GAAX,EAAd;AACA,WAAO;AACLC,MAAAA,YAAY,EAAEZ,MAAM,IAAI,KAAKa,UAAL,IAAmB,CAAvB,CADf;AAELC,MAAAA,YAAY,EAAEb,MAAM,IAAI,KAAKc,UAAL,IAAmB,CAAvB,CAFf;AAGLC,MAAAA,SAAS,EAAEX,CAHN;AAILY,MAAAA,SAAS,EAAEX,CAJN;AAKLJ,MAAAA,SAAS,EAAEA,SAAS,GAAGQ,KALlB;AAMLP,MAAAA,SAAS,EAAEA,SAAS,GAAGO,KANlB;AAOLL,MAAAA,CAAC,EAAEA,CAAC,GAAGE,IAAI,CAACW,IAPP;AAQLZ,MAAAA,CAAC,EAAEA,CAAC,GAAGC,IAAI,CAACY;AARP,KAAP;AAUD;;AAzB0D;;AA4B7D,eAAetB,sBAAf","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler, { HammerInputExt } from './GestureHandler';\nimport { PixelRatio } from 'react-native';\n\nabstract class DraggingGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return true;\n  }\n\n  transformNativeEvent({\n    deltaX,\n    deltaY,\n    velocityX,\n    velocityY,\n    center: { x, y },\n  }: HammerInputExt) {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const ratio = PixelRatio.get();\n    return {\n      translationX: deltaX - (this.__initialX || 0),\n      translationY: deltaY - (this.__initialY || 0),\n      absoluteX: x,\n      absoluteY: y,\n      velocityX: velocityX * ratio,\n      velocityY: velocityY * ratio,\n      x: x - rect.left,\n      y: y - rect.top,\n    };\n  }\n}\n\nexport default DraggingGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/Errors.js b/node_modules/react-native-gesture-handler/lib/module/web/Errors.js
new file mode 100644
index 0000000..1a00db7
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/Errors.js
@@ -0,0 +1,7 @@
+export class GesturePropError extends Error {
+  constructor(name, value, expectedType) {
+    super("Invalid property `".concat(name, ": ").concat(value, "` expected `").concat(expectedType, "`"));
+  }
+
+}
+//# sourceMappingURL=Errors.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/Errors.js.map b/node_modules/react-native-gesture-handler/lib/module/web/Errors.js.map
new file mode 100644
index 0000000..701a913
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/Errors.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["Errors.ts"],"names":["GesturePropError","Error","constructor","name","value","expectedType"],"mappings":"AAAA,OAAO,MAAMA,gBAAN,SAA+BC,KAA/B,CAAqC;AAC1CC,EAAAA,WAAW,CAACC,IAAD,EAAeC,KAAf,EAA+BC,YAA/B,EAAqD;AAC9D,sCACwBF,IADxB,eACiCC,KADjC,yBACuDC,YADvD;AAGD;;AALyC","sourcesContent":["export class GesturePropError extends Error {\n  constructor(name: string, value: unknown, expectedType: string) {\n    super(\n      `Invalid property \\`${name}: ${value}\\` expected \\`${expectedType}\\``\n    );\n  }\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js
new file mode 100644
index 0000000..4eeb510
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js
@@ -0,0 +1,156 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+import Hammer from '@egjs/hammerjs';
+import { Direction } from './constants';
+import { GesturePropError } from './Errors';
+import DraggingGestureHandler from './DraggingGestureHandler';
+import { isnan } from './utils';
+
+class FlingGestureHandler extends DraggingGestureHandler {
+  get name() {
+    return 'swipe';
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Swipe;
+  }
+
+  onGestureActivated(event) {
+    this.sendEvent({ ...event,
+      eventType: Hammer.INPUT_MOVE,
+      isFinal: false,
+      isFirst: true
+    });
+    this.isGestureRunning = false;
+    this.hasGestureFailed = false;
+    this.sendEvent({ ...event,
+      eventType: Hammer.INPUT_END,
+      isFinal: true
+    });
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (this.hasGestureFailed) {
+      return;
+    } // Hammer doesn't send a `cancel` event for taps.
+    // Manually fail the event.
+
+
+    if (ev.isFinal) {
+      setTimeout(() => {
+        if (this.isGestureRunning) {
+          this.cancelEvent(ev);
+        }
+      });
+    } else if (!this.hasGestureFailed && !this.isGestureRunning) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore FIXME(TS)
+
+      if (gesture.options.enable(gesture, ev)) {
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+  }
+
+  getHammerConfig() {
+    return {
+      // @ts-ignore FIXME(TS)
+      pointers: this.config.numberOfPointers,
+      direction: this.getDirection()
+    };
+  }
+
+  getTargetDirections(direction) {
+    const directions = [];
+
+    if (direction & Direction.RIGHT) {
+      directions.push(Hammer.DIRECTION_RIGHT);
+    }
+
+    if (direction & Direction.LEFT) {
+      directions.push(Hammer.DIRECTION_LEFT);
+    }
+
+    if (direction & Direction.UP) {
+      directions.push(Hammer.DIRECTION_UP);
+    }
+
+    if (direction & Direction.DOWN) {
+      directions.push(Hammer.DIRECTION_DOWN);
+    } // const hammerDirection = directions.reduce((a, b) => a | b, 0);
+
+
+    return directions;
+  }
+
+  getDirection() {
+    // @ts-ignore FIXME(TS)
+    const {
+      direction
+    } = this.getConfig();
+    let directions = [];
+
+    if (direction & Direction.RIGHT) {
+      directions.push(Hammer.DIRECTION_HORIZONTAL);
+    }
+
+    if (direction & Direction.LEFT) {
+      directions.push(Hammer.DIRECTION_HORIZONTAL);
+    }
+
+    if (direction & Direction.UP) {
+      directions.push(Hammer.DIRECTION_VERTICAL);
+    }
+
+    if (direction & Direction.DOWN) {
+      directions.push(Hammer.DIRECTION_VERTICAL);
+    }
+
+    directions = [...new Set(directions)];
+    if (directions.length === 0) return Hammer.DIRECTION_NONE;
+    if (directions.length === 1) return directions[0];
+    return Hammer.DIRECTION_ALL;
+  }
+
+  isGestureEnabledForEvent({
+    numberOfPointers
+  }, _recognizer, {
+    maxPointers: pointerLength
+  }) {
+    const validPointerCount = pointerLength === numberOfPointers;
+
+    if (!validPointerCount && this.isGestureRunning) {
+      return {
+        failed: true
+      };
+    }
+
+    return {
+      success: validPointerCount
+    };
+  }
+
+  updateGestureConfig({
+    numberOfPointers = 1,
+    direction,
+    ...props
+  }) {
+    if (isnan(direction) || typeof direction !== 'number') {
+      throw new GesturePropError('direction', direction, 'number');
+    }
+
+    return super.updateGestureConfig({
+      numberOfPointers,
+      direction,
+      ...props
+    });
+  }
+
+}
+
+export default FlingGestureHandler;
+//# sourceMappingURL=FlingGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js.map
new file mode 100644
index 0000000..a6336ec
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/FlingGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["FlingGestureHandler.ts"],"names":["Hammer","Direction","GesturePropError","DraggingGestureHandler","isnan","FlingGestureHandler","name","NativeGestureClass","Swipe","onGestureActivated","event","sendEvent","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","props"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js
new file mode 100644
index 0000000..9d98039
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js
@@ -0,0 +1,520 @@
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+import Hammer from '@egjs/hammerjs';
+import { findNodeHandle } from 'react-native';
+import { State } from '../State';
+import { EventMap } from './constants';
+import * as NodeManager from './NodeManager'; // TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged
+
+let gestureInstances = 0;
+
+class GestureHandler {
+  get id() {
+    return "".concat(this.name).concat(this.gestureInstance);
+  }
+
+  get isDiscrete() {
+    return false;
+  }
+
+  get shouldEnableGestureOnSetup() {
+    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');
+  }
+
+  constructor() {
+    _defineProperty(this, "handlerTag", void 0);
+
+    _defineProperty(this, "isGestureRunning", false);
+
+    _defineProperty(this, "view", null);
+
+    _defineProperty(this, "hasCustomActivationCriteria", void 0);
+
+    _defineProperty(this, "hasGestureFailed", false);
+
+    _defineProperty(this, "hammer", null);
+
+    _defineProperty(this, "initialRotation", null);
+
+    _defineProperty(this, "__initialX", void 0);
+
+    _defineProperty(this, "__initialY", void 0);
+
+    _defineProperty(this, "config", {});
+
+    _defineProperty(this, "previousState", State.UNDETERMINED);
+
+    _defineProperty(this, "pendingGestures", {});
+
+    _defineProperty(this, "oldState", State.UNDETERMINED);
+
+    _defineProperty(this, "lastSentState", null);
+
+    _defineProperty(this, "gestureInstance", void 0);
+
+    _defineProperty(this, "_stillWaiting", void 0);
+
+    _defineProperty(this, "propsRef", void 0);
+
+    _defineProperty(this, "ref", void 0);
+
+    _defineProperty(this, "clearSelfAsPending", () => {
+      if (Array.isArray(this.config.waitFor)) {
+        for (const gesture of this.config.waitFor) {
+          gesture.removePendingGesture(this.id);
+        }
+      }
+    });
+
+    _defineProperty(this, "destroy", () => {
+      this.clearSelfAsPending();
+
+      if (this.hammer) {
+        this.hammer.stop(false);
+        this.hammer.destroy();
+      }
+
+      this.hammer = null;
+    });
+
+    _defineProperty(this, "isPointInView", ({
+      x,
+      y
+    }) => {
+      // @ts-ignore FIXME(TS)
+      const rect = this.view.getBoundingClientRect();
+      const pointerInside = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
+      return pointerInside;
+    });
+
+    _defineProperty(this, "sendEvent", nativeEvent => {
+      const {
+        onGestureHandlerEvent,
+        onGestureHandlerStateChange
+      } = this.propsRef.current;
+      const event = this.transformEventData(nativeEvent);
+      invokeNullableMethod(onGestureHandlerEvent, event);
+
+      if (this.lastSentState !== event.nativeEvent.state) {
+        this.lastSentState = event.nativeEvent.state;
+        invokeNullableMethod(onGestureHandlerStateChange, event);
+      }
+    });
+
+    _defineProperty(this, "sync", () => {
+      const gesture = this.hammer.get(this.name);
+      if (!gesture) return;
+
+      const enable = (recognizer, inputData) => {
+        if (!this.config.enabled) {
+          this.isGestureRunning = false;
+          this.hasGestureFailed = false;
+          return false;
+        } // Prevent events before the system is ready.
+
+
+        if (!inputData || !recognizer.options || typeof inputData.maxPointers === 'undefined') {
+          return this.shouldEnableGestureOnSetup;
+        }
+
+        if (this.hasGestureFailed) {
+          return false;
+        }
+
+        if (!this.isDiscrete) {
+          if (this.isGestureRunning) {
+            return true;
+          } // The built-in hammer.js "waitFor" doesn't work across multiple views.
+          // Only process if there are views to wait for.
+
+
+          this._stillWaiting = this._getPendingGestures(); // This gesture should continue waiting.
+
+          if (this._stillWaiting.length) {
+            // Check to see if one of the gestures you're waiting for has started.
+            // If it has then the gesture should fail.
+            for (const gesture of this._stillWaiting) {
+              // When the target gesture has started, this gesture must force fail.
+              if (!gesture.isDiscrete && gesture.isGestureRunning) {
+                this.hasGestureFailed = true;
+                this.isGestureRunning = false;
+                return false;
+              }
+            } // This gesture shouldn't start until the others have finished.
+
+
+            return false;
+          }
+        } // Use default behaviour
+
+
+        if (!this.hasCustomActivationCriteria) {
+          return true;
+        }
+
+        const deltaRotation = this.initialRotation == null ? 0 : inputData.rotation - this.initialRotation; // @ts-ignore FIXME(TS)
+
+        const {
+          success,
+          failed
+        } = this.isGestureEnabledForEvent(this.getConfig(), recognizer, { ...inputData,
+          deltaRotation
+        });
+
+        if (failed) {
+          this.simulateCancelEvent(inputData);
+          this.hasGestureFailed = true;
+        }
+
+        return success;
+      };
+
+      const params = this.getHammerConfig(); // @ts-ignore FIXME(TS)
+
+      gesture.set({ ...params,
+        enable
+      });
+    });
+
+    this.gestureInstance = gestureInstances++;
+    this.hasCustomActivationCriteria = false;
+  }
+
+  getConfig() {
+    return this.config;
+  }
+
+  onWaitingEnded(_gesture) {}
+
+  removePendingGesture(id) {
+    delete this.pendingGestures[id];
+  }
+
+  addPendingGesture(gesture) {
+    this.pendingGestures[gesture.id] = gesture;
+  }
+
+  isGestureEnabledForEvent(_config, _recognizer, _event) {
+    return {
+      success: true
+    };
+  }
+
+  get NativeGestureClass() {
+    throw new Error('Must override GestureHandler.NativeGestureClass');
+  }
+
+  updateHasCustomActivationCriteria(_config) {
+    return true;
+  }
+
+  updateGestureConfig({
+    enabled = true,
+    ...props
+  }) {
+    this.clearSelfAsPending();
+    this.config = ensureConfig({
+      enabled,
+      ...props
+    });
+    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(this.config);
+
+    if (Array.isArray(this.config.waitFor)) {
+      for (const gesture of this.config.waitFor) {
+        gesture.addPendingGesture(this);
+      }
+    }
+
+    if (this.hammer) {
+      this.sync();
+    }
+
+    return this.config;
+  }
+
+  getState(type) {
+    // @ts-ignore TODO(TS) check if this is needed
+    if (type == 0) {
+      return 0;
+    }
+
+    return EventMap[type];
+  }
+
+  transformEventData(event) {
+    const {
+      eventType,
+      maxPointers: numberOfPointers
+    } = event; // const direction = DirectionMap[ev.direction];
+
+    const changedTouch = event.changedPointers[0];
+    const pointerInside = this.isPointInView({
+      x: changedTouch.clientX,
+      y: changedTouch.clientY
+    }); // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.
+
+    const state = this.getState(eventType);
+
+    if (state !== this.previousState) {
+      this.oldState = this.previousState;
+      this.previousState = state;
+    }
+
+    return {
+      nativeEvent: {
+        numberOfPointers,
+        state,
+        pointerInside,
+        ...this.transformNativeEvent(event),
+        // onHandlerStateChange only
+        handlerTag: this.handlerTag,
+        target: this.ref,
+        oldState: this.oldState
+      },
+      timeStamp: Date.now()
+    };
+  }
+
+  transformNativeEvent(_event) {
+    return {};
+  }
+
+  cancelPendingGestures(event) {
+    for (const gesture of Object.values(this.pendingGestures)) {
+      if (gesture && gesture.isGestureRunning) {
+        gesture.hasGestureFailed = true;
+        gesture.cancelEvent(event);
+      }
+    }
+  }
+
+  notifyPendingGestures() {
+    for (const gesture of Object.values(this.pendingGestures)) {
+      if (gesture) {
+        gesture.onWaitingEnded(this);
+      }
+    }
+  } // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input
+
+
+  onGestureEnded(event) {
+    this.isGestureRunning = false;
+    this.cancelPendingGestures(event);
+  }
+
+  forceInvalidate(event) {
+    if (this.isGestureRunning) {
+      this.hasGestureFailed = true;
+      this.cancelEvent(event);
+    }
+  }
+
+  cancelEvent(event) {
+    this.notifyPendingGestures();
+    this.sendEvent({ ...event,
+      eventType: Hammer.INPUT_CANCEL,
+      isFinal: true
+    });
+    this.onGestureEnded(event);
+  }
+
+  onRawEvent({
+    isFirst
+  }) {
+    if (isFirst) {
+      this.hasGestureFailed = false;
+    }
+  }
+
+  setView(ref, propsRef) {
+    if (ref == null) {
+      this.destroy();
+      this.view = null;
+      return;
+    }
+
+    this.propsRef = propsRef;
+    this.ref = ref;
+    this.view = findNodeHandle(ref);
+    this.hammer = new Hammer.Manager(this.view);
+    this.oldState = State.UNDETERMINED;
+    this.previousState = State.UNDETERMINED;
+    this.lastSentState = null;
+    const {
+      NativeGestureClass
+    } = this; // @ts-ignore TODO(TS)
+
+    const gesture = new NativeGestureClass(this.getHammerConfig());
+    this.hammer.add(gesture);
+    this.hammer.on('hammer.input', ev => {
+      if (!this.config.enabled) {
+        this.hasGestureFailed = false;
+        this.isGestureRunning = false;
+        return;
+      }
+
+      this.onRawEvent(ev); // TODO: Bacon: Check against something other than null
+      // The isFirst value is not called when the first rotation is calculated.
+
+      if (this.initialRotation === null && ev.rotation !== 0) {
+        this.initialRotation = ev.rotation;
+      }
+
+      if (ev.isFinal) {
+        // in favor of a willFail otherwise the last frame of the gesture will be captured.
+        setTimeout(() => {
+          this.initialRotation = null;
+          this.hasGestureFailed = false;
+        });
+      }
+    });
+    this.setupEvents();
+    this.sync();
+  }
+
+  setupEvents() {
+    // TODO(TS) Hammer types aren't exactly that what we get in runtime
+    if (!this.isDiscrete) {
+      this.hammer.on("".concat(this.name, "start"), event => this.onStart(event));
+      this.hammer.on("".concat(this.name, "end ").concat(this.name, "cancel"), event => {
+        this.onGestureEnded(event);
+      });
+    }
+
+    this.hammer.on(this.name, ev => this.onGestureActivated(ev)); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged
+  }
+
+  onStart({
+    deltaX,
+    deltaY,
+    rotation
+  }) {
+    // Reset the state for the next gesture
+    this.oldState = State.UNDETERMINED;
+    this.previousState = State.UNDETERMINED;
+    this.lastSentState = null;
+    this.isGestureRunning = true;
+    this.__initialX = deltaX;
+    this.__initialY = deltaY;
+    this.initialRotation = rotation;
+  }
+
+  onGestureActivated(ev) {
+    this.sendEvent(ev);
+  }
+
+  onSuccess() {}
+
+  _getPendingGestures() {
+    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {
+      // Get the list of gestures that this gesture is still waiting for.
+      // Use `=== false` in case a ref that isn't a gesture handler is used.
+      const stillWaiting = this.config.waitFor.filter(({
+        hasGestureFailed
+      }) => hasGestureFailed === false);
+      return stillWaiting;
+    }
+
+    return [];
+  }
+
+  getHammerConfig() {
+    const pointers = this.config.minPointers === this.config.maxPointers ? this.config.minPointers : 0;
+    return {
+      pointers
+    };
+  }
+
+  simulateCancelEvent(_inputData) {}
+
+} // TODO(TS) investigate this method
+// Used for sending data to a callback or AnimatedEvent
+
+
+function invokeNullableMethod(method, event) {
+  if (method) {
+    if (typeof method === 'function') {
+      method(event);
+    } else {
+      // For use with reanimated's AnimatedEvent
+      if ('__getHandler' in method && typeof method.__getHandler === 'function') {
+        const handler = method.__getHandler();
+
+        invokeNullableMethod(handler, event);
+      } else {
+        if ('__nodeConfig' in method) {
+          const {
+            argMapping
+          } = method.__nodeConfig;
+
+          if (Array.isArray(argMapping)) {
+            for (const index in argMapping) {
+              const [key, value] = argMapping[index];
+
+              if (key in event.nativeEvent) {
+                // @ts-ignore fix method type
+                const nativeValue = event.nativeEvent[key];
+
+                if (value && value.setValue) {
+                  // Reanimated API
+                  value.setValue(nativeValue);
+                } else {
+                  // RN Animated API
+                  method.__nodeConfig.argMapping[index] = [key, nativeValue];
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+} // Validate the props
+
+
+function ensureConfig(config) {
+  const props = { ...config
+  }; // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)
+
+  if ('minDist' in config) {
+    props.minDist = config.minDist;
+    props.minDistSq = props.minDist * props.minDist;
+  }
+
+  if ('minVelocity' in config) {
+    props.minVelocity = config.minVelocity;
+    props.minVelocitySq = props.minVelocity * props.minVelocity;
+  }
+
+  if ('maxDist' in config) {
+    props.maxDist = config.maxDist;
+    props.maxDistSq = config.maxDist * config.maxDist;
+  }
+
+  if ('waitFor' in config) {
+    props.waitFor = asArray(config.waitFor).map(({
+      handlerTag
+    }) => NodeManager.getHandler(handlerTag)).filter(v => v);
+  } else {
+    props.waitFor = null;
+  }
+
+  const configProps = ['minPointers', 'maxPointers', 'minDist', 'maxDist', 'maxDistSq', 'minVelocitySq', 'minDistSq', 'minVelocity', 'failOffsetXStart', 'failOffsetYStart', 'failOffsetXEnd', 'failOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'activeOffsetYStart', 'activeOffsetYEnd'];
+  configProps.forEach(prop => {
+    if (typeof props[prop] === 'undefined') {
+      props[prop] = Number.NaN;
+    }
+  });
+  return props; // TODO(TS) how to convince TS that props are filled?
+}
+
+function asArray(value) {
+  // TODO(TS) use config.waitFor type
+  return value == null ? [] : Array.isArray(value) ? value : [value];
+}
+
+export default GestureHandler;
+//# sourceMappingURL=GestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js.map
new file mode 100644
index 0000000..f786f40
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/GestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["GestureHandler.ts"],"names":["Hammer","findNodeHandle","State","EventMap","NodeManager","gestureInstances","GestureHandler","id","name","gestureInstance","isDiscrete","shouldEnableGestureOnSetup","Error","constructor","UNDETERMINED","Array","isArray","config","waitFor","gesture","removePendingGesture","clearSelfAsPending","hammer","stop","destroy","x","y","rect","view","getBoundingClientRect","pointerInside","left","right","top","bottom","nativeEvent","onGestureHandlerEvent","onGestureHandlerStateChange","propsRef","current","event","transformEventData","invokeNullableMethod","lastSentState","state","get","enable","recognizer","inputData","enabled","isGestureRunning","hasGestureFailed","options","maxPointers","_stillWaiting","_getPendingGestures","length","hasCustomActivationCriteria","deltaRotation","initialRotation","rotation","success","failed","isGestureEnabledForEvent","getConfig","simulateCancelEvent","params","getHammerConfig","set","onWaitingEnded","_gesture","pendingGestures","addPendingGesture","_config","_recognizer","_event","NativeGestureClass","updateHasCustomActivationCriteria","updateGestureConfig","props","ensureConfig","sync","getState","type","eventType","numberOfPointers","changedTouch","changedPointers","isPointInView","clientX","clientY","previousState","oldState","transformNativeEvent","handlerTag","target","ref","timeStamp","Date","now","cancelPendingGestures","Object","values","cancelEvent","notifyPendingGestures","onGestureEnded","forceInvalidate","sendEvent","INPUT_CANCEL","isFinal","onRawEvent","isFirst","setView","Manager","add","on","ev","setTimeout","setupEvents","onStart","onGestureActivated","deltaX","deltaY","__initialX","__initialY","onSuccess","stillWaiting","filter","pointers","minPointers","_inputData","method","__getHandler","handler","argMapping","__nodeConfig","index","key","value","nativeValue","setValue","minDist","minDistSq","minVelocity","minVelocitySq","maxDist","maxDistSq","asArray","map","getHandler","v","configProps","forEach","prop","Number","NaN"],"mappings":"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","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\nimport { findNodeHandle } from 'react-native';\n\nimport { State } from '../State';\nimport { EventMap } from './constants';\nimport * as NodeManager from './NodeManager';\n\n// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged\nexport type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;\n\nexport type Config = Partial<{\n  enabled: boolean;\n  minPointers: number;\n  maxPointers: number;\n  minDist: number;\n  minDistSq: number;\n  minVelocity: number;\n  minVelocitySq: number;\n  maxDist: number;\n  maxDistSq: number;\n  failOffsetXStart: number;\n  failOffsetYStart: number;\n  failOffsetXEnd: number;\n  failOffsetYEnd: number;\n  activeOffsetXStart: number;\n  activeOffsetXEnd: number;\n  activeOffsetYStart: number;\n  activeOffsetYEnd: number;\n  waitFor: any[] | null;\n}>;\n\ntype NativeEvent = ReturnType<GestureHandler['transformEventData']>;\n\nlet gestureInstances = 0;\n\nabstract class GestureHandler {\n  public handlerTag: any;\n  public isGestureRunning = false;\n  public view: number | null = null;\n  protected hasCustomActivationCriteria: boolean;\n  protected hasGestureFailed = false;\n  protected hammer: HammerManager | null = null;\n  protected initialRotation: number | null = null;\n  protected __initialX: any;\n  protected __initialY: any;\n  protected config: Config = {};\n  protected previousState: State = State.UNDETERMINED;\n  private pendingGestures: Record<string, this> = {};\n  private oldState: State = State.UNDETERMINED;\n  private lastSentState: State | null = null;\n  private gestureInstance: number;\n  private _stillWaiting: any;\n  private propsRef: any;\n  private ref: any;\n\n  abstract get name(): string;\n\n  get id() {\n    return `${this.name}${this.gestureInstance}`;\n  }\n\n  get isDiscrete() {\n    return false;\n  }\n\n  get shouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  constructor() {\n    this.gestureInstance = gestureInstances++;\n    this.hasCustomActivationCriteria = false;\n  }\n\n  getConfig() {\n    return this.config;\n  }\n\n  onWaitingEnded(_gesture: this) {}\n\n  removePendingGesture(id: string) {\n    delete this.pendingGestures[id];\n  }\n\n  addPendingGesture(gesture: this) {\n    this.pendingGestures[gesture.id] = gesture;\n  }\n\n  isGestureEnabledForEvent(\n    _config: any,\n    _recognizer: any,\n    _event: any\n  ): { failed?: boolean; success?: boolean } {\n    return { success: true };\n  }\n\n  get NativeGestureClass(): RecognizerStatic {\n    throw new Error('Must override GestureHandler.NativeGestureClass');\n  }\n\n  updateHasCustomActivationCriteria(_config: Config) {\n    return true;\n  }\n\n  clearSelfAsPending = () => {\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.removePendingGesture(this.id);\n      }\n    }\n  };\n\n  updateGestureConfig({ enabled = true, ...props }) {\n    this.clearSelfAsPending();\n\n    this.config = ensureConfig({ enabled, ...props });\n    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(\n      this.config\n    );\n    if (Array.isArray(this.config.waitFor)) {\n      for (const gesture of this.config.waitFor) {\n        gesture.addPendingGesture(this);\n      }\n    }\n\n    if (this.hammer) {\n      this.sync();\n    }\n    return this.config;\n  }\n\n  destroy = () => {\n    this.clearSelfAsPending();\n\n    if (this.hammer) {\n      this.hammer.stop(false);\n      this.hammer.destroy();\n    }\n    this.hammer = null;\n  };\n\n  isPointInView = ({ x, y }: { x: number; y: number }) => {\n    // @ts-ignore FIXME(TS)\n    const rect = this.view!.getBoundingClientRect();\n    const pointerInside =\n      x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n    return pointerInside;\n  };\n\n  getState(type: keyof typeof EventMap): State {\n    // @ts-ignore TODO(TS) check if this is needed\n    if (type == 0) {\n      return 0;\n    }\n    return EventMap[type];\n  }\n\n  transformEventData(event: HammerInputExt) {\n    const { eventType, maxPointers: numberOfPointers } = event;\n    // const direction = DirectionMap[ev.direction];\n    const changedTouch = event.changedPointers[0];\n    const pointerInside = this.isPointInView({\n      x: changedTouch.clientX,\n      y: changedTouch.clientY,\n    });\n\n    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.\n    const state = this.getState(eventType as 1 | 2 | 4 | 8);\n    if (state !== this.previousState) {\n      this.oldState = this.previousState;\n      this.previousState = state;\n    }\n\n    return {\n      nativeEvent: {\n        numberOfPointers,\n        state,\n        pointerInside,\n        ...this.transformNativeEvent(event),\n        // onHandlerStateChange only\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: this.oldState,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  transformNativeEvent(_event: HammerInputExt) {\n    return {};\n  }\n\n  sendEvent = (nativeEvent: HammerInputExt) => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    } = this.propsRef.current;\n\n    const event = this.transformEventData(nativeEvent);\n\n    invokeNullableMethod(onGestureHandlerEvent, event);\n    if (this.lastSentState !== event.nativeEvent.state) {\n      this.lastSentState = event.nativeEvent.state as State;\n      invokeNullableMethod(onGestureHandlerStateChange, event);\n    }\n  };\n\n  cancelPendingGestures(event: HammerInputExt) {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture && gesture.isGestureRunning) {\n        gesture.hasGestureFailed = true;\n        gesture.cancelEvent(event);\n      }\n    }\n  }\n\n  notifyPendingGestures() {\n    for (const gesture of Object.values(this.pendingGestures)) {\n      if (gesture) {\n        gesture.onWaitingEnded(this);\n      }\n    }\n  }\n\n  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input\n  onGestureEnded(event: HammerInputExt) {\n    this.isGestureRunning = false;\n    this.cancelPendingGestures(event);\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.hasGestureFailed = true;\n      this.cancelEvent(event);\n    }\n  }\n\n  cancelEvent(event: HammerInputExt) {\n    this.notifyPendingGestures();\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_CANCEL,\n      isFinal: true,\n    });\n    this.onGestureEnded(event);\n  }\n\n  onRawEvent({ isFirst }: HammerInputExt) {\n    if (isFirst) {\n      this.hasGestureFailed = false;\n    }\n  }\n\n  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {\n    if (ref == null) {\n      this.destroy();\n      this.view = null;\n      return;\n    }\n\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.view = findNodeHandle(ref);\n    this.hammer = new Hammer.Manager(this.view as any);\n\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    const { NativeGestureClass } = this;\n    // @ts-ignore TODO(TS)\n    const gesture = new NativeGestureClass(this.getHammerConfig());\n    this.hammer.add(gesture);\n\n    this.hammer.on('hammer.input', (ev: HammerInput) => {\n      if (!this.config.enabled) {\n        this.hasGestureFailed = false;\n        this.isGestureRunning = false;\n        return;\n      }\n\n      this.onRawEvent((ev as unknown) as HammerInputExt);\n\n      // TODO: Bacon: Check against something other than null\n      // The isFirst value is not called when the first rotation is calculated.\n      if (this.initialRotation === null && ev.rotation !== 0) {\n        this.initialRotation = ev.rotation;\n      }\n      if (ev.isFinal) {\n        // in favor of a willFail otherwise the last frame of the gesture will be captured.\n        setTimeout(() => {\n          this.initialRotation = null;\n          this.hasGestureFailed = false;\n        });\n      }\n    });\n\n    this.setupEvents();\n    this.sync();\n  }\n\n  setupEvents() {\n    // TODO(TS) Hammer types aren't exactly that what we get in runtime\n    if (!this.isDiscrete) {\n      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>\n        this.onStart((event as unknown) as HammerInputExt)\n      );\n      this.hammer!.on(\n        `${this.name}end ${this.name}cancel`,\n        (event: HammerInput) => {\n          this.onGestureEnded((event as unknown) as HammerInputExt);\n        }\n      );\n    }\n    this.hammer!.on(this.name, (ev: HammerInput) =>\n      this.onGestureActivated((ev as unknown) as HammerInputExt)\n    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged\n  }\n\n  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {\n    // Reset the state for the next gesture\n    this.oldState = State.UNDETERMINED;\n    this.previousState = State.UNDETERMINED;\n    this.lastSentState = null;\n\n    this.isGestureRunning = true;\n    this.__initialX = deltaX;\n    this.__initialY = deltaY;\n    this.initialRotation = rotation;\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.sendEvent(ev);\n  }\n\n  onSuccess() {}\n\n  _getPendingGestures() {\n    if (Array.isArray(this.config.waitFor) && this.config.waitFor.length) {\n      // Get the list of gestures that this gesture is still waiting for.\n      // Use `=== false` in case a ref that isn't a gesture handler is used.\n      const stillWaiting = this.config.waitFor.filter(\n        ({ hasGestureFailed }) => hasGestureFailed === false\n      );\n      return stillWaiting;\n    }\n    return [];\n  }\n\n  getHammerConfig() {\n    const pointers =\n      this.config.minPointers === this.config.maxPointers\n        ? this.config.minPointers\n        : 0;\n    return {\n      pointers,\n    };\n  }\n\n  sync = () => {\n    const gesture = this.hammer!.get(this.name);\n    if (!gesture) return;\n\n    const enable = (recognizer: any, inputData: any) => {\n      if (!this.config.enabled) {\n        this.isGestureRunning = false;\n        this.hasGestureFailed = false;\n        return false;\n      }\n\n      // Prevent events before the system is ready.\n      if (\n        !inputData ||\n        !recognizer.options ||\n        typeof inputData.maxPointers === 'undefined'\n      ) {\n        return this.shouldEnableGestureOnSetup;\n      }\n\n      if (this.hasGestureFailed) {\n        return false;\n      }\n\n      if (!this.isDiscrete) {\n        if (this.isGestureRunning) {\n          return true;\n        }\n        // The built-in hammer.js \"waitFor\" doesn't work across multiple views.\n        // Only process if there are views to wait for.\n        this._stillWaiting = this._getPendingGestures();\n        // This gesture should continue waiting.\n        if (this._stillWaiting.length) {\n          // Check to see if one of the gestures you're waiting for has started.\n          // If it has then the gesture should fail.\n          for (const gesture of this._stillWaiting) {\n            // When the target gesture has started, this gesture must force fail.\n            if (!gesture.isDiscrete && gesture.isGestureRunning) {\n              this.hasGestureFailed = true;\n              this.isGestureRunning = false;\n              return false;\n            }\n          }\n          // This gesture shouldn't start until the others have finished.\n          return false;\n        }\n      }\n\n      // Use default behaviour\n      if (!this.hasCustomActivationCriteria) {\n        return true;\n      }\n\n      const deltaRotation =\n        this.initialRotation == null\n          ? 0\n          : inputData.rotation - this.initialRotation;\n      // @ts-ignore FIXME(TS)\n      const { success, failed } = this.isGestureEnabledForEvent(\n        this.getConfig(),\n        recognizer,\n        {\n          ...inputData,\n          deltaRotation,\n        }\n      );\n\n      if (failed) {\n        this.simulateCancelEvent(inputData);\n        this.hasGestureFailed = true;\n      }\n      return success;\n    };\n\n    const params = this.getHammerConfig();\n    // @ts-ignore FIXME(TS)\n    gesture.set({ ...params, enable });\n  };\n\n  simulateCancelEvent(_inputData: any) {}\n}\n\n// TODO(TS) investigate this method\n// Used for sending data to a callback or AnimatedEvent\nfunction invokeNullableMethod(\n  method:\n    | ((event: NativeEvent) => void)\n    | { __getHandler: () => (event: NativeEvent) => void }\n    | { __nodeConfig: { argMapping: any } },\n  event: NativeEvent\n) {\n  if (method) {\n    if (typeof method === 'function') {\n      method(event);\n    } else {\n      // For use with reanimated's AnimatedEvent\n      if (\n        '__getHandler' in method &&\n        typeof method.__getHandler === 'function'\n      ) {\n        const handler = method.__getHandler();\n        invokeNullableMethod(handler, event);\n      } else {\n        if ('__nodeConfig' in method) {\n          const { argMapping } = method.__nodeConfig;\n          if (Array.isArray(argMapping)) {\n            for (const index in argMapping) {\n              const [key, value] = argMapping[index];\n              if (key in event.nativeEvent) {\n                // @ts-ignore fix method type\n                const nativeValue = event.nativeEvent[key];\n                if (value && value.setValue) {\n                  // Reanimated API\n                  value.setValue(nativeValue);\n                } else {\n                  // RN Animated API\n                  method.__nodeConfig.argMapping[index] = [key, nativeValue];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// Validate the props\nfunction ensureConfig(config: Config): Required<Config> {\n  const props = { ...config };\n\n  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)\n  if ('minDist' in config) {\n    props.minDist = config.minDist;\n    props.minDistSq = props.minDist! * props.minDist!;\n  }\n  if ('minVelocity' in config) {\n    props.minVelocity = config.minVelocity;\n    props.minVelocitySq = props.minVelocity! * props.minVelocity!;\n  }\n  if ('maxDist' in config) {\n    props.maxDist = config.maxDist;\n    props.maxDistSq = config.maxDist! * config.maxDist!;\n  }\n  if ('waitFor' in config) {\n    props.waitFor = asArray(config.waitFor)\n      .map(({ handlerTag }: { handlerTag: number }) =>\n        NodeManager.getHandler(handlerTag)\n      )\n      .filter((v) => v);\n  } else {\n    props.waitFor = null;\n  }\n\n  const configProps = [\n    'minPointers',\n    'maxPointers',\n    'minDist',\n    'maxDist',\n    'maxDistSq',\n    'minVelocitySq',\n    'minDistSq',\n    'minVelocity',\n    'failOffsetXStart',\n    'failOffsetYStart',\n    'failOffsetXEnd',\n    'failOffsetYEnd',\n    'activeOffsetXStart',\n    'activeOffsetXEnd',\n    'activeOffsetYStart',\n    'activeOffsetYEnd',\n  ] as const;\n  configProps.forEach((prop: typeof configProps[number]) => {\n    if (typeof props[prop] === 'undefined') {\n      props[prop] = Number.NaN;\n    }\n  });\n  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?\n}\n\nfunction asArray<T>(value: T | T[]) {\n  // TODO(TS) use config.waitFor type\n  return value == null ? [] : Array.isArray(value) ? value : [value];\n}\n\nexport default GestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js
new file mode 100644
index 0000000..404d299
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js
@@ -0,0 +1,44 @@
+import GestureHandler from './GestureHandler';
+/**
+ * The base class for **Rotation** and **Pinch** gesture handlers.
+ */
+
+class IndiscreteGestureHandler extends GestureHandler {
+  get shouldEnableGestureOnSetup() {
+    return false;
+  }
+
+  updateGestureConfig({
+    minPointers = 2,
+    maxPointers = 2,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+  isGestureEnabledForEvent({
+    minPointers,
+    maxPointers
+  }, _recognizer, {
+    maxPointers: pointerLength
+  }) {
+    if (pointerLength > maxPointers) {
+      return {
+        failed: true
+      };
+    }
+
+    const validPointerCount = pointerLength >= minPointers;
+    return {
+      success: validPointerCount
+    };
+  }
+
+}
+
+export default IndiscreteGestureHandler;
+//# sourceMappingURL=IndiscreteGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js.map
new file mode 100644
index 0000000..e69b587
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/IndiscreteGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["IndiscreteGestureHandler.ts"],"names":["GestureHandler","IndiscreteGestureHandler","shouldEnableGestureOnSetup","updateGestureConfig","minPointers","maxPointers","props","isGestureEnabledForEvent","_recognizer","pointerLength","failed","validPointerCount","success"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,kBAA3B;AAEA;AACA;AACA;;AACA,MAAeC,wBAAf,SAAgDD,cAAhD,CAA+D;AAC/B,MAA1BE,0BAA0B,GAAG;AAC/B,WAAO,KAAP;AACD;;AAEDC,EAAAA,mBAAmB,CAAC;AAAEC,IAAAA,WAAW,GAAG,CAAhB;AAAmBC,IAAAA,WAAW,GAAG,CAAjC;AAAoC,OAAGC;AAAvC,GAAD,EAAiD;AAClE,WAAO,MAAMH,mBAAN,CAA0B;AAC/BC,MAAAA,WAD+B;AAE/BC,MAAAA,WAF+B;AAG/B,SAAGC;AAH4B,KAA1B,CAAP;AAKD;;AAEDC,EAAAA,wBAAwB,CACtB;AAAEH,IAAAA,WAAF;AAAeC,IAAAA;AAAf,GADsB,EAEtBG,WAFsB,EAGtB;AAAEH,IAAAA,WAAW,EAAEI;AAAf,GAHsB,EAItB;AACA,QAAIA,aAAa,GAAGJ,WAApB,EAAiC;AAC/B,aAAO;AAAEK,QAAAA,MAAM,EAAE;AAAV,OAAP;AACD;;AACD,UAAMC,iBAAiB,GAAGF,aAAa,IAAIL,WAA3C;AACA,WAAO;AACLQ,MAAAA,OAAO,EAAED;AADJ,KAAP;AAGD;;AAzB4D;;AA2B/D,eAAeV,wBAAf","sourcesContent":["import GestureHandler from './GestureHandler';\n\n/**\n * The base class for **Rotation** and **Pinch** gesture handlers.\n */\nabstract class IndiscreteGestureHandler extends GestureHandler {\n  get shouldEnableGestureOnSetup() {\n    return false;\n  }\n\n  updateGestureConfig({ minPointers = 2, maxPointers = 2, ...props }) {\n    return super.updateGestureConfig({\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  isGestureEnabledForEvent(\n    { minPointers, maxPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    if (pointerLength > maxPointers) {\n      return { failed: true };\n    }\n    const validPointerCount = pointerLength >= minPointers;\n    return {\n      success: validPointerCount,\n    };\n  }\n}\nexport default IndiscreteGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js
new file mode 100644
index 0000000..4483a49
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js
@@ -0,0 +1,58 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+
+/* eslint-disable */
+import Hammer from '@egjs/hammerjs';
+import { State } from '../State';
+import PressGestureHandler from './PressGestureHandler';
+import { isnan, isValidNumber } from './utils';
+
+class LongPressGestureHandler extends PressGestureHandler {
+  get minDurationMs() {
+    // @ts-ignore FIXNE(TS)
+    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;
+  }
+
+  get maxDist() {
+    // @ts-ignore FIXNE(TS)
+    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;
+  }
+
+  updateHasCustomActivationCriteria({
+    maxDistSq
+  }) {
+    return !isValidNumber(maxDistSq);
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        shouldCancelWhenOutside: true,
+        maxDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      // threshold: this.maxDist,
+      time: this.minDurationMs
+    };
+  }
+
+  getState(type) {
+    return {
+      [Hammer.INPUT_START]: State.ACTIVE,
+      [Hammer.INPUT_MOVE]: State.ACTIVE,
+      [Hammer.INPUT_END]: State.END,
+      [Hammer.INPUT_CANCEL]: State.FAILED
+    }[type];
+  }
+
+}
+
+export default LongPressGestureHandler;
+//# sourceMappingURL=LongPressGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js.map
new file mode 100644
index 0000000..9414082
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/LongPressGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["LongPressGestureHandler.ts"],"names":["Hammer","State","PressGestureHandler","isnan","isValidNumber","LongPressGestureHandler","minDurationMs","config","maxDist","updateHasCustomActivationCriteria","maxDistSq","getConfig","hasCustomActivationCriteria","shouldCancelWhenOutside","getHammerConfig","time","getState","type","INPUT_START","ACTIVE","INPUT_MOVE","INPUT_END","END","INPUT_CANCEL","FAILED"],"mappings":"AAAA;;AACA;AACA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,KAAT,QAAsB,UAAtB;AACA,OAAOC,mBAAP,MAAgC,uBAAhC;AACA,SAASC,KAAT,EAAgBC,aAAhB,QAAqC,SAArC;;AAIA,MAAMC,uBAAN,SAAsCH,mBAAtC,CAA0D;AACvC,MAAbI,aAAa,GAAW;AAC1B;AACA,WAAOH,KAAK,CAAC,KAAKI,MAAL,CAAYD,aAAb,CAAL,GAAmC,GAAnC,GAAyC,KAAKC,MAAL,CAAYD,aAA5D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ;AACA,WAAOL,KAAK,CAAC,KAAKI,MAAL,CAAYC,OAAb,CAAL,GAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEDC,EAAAA,iCAAiC,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAwB;AACvD,WAAO,CAACN,aAAa,CAACM,SAAD,CAArB;AACD;;AAEDC,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLC,QAAAA,uBAAuB,EAAE,IADpB;AAELH,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKH,MAAZ;AACD;;AAEDO,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKT;AAHN,KAAP;AAKD;;AAEDU,EAAAA,QAAQ,CAACC,IAAD,EAAsC;AAC5C,WAAO;AACL,OAACjB,MAAM,CAACkB,WAAR,GAAsBjB,KAAK,CAACkB,MADvB;AAEL,OAACnB,MAAM,CAACoB,UAAR,GAAqBnB,KAAK,CAACkB,MAFtB;AAGL,OAACnB,MAAM,CAACqB,SAAR,GAAoBpB,KAAK,CAACqB,GAHrB;AAIL,OAACtB,MAAM,CAACuB,YAAR,GAAuBtB,KAAK,CAACuB;AAJxB,MAKLP,IALK,CAAP;AAMD;;AA1CuD;;AA6C1D,eAAeZ,uBAAf","sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport PressGestureHandler from './PressGestureHandler';\nimport { isnan, isValidNumber } from './utils';\nimport { Config } from './GestureHandler';\nimport { HammerInputNames } from './constants';\n\nclass LongPressGestureHandler extends PressGestureHandler {\n  get minDurationMs(): number {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    // @ts-ignore FIXNE(TS)\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  updateHasCustomActivationCriteria({ maxDistSq }: Config) {\n    return !isValidNumber(maxDistSq);\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  getState(type: keyof typeof HammerInputNames) {\n    return {\n      [Hammer.INPUT_START]: State.ACTIVE,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.FAILED,\n    }[type];\n  }\n}\n\nexport default LongPressGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js
new file mode 100644
index 0000000..328509a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js
@@ -0,0 +1,45 @@
+import DiscreteGestureHandler from './DiscreteGestureHandler';
+import * as NodeManager from './NodeManager';
+import PressGestureHandler from './PressGestureHandler';
+import { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';
+
+class NativeViewGestureHandler extends PressGestureHandler {
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (!ev.isFinal) {
+      // if (this.ref instanceof ScrollView) {
+      if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({
+        x: ev.deltaX,
+        y: ev.deltaY
+      }), 10)) {
+        // @ts-ignore FIXME(TS) config type
+        if (this.config.disallowInterruption) {
+          const gestures = Object.values(NodeManager.getNodes()).filter(gesture => {
+            const {
+              handlerTag,
+              view,
+              isGestureRunning
+            } = gesture;
+            return (// Check if this gesture isn't self
+              handlerTag !== this.handlerTag && // Ensure the gesture needs to be cancelled
+              isGestureRunning && // ScrollView can cancel discrete gestures like taps and presses
+              gesture instanceof DiscreteGestureHandler && // Ensure a view exists and is a child of the current view
+              view && // @ts-ignore FIXME(TS) view type
+              this.view.contains(view)
+            );
+          }); // Cancel all of the gestures that passed the filter
+
+          for (const gesture of gestures) {
+            // TODO: Bacon: Send some cached event.
+            gesture.forceInvalidate(ev);
+          }
+        }
+      }
+    }
+  }
+
+}
+
+export default NativeViewGestureHandler;
+//# sourceMappingURL=NativeViewGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js.map
new file mode 100644
index 0000000..e71fcf6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/NativeViewGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NativeViewGestureHandler.ts"],"names":["DiscreteGestureHandler","NodeManager","PressGestureHandler","TEST_MIN_IF_NOT_NAN","VEC_LEN_SQ","NativeViewGestureHandler","onRawEvent","ev","isFinal","x","deltaX","y","deltaY","config","disallowInterruption","gestures","Object","values","getNodes","filter","gesture","handlerTag","view","isGestureRunning","contains","forceInvalidate"],"mappings":"AAAA,OAAOA,sBAAP,MAAmC,0BAAnC;AAEA,OAAO,KAAKC,WAAZ,MAA6B,eAA7B;AACA,OAAOC,mBAAP,MAAgC,uBAAhC;AACA,SAASC,mBAAT,EAA8BC,UAA9B,QAAgD,SAAhD;;AAEA,MAAMC,wBAAN,SAAuCH,mBAAvC,CAA2D;AACzDI,EAAAA,UAAU,CAACC,EAAD,EAAqB;AAC7B,UAAMD,UAAN,CAAiBC,EAAjB;;AACA,QAAI,CAACA,EAAE,CAACC,OAAR,EAAiB;AACf;AACA,UAAIL,mBAAmB,CAACC,UAAU,CAAC;AAAEK,QAAAA,CAAC,EAAEF,EAAE,CAACG,MAAR;AAAgBC,QAAAA,CAAC,EAAEJ,EAAE,CAACK;AAAtB,OAAD,CAAX,EAA6C,EAA7C,CAAvB,EAAyE;AACvE;AACA,YAAI,KAAKC,MAAL,CAAYC,oBAAhB,EAAsC;AACpC,gBAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAchB,WAAW,CAACiB,QAAZ,EAAd,EAAsCC,MAAtC,CACdC,OAAD,IAAa;AACX,kBAAM;AAAEC,cAAAA,UAAF;AAAcC,cAAAA,IAAd;AAAoBC,cAAAA;AAApB,gBAAyCH,OAA/C;AACA,mBACE;AACAC,cAAAA,UAAU,KAAK,KAAKA,UAApB,IACA;AACAE,cAAAA,gBAFA,IAGA;AACAH,cAAAA,OAAO,YAAYpB,sBAJnB,IAKA;AACAsB,cAAAA,IANA,IAOA;AACA,mBAAKA,IAAL,CAAUE,QAAV,CAAmBF,IAAnB;AAVF;AAYD,WAfc,CAAjB,CADoC,CAkBpC;;AACA,eAAK,MAAMF,OAAX,IAAsBL,QAAtB,EAAgC;AAC9B;AACAK,YAAAA,OAAO,CAACK,eAAR,CAAwBlB,EAAxB;AACD;AACF;AACF;AACF;AACF;;AAjCwD;;AAoC3D,eAAeF,wBAAf","sourcesContent":["import DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport * as NodeManager from './NodeManager';\nimport PressGestureHandler from './PressGestureHandler';\nimport { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\n\nclass NativeViewGestureHandler extends PressGestureHandler {\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (!ev.isFinal) {\n      // if (this.ref instanceof ScrollView) {\n      if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({ x: ev.deltaX, y: ev.deltaY }), 10)) {\n        // @ts-ignore FIXME(TS) config type\n        if (this.config.disallowInterruption) {\n          const gestures = Object.values(NodeManager.getNodes()).filter(\n            (gesture) => {\n              const { handlerTag, view, isGestureRunning } = gesture;\n              return (\n                // Check if this gesture isn't self\n                handlerTag !== this.handlerTag &&\n                // Ensure the gesture needs to be cancelled\n                isGestureRunning &&\n                // ScrollView can cancel discrete gestures like taps and presses\n                gesture instanceof DiscreteGestureHandler &&\n                // Ensure a view exists and is a child of the current view\n                view &&\n                // @ts-ignore FIXME(TS) view type\n                this.view.contains(view)\n              );\n            }\n          );\n          // Cancel all of the gestures that passed the filter\n          for (const gesture of gestures) {\n            // TODO: Bacon: Send some cached event.\n            gesture.forceInvalidate(ev);\n          }\n        }\n      }\n    }\n  }\n}\n\nexport default NativeViewGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js b/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js
new file mode 100644
index 0000000..1d64276
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js
@@ -0,0 +1,24 @@
+const gestures = {};
+export function getHandler(tag) {
+  if (tag in gestures) return gestures[tag];
+  throw new Error("No handler for tag ".concat(tag));
+}
+export function createGestureHandler(handlerTag, handler) {
+  if (handlerTag in gestures) {
+    throw new Error("Handler with tag ".concat(handlerTag, " already exists"));
+  }
+
+  gestures[handlerTag] = handler; // @ts-ignore no types for web handlers yet
+
+  gestures[handlerTag].handlerTag = handlerTag;
+}
+export function dropGestureHandler(handlerTag) {
+  getHandler(handlerTag).destroy(); // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+
+  delete gestures[handlerTag];
+}
+export function getNodes() {
+  return { ...gestures
+  };
+}
+//# sourceMappingURL=NodeManager.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js.map b/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js.map
new file mode 100644
index 0000000..401a34b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/NodeManager.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["NodeManager.ts"],"names":["gestures","getHandler","tag","Error","createGestureHandler","handlerTag","handler","dropGestureHandler","destroy","getNodes"],"mappings":"AAGA,MAAMA,QAAgE,GAAG,EAAzE;AAEA,OAAO,SAASC,UAAT,CAAoBC,GAApB,EAAiC;AACtC,MAAIA,GAAG,IAAIF,QAAX,EAAqB,OAAOA,QAAQ,CAACE,GAAD,CAAf;AAErB,QAAM,IAAIC,KAAJ,8BAAgCD,GAAhC,EAAN;AACD;AAED,OAAO,SAASE,oBAAT,CACLC,UADK,EAELC,OAFK,EAGL;AACA,MAAID,UAAU,IAAIL,QAAlB,EAA4B;AAC1B,UAAM,IAAIG,KAAJ,4BAA8BE,UAA9B,qBAAN;AACD;;AACDL,EAAAA,QAAQ,CAACK,UAAD,CAAR,GAAuBC,OAAvB,CAJA,CAKA;;AACAN,EAAAA,QAAQ,CAACK,UAAD,CAAR,CAAqBA,UAArB,GAAkCA,UAAlC;AACD;AAED,OAAO,SAASE,kBAAT,CAA4BF,UAA5B,EAAgD;AACrDJ,EAAAA,UAAU,CAACI,UAAD,CAAV,CAAuBG,OAAvB,GADqD,CAErD;;AACA,SAAOR,QAAQ,CAACK,UAAD,CAAf;AACD;AAED,OAAO,SAASI,QAAT,GAAoB;AACzB,SAAO,EAAE,GAAGT;AAAL,GAAP;AACD","sourcesContent":["import { ValueOf } from '../typeUtils';\nimport { Gestures } from '../RNGestureHandlerModule.web';\n\nconst gestures: Record<number, InstanceType<ValueOf<typeof Gestures>>> = {};\n\nexport function getHandler(tag: number) {\n  if (tag in gestures) return gestures[tag];\n\n  throw new Error(`No handler for tag ${tag}`);\n}\n\nexport function createGestureHandler(\n  handlerTag: number,\n  handler: InstanceType<ValueOf<typeof Gestures>>\n) {\n  if (handlerTag in gestures) {\n    throw new Error(`Handler with tag ${handlerTag} already exists`);\n  }\n  gestures[handlerTag] = handler;\n  // @ts-ignore no types for web handlers yet\n  gestures[handlerTag].handlerTag = handlerTag;\n}\n\nexport function dropGestureHandler(handlerTag: number) {\n  getHandler(handlerTag).destroy();\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete gestures[handlerTag];\n}\n\nexport function getNodes() {\n  return { ...gestures };\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js
new file mode 100644
index 0000000..db0bf7f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js
@@ -0,0 +1,175 @@
+import Hammer from '@egjs/hammerjs';
+import { MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD, MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD } from './constants';
+import DraggingGestureHandler from './DraggingGestureHandler';
+import { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';
+import { State } from '../State';
+
+class PanGestureHandler extends DraggingGestureHandler {
+  get name() {
+    return 'pan';
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Pan;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      direction: this.getDirection()
+    };
+  }
+
+  getState(type) {
+    const nextState = super.getState(type); // Ensure that the first state sent is `BEGAN` and not `ACTIVE`
+
+    if (this.previousState === State.UNDETERMINED && nextState === State.ACTIVE) {
+      return State.BEGAN;
+    }
+
+    return nextState;
+  }
+
+  getDirection() {
+    const config = this.getConfig();
+    const {
+      activeOffsetXStart,
+      activeOffsetXEnd,
+      activeOffsetYStart,
+      activeOffsetYEnd,
+      minDist
+    } = config;
+    let directions = [];
+    let horizontalDirections = [];
+
+    if (!isnan(minDist)) {
+      return Hammer.DIRECTION_ALL;
+    }
+
+    if (!isnan(activeOffsetXStart)) horizontalDirections.push(Hammer.DIRECTION_LEFT);
+    if (!isnan(activeOffsetXEnd)) horizontalDirections.push(Hammer.DIRECTION_RIGHT);
+    if (horizontalDirections.length === 2) horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];
+    directions = directions.concat(horizontalDirections);
+    let verticalDirections = [];
+    if (!isnan(activeOffsetYStart)) verticalDirections.push(Hammer.DIRECTION_UP);
+    if (!isnan(activeOffsetYEnd)) verticalDirections.push(Hammer.DIRECTION_DOWN);
+    if (verticalDirections.length === 2) verticalDirections = [Hammer.DIRECTION_VERTICAL];
+    directions = directions.concat(verticalDirections);
+
+    if (!directions.length) {
+      return Hammer.DIRECTION_NONE;
+    }
+
+    if (directions[0] === Hammer.DIRECTION_HORIZONTAL && directions[1] === Hammer.DIRECTION_VERTICAL) {
+      return Hammer.DIRECTION_ALL;
+    }
+
+    if (horizontalDirections.length && verticalDirections.length) {
+      return Hammer.DIRECTION_ALL;
+    }
+
+    return directions[0];
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        minDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  shouldFailUnderCustomCriteria({
+    deltaX,
+    deltaY
+  }, criteria) {
+    return !isnan(criteria.failOffsetXStart) && deltaX < criteria.failOffsetXStart || !isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd || !isnan(criteria.failOffsetYStart) && deltaY < criteria.failOffsetYStart || !isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd;
+  }
+
+  shouldActivateUnderCustomCriteria({
+    deltaX,
+    deltaY,
+    velocity
+  }, criteria) {
+    return !isnan(criteria.activeOffsetXStart) && deltaX < criteria.activeOffsetXStart || !isnan(criteria.activeOffsetXEnd) && deltaX > criteria.activeOffsetXEnd || !isnan(criteria.activeOffsetYStart) && deltaY < criteria.activeOffsetYStart || !isnan(criteria.activeOffsetYEnd) && deltaY > criteria.activeOffsetYEnd || TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({
+      x: deltaX,
+      y: deltaY
+    }), criteria.minDistSq) || TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) || TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) || TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq);
+  }
+
+  shouldMultiFingerPanFail({
+    pointerLength,
+    scale,
+    deltaRotation
+  }) {
+    if (pointerLength <= 1) {
+      return false;
+    } // Test if the pan had too much pinching or rotating.
+
+
+    const deltaScale = Math.abs(scale - 1);
+    const absDeltaRotation = Math.abs(deltaRotation);
+
+    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {
+      // > If the threshold doesn't seem right.
+      // You can log the value which it failed at here:
+      return true;
+    }
+
+    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {
+      // > If the threshold doesn't seem right.
+      // You can log the value which it failed at here:
+      return true;
+    }
+
+    return false;
+  }
+
+  updateHasCustomActivationCriteria(criteria) {
+    return isValidNumber(criteria.minDistSq) || isValidNumber(criteria.minVelocityX) || isValidNumber(criteria.minVelocityY) || isValidNumber(criteria.minVelocitySq) || isValidNumber(criteria.activeOffsetXStart) || isValidNumber(criteria.activeOffsetXEnd) || isValidNumber(criteria.activeOffsetYStart) || isValidNumber(criteria.activeOffsetYEnd);
+  }
+
+  isGestureEnabledForEvent(props, _recognizer, inputData) {
+    if (this.shouldFailUnderCustomCriteria(inputData, props)) {
+      return {
+        failed: true
+      };
+    }
+
+    const velocity = {
+      x: inputData.velocityX,
+      y: inputData.velocityY
+    };
+
+    if (this.hasCustomActivationCriteria && this.shouldActivateUnderCustomCriteria({
+      deltaX: inputData.deltaX,
+      deltaY: inputData.deltaY,
+      velocity
+    }, props)) {
+      if (this.shouldMultiFingerPanFail({
+        pointerLength: inputData.maxPointers,
+        scale: inputData.scale,
+        deltaRotation: inputData.deltaRotation
+      })) {
+        return {
+          failed: true
+        };
+      }
+
+      return {
+        success: true
+      };
+    }
+
+    return {
+      success: false
+    };
+  }
+
+}
+
+export default PanGestureHandler;
+//# sourceMappingURL=PanGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js.map
new file mode 100644
index 0000000..cb1568e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PanGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PanGestureHandler.ts"],"names":["Hammer","MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD","MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD","DraggingGestureHandler","isValidNumber","isnan","TEST_MIN_IF_NOT_NAN","VEC_LEN_SQ","State","PanGestureHandler","name","NativeGestureClass","Pan","getHammerConfig","direction","getDirection","getState","type","nextState","previousState","UNDETERMINED","ACTIVE","BEGAN","config","getConfig","activeOffsetXStart","activeOffsetXEnd","activeOffsetYStart","activeOffsetYEnd","minDist","directions","horizontalDirections","DIRECTION_ALL","push","DIRECTION_LEFT","DIRECTION_RIGHT","length","DIRECTION_HORIZONTAL","concat","verticalDirections","DIRECTION_UP","DIRECTION_DOWN","DIRECTION_VERTICAL","DIRECTION_NONE","hasCustomActivationCriteria","minDistSq","shouldFailUnderCustomCriteria","deltaX","deltaY","criteria","failOffsetXStart","failOffsetXEnd","failOffsetYStart","failOffsetYEnd","shouldActivateUnderCustomCriteria","velocity","x","y","minVelocityX","minVelocityY","minVelocitySq","shouldMultiFingerPanFail","pointerLength","scale","deltaRotation","deltaScale","Math","abs","absDeltaRotation","updateHasCustomActivationCriteria","isGestureEnabledForEvent","props","_recognizer","inputData","failed","velocityX","velocityY","maxPointers","success"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport {\n  EventMap,\n  MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,\n  MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,\n} from './constants';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';\nimport { State } from '../State';\n\nimport { Config, HammerInputExt } from './GestureHandler';\nclass PanGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'pan';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pan;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      direction: this.getDirection(),\n    };\n  }\n\n  getState(type: keyof typeof EventMap) {\n    const nextState = super.getState(type);\n    // Ensure that the first state sent is `BEGAN` and not `ACTIVE`\n    if (\n      this.previousState === State.UNDETERMINED &&\n      nextState === State.ACTIVE\n    ) {\n      return State.BEGAN;\n    }\n    return nextState;\n  }\n\n  getDirection() {\n    const config = this.getConfig();\n    const {\n      activeOffsetXStart,\n      activeOffsetXEnd,\n      activeOffsetYStart,\n      activeOffsetYEnd,\n      minDist,\n    } = config;\n    let directions: number[] = [];\n    let horizontalDirections = [];\n\n    if (!isnan(minDist)) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    if (!isnan(activeOffsetXStart))\n      horizontalDirections.push(Hammer.DIRECTION_LEFT);\n    if (!isnan(activeOffsetXEnd))\n      horizontalDirections.push(Hammer.DIRECTION_RIGHT);\n    if (horizontalDirections.length === 2)\n      horizontalDirections = [Hammer.DIRECTION_HORIZONTAL];\n\n    directions = directions.concat(horizontalDirections);\n    let verticalDirections = [];\n\n    if (!isnan(activeOffsetYStart))\n      verticalDirections.push(Hammer.DIRECTION_UP);\n    if (!isnan(activeOffsetYEnd))\n      verticalDirections.push(Hammer.DIRECTION_DOWN);\n\n    if (verticalDirections.length === 2)\n      verticalDirections = [Hammer.DIRECTION_VERTICAL];\n\n    directions = directions.concat(verticalDirections);\n\n    if (!directions.length) {\n      return Hammer.DIRECTION_NONE;\n    }\n    if (\n      directions[0] === Hammer.DIRECTION_HORIZONTAL &&\n      directions[1] === Hammer.DIRECTION_VERTICAL\n    ) {\n      return Hammer.DIRECTION_ALL;\n    }\n    if (horizontalDirections.length && verticalDirections.length) {\n      return Hammer.DIRECTION_ALL;\n    }\n\n    return directions[0];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        minDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  shouldFailUnderCustomCriteria(\n    { deltaX, deltaY }: HammerInputExt,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.failOffsetXStart) &&\n        deltaX < criteria.failOffsetXStart) ||\n      (!isnan(criteria.failOffsetXEnd) && deltaX > criteria.failOffsetXEnd) ||\n      (!isnan(criteria.failOffsetYStart) &&\n        deltaY < criteria.failOffsetYStart) ||\n      (!isnan(criteria.failOffsetYEnd) && deltaY > criteria.failOffsetYEnd)\n    );\n  }\n\n  shouldActivateUnderCustomCriteria(\n    { deltaX, deltaY, velocity }: any,\n    criteria: any\n  ) {\n    return (\n      (!isnan(criteria.activeOffsetXStart) &&\n        deltaX < criteria.activeOffsetXStart) ||\n      (!isnan(criteria.activeOffsetXEnd) &&\n        deltaX > criteria.activeOffsetXEnd) ||\n      (!isnan(criteria.activeOffsetYStart) &&\n        deltaY < criteria.activeOffsetYStart) ||\n      (!isnan(criteria.activeOffsetYEnd) &&\n        deltaY > criteria.activeOffsetYEnd) ||\n      TEST_MIN_IF_NOT_NAN(\n        VEC_LEN_SQ({ x: deltaX, y: deltaY }),\n        criteria.minDistSq\n      ) ||\n      TEST_MIN_IF_NOT_NAN(velocity.x, criteria.minVelocityX) ||\n      TEST_MIN_IF_NOT_NAN(velocity.y, criteria.minVelocityY) ||\n      TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ(velocity), criteria.minVelocitySq)\n    );\n  }\n\n  shouldMultiFingerPanFail({\n    pointerLength,\n    scale,\n    deltaRotation,\n  }: {\n    deltaRotation: number;\n    pointerLength: number;\n    scale: number;\n  }) {\n    if (pointerLength <= 1) {\n      return false;\n    }\n\n    // Test if the pan had too much pinching or rotating.\n    const deltaScale = Math.abs(scale - 1);\n    const absDeltaRotation = Math.abs(deltaRotation);\n    if (deltaScale > MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n    if (absDeltaRotation > MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD) {\n      // > If the threshold doesn't seem right.\n      // You can log the value which it failed at here:\n      return true;\n    }\n\n    return false;\n  }\n\n  updateHasCustomActivationCriteria(\n    criteria: Config & { minVelocityX?: number; minVelocityY?: number }\n  ) {\n    return (\n      isValidNumber(criteria.minDistSq) ||\n      isValidNumber(criteria.minVelocityX) ||\n      isValidNumber(criteria.minVelocityY) ||\n      isValidNumber(criteria.minVelocitySq) ||\n      isValidNumber(criteria.activeOffsetXStart) ||\n      isValidNumber(criteria.activeOffsetXEnd) ||\n      isValidNumber(criteria.activeOffsetYStart) ||\n      isValidNumber(criteria.activeOffsetYEnd)\n    );\n  }\n\n  isGestureEnabledForEvent(\n    props: any,\n    _recognizer: any,\n    inputData: HammerInputExt & { deltaRotation: number }\n  ) {\n    if (this.shouldFailUnderCustomCriteria(inputData, props)) {\n      return { failed: true };\n    }\n\n    const velocity = { x: inputData.velocityX, y: inputData.velocityY };\n    if (\n      this.hasCustomActivationCriteria &&\n      this.shouldActivateUnderCustomCriteria(\n        { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },\n        props\n      )\n    ) {\n      if (\n        this.shouldMultiFingerPanFail({\n          pointerLength: inputData.maxPointers,\n          scale: inputData.scale,\n          deltaRotation: inputData.deltaRotation,\n        })\n      ) {\n        return {\n          failed: true,\n        };\n      }\n      return { success: true };\n    }\n    return { success: false };\n  }\n}\n\nexport default PanGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js
new file mode 100644
index 0000000..3821d85
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js
@@ -0,0 +1,29 @@
+import Hammer from '@egjs/hammerjs';
+import IndiscreteGestureHandler from './IndiscreteGestureHandler';
+
+class PinchGestureHandler extends IndiscreteGestureHandler {
+  get name() {
+    return 'pinch';
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Pinch;
+  }
+
+  transformNativeEvent({
+    scale,
+    velocity,
+    center
+  }) {
+    return {
+      focalX: center.x,
+      focalY: center.y,
+      velocity,
+      scale
+    };
+  }
+
+}
+
+export default PinchGestureHandler;
+//# sourceMappingURL=PinchGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js.map
new file mode 100644
index 0000000..15875b0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PinchGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PinchGestureHandler.ts"],"names":["Hammer","IndiscreteGestureHandler","PinchGestureHandler","name","NativeGestureClass","Pinch","transformNativeEvent","scale","velocity","center","focalX","x","focalY","y"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAGA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,mBAAN,SAAkCD,wBAAlC,CAA2D;AACjD,MAAJE,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOJ,MAAM,CAACK,KAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,KAAF;AAASC,IAAAA,QAAT;AAAmBC,IAAAA;AAAnB,GAAD,EAA8C;AAChE,WAAO;AACLC,MAAAA,MAAM,EAAED,MAAM,CAACE,CADV;AAELC,MAAAA,MAAM,EAAEH,MAAM,CAACI,CAFV;AAGLL,MAAAA,QAHK;AAILD,MAAAA;AAJK,KAAP;AAMD;;AAhBwD;;AAmB3D,eAAeL,mBAAf","sourcesContent":["import Hammer from '@egjs/hammerjs';\nimport { HammerInputExt } from './GestureHandler';\n\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass PinchGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'pinch';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Pinch;\n  }\n\n  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {\n    return {\n      focalX: center.x,\n      focalY: center.y,\n      velocity,\n      scale,\n    };\n  }\n}\n\nexport default PinchGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js
new file mode 100644
index 0000000..4e580c4
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js
@@ -0,0 +1,174 @@
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import Hammer from '@egjs/hammerjs';
+import { State } from '../State';
+import { CONTENT_TOUCHES_DELAY, CONTENT_TOUCHES_QUICK_TAP_END_DELAY } from './constants';
+import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { fireAfterInterval, isValidNumber, isnan } from './utils';
+
+class PressGestureHandler extends DiscreteGestureHandler {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "visualFeedbackTimer", void 0);
+
+    _defineProperty(this, "initialEvent", null);
+
+    _defineProperty(this, "shouldDelayTouches", true);
+  }
+
+  get name() {
+    return 'press';
+  }
+
+  get minDurationMs() {
+    // @ts-ignore FIXME(TS)
+    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;
+  }
+
+  get maxDist() {
+    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Press;
+  }
+
+  simulateCancelEvent(inputData) {
+    // Long press never starts so we can't rely on the running event boolean.
+    this.hasGestureFailed = true;
+    this.cancelEvent(inputData);
+  }
+
+  updateHasCustomActivationCriteria({
+    shouldCancelWhenOutside,
+    maxDistSq
+  }) {
+    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);
+  }
+
+  getState(type) {
+    return {
+      [Hammer.INPUT_START]: State.BEGAN,
+      [Hammer.INPUT_MOVE]: State.ACTIVE,
+      [Hammer.INPUT_END]: State.END,
+      [Hammer.INPUT_CANCEL]: State.CANCELLED
+    }[type];
+  }
+
+  getConfig() {
+    if (!this.hasCustomActivationCriteria) {
+      // Default config
+      // If no params have been defined then this config should emulate the native gesture as closely as possible.
+      return {
+        shouldCancelWhenOutside: true,
+        maxDistSq: 10
+      };
+    }
+
+    return this.config;
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      // threshold: this.maxDist,
+      time: this.minDurationMs
+    };
+  }
+
+  onGestureActivated(ev) {
+    this.onGestureStart(ev);
+  }
+
+  shouldDelayTouchForEvent({
+    pointerType
+  }) {
+    // Don't disable event for mouse input
+    return this.shouldDelayTouches && pointerType === 'touch';
+  }
+
+  onGestureStart(ev) {
+    this.isGestureRunning = true;
+    clearTimeout(this.visualFeedbackTimer);
+    this.initialEvent = ev;
+    this.visualFeedbackTimer = fireAfterInterval(() => {
+      this.sendGestureStartedEvent(this.initialEvent);
+      this.initialEvent = null;
+    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);
+  }
+
+  sendGestureStartedEvent(ev) {
+    clearTimeout(this.visualFeedbackTimer);
+    this.visualFeedbackTimer = null;
+    this.sendEvent({ ...ev,
+      eventType: Hammer.INPUT_MOVE,
+      isFirst: true
+    });
+  }
+
+  forceInvalidate(event) {
+    super.forceInvalidate(event);
+    clearTimeout(this.visualFeedbackTimer);
+    this.visualFeedbackTimer = null;
+    this.initialEvent = null;
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev);
+
+    if (this.isGestureRunning) {
+      if (ev.isFinal) {
+        let timeout;
+
+        if (this.visualFeedbackTimer) {
+          // Aesthetic timing for a quick tap.
+          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`
+          // Now we must send the initial activation event and wait a set amount of time before firing the end event.
+          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
+          this.sendGestureStartedEvent(this.initialEvent);
+          this.initialEvent = null;
+        }
+
+        fireAfterInterval(() => {
+          this.sendEvent({ ...ev,
+            eventType: Hammer.INPUT_END,
+            isFinal: true
+          }); // @ts-ignore -- this should explicitly support undefined
+
+          this.onGestureEnded();
+        }, timeout);
+      } else {
+        this.sendEvent({ ...ev,
+          eventType: Hammer.INPUT_MOVE,
+          isFinal: false
+        });
+      }
+    }
+  }
+
+  updateGestureConfig({
+    shouldActivateOnStart = false,
+    disallowInterruption = false,
+    shouldCancelWhenOutside = true,
+    minDurationMs = Number.NaN,
+    maxDist = Number.NaN,
+    minPointers = 1,
+    maxPointers = 1,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      shouldActivateOnStart,
+      disallowInterruption,
+      shouldCancelWhenOutside,
+      minDurationMs,
+      maxDist,
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+}
+
+export default PressGestureHandler;
+//# sourceMappingURL=PressGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js.map
new file mode 100644
index 0000000..de2f7f7
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/PressGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["PressGestureHandler.ts"],"names":["Hammer","State","CONTENT_TOUCHES_DELAY","CONTENT_TOUCHES_QUICK_TAP_END_DELAY","DiscreteGestureHandler","fireAfterInterval","isValidNumber","isnan","PressGestureHandler","name","minDurationMs","config","maxDist","NativeGestureClass","Press","simulateCancelEvent","inputData","hasGestureFailed","cancelEvent","updateHasCustomActivationCriteria","shouldCancelWhenOutside","maxDistSq","getState","type","INPUT_START","BEGAN","INPUT_MOVE","ACTIVE","INPUT_END","END","INPUT_CANCEL","CANCELLED","getConfig","hasCustomActivationCriteria","getHammerConfig","time","onGestureActivated","ev","onGestureStart","shouldDelayTouchForEvent","pointerType","shouldDelayTouches","isGestureRunning","clearTimeout","visualFeedbackTimer","initialEvent","sendGestureStartedEvent","sendEvent","eventType","isFirst","forceInvalidate","event","onRawEvent","isFinal","timeout","onGestureEnded","updateGestureConfig","shouldActivateOnStart","disallowInterruption","Number","NaN","minPointers","maxPointers","props"],"mappings":";;AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,KAAT,QAAsB,UAAtB;AACA,SACEC,qBADF,EAEEC,mCAFF,QAIO,aAJP;AAKA,OAAOC,sBAAP,MAAmC,0BAAnC;AAEA,SAASC,iBAAT,EAA4BC,aAA5B,EAA2CC,KAA3C,QAAwD,SAAxD;;AAEA,MAAMC,mBAAN,SAAkCJ,sBAAlC,CAAyD;AAAA;AAAA;;AAAA;;AAAA,0CAET,IAFS;;AAAA,gDAoBlC,IApBkC;AAAA;;AAG/C,MAAJK,IAAI,GAAG;AACT,WAAO,OAAP;AACD;;AAEgB,MAAbC,aAAa,GAAG;AAClB;AACA,WAAOH,KAAK,CAAC,KAAKI,MAAL,CAAYD,aAAb,CAAL,GAAmC,CAAnC,GAAuC,KAAKC,MAAL,CAAYD,aAA1D;AACD;;AAEU,MAAPE,OAAO,GAAG;AACZ,WAAOL,KAAK,CAAC,KAAKI,MAAL,CAAYC,OAAb,CAAL,GAA6B,CAA7B,GAAiC,KAAKD,MAAL,CAAYC,OAApD;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOb,MAAM,CAACc,KAAd;AACD;;AAIDC,EAAAA,mBAAmB,CAACC,SAAD,EAA4B;AAC7C;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,WAAL,CAAiBF,SAAjB;AACD;;AAEDG,EAAAA,iCAAiC,CAAC;AAChCC,IAAAA,uBADgC;AAEhCC,IAAAA;AAFgC,GAAD,EAGiB;AAChD,WAAOD,uBAAuB,IAAI,CAACd,aAAa,CAACe,SAAD,CAAhD;AACD;;AAEDC,EAAAA,QAAQ,CAACC,IAAD,EAA6C;AACnD,WAAO;AACL,OAACvB,MAAM,CAACwB,WAAR,GAAsBvB,KAAK,CAACwB,KADvB;AAEL,OAACzB,MAAM,CAAC0B,UAAR,GAAqBzB,KAAK,CAAC0B,MAFtB;AAGL,OAAC3B,MAAM,CAAC4B,SAAR,GAAoB3B,KAAK,CAAC4B,GAHrB;AAIL,OAAC7B,MAAM,CAAC8B,YAAR,GAAuB7B,KAAK,CAAC8B;AAJxB,MAKLR,IALK,CAAP;AAMD;;AAEDS,EAAAA,SAAS,GAAG;AACV,QAAI,CAAC,KAAKC,2BAAV,EAAuC;AACrC;AACA;AACA,aAAO;AACLb,QAAAA,uBAAuB,EAAE,IADpB;AAELC,QAAAA,SAAS,EAAE;AAFN,OAAP;AAID;;AACD,WAAO,KAAKV,MAAZ;AACD;;AAEDuB,EAAAA,eAAe,GAAG;AAChB,WAAO,EACL,GAAG,MAAMA,eAAN,EADE;AAEL;AACAC,MAAAA,IAAI,EAAE,KAAKzB;AAHN,KAAP;AAKD;;AAED0B,EAAAA,kBAAkB,CAACC,EAAD,EAAqB;AACrC,SAAKC,cAAL,CAAoBD,EAApB;AACD;;AAEDE,EAAAA,wBAAwB,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAkC;AACxD;AACA,WAAO,KAAKC,kBAAL,IAA2BD,WAAW,KAAK,OAAlD;AACD;;AAEDF,EAAAA,cAAc,CAACD,EAAD,EAAqB;AACjC,SAAKK,gBAAL,GAAwB,IAAxB;AACAC,IAAAA,YAAY,CAAC,KAAKC,mBAAN,CAAZ;AACA,SAAKC,YAAL,GAAoBR,EAApB;AACA,SAAKO,mBAAL,GAA2BvC,iBAAiB,CAAC,MAAM;AACjD,WAAKyC,uBAAL,CAA6B,KAAKD,YAAlC;AACA,WAAKA,YAAL,GAAoB,IAApB;AACD,KAH2C,EAGzC,KAAKN,wBAAL,CAA8BF,EAA9B,KAAqCnC,qBAHI,CAA5C;AAID;;AAED4C,EAAAA,uBAAuB,CAACT,EAAD,EAAqB;AAC1CM,IAAAA,YAAY,CAAC,KAAKC,mBAAN,CAAZ;AACA,SAAKA,mBAAL,GAA2B,IAA3B;AACA,SAAKG,SAAL,CAAe,EACb,GAAGV,EADU;AAEbW,MAAAA,SAAS,EAAEhD,MAAM,CAAC0B,UAFL;AAGbuB,MAAAA,OAAO,EAAE;AAHI,KAAf;AAKD;;AAEDC,EAAAA,eAAe,CAACC,KAAD,EAAwB;AACrC,UAAMD,eAAN,CAAsBC,KAAtB;AACAR,IAAAA,YAAY,CAAC,KAAKC,mBAAN,CAAZ;AACA,SAAKA,mBAAL,GAA2B,IAA3B;AACA,SAAKC,YAAL,GAAoB,IAApB;AACD;;AAEDO,EAAAA,UAAU,CAACf,EAAD,EAAqB;AAC7B,UAAMe,UAAN,CAAiBf,EAAjB;;AACA,QAAI,KAAKK,gBAAT,EAA2B;AACzB,UAAIL,EAAE,CAACgB,OAAP,EAAgB;AACd,YAAIC,OAAJ;;AACA,YAAI,KAAKV,mBAAT,EAA8B;AAC5B;AACA;AACA;AACAU,UAAAA,OAAO,GAAGnD,mCAAV;AACA,eAAK2C,uBAAL,CAA6B,KAAKD,YAAlC;AACA,eAAKA,YAAL,GAAoB,IAApB;AACD;;AACDxC,QAAAA,iBAAiB,CAAC,MAAM;AACtB,eAAK0C,SAAL,CAAe,EACb,GAAGV,EADU;AAEbW,YAAAA,SAAS,EAAEhD,MAAM,CAAC4B,SAFL;AAGbyB,YAAAA,OAAO,EAAE;AAHI,WAAf,EADsB,CAMtB;;AACA,eAAKE,cAAL;AACD,SARgB,EAQdD,OARc,CAAjB;AASD,OAnBD,MAmBO;AACL,aAAKP,SAAL,CAAe,EACb,GAAGV,EADU;AAEbW,UAAAA,SAAS,EAAEhD,MAAM,CAAC0B,UAFL;AAGb2B,UAAAA,OAAO,EAAE;AAHI,SAAf;AAKD;AACF;AACF;;AAEDG,EAAAA,mBAAmB,CAAC;AAClBC,IAAAA,qBAAqB,GAAG,KADN;AAElBC,IAAAA,oBAAoB,GAAG,KAFL;AAGlBtC,IAAAA,uBAAuB,GAAG,IAHR;AAIlBV,IAAAA,aAAa,GAAGiD,MAAM,CAACC,GAJL;AAKlBhD,IAAAA,OAAO,GAAG+C,MAAM,CAACC,GALC;AAMlBC,IAAAA,WAAW,GAAG,CANI;AAOlBC,IAAAA,WAAW,GAAG,CAPI;AAQlB,OAAGC;AARe,GAAD,EAShB;AACD,WAAO,MAAMP,mBAAN,CAA0B;AAC/BC,MAAAA,qBAD+B;AAE/BC,MAAAA,oBAF+B;AAG/BtC,MAAAA,uBAH+B;AAI/BV,MAAAA,aAJ+B;AAK/BE,MAAAA,OAL+B;AAM/BiD,MAAAA,WAN+B;AAO/BC,MAAAA,WAP+B;AAQ/B,SAAGC;AAR4B,KAA1B,CAAP;AAUD;;AAxJsD;;AA0JzD,eAAevD,mBAAf","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\nimport {\n  CONTENT_TOUCHES_DELAY,\n  CONTENT_TOUCHES_QUICK_TAP_END_DELAY,\n  HammerInputNames,\n} from './constants';\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { Config, HammerInputExt } from './GestureHandler';\nimport { fireAfterInterval, isValidNumber, isnan } from './utils';\n\nclass PressGestureHandler extends DiscreteGestureHandler {\n  private visualFeedbackTimer: any;\n  private initialEvent: HammerInputExt | null = null;\n  get name() {\n    return 'press';\n  }\n\n  get minDurationMs() {\n    // @ts-ignore FIXME(TS)\n    return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;\n  }\n\n  get maxDist() {\n    return isnan(this.config.maxDist) ? 9 : this.config.maxDist;\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Press;\n  }\n\n  shouldDelayTouches = true;\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    // Long press never starts so we can't rely on the running event boolean.\n    this.hasGestureFailed = true;\n    this.cancelEvent(inputData);\n  }\n\n  updateHasCustomActivationCriteria({\n    shouldCancelWhenOutside,\n    maxDistSq,\n  }: Config & { shouldCancelWhenOutside: boolean }) {\n    return shouldCancelWhenOutside || !isValidNumber(maxDistSq);\n  }\n\n  getState(type: keyof typeof HammerInputNames): State {\n    return {\n      [Hammer.INPUT_START]: State.BEGAN,\n      [Hammer.INPUT_MOVE]: State.ACTIVE,\n      [Hammer.INPUT_END]: State.END,\n      [Hammer.INPUT_CANCEL]: State.CANCELLED,\n    }[type];\n  }\n\n  getConfig() {\n    if (!this.hasCustomActivationCriteria) {\n      // Default config\n      // If no params have been defined then this config should emulate the native gesture as closely as possible.\n      return {\n        shouldCancelWhenOutside: true,\n        maxDistSq: 10,\n      };\n    }\n    return this.config;\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      // threshold: this.maxDist,\n      time: this.minDurationMs,\n    };\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    this.onGestureStart(ev);\n  }\n\n  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {\n    // Don't disable event for mouse input\n    return this.shouldDelayTouches && pointerType === 'touch';\n  }\n\n  onGestureStart(ev: HammerInputExt) {\n    this.isGestureRunning = true;\n    clearTimeout(this.visualFeedbackTimer);\n    this.initialEvent = ev;\n    this.visualFeedbackTimer = fireAfterInterval(() => {\n      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n      this.initialEvent = null;\n    }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);\n  }\n\n  sendGestureStartedEvent(ev: HammerInputExt) {\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.sendEvent({\n      ...ev,\n      eventType: Hammer.INPUT_MOVE,\n      isFirst: true,\n    });\n  }\n\n  forceInvalidate(event: HammerInputExt) {\n    super.forceInvalidate(event);\n    clearTimeout(this.visualFeedbackTimer);\n    this.visualFeedbackTimer = null;\n    this.initialEvent = null;\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.isGestureRunning) {\n      if (ev.isFinal) {\n        let timeout;\n        if (this.visualFeedbackTimer) {\n          // Aesthetic timing for a quick tap.\n          // We haven't activated the tap right away to emulate iOS `delaysContentTouches`\n          // Now we must send the initial activation event and wait a set amount of time before firing the end event.\n          timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;\n          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);\n          this.initialEvent = null;\n        }\n        fireAfterInterval(() => {\n          this.sendEvent({\n            ...ev,\n            eventType: Hammer.INPUT_END,\n            isFinal: true,\n          });\n          // @ts-ignore -- this should explicitly support undefined\n          this.onGestureEnded();\n        }, timeout);\n      } else {\n        this.sendEvent({\n          ...ev,\n          eventType: Hammer.INPUT_MOVE,\n          isFinal: false,\n        });\n      }\n    }\n  }\n\n  updateGestureConfig({\n    shouldActivateOnStart = false,\n    disallowInterruption = false,\n    shouldCancelWhenOutside = true,\n    minDurationMs = Number.NaN,\n    maxDist = Number.NaN,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldActivateOnStart,\n      disallowInterruption,\n      shouldCancelWhenOutside,\n      minDurationMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n}\nexport default PressGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js
new file mode 100644
index 0000000..42f97cc
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js
@@ -0,0 +1,32 @@
+import Hammer from '@egjs/hammerjs';
+import { DEG_RAD } from './constants';
+import IndiscreteGestureHandler from './IndiscreteGestureHandler';
+
+class RotationGestureHandler extends IndiscreteGestureHandler {
+  get name() {
+    return 'rotate';
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Rotate;
+  }
+
+  transformNativeEvent({
+    rotation,
+    velocity,
+    center
+  }) {
+    var _this$initialRotation;
+
+    return {
+      rotation: (rotation - ((_this$initialRotation = this.initialRotation) !== null && _this$initialRotation !== void 0 ? _this$initialRotation : 0)) * DEG_RAD,
+      anchorX: center.x,
+      anchorY: center.y,
+      velocity
+    };
+  }
+
+}
+
+export default RotationGestureHandler;
+//# sourceMappingURL=RotationGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js.map
new file mode 100644
index 0000000..fb7b3c3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/RotationGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["RotationGestureHandler.ts"],"names":["Hammer","DEG_RAD","IndiscreteGestureHandler","RotationGestureHandler","name","NativeGestureClass","Rotate","transformNativeEvent","rotation","velocity","center","initialRotation","anchorX","x","anchorY","y"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,OAAT,QAAwB,aAAxB;AAEA,OAAOC,wBAAP,MAAqC,4BAArC;;AAEA,MAAMC,sBAAN,SAAqCD,wBAArC,CAA8D;AACpD,MAAJE,IAAI,GAAG;AACT,WAAO,QAAP;AACD;;AAEqB,MAAlBC,kBAAkB,GAAG;AACvB,WAAOL,MAAM,CAACM,MAAd;AACD;;AAEDC,EAAAA,oBAAoB,CAAC;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,QAAZ;AAAsBC,IAAAA;AAAtB,GAAD,EAAiD;AAAA;;AACnE,WAAO;AACLF,MAAAA,QAAQ,EAAE,CAACA,QAAQ,6BAAI,KAAKG,eAAT,yEAA4B,CAA5B,CAAT,IAA2CV,OADhD;AAELW,MAAAA,OAAO,EAAEF,MAAM,CAACG,CAFX;AAGLC,MAAAA,OAAO,EAAEJ,MAAM,CAACK,CAHX;AAILN,MAAAA;AAJK,KAAP;AAMD;;AAhB2D;;AAkB9D,eAAeN,sBAAf","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { DEG_RAD } from './constants';\nimport { HammerInputExt } from './GestureHandler';\nimport IndiscreteGestureHandler from './IndiscreteGestureHandler';\n\nclass RotationGestureHandler extends IndiscreteGestureHandler {\n  get name() {\n    return 'rotate';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Rotate;\n  }\n\n  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {\n    return {\n      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,\n      anchorX: center.x,\n      anchorY: center.y,\n      velocity,\n    };\n  }\n}\nexport default RotationGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js b/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js
new file mode 100644
index 0000000..ed067cd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js
@@ -0,0 +1,180 @@
+function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
+
+import Hammer from '@egjs/hammerjs';
+import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { isnan } from './utils';
+
+class TapGestureHandler extends DiscreteGestureHandler {
+  constructor(...args) {
+    super(...args);
+
+    _defineProperty(this, "_shouldFireEndEvent", null);
+
+    _defineProperty(this, "_timer", void 0);
+
+    _defineProperty(this, "_multiTapTimer", void 0);
+
+    _defineProperty(this, "onSuccessfulTap", ev => {
+      if (this._getPendingGestures().length) {
+        this._shouldFireEndEvent = ev;
+        return;
+      }
+
+      if (ev.eventType === Hammer.INPUT_END) {
+        this.sendEvent({ ...ev,
+          eventType: Hammer.INPUT_MOVE
+        });
+      } // When handler gets activated it will turn into State.END immediately.
+
+
+      this.sendEvent({ ...ev,
+        isFinal: true
+      });
+      this.onGestureEnded(ev);
+    });
+  }
+
+  // TODO unused?
+  get name() {
+    return 'tap';
+  }
+
+  get NativeGestureClass() {
+    return Hammer.Tap;
+  }
+
+  get maxDelayMs() {
+    // @ts-ignore TODO(TS) trace down config
+    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;
+  }
+
+  simulateCancelEvent(inputData) {
+    if (this.isGestureRunning) {
+      this.cancelEvent(inputData);
+    }
+  }
+
+  onGestureActivated(ev) {
+    if (this.isGestureRunning) {
+      this.onSuccessfulTap(ev);
+    }
+  }
+
+  onRawEvent(ev) {
+    super.onRawEvent(ev); // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.
+
+    if (!this.hasGestureFailed && !this.isGestureRunning && // Prevent multi-pointer events from misfiring.
+    !ev.isFinal) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
+
+      if (gesture.options.enable(gesture, ev)) {
+        clearTimeout(this._multiTapTimer);
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+
+    if (ev.isFinal && ev.maxPointers > 1) {
+      setTimeout(() => {
+        // Handle case where one finger presses slightly
+        // after the first finger on a multi-tap event
+        if (this.isGestureRunning) {
+          this.cancelEvent(ev);
+        }
+      });
+    }
+
+    if (this.hasGestureFailed) {
+      return;
+    } // Hammer doesn't send a `cancel` event for taps.
+    // Manually fail the event.
+
+
+    if (ev.isFinal) {
+      // Handle case where one finger presses slightly
+      // after the first finger on a multi-tap event
+      if (ev.maxPointers > 1) {
+        setTimeout(() => {
+          if (this.isGestureRunning) {
+            this.cancelEvent(ev);
+          }
+        });
+      } // Clear last timer
+
+
+      clearTimeout(this._timer); // Create time out for multi-taps.
+
+      this._timer = setTimeout(() => {
+        this.hasGestureFailed = true;
+        this.cancelEvent(ev);
+      }, this.maxDelayMs);
+    } else if (!this.hasGestureFailed && !this.isGestureRunning) {
+      // Tap Gesture start event
+      const gesture = this.hammer.get(this.name); // @ts-ignore TODO(TS) trace down config
+
+      if (gesture.options.enable(gesture, ev)) {
+        clearTimeout(this._multiTapTimer);
+        this.onStart(ev);
+        this.sendEvent(ev);
+      }
+    }
+  }
+
+  getHammerConfig() {
+    return { ...super.getHammerConfig(),
+      event: this.name,
+      // @ts-ignore TODO(TS) trace down config
+      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,
+      interval: this.maxDelayMs,
+      time: // @ts-ignore TODO(TS) trace down config
+      isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null ? 250 : // @ts-ignore TODO(TS) trace down config
+      this.config.maxDurationMs
+    };
+  }
+
+  updateGestureConfig({
+    shouldCancelWhenOutside = true,
+    maxDeltaX = Number.NaN,
+    maxDeltaY = Number.NaN,
+    numberOfTaps = 1,
+    minDurationMs = 525,
+    maxDelayMs = Number.NaN,
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?
+    maxDurationMs = Number.NaN,
+    maxDist = 2,
+    minPointers = 1,
+    maxPointers = 1,
+    ...props
+  }) {
+    return super.updateGestureConfig({
+      shouldCancelWhenOutside,
+      numberOfTaps,
+      maxDeltaX,
+      maxDeltaY,
+      minDurationMs,
+      maxDelayMs,
+      maxDist,
+      minPointers,
+      maxPointers,
+      ...props
+    });
+  }
+
+  onGestureEnded(...props) {
+    clearTimeout(this._timer); // @ts-ignore TODO(TS) check how onGestureEnded works
+
+    super.onGestureEnded(...props);
+  }
+
+  onWaitingEnded(_gesture) {
+    if (this._shouldFireEndEvent) {
+      this.onSuccessfulTap(this._shouldFireEndEvent);
+      this._shouldFireEndEvent = null;
+    }
+  }
+
+}
+
+export default TapGestureHandler;
+//# sourceMappingURL=TapGestureHandler.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js.map b/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js.map
new file mode 100644
index 0000000..4145c77
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/TapGestureHandler.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["TapGestureHandler.ts"],"names":["Hammer","DiscreteGestureHandler","isnan","TapGestureHandler","ev","_getPendingGestures","length","_shouldFireEndEvent","eventType","INPUT_END","sendEvent","INPUT_MOVE","isFinal","onGestureEnded","name","NativeGestureClass","Tap","maxDelayMs","config","simulateCancelEvent","inputData","isGestureRunning","cancelEvent","onGestureActivated","onSuccessfulTap","onRawEvent","hasGestureFailed","gesture","hammer","get","options","enable","clearTimeout","_multiTapTimer","onStart","maxPointers","setTimeout","_timer","getHammerConfig","event","taps","numberOfTaps","interval","time","maxDurationMs","updateGestureConfig","shouldCancelWhenOutside","maxDeltaX","Number","NaN","maxDeltaY","minDurationMs","maxDist","minPointers","props","onWaitingEnded","_gesture"],"mappings":"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","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { HammerInputExt } from './GestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  private _shouldFireEndEvent: HammerInputExt | null = null;\n  private _timer: any;\n  private _multiTapTimer: any; // TODO unused?\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    // @ts-ignore TODO(TS) trace down config\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev: HammerInputExt) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = (ev: HammerInputExt) => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev: HammerInput) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore TODO(TS) trace down config\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      // @ts-ignore TODO(TS) trace down config\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        // @ts-ignore TODO(TS) trace down config\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : // @ts-ignore TODO(TS) trace down config\n            this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props: any) {\n    clearTimeout(this._timer);\n    // @ts-ignore TODO(TS) check how onGestureEnded works\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(_gesture: any) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/constants.js b/node_modules/react-native-gesture-handler/lib/module/web/constants.js
new file mode 100644
index 0000000..5944bdd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/constants.js
@@ -0,0 +1,43 @@
+import Hammer from '@egjs/hammerjs';
+import { State } from '../State';
+export const CONTENT_TOUCHES_DELAY = 240;
+export const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;
+export const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;
+export const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;
+export const DEG_RAD = Math.PI / 180; // Map Hammer values to RNGH
+
+export const EventMap = {
+  [Hammer.INPUT_START]: State.BEGAN,
+  [Hammer.INPUT_MOVE]: State.ACTIVE,
+  [Hammer.INPUT_END]: State.END,
+  [Hammer.INPUT_CANCEL]: State.FAILED
+};
+export const Direction = {
+  RIGHT: 1,
+  LEFT: 2,
+  UP: 4,
+  DOWN: 8
+};
+export const DirectionMap = {
+  [Hammer.DIRECTION_RIGHT]: Direction.RIGHT,
+  [Hammer.DIRECTION_LEFT]: Direction.LEFT,
+  [Hammer.DIRECTION_UP]: Direction.UP,
+  [Hammer.DIRECTION_DOWN]: Direction.DOWN
+};
+export const HammerInputNames = {
+  [Hammer.INPUT_START]: 'START',
+  [Hammer.INPUT_MOVE]: 'MOVE',
+  [Hammer.INPUT_END]: 'END',
+  [Hammer.INPUT_CANCEL]: 'CANCEL'
+};
+export const HammerDirectionNames = {
+  [Hammer.DIRECTION_HORIZONTAL]: 'HORIZONTAL',
+  [Hammer.DIRECTION_UP]: 'UP',
+  [Hammer.DIRECTION_DOWN]: 'DOWN',
+  [Hammer.DIRECTION_VERTICAL]: 'VERTICAL',
+  [Hammer.DIRECTION_NONE]: 'NONE',
+  [Hammer.DIRECTION_ALL]: 'ALL',
+  [Hammer.DIRECTION_RIGHT]: 'RIGHT',
+  [Hammer.DIRECTION_LEFT]: 'LEFT'
+};
+//# sourceMappingURL=constants.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/constants.js.map b/node_modules/react-native-gesture-handler/lib/module/web/constants.js.map
new file mode 100644
index 0000000..56a31eb
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/constants.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["constants.ts"],"names":["Hammer","State","CONTENT_TOUCHES_DELAY","CONTENT_TOUCHES_QUICK_TAP_END_DELAY","MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD","MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD","DEG_RAD","Math","PI","EventMap","INPUT_START","BEGAN","INPUT_MOVE","ACTIVE","INPUT_END","END","INPUT_CANCEL","FAILED","Direction","RIGHT","LEFT","UP","DOWN","DirectionMap","DIRECTION_RIGHT","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_DOWN","HammerInputNames","HammerDirectionNames","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","DIRECTION_NONE","DIRECTION_ALL"],"mappings":"AAAA,OAAOA,MAAP,MAAmB,gBAAnB;AAEA,SAASC,KAAT,QAAsB,UAAtB;AAEA,OAAO,MAAMC,qBAAqB,GAAG,GAA9B;AACP,OAAO,MAAMC,mCAAmC,GAAG,EAA5C;AACP,OAAO,MAAMC,oCAAoC,GAAG,GAA7C;AACP,OAAO,MAAMC,uCAAuC,GAAG,CAAhD;AACP,OAAO,MAAMC,OAAO,GAAGC,IAAI,CAACC,EAAL,GAAU,GAA1B,C,CAEP;;AACA,OAAO,MAAMC,QAAQ,GAAG;AACtB,GAACT,MAAM,CAACU,WAAR,GAAsBT,KAAK,CAACU,KADN;AAEtB,GAACX,MAAM,CAACY,UAAR,GAAqBX,KAAK,CAACY,MAFL;AAGtB,GAACb,MAAM,CAACc,SAAR,GAAoBb,KAAK,CAACc,GAHJ;AAItB,GAACf,MAAM,CAACgB,YAAR,GAAuBf,KAAK,CAACgB;AAJP,CAAjB;AAOP,OAAO,MAAMC,SAAS,GAAG;AACvBC,EAAAA,KAAK,EAAE,CADgB;AAEvBC,EAAAA,IAAI,EAAE,CAFiB;AAGvBC,EAAAA,EAAE,EAAE,CAHmB;AAIvBC,EAAAA,IAAI,EAAE;AAJiB,CAAlB;AAOP,OAAO,MAAMC,YAAY,GAAG;AAC1B,GAACvB,MAAM,CAACwB,eAAR,GAA0BN,SAAS,CAACC,KADV;AAE1B,GAACnB,MAAM,CAACyB,cAAR,GAAyBP,SAAS,CAACE,IAFT;AAG1B,GAACpB,MAAM,CAAC0B,YAAR,GAAuBR,SAAS,CAACG,EAHP;AAI1B,GAACrB,MAAM,CAAC2B,cAAR,GAAyBT,SAAS,CAACI;AAJT,CAArB;AAOP,OAAO,MAAMM,gBAAgB,GAAG;AAC9B,GAAC5B,MAAM,CAACU,WAAR,GAAsB,OADQ;AAE9B,GAACV,MAAM,CAACY,UAAR,GAAqB,MAFS;AAG9B,GAACZ,MAAM,CAACc,SAAR,GAAoB,KAHU;AAI9B,GAACd,MAAM,CAACgB,YAAR,GAAuB;AAJO,CAAzB;AAMP,OAAO,MAAMa,oBAAoB,GAAG;AAClC,GAAC7B,MAAM,CAAC8B,oBAAR,GAA+B,YADG;AAElC,GAAC9B,MAAM,CAAC0B,YAAR,GAAuB,IAFW;AAGlC,GAAC1B,MAAM,CAAC2B,cAAR,GAAyB,MAHS;AAIlC,GAAC3B,MAAM,CAAC+B,kBAAR,GAA6B,UAJK;AAKlC,GAAC/B,MAAM,CAACgC,cAAR,GAAyB,MALS;AAMlC,GAAChC,MAAM,CAACiC,aAAR,GAAwB,KANU;AAOlC,GAACjC,MAAM,CAACwB,eAAR,GAA0B,OAPQ;AAQlC,GAACxB,MAAM,CAACyB,cAAR,GAAyB;AARS,CAA7B","sourcesContent":["import Hammer from '@egjs/hammerjs';\n\nimport { State } from '../State';\n\nexport const CONTENT_TOUCHES_DELAY = 240;\nexport const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;\nexport const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;\nexport const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;\nexport const DEG_RAD = Math.PI / 180;\n\n// Map Hammer values to RNGH\nexport const EventMap = {\n  [Hammer.INPUT_START]: State.BEGAN,\n  [Hammer.INPUT_MOVE]: State.ACTIVE,\n  [Hammer.INPUT_END]: State.END,\n  [Hammer.INPUT_CANCEL]: State.FAILED,\n} as const;\n\nexport const Direction = {\n  RIGHT: 1,\n  LEFT: 2,\n  UP: 4,\n  DOWN: 8,\n};\n\nexport const DirectionMap = {\n  [Hammer.DIRECTION_RIGHT]: Direction.RIGHT,\n  [Hammer.DIRECTION_LEFT]: Direction.LEFT,\n  [Hammer.DIRECTION_UP]: Direction.UP,\n  [Hammer.DIRECTION_DOWN]: Direction.DOWN,\n};\n\nexport const HammerInputNames = {\n  [Hammer.INPUT_START]: 'START',\n  [Hammer.INPUT_MOVE]: 'MOVE',\n  [Hammer.INPUT_END]: 'END',\n  [Hammer.INPUT_CANCEL]: 'CANCEL',\n};\nexport const HammerDirectionNames = {\n  [Hammer.DIRECTION_HORIZONTAL]: 'HORIZONTAL',\n  [Hammer.DIRECTION_UP]: 'UP',\n  [Hammer.DIRECTION_DOWN]: 'DOWN',\n  [Hammer.DIRECTION_VERTICAL]: 'VERTICAL',\n  [Hammer.DIRECTION_NONE]: 'NONE',\n  [Hammer.DIRECTION_ALL]: 'ALL',\n  [Hammer.DIRECTION_RIGHT]: 'RIGHT',\n  [Hammer.DIRECTION_LEFT]: 'LEFT',\n};\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/utils.js b/node_modules/react-native-gesture-handler/lib/module/web/utils.js
new file mode 100644
index 0000000..2591b7f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/utils.js
@@ -0,0 +1,19 @@
+// TODO(TS) remove if not necessary after rewrite
+export const isnan = v => Number.isNaN(v); // TODO(TS) remove if not necessary after rewrite
+
+export const isValidNumber = v => typeof v === 'number' && !Number.isNaN(v);
+export const TEST_MIN_IF_NOT_NAN = (value, limit) => !isnan(limit) && (limit < 0 && value <= limit || limit >= 0 && value >= limit);
+export const VEC_LEN_SQ = ({
+  x = 0,
+  y = 0
+} = {}) => x * x + y * y;
+export const TEST_MAX_IF_NOT_NAN = (value, max) => !isnan(max) && (max < 0 && value < max || max >= 0 && value > max);
+export function fireAfterInterval(method, interval) {
+  if (!interval) {
+    method();
+    return null;
+  }
+
+  return setTimeout(() => method(), interval);
+}
+//# sourceMappingURL=utils.js.map
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/module/web/utils.js.map b/node_modules/react-native-gesture-handler/lib/module/web/utils.js.map
new file mode 100644
index 0000000..23adbe2
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/module/web/utils.js.map
@@ -0,0 +1 @@
+{"version":3,"sources":["utils.ts"],"names":["isnan","v","Number","isNaN","isValidNumber","TEST_MIN_IF_NOT_NAN","value","limit","VEC_LEN_SQ","x","y","TEST_MAX_IF_NOT_NAN","max","fireAfterInterval","method","interval","setTimeout"],"mappings":"AAAA;AACA,OAAO,MAAMA,KAAK,GAAIC,CAAD,IAAgBC,MAAM,CAACC,KAAP,CAAaF,CAAb,CAA9B,C,CAEP;;AACA,OAAO,MAAMG,aAAa,GAAIH,CAAD,IAC3B,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,MAAM,CAACC,KAAP,CAAaF,CAAb,CADrB;AAGP,OAAO,MAAMI,mBAAmB,GAAG,CAACC,KAAD,EAAgBC,KAAhB,KACjC,CAACP,KAAK,CAACO,KAAD,CAAN,KACEA,KAAK,GAAG,CAAR,IAAaD,KAAK,IAAIC,KAAvB,IAAkCA,KAAK,IAAI,CAAT,IAAcD,KAAK,IAAIC,KAD1D,CADK;AAGP,OAAO,MAAMC,UAAU,GAAG,CAAC;AAAEC,EAAAA,CAAC,GAAG,CAAN;AAASC,EAAAA,CAAC,GAAG;AAAb,IAAmB,EAApB,KAA2BD,CAAC,GAAGA,CAAJ,GAAQC,CAAC,GAAGA,CAA1D;AACP,OAAO,MAAMC,mBAAmB,GAAG,CAACL,KAAD,EAAgBM,GAAhB,KACjC,CAACZ,KAAK,CAACY,GAAD,CAAN,KAAiBA,GAAG,GAAG,CAAN,IAAWN,KAAK,GAAGM,GAApB,IAA6BA,GAAG,IAAI,CAAP,IAAYN,KAAK,GAAGM,GAAjE,CADK;AAGP,OAAO,SAASC,iBAAT,CACLC,MADK,EAELC,QAFK,EAGL;AACA,MAAI,CAACA,QAAL,EAAe;AACbD,IAAAA,MAAM;AACN,WAAO,IAAP;AACD;;AACD,SAAOE,UAAU,CAAC,MAAMF,MAAM,EAAb,EAAiBC,QAAjB,CAAjB;AACD","sourcesContent":["// TODO(TS) remove if not necessary after rewrite\nexport const isnan = (v: unknown) => Number.isNaN(v);\n\n// TODO(TS) remove if not necessary after rewrite\nexport const isValidNumber = (v: unknown) =>\n  typeof v === 'number' && !Number.isNaN(v);\n\nexport const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>\n  !isnan(limit) &&\n  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));\nexport const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;\nexport const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>\n  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));\n\nexport function fireAfterInterval(\n  method: () => void,\n  interval?: number | boolean\n) {\n  if (!interval) {\n    method();\n    return null;\n  }\n  return setTimeout(() => method(), interval);\n}\n"]}
\ No newline at end of file
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/Directions.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/Directions.d.ts
new file mode 100644
index 0000000..e102020
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/Directions.d.ts
@@ -0,0 +1,7 @@
+export declare const Directions: {
+    readonly RIGHT: 1;
+    readonly LEFT: 2;
+    readonly UP: 4;
+    readonly DOWN: 8;
+};
+export declare type Directions = typeof Directions[keyof typeof Directions];
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.android.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.android.d.ts
new file mode 100644
index 0000000..a0a7de7
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.android.d.ts
@@ -0,0 +1,4 @@
+import { PropsWithChildren } from 'react';
+declare type Props = PropsWithChildren<Record<string, unknown>>;
+export default function GestureHandlerRootView({ children, ...rest }: Props): JSX.Element;
+export {};
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerRootView.js b/node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.d.ts
similarity index 67%
rename from node_modules/react-native-gesture-handler/GestureHandlerRootView.js
rename to node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.d.ts
index 9380603..a81d3b9 100644
--- a/node_modules/react-native-gesture-handler/GestureHandlerRootView.js
+++ b/node_modules/react-native-gesture-handler/lib/typescript/GestureHandlerRootView.d.ts
@@ -1,4 +1,2 @@
-import React from 'react';
 import { View } from 'react-native';
-
 export default View;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.d.ts
new file mode 100644
index 0000000..d9fa237
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.d.ts
@@ -0,0 +1,5 @@
+declare type PlatformConstants = {
+    forceTouchAvailable: boolean;
+};
+declare const _default: PlatformConstants;
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.web.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.web.d.ts
new file mode 100644
index 0000000..7b53029
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/PlatformConstants.web.d.ts
@@ -0,0 +1,4 @@
+declare const _default: {
+    readonly forceTouchAvailable: boolean;
+};
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.d.ts
new file mode 100644
index 0000000..b29b8ff
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.d.ts
@@ -0,0 +1,10 @@
+export declare type RNGestureHandlerModuleProps = {
+    handleSetJSResponder: (tag: number, blockNativeResponder: boolean) => void;
+    handleClearJSResponder: () => void;
+    createGestureHandler: (handlerName: string, handlerTag: number, config: Readonly<Record<string, unknown>>) => void;
+    attachGestureHandler: (handlerTag: number, newView: number) => void;
+    updateGestureHandler: (handlerTag: number, newConfig: Readonly<Record<string, unknown>>) => void;
+    dropGestureHandler: (handlerTag: number) => void;
+};
+declare const _default: RNGestureHandlerModuleProps;
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.web.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.web.d.ts
new file mode 100644
index 0000000..d2f3c2a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/RNGestureHandlerModule.web.d.ts
@@ -0,0 +1,32 @@
+import FlingGestureHandler from './web/FlingGestureHandler';
+import LongPressGestureHandler from './web/LongPressGestureHandler';
+import NativeViewGestureHandler from './web/NativeViewGestureHandler';
+import PanGestureHandler from './web/PanGestureHandler';
+import PinchGestureHandler from './web/PinchGestureHandler';
+import RotationGestureHandler from './web/RotationGestureHandler';
+import TapGestureHandler from './web/TapGestureHandler';
+export declare const Gestures: {
+    PanGestureHandler: typeof PanGestureHandler;
+    RotationGestureHandler: typeof RotationGestureHandler;
+    PinchGestureHandler: typeof PinchGestureHandler;
+    TapGestureHandler: typeof TapGestureHandler;
+    NativeViewGestureHandler: typeof NativeViewGestureHandler;
+    LongPressGestureHandler: typeof LongPressGestureHandler;
+    FlingGestureHandler: typeof FlingGestureHandler;
+};
+declare const _default: {
+    Direction: {
+        RIGHT: number;
+        LEFT: number;
+        UP: number;
+        DOWN: number;
+    };
+    handleSetJSResponder(tag: number, blockNativeResponder: boolean): void;
+    handleClearJSResponder(): void;
+    createGestureHandler<T>(handlerName: keyof typeof Gestures, handlerTag: number, config: T): void;
+    attachGestureHandler(handlerTag: number, newView: number, propsRef: React.RefObject<unknown>): void;
+    updateGestureHandler(handlerTag: number, newConfig: any): void;
+    getGestureHandlerNode(handlerTag: number): PanGestureHandler | RotationGestureHandler | PinchGestureHandler | TapGestureHandler | NativeViewGestureHandler | LongPressGestureHandler | FlingGestureHandler;
+    dropGestureHandler(handlerTag: number): void;
+};
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/State.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/State.d.ts
new file mode 100644
index 0000000..04cc91f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/State.d.ts
@@ -0,0 +1,9 @@
+export declare const State: {
+    readonly UNDETERMINED: 0;
+    readonly FAILED: 1;
+    readonly BEGAN: 2;
+    readonly CANCELLED: 3;
+    readonly ACTIVE: 4;
+    readonly END: 5;
+};
+export declare type State = typeof State[keyof typeof State];
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/DrawerLayout.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/DrawerLayout.d.ts
new file mode 100644
index 0000000..ca77372
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/DrawerLayout.d.ts
@@ -0,0 +1,81 @@
+import * as React from 'react';
+import { Component } from 'react';
+import { Animated, StatusBarAnimation, StyleProp, ViewStyle } from 'react-native';
+import { PanGestureHandler } from '../handlers/gestureHandlers';
+export declare type DrawerPosition = 'left' | 'right';
+export declare type DrawerState = 'Idle' | 'Dragging' | 'Settling';
+export declare type DrawerType = 'front' | 'back' | 'slide';
+export declare type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';
+export declare type DrawerKeyboardDismissMode = 'none' | 'on-drag';
+export interface DrawerLayoutProps {
+    renderNavigationView: (progressAnimatedValue: Animated.Value) => React.ReactNode;
+    drawerPosition?: DrawerPosition;
+    drawerWidth?: number;
+    drawerBackgroundColor?: string;
+    drawerLockMode?: DrawerLockMode;
+    keyboardDismissMode?: DrawerKeyboardDismissMode;
+    onDrawerClose?: () => void;
+    onDrawerOpen?: () => void;
+    onDrawerStateChanged?: (newState: DrawerState, drawerWillShow: boolean) => void;
+    useNativeAnimations?: boolean;
+    drawerType?: DrawerType;
+    edgeWidth?: number;
+    minSwipeDistance?: number;
+    hideStatusBar?: boolean;
+    statusBarAnimation?: StatusBarAnimation;
+    overlayColor?: string;
+    contentContainerStyle?: StyleProp<ViewStyle>;
+    drawerContainerStyle?: StyleProp<ViewStyle>;
+    enableTrackpadTwoFingerGesture?: boolean;
+    onDrawerSlide?: (position: number) => void;
+    onGestureRef?: (ref: PanGestureHandler) => void;
+}
+export declare type DrawerLayoutState = {
+    dragX: Animated.Value;
+    touchX: Animated.Value;
+    drawerTranslation: Animated.Value;
+    containerWidth: number;
+};
+export declare type DrawerMovementOption = {
+    velocity?: number;
+    speed?: number;
+};
+export default class DrawerLayout extends Component<DrawerLayoutProps, DrawerLayoutState> {
+    static defaultProps: {
+        drawerWidth: number;
+        drawerPosition: string;
+        useNativeAnimations: boolean;
+        drawerType: string;
+        edgeWidth: number;
+        minSwipeDistance: number;
+        overlayColor: string;
+        drawerLockMode: string;
+        enableTrackpadTwoFingerGesture: boolean;
+    };
+    constructor(props: DrawerLayoutProps);
+    UNSAFE_componentWillUpdate(props: DrawerLayoutProps, state: DrawerLayoutState): void;
+    private openValue?;
+    private onGestureEvent?;
+    private accessibilityIsModalView;
+    private pointerEventsView;
+    private panGestureHandler;
+    private drawerShown;
+    static positions: {
+        Left: string;
+        Right: string;
+    };
+    private updateAnimatedEvent;
+    private handleContainerLayout;
+    private emitStateChanged;
+    private openingHandlerStateChange;
+    private onTapHandlerStateChange;
+    private handleRelease;
+    private updateShowing;
+    private animateDrawer;
+    openDrawer: (options?: DrawerMovementOption) => void;
+    closeDrawer: (options?: DrawerMovementOption) => void;
+    private renderOverlay;
+    private renderDrawer;
+    private setPanGestureRef;
+    render(): JSX.Element;
+}
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/GestureButtons.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureButtons.d.ts
new file mode 100644
index 0000000..0c10368
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureButtons.d.ts
@@ -0,0 +1,51 @@
+import * as React from 'react';
+import { StyleProp, ViewStyle } from 'react-native';
+import { NativeViewGestureHandlerProps } from '../handlers/NativeViewGestureHandler';
+export interface RawButtonProps extends NativeViewGestureHandlerProps {
+    exclusive?: boolean;
+    rippleColor?: any;
+}
+export interface BaseButtonProps extends RawButtonProps {
+    onPress?: (pointerInside: boolean) => void;
+    onActiveStateChange?: (active: boolean) => void;
+    style?: StyleProp<ViewStyle>;
+    testID?: string;
+}
+export interface RectButtonProps extends BaseButtonProps {
+    underlayColor?: string;
+    activeOpacity?: number;
+}
+export interface BorderlessButtonProps extends BaseButtonProps {
+    borderless?: boolean;
+    activeOpacity?: number;
+}
+export declare const RawButton: React.ForwardRefExoticComponent<RawButtonProps & NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare class BaseButton extends React.Component<BaseButtonProps> {
+    private lastActive;
+    constructor(props: BaseButtonProps);
+    private handleEvent;
+    private onHandlerStateChange;
+    private onGestureEvent;
+    render(): JSX.Element;
+}
+export declare class RectButton extends React.Component<RectButtonProps> {
+    static defaultProps: {
+        activeOpacity: number;
+        underlayColor: string;
+    };
+    private opacity;
+    constructor(props: RectButtonProps);
+    private onActiveStateChange;
+    render(): JSX.Element;
+}
+export declare class BorderlessButton extends React.Component<BorderlessButtonProps> {
+    static defaultProps: {
+        activeOpacity: number;
+        borderless: boolean;
+    };
+    private opacity;
+    constructor(props: BorderlessButtonProps);
+    private onActiveStateChange;
+    render(): JSX.Element;
+}
+export { default as PureNativeButton } from './GestureHandlerButton';
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.d.ts
new file mode 100644
index 0000000..30c28fc
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.d.ts
@@ -0,0 +1,45 @@
+import * as React from 'react';
+import { ScrollViewProps as RNScrollViewProps, SwitchProps as RNSwitchProps, TextInputProps as RNTextInputProps, DrawerLayoutAndroidProps as RNDrawerLayoutAndroidProps, FlatList as RNFlatList, FlatListProps as RNFlatListProps } from 'react-native';
+import { NativeViewGestureHandlerProps } from '../handlers/NativeViewGestureHandler';
+export declare const ScrollView: React.ForwardRefExoticComponent<RNScrollViewProps & {
+    children?: React.ReactNode;
+} & NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare type ScrollView = typeof ScrollView & {
+    scrollTo(y?: number | {
+        x?: number;
+        y?: number;
+        animated?: boolean;
+    }, x?: number, animated?: boolean): void;
+    scrollToEnd(options?: {
+        animated: boolean;
+    }): void;
+};
+export declare const Switch: React.ForwardRefExoticComponent<RNSwitchProps & NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare type Switch = typeof Switch;
+export declare const TextInput: React.ForwardRefExoticComponent<RNTextInputProps & NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare type TextInput = typeof TextInput;
+export declare const DrawerLayoutAndroid: React.ForwardRefExoticComponent<RNDrawerLayoutAndroidProps & {
+    children?: React.ReactNode;
+} & NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare type DrawerLayoutAndroid = typeof DrawerLayoutAndroid;
+export declare const FlatList: React.ForwardRefExoticComponent<RNFlatListProps<any> & React.RefAttributes<RNFlatList<any>>>;
+export declare type FlatList<ItemT> = React.ComponentType<RNFlatListProps<ItemT> & NativeViewGestureHandlerProps & React.RefAttributes<any>> & {
+    scrollToEnd: (params?: {
+        animated?: boolean;
+    }) => void;
+    scrollToIndex: (params: {
+        animated?: boolean;
+        index: number;
+        viewOffset?: number;
+        viewPosition?: number;
+    }) => void;
+    scrollToItem: (params: {
+        animated?: boolean;
+        item: ItemT;
+        viewPosition?: number;
+    }) => void;
+    scrollToOffset: (params: {
+        animated?: boolean;
+        offset: number;
+    }) => void;
+};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.web.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.web.d.ts
new file mode 100644
index 0000000..0b39f65
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureComponents.web.d.ts
@@ -0,0 +1,7 @@
+import * as React from 'react';
+import { FlatListProps } from 'react-native';
+export declare const ScrollView: React.ForwardRefExoticComponent<import("react-native").ScrollViewProps & import("..").NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare const Switch: React.ForwardRefExoticComponent<import("react-native").SwitchProps & import("..").NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare const TextInput: React.ForwardRefExoticComponent<import("react-native").TextInputProps & import("..").NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare const DrawerLayoutAndroid: React.ForwardRefExoticComponent<import("react-native").DrawerLayoutAndroidProps & import("..").NativeViewGestureHandlerProps & React.RefAttributes<React.ComponentType<any>>>;
+export declare const FlatList: React.ForwardRefExoticComponent<FlatListProps<unknown> & React.RefAttributes<unknown>>;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.d.ts
new file mode 100644
index 0000000..db68ffd
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.d.ts
@@ -0,0 +1,4 @@
+import { HostComponent } from 'react-native';
+import { RawButtonProps } from './GestureButtons';
+declare const RNGestureHandlerButton: HostComponent<RawButtonProps>;
+export default RNGestureHandlerButton;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.web.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.web.d.ts
new file mode 100644
index 0000000..2e71ae6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/GestureHandlerButton.web.d.ts
@@ -0,0 +1,4 @@
+import * as React from 'react';
+import { View } from 'react-native';
+declare const _default: React.ForwardRefExoticComponent<React.RefAttributes<View>>;
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/Swipeable.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/Swipeable.d.ts
new file mode 100644
index 0000000..60237c7
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/Swipeable.d.ts
@@ -0,0 +1,83 @@
+import * as React from 'react';
+import { Component } from 'react';
+import { Animated, StyleProp, ViewStyle } from 'react-native';
+import { PanGestureHandlerProps } from '../handlers/gestureHandlers';
+declare type SwipeableExcludes = Exclude<keyof PanGestureHandlerProps, 'onGestureEvent' | 'onHandlerStateChange'>;
+interface SwipeableProps extends Pick<PanGestureHandlerProps, SwipeableExcludes> {
+    enableTrackpadTwoFingerGesture?: boolean;
+    friction?: number;
+    leftThreshold?: number;
+    rightThreshold?: number;
+    overshootLeft?: boolean;
+    overshootRight?: boolean;
+    overshootFriction?: number;
+    onSwipeableLeftOpen?: () => void;
+    onSwipeableRightOpen?: () => void;
+    onSwipeableOpen?: () => void;
+    onSwipeableClose?: () => void;
+    onSwipeableLeftWillOpen?: () => void;
+    onSwipeableRightWillOpen?: () => void;
+    onSwipeableWillOpen?: () => void;
+    onSwipeableWillClose?: () => void;
+    /**
+     *
+     * This map describes the values to use as inputRange for extra interpolation:
+     * AnimatedValue: [startValue, endValue]
+     *
+     * progressAnimatedValue: [0, 1]
+     * dragAnimatedValue: [0, +]
+     *
+     * To support `rtl` flexbox layouts use `flexDirection` styling.
+     * */
+    renderLeftActions?: (progressAnimatedValue: Animated.AnimatedInterpolation, dragAnimatedValue: Animated.AnimatedInterpolation) => React.ReactNode;
+    /**
+     *
+     * This map describes the values to use as inputRange for extra interpolation:
+     * AnimatedValue: [startValue, endValue]
+     *
+     * progressAnimatedValue: [0, 1]
+     * dragAnimatedValue: [0, -]
+     *
+     * To support `rtl` flexbox layouts use `flexDirection` styling.
+     * */
+    renderRightActions?: (progressAnimatedValue: Animated.AnimatedInterpolation, dragAnimatedValue: Animated.AnimatedInterpolation) => React.ReactNode;
+    useNativeAnimations?: boolean;
+    animationOptions?: Record<string, unknown>;
+    containerStyle?: StyleProp<ViewStyle>;
+    childrenContainerStyle?: StyleProp<ViewStyle>;
+}
+declare type SwipeableState = {
+    dragX: Animated.Value;
+    rowTranslation: Animated.Value;
+    rowState: number;
+    leftWidth?: number;
+    rightOffset?: number;
+    rowWidth?: number;
+};
+export default class Swipeable extends Component<SwipeableProps, SwipeableState> {
+    static defaultProps: {
+        friction: number;
+        overshootFriction: number;
+        useNativeAnimations: boolean;
+    };
+    constructor(props: SwipeableProps);
+    UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState): void;
+    private onGestureEvent?;
+    private transX?;
+    private showLeftAction?;
+    private leftActionTranslate?;
+    private showRightAction?;
+    private rightActionTranslate?;
+    private updateAnimatedEvent;
+    private onTapHandlerStateChange;
+    private onHandlerStateChange;
+    private handleRelease;
+    private animateRow;
+    private onRowLayout;
+    private currentOffset;
+    close: () => void;
+    openLeft: () => void;
+    openRight: () => void;
+    render(): JSX.Element;
+}
+export {};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/GenericTouchable.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/GenericTouchable.d.ts
new file mode 100644
index 0000000..343288f
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/GenericTouchable.d.ts
@@ -0,0 +1,66 @@
+/// <reference types="node" />
+import { Component } from 'react';
+import { StyleProp, ViewStyle, TouchableWithoutFeedbackProps } from 'react-native';
+import { GestureEvent, HandlerStateChangeEvent } from '../../handlers/gestureHandlers';
+import { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';
+import { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';
+/**
+ * Each touchable is a states' machine which preforms transitions.
+ * On very beginning (and on the very end or recognition) touchable is
+ * UNDETERMINED. Then it moves to BEGAN. If touchable recognizes that finger
+ * travel outside it transits to special MOVED_OUTSIDE state. Gesture recognition
+ * finishes in UNDETERMINED state.
+ */
+export declare const TOUCHABLE_STATE: {
+    readonly UNDETERMINED: 0;
+    readonly BEGAN: 1;
+    readonly MOVED_OUTSIDE: 2;
+};
+declare type TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];
+export interface GenericTouchableProps extends TouchableWithoutFeedbackProps {
+    onPress?: () => void;
+    onPressIn?: () => void;
+    onPressOut?: () => void;
+    onLongPress?: () => void;
+    nativeID?: string;
+    shouldActivateOnStart?: boolean;
+    disallowInterruption?: boolean;
+    containerStyle?: StyleProp<ViewStyle>;
+}
+interface InternalProps {
+    extraButtonProps: TouchableNativeFeedbackExtraProps;
+    onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;
+}
+declare type Timeout = ReturnType<typeof setTimeout> | null | undefined;
+/**
+ * GenericTouchable is not intented to be used as it is.
+ * Should be treated as a source for the rest of touchables
+ */
+export default class GenericTouchable extends Component<GenericTouchableProps & InternalProps> {
+    static defaultProps: {
+        delayLongPress: number;
+        extraButtonProps: {
+            rippleColor: string;
+        };
+    };
+    pressInTimeout: Timeout;
+    pressOutTimeout: Timeout;
+    longPressTimeout: Timeout;
+    longPressDetected: boolean;
+    pointerInside: boolean;
+    STATE: TouchableState;
+    handlePressIn(): void;
+    handleMoveOutside(): void;
+    handleGoToUndetermined(): void;
+    componentDidMount(): void;
+    reset(): void;
+    moveToState(newState: TouchableState): void;
+    onGestureEvent: ({ nativeEvent: { pointerInside }, }: GestureEvent<NativeViewGestureHandlerPayload>) => void;
+    onHandlerStateChange: ({ nativeEvent, }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => void;
+    onLongPressDetected: () => void;
+    componentWillUnmount(): void;
+    onMoveIn(): void;
+    onMoveOut(): void;
+    render(): JSX.Element;
+}
+export {};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableHighlight.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableHighlight.d.ts
new file mode 100644
index 0000000..b30b432
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableHighlight.d.ts
@@ -0,0 +1,33 @@
+import { Component } from 'react';
+import { GenericTouchableProps } from './GenericTouchable';
+import { TouchableHighlightProps, ColorValue } from 'react-native';
+interface State {
+    extraChildStyle: null | {
+        opacity?: number;
+    };
+    extraUnderlayStyle: null | {
+        backgroundColor?: ColorValue;
+    };
+}
+/**
+ * TouchableHighlight follows RN's implementation
+ */
+export default class TouchableHighlight extends Component<TouchableHighlightProps & GenericTouchableProps, State> {
+    static defaultProps: {
+        activeOpacity: number;
+        delayPressOut: number;
+        underlayColor: string;
+        delayLongPress: number;
+        extraButtonProps: {
+            rippleColor: string;
+        };
+    };
+    constructor(props: TouchableHighlightProps & GenericTouchableProps);
+    showUnderlay: () => void;
+    hasPressHandler: () => (((event: import("react-native").GestureResponderEvent) => void) & (() => void)) | undefined;
+    hideUnderlay: () => void;
+    renderChildren(): JSX.Element;
+    onStateChange: (_from: number, to: number) => void;
+    render(): JSX.Element;
+}
+export {};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.android.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.android.d.ts
new file mode 100644
index 0000000..3cf5dc9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.android.d.ts
@@ -0,0 +1,43 @@
+import { TouchableNativeFeedbackProps, ColorValue } from 'react-native';
+import { Component } from 'react';
+import { GenericTouchableProps } from './GenericTouchable';
+export declare type TouchableNativeFeedbackExtraProps = {
+    borderless?: boolean;
+    rippleColor?: number | null;
+    rippleRadius?: number | null;
+    foreground?: boolean;
+};
+/**
+ * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.
+ * There's small difference with handling long press ripple since RN's implementation calls
+ * ripple animation via bridge. This solution leaves all animations' handling for native components so
+ * it follows native behaviours.
+ */
+export default class TouchableNativeFeedback extends Component<TouchableNativeFeedbackProps & GenericTouchableProps> {
+    static defaultProps: {
+        useForeground: boolean;
+        extraButtonProps: {
+            rippleColor: null;
+        };
+        delayLongPress: number;
+    };
+    static SelectableBackground: (rippleRadius?: number | undefined) => {
+        type: string;
+        attribute: string;
+        rippleRadius: number | undefined;
+    };
+    static SelectableBackgroundBorderless: (rippleRadius?: number | undefined) => {
+        type: string;
+        attribute: string;
+        rippleRadius: number | undefined;
+    };
+    static Ripple: (color: ColorValue, borderless: boolean, rippleRadius?: number | undefined) => {
+        type: string;
+        color: string | symbol;
+        borderless: boolean;
+        rippleRadius: number | undefined;
+    };
+    static canUseNativeForeground: () => boolean;
+    getExtraButtonProps(): TouchableNativeFeedbackExtraProps;
+    render(): JSX.Element;
+}
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.d.ts
new file mode 100644
index 0000000..add3ff6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableNativeFeedback.d.ts
@@ -0,0 +1,2 @@
+import { TouchableNativeFeedback } from 'react-native';
+export default TouchableNativeFeedback;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableOpacity.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableOpacity.d.ts
new file mode 100644
index 0000000..6d03e49
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableOpacity.d.ts
@@ -0,0 +1,20 @@
+import { Animated, TouchableOpacityProps } from 'react-native';
+import { GenericTouchableProps } from './GenericTouchable';
+import { Component } from 'react';
+/**
+ * TouchableOpacity bases on timing animation which has been used in RN's core
+ */
+export default class TouchableOpacity extends Component<TouchableOpacityProps> {
+    static defaultProps: {
+        activeOpacity: number;
+        delayLongPress: number;
+        extraButtonProps: {
+            rippleColor: string;
+        };
+    };
+    getChildStyleOpacityWithDefault: () => number;
+    opacity: Animated.Value;
+    setOpacityTo: (value: number, duration: number) => void;
+    onStateChange: (_from: number, to: number) => void;
+    render(): JSX.Element;
+}
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableWithoutFeedback.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableWithoutFeedback.d.ts
new file mode 100644
index 0000000..9f25968
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/TouchableWithoutFeedback.d.ts
@@ -0,0 +1,6 @@
+import * as React from 'react';
+import GenericTouchable, { GenericTouchableProps } from './GenericTouchable';
+declare const TouchableWithoutFeedback: React.ForwardRefExoticComponent<GenericTouchableProps & {
+    children?: React.ReactNode;
+} & React.RefAttributes<GenericTouchable>>;
+export default TouchableWithoutFeedback;
diff --git a/node_modules/react-native-gesture-handler/touchables/index.js b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/index.d.ts
similarity index 71%
rename from node_modules/react-native-gesture-handler/touchables/index.js
rename to node_modules/react-native-gesture-handler/lib/typescript/components/touchables/index.d.ts
index 0d7f0c2..fa9ae12 100644
--- a/node_modules/react-native-gesture-handler/touchables/index.js
+++ b/node_modules/react-native-gesture-handler/lib/typescript/components/touchables/index.d.ts
@@ -1,6 +1,4 @@
 export { default as TouchableNativeFeedback } from './TouchableNativeFeedback';
-export {
-  default as TouchableWithoutFeedback,
-} from './TouchableWithoutFeedback';
+export { default as TouchableWithoutFeedback } from './TouchableWithoutFeedback';
 export { default as TouchableOpacity } from './TouchableOpacity';
 export { default as TouchableHighlight } from './TouchableHighlight';
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/gestureHandlerRootHOC.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/gestureHandlerRootHOC.d.ts
new file mode 100644
index 0000000..52a9b52
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/gestureHandlerRootHOC.d.ts
@@ -0,0 +1,3 @@
+import * as React from 'react';
+import { StyleProp, ViewStyle } from 'react-native';
+export default function gestureHandlerRootHOC<P>(Component: React.ComponentType<P>, containerStyles?: StyleProp<ViewStyle>): React.ComponentType<P>;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/handlers/NativeViewGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/handlers/NativeViewGestureHandler.d.ts
new file mode 100644
index 0000000..14b9fd3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/handlers/NativeViewGestureHandler.d.ts
@@ -0,0 +1,12 @@
+/// <reference types="react" />
+import { BaseGestureHandlerProps } from './gestureHandlers';
+export interface NativeViewGestureHandlerProps extends BaseGestureHandlerProps<NativeViewGestureHandlerPayload> {
+    shouldActivateOnStart?: boolean;
+    disallowInterruption?: boolean;
+}
+export declare type NativeViewGestureHandlerPayload = {
+    pointerInside: boolean;
+};
+export declare const nativeViewProps: readonly ["id", "enabled", "minPointers", "waitFor", "simultaneousHandlers", "shouldCancelWhenOutside", "hitSlop", "onBegan", "onFailed", "onCancelled", "onActivated", "onEnded", "onGestureEvent", "onHandlerStateChange", "shouldActivateOnStart", "disallowInterruption"];
+export declare type NativeViewGestureHandler = typeof NativeViewGestureHandler;
+export declare const NativeViewGestureHandler: import("react").ComponentType<NativeViewGestureHandlerProps & import("react").RefAttributes<any>>;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/handlers/createHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/handlers/createHandler.d.ts
new file mode 100644
index 0000000..a51ee70
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/handlers/createHandler.d.ts
@@ -0,0 +1,11 @@
+import * as React from 'react';
+import { BaseGestureHandlerProps } from './gestureHandlers';
+declare type CreateHandlerArgs<HandlerPropsT extends Record<string, unknown>> = Readonly<{
+    name: string;
+    allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;
+    config: Readonly<Record<string, unknown>>;
+    transformProps?: (props: HandlerPropsT) => HandlerPropsT;
+    customNativeProps?: Readonly<string[]>;
+}>;
+export default function createHandler<T extends BaseGestureHandlerProps<U>, U extends Record<string, unknown>>({ name, allowedProps, config, transformProps, customNativeProps, }: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>>;
+export {};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/handlers/createNativeWrapper.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/handlers/createNativeWrapper.d.ts
new file mode 100644
index 0000000..2d1dbd8
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/handlers/createNativeWrapper.d.ts
@@ -0,0 +1,3 @@
+import * as React from 'react';
+import { NativeViewGestureHandlerProps } from './NativeViewGestureHandler';
+export default function createNativeWrapper<P>(Component: React.ComponentType<P>, config?: Readonly<NativeViewGestureHandlerProps>): React.ForwardRefExoticComponent<React.PropsWithoutRef<P & NativeViewGestureHandlerProps> & React.RefAttributes<React.ComponentType<any>>>;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlerTypesCompat.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlerTypesCompat.d.ts
new file mode 100644
index 0000000..66947bb
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlerTypesCompat.d.ts
@@ -0,0 +1,35 @@
+import { BaseButtonProps, BorderlessButtonProps, RawButtonProps, RectButtonProps } from '../components/GestureButtons';
+import { FlingGestureHandlerEventPayload, FlingGestureHandlerProps, ForceTouchGestureHandlerEventPayload, ForceTouchGestureHandlerProps, GestureEvent, GestureEventPayload, HandlerStateChangeEvent, HandlerStateChangeEventPayload, LongPressGestureHandlerEventPayload, LongPressGestureHandlerProps, PanGestureHandlerEventPayload, PanGestureHandlerProps, PinchGestureHandlerEventPayload, PinchGestureHandlerProps, RotationGestureHandlerEventPayload, RotationGestureHandlerProps, TapGestureHandlerEventPayload, TapGestureHandlerProps } from './gestureHandlers';
+import { NativeViewGestureHandlerPayload, NativeViewGestureHandlerProps } from './NativeViewGestureHandler';
+export declare type GestureHandlerGestureEventNativeEvent = GestureEventPayload;
+export declare type GestureHandlerStateChangeNativeEvent = HandlerStateChangeEventPayload;
+export declare type GestureHandlerGestureEvent = GestureEvent;
+export declare type GestureHandlerStateChangeEvent = HandlerStateChangeEvent;
+export declare type NativeViewGestureHandlerGestureEvent = GestureEvent<NativeViewGestureHandlerPayload>;
+export declare type NativeViewGestureHandlerStateChangeEvent = HandlerStateChangeEvent<NativeViewGestureHandlerPayload>;
+export declare type TapGestureHandlerGestureEvent = GestureEvent<TapGestureHandlerEventPayload>;
+export declare type TapGestureHandlerStateChangeEvent = HandlerStateChangeEvent<TapGestureHandlerEventPayload>;
+export declare type ForceTouchGestureHandlerGestureEvent = GestureEvent<ForceTouchGestureHandlerEventPayload>;
+export declare type ForceTouchGestureHandlerStateChangeEvent = HandlerStateChangeEvent<ForceTouchGestureHandlerEventPayload>;
+export declare type LongPressGestureHandlerGestureEvent = GestureEvent<LongPressGestureHandlerEventPayload>;
+export declare type LongPressGestureHandlerStateChangeEvent = HandlerStateChangeEvent<LongPressGestureHandlerEventPayload>;
+export declare type PanGestureHandlerGestureEvent = GestureEvent<PanGestureHandlerEventPayload>;
+export declare type PanGestureHandlerStateChangeEvent = HandlerStateChangeEvent<PanGestureHandlerEventPayload>;
+export declare type PinchGestureHandlerGestureEvent = GestureEvent<PinchGestureHandlerEventPayload>;
+export declare type PinchGestureHandlerStateChangeEvent = HandlerStateChangeEvent<PinchGestureHandlerEventPayload>;
+export declare type RotationGestureHandlerGestureEvent = GestureEvent<RotationGestureHandlerEventPayload>;
+export declare type RotationGestureHandlerStateChangeEvent = HandlerStateChangeEvent<RotationGestureHandlerEventPayload>;
+export declare type FlingGestureHandlerGestureEvent = GestureEvent<FlingGestureHandlerEventPayload>;
+export declare type FlingGestureHandlerStateChangeEvent = HandlerStateChangeEvent<FlingGestureHandlerEventPayload>;
+export declare type NativeViewGestureHandlerProperties = NativeViewGestureHandlerProps;
+export declare type TapGestureHandlerProperties = TapGestureHandlerProps;
+export declare type LongPressGestureHandlerProperties = LongPressGestureHandlerProps;
+export declare type PanGestureHandlerProperties = PanGestureHandlerProps;
+export declare type PinchGestureHandlerProperties = PinchGestureHandlerProps;
+export declare type RotationGestureHandlerProperties = RotationGestureHandlerProps;
+export declare type FlingGestureHandlerProperties = FlingGestureHandlerProps;
+export declare type ForceTouchGestureHandlerProperties = ForceTouchGestureHandlerProps;
+export declare type RawButtonProperties = RawButtonProps;
+export declare type BaseButtonProperties = BaseButtonProps;
+export declare type RectButtonProperties = RectButtonProps;
+export declare type BorderlessButtonProperties = BorderlessButtonProps;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlers.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlers.d.ts
new file mode 100644
index 0000000..0ad6d92
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/handlers/gestureHandlers.d.ts
@@ -0,0 +1,158 @@
+import * as React from 'react';
+import { State } from '../State';
+import { ValueOf } from '../typeUtils';
+export interface GestureEventPayload {
+    handlerTag: number;
+    numberOfPointers: number;
+    state: ValueOf<typeof State>;
+}
+export interface HandlerStateChangeEventPayload {
+    handlerTag: number;
+    numberOfPointers: number;
+    state: ValueOf<typeof State>;
+    oldState: ValueOf<typeof State>;
+}
+export interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {
+    nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;
+}
+export interface HandlerStateChangeEvent<ExtraEventPayloadT = Record<string, unknown>> {
+    nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;
+}
+export declare type BaseGestureHandlerProps<ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>> = {
+    id?: string;
+    enabled?: boolean;
+    minPointers?: number;
+    waitFor?: React.Ref<unknown> | React.Ref<unknown>[];
+    simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];
+    shouldCancelWhenOutside?: boolean;
+    hitSlop?: number | Partial<Record<'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal', number>> | Record<'width' | 'left', number> | Record<'width' | 'right', number> | Record<'height' | 'top', number> | Record<'height' | 'bottom', number>;
+    onBegan?: (event: HandlerStateChangeEvent) => void;
+    onFailed?: (event: HandlerStateChangeEvent) => void;
+    onCancelled?: (event: HandlerStateChangeEvent) => void;
+    onActivated?: (event: HandlerStateChangeEvent) => void;
+    onEnded?: (event: HandlerStateChangeEvent) => void;
+    onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;
+    onHandlerStateChange?: (event: HandlerStateChangeEvent<ExtraEventPayloadT>) => void;
+};
+export declare const baseProps: readonly ["id", "enabled", "minPointers", "waitFor", "simultaneousHandlers", "shouldCancelWhenOutside", "hitSlop", "onBegan", "onFailed", "onCancelled", "onActivated", "onEnded", "onGestureEvent", "onHandlerStateChange"];
+export declare type TapGestureHandlerEventPayload = {
+    x: number;
+    y: number;
+    absoluteX: number;
+    absoluteY: number;
+};
+export interface TapGestureHandlerProps extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {
+    minPointers?: number;
+    maxDurationMs?: number;
+    maxDelayMs?: number;
+    numberOfTaps?: number;
+    maxDeltaX?: number;
+    maxDeltaY?: number;
+    maxDist?: number;
+}
+export declare type TapGestureHandler = typeof TapGestureHandler;
+export declare const TapGestureHandler: React.ComponentType<TapGestureHandlerProps & React.RefAttributes<any>>;
+export declare type FlingGestureHandlerEventPayload = {
+    x: number;
+    y: number;
+    absoluteX: number;
+    absoluteY: number;
+};
+export interface FlingGestureHandlerProps extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {
+    direction?: number;
+    numberOfPointers?: number;
+}
+export declare type FlingGestureHandler = typeof FlingGestureHandler;
+export declare const FlingGestureHandler: React.ComponentType<FlingGestureHandlerProps & React.RefAttributes<any>>;
+declare class ForceTouchFallback extends React.Component {
+    static forceTouchAvailable: boolean;
+    componentDidMount(): void;
+    render(): React.ReactNode;
+}
+export declare type ForceTouchGestureHandlerEventPayload = {
+    x: number;
+    y: number;
+    absoluteX: number;
+    absoluteY: number;
+    force: number;
+};
+export interface ForceTouchGestureHandlerProps extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {
+    minForce?: number;
+    maxForce?: number;
+    feedbackOnActivation?: boolean;
+}
+export declare type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {
+    forceTouchAvailable: boolean;
+};
+export declare const ForceTouchGestureHandler: typeof ForceTouchFallback | React.ComponentClass<ForceTouchGestureHandlerProps & React.RefAttributes<any>, any> | React.FunctionComponent<ForceTouchGestureHandlerProps & React.RefAttributes<any>>;
+export declare type LongPressGestureHandlerEventPayload = {
+    x: number;
+    y: number;
+    absoluteX: number;
+    absoluteY: number;
+};
+export interface LongPressGestureHandlerProps extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {
+    minDurationMs?: number;
+    maxDist?: number;
+}
+export declare type LongPressGestureHandler = typeof LongPressGestureHandler;
+export declare const LongPressGestureHandler: React.ComponentType<LongPressGestureHandlerProps & React.RefAttributes<any>>;
+export declare type PanGestureHandlerEventPayload = {
+    x: number;
+    y: number;
+    absoluteX: number;
+    absoluteY: number;
+    translationX: number;
+    translationY: number;
+    velocityX: number;
+    velocityY: number;
+};
+export interface PanGestureHandlerProps extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {
+    /** @deprecated  use activeOffsetX*/
+    minDeltaX?: number;
+    /** @deprecated  use activeOffsetY*/
+    minDeltaY?: number;
+    /** @deprecated  use failOffsetX*/
+    maxDeltaX?: number;
+    /** @deprecated  use failOffsetY*/
+    maxDeltaY?: number;
+    /** @deprecated  use activeOffsetX*/
+    minOffsetX?: number;
+    /** @deprecated  use failOffsetY*/
+    minOffsetY?: number;
+    activeOffsetY?: number | number[];
+    activeOffsetX?: number | number[];
+    failOffsetY?: number | number[];
+    failOffsetX?: number | number[];
+    minDist?: number;
+    minVelocity?: number;
+    minVelocityX?: number;
+    minVelocityY?: number;
+    minPointers?: number;
+    maxPointers?: number;
+    avgTouches?: boolean;
+    enableTrackpadTwoFingerGesture?: boolean;
+}
+export declare type PanGestureHandler = typeof PanGestureHandler;
+export declare const PanGestureHandler: React.ComponentType<PanGestureHandlerProps & React.RefAttributes<any>>;
+export declare type PinchGestureHandlerEventPayload = {
+    scale: number;
+    focalX: number;
+    focalY: number;
+    velocity: number;
+};
+export interface PinchGestureHandlerProps extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {
+}
+export declare type PinchGestureHandler = typeof PinchGestureHandler;
+export declare const PinchGestureHandler: React.ComponentType<PinchGestureHandlerProps & React.RefAttributes<any>>;
+export declare type RotationGestureHandlerEventPayload = {
+    rotation: number;
+    anchorX: number;
+    anchorY: number;
+    velocity: number;
+};
+export interface RotationGestureHandlerProps extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {
+}
+export declare type RotationGestureHandler = typeof RotationGestureHandler;
+export declare const RotationGestureHandler: React.ComponentType<RotationGestureHandlerProps & React.RefAttributes<any>>;
+export {};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/index.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/index.d.ts
new file mode 100644
index 0000000..0d337d0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/index.d.ts
@@ -0,0 +1,17 @@
+export { Directions } from './Directions';
+export { State } from './State';
+export { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';
+export { default as GestureHandlerRootView } from './GestureHandlerRootView';
+export type { GestureEvent, HandlerStateChangeEvent, GestureEventPayload, HandlerStateChangeEventPayload, TapGestureHandlerEventPayload, ForceTouchGestureHandlerEventPayload, LongPressGestureHandlerEventPayload, PanGestureHandlerEventPayload, PinchGestureHandlerEventPayload, RotationGestureHandlerEventPayload, FlingGestureHandlerEventPayload, TapGestureHandlerProps, ForceTouchGestureHandlerProps, LongPressGestureHandlerProps, PanGestureHandlerProps, PinchGestureHandlerProps, RotationGestureHandlerProps, FlingGestureHandlerProps, } from './handlers/gestureHandlers';
+export { TapGestureHandler, ForceTouchGestureHandler, LongPressGestureHandler, PanGestureHandler, PinchGestureHandler, RotationGestureHandler, FlingGestureHandler, } from './handlers/gestureHandlers';
+export { default as createNativeWrapper } from './handlers/createNativeWrapper';
+export type { NativeViewGestureHandlerPayload, NativeViewGestureHandlerProps, } from './handlers/NativeViewGestureHandler';
+export { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';
+export type { RawButtonProps, BaseButtonProps, RectButtonProps, BorderlessButtonProps, } from './components/GestureButtons';
+export { RawButton, BaseButton, RectButton, BorderlessButton, } from './components/GestureButtons';
+export { TouchableHighlight, TouchableNativeFeedback, TouchableOpacity, TouchableWithoutFeedback, } from './components/touchables';
+export { ScrollView, Switch, TextInput, DrawerLayoutAndroid, FlatList, } from './components/GestureComponents';
+export type { GestureHandlerGestureEvent, GestureHandlerStateChangeEvent, GestureHandlerGestureEventNativeEvent, GestureHandlerStateChangeNativeEvent, NativeViewGestureHandlerGestureEvent, NativeViewGestureHandlerStateChangeEvent, TapGestureHandlerGestureEvent, TapGestureHandlerStateChangeEvent, ForceTouchGestureHandlerGestureEvent, ForceTouchGestureHandlerStateChangeEvent, LongPressGestureHandlerGestureEvent, LongPressGestureHandlerStateChangeEvent, PanGestureHandlerGestureEvent, PanGestureHandlerStateChangeEvent, PinchGestureHandlerGestureEvent, PinchGestureHandlerStateChangeEvent, RotationGestureHandlerGestureEvent, RotationGestureHandlerStateChangeEvent, FlingGestureHandlerGestureEvent, FlingGestureHandlerStateChangeEvent, NativeViewGestureHandlerProperties, TapGestureHandlerProperties, LongPressGestureHandlerProperties, PanGestureHandlerProperties, PinchGestureHandlerProperties, RotationGestureHandlerProperties, FlingGestureHandlerProperties, ForceTouchGestureHandlerProperties, RawButtonProperties, BaseButtonProperties, RectButtonProperties, BorderlessButtonProperties, } from './handlers/gestureHandlerTypesCompat';
+export { default as Swipeable } from './components/Swipeable';
+export type { DrawerLayoutProps, DrawerPosition, DrawerState, DrawerType, DrawerLockMode, DrawerKeyboardDismissMode, } from './components/DrawerLayout';
+export { default as DrawerLayout } from './components/DrawerLayout';
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/mocks.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/mocks.d.ts
new file mode 100644
index 0000000..8b1ef5c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/mocks.d.ts
@@ -0,0 +1,24 @@
+import { View, ScrollView as RNScrollView } from 'react-native';
+declare const _default: {
+    readonly ScrollView: typeof RNScrollView;
+    readonly PanGestureHandler: typeof View;
+    readonly attachGestureHandler: () => void;
+    readonly createGestureHandler: () => void;
+    readonly dropGestureHandler: () => void;
+    readonly updateGestureHandler: () => void;
+    readonly Directions: {
+        readonly RIGHT: 1;
+        readonly LEFT: 2;
+        readonly UP: 4;
+        readonly DOWN: 8;
+    };
+    readonly State: {
+        readonly UNDETERMINED: 0;
+        readonly FAILED: 1;
+        readonly BEGAN: 2;
+        readonly CANCELLED: 3;
+        readonly ACTIVE: 4;
+        readonly END: 5;
+    };
+};
+export default _default;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/typeUtils.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/typeUtils.d.ts
new file mode 100644
index 0000000..c00f6b9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/typeUtils.d.ts
@@ -0,0 +1 @@
+export declare type ValueOf<T> = T[keyof T];
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/DiscreteGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/DiscreteGestureHandler.d.ts
new file mode 100644
index 0000000..d00353e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/DiscreteGestureHandler.d.ts
@@ -0,0 +1,20 @@
+import GestureHandler from './GestureHandler';
+declare abstract class DiscreteGestureHandler extends GestureHandler {
+    get isDiscrete(): boolean;
+    get shouldEnableGestureOnSetup(): boolean;
+    shouldFailUnderCustomCriteria({ x, y, deltaX, deltaY }: any, { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any): boolean;
+    transformNativeEvent({ center: { x, y } }: any): {
+        absoluteX: any;
+        absoluteY: any;
+        x: number;
+        y: number;
+    };
+    isGestureEnabledForEvent({ minPointers, maxPointers, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside, }: any, _recognizer: any, { maxPointers: pointerLength, center, deltaX, deltaY }: any): {
+        failed: boolean;
+        success?: undefined;
+    } | {
+        success: boolean;
+        failed?: undefined;
+    };
+}
+export default DiscreteGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/DraggingGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/DraggingGestureHandler.d.ts
new file mode 100644
index 0000000..dd34937
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/DraggingGestureHandler.d.ts
@@ -0,0 +1,15 @@
+import GestureHandler, { HammerInputExt } from './GestureHandler';
+declare abstract class DraggingGestureHandler extends GestureHandler {
+    get shouldEnableGestureOnSetup(): boolean;
+    transformNativeEvent({ deltaX, deltaY, velocityX, velocityY, center: { x, y }, }: HammerInputExt): {
+        translationX: number;
+        translationY: number;
+        absoluteX: number;
+        absoluteY: number;
+        velocityX: number;
+        velocityY: number;
+        x: number;
+        y: number;
+    };
+}
+export default DraggingGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/Errors.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/Errors.d.ts
new file mode 100644
index 0000000..7ac1cfa
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/Errors.d.ts
@@ -0,0 +1,3 @@
+export declare class GesturePropError extends Error {
+    constructor(name: string, value: unknown, expectedType: string);
+}
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/FlingGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/FlingGestureHandler.d.ts
new file mode 100644
index 0000000..4817f07
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/FlingGestureHandler.d.ts
@@ -0,0 +1,43 @@
+/// <reference types="hammerjs" />
+import DraggingGestureHandler from './DraggingGestureHandler';
+import { HammerInputExt } from './GestureHandler';
+declare class FlingGestureHandler extends DraggingGestureHandler {
+    get name(): string;
+    get NativeGestureClass(): SwipeRecognizerStatic;
+    onGestureActivated(event: HammerInputExt): void;
+    onRawEvent(ev: HammerInputExt): void;
+    getHammerConfig(): {
+        pointers: any;
+        direction: number;
+    };
+    getTargetDirections(direction: number): number[];
+    getDirection(): number;
+    isGestureEnabledForEvent({ numberOfPointers }: any, _recognizer: any, { maxPointers: pointerLength }: any): {
+        failed: boolean;
+        success?: undefined;
+    } | {
+        success: boolean;
+        failed?: undefined;
+    };
+    updateGestureConfig({ numberOfPointers, direction, ...props }: any): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+}
+export default FlingGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/GestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/GestureHandler.d.ts
new file mode 100644
index 0000000..1549233
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/GestureHandler.d.ts
@@ -0,0 +1,140 @@
+/// <reference types="hammerjs" />
+import { findNodeHandle } from 'react-native';
+import { State } from '../State';
+import { EventMap } from './constants';
+export declare type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;
+export declare type Config = Partial<{
+    enabled: boolean;
+    minPointers: number;
+    maxPointers: number;
+    minDist: number;
+    minDistSq: number;
+    minVelocity: number;
+    minVelocitySq: number;
+    maxDist: number;
+    maxDistSq: number;
+    failOffsetXStart: number;
+    failOffsetYStart: number;
+    failOffsetXEnd: number;
+    failOffsetYEnd: number;
+    activeOffsetXStart: number;
+    activeOffsetXEnd: number;
+    activeOffsetYStart: number;
+    activeOffsetYEnd: number;
+    waitFor: any[] | null;
+}>;
+declare abstract class GestureHandler {
+    handlerTag: any;
+    isGestureRunning: boolean;
+    view: number | null;
+    protected hasCustomActivationCriteria: boolean;
+    protected hasGestureFailed: boolean;
+    protected hammer: HammerManager | null;
+    protected initialRotation: number | null;
+    protected __initialX: any;
+    protected __initialY: any;
+    protected config: Config;
+    protected previousState: State;
+    private pendingGestures;
+    private oldState;
+    private lastSentState;
+    private gestureInstance;
+    private _stillWaiting;
+    private propsRef;
+    private ref;
+    abstract get name(): string;
+    get id(): string;
+    get isDiscrete(): boolean;
+    get shouldEnableGestureOnSetup(): boolean;
+    constructor();
+    getConfig(): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+    onWaitingEnded(_gesture: this): void;
+    removePendingGesture(id: string): void;
+    addPendingGesture(gesture: this): void;
+    isGestureEnabledForEvent(_config: any, _recognizer: any, _event: any): {
+        failed?: boolean;
+        success?: boolean;
+    };
+    get NativeGestureClass(): RecognizerStatic;
+    updateHasCustomActivationCriteria(_config: Config): boolean;
+    clearSelfAsPending: () => void;
+    updateGestureConfig({ enabled, ...props }: {
+        [x: string]: any;
+        enabled?: boolean | undefined;
+    }): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+    destroy: () => void;
+    isPointInView: ({ x, y }: {
+        x: number;
+        y: number;
+    }) => boolean;
+    getState(type: keyof typeof EventMap): State;
+    transformEventData(event: HammerInputExt): {
+        nativeEvent: {
+            handlerTag: any;
+            target: any;
+            oldState: State;
+            numberOfPointers: number;
+            state: State;
+            pointerInside: boolean;
+        };
+        timeStamp: number;
+    };
+    transformNativeEvent(_event: HammerInputExt): {};
+    sendEvent: (nativeEvent: HammerInputExt) => void;
+    cancelPendingGestures(event: HammerInputExt): void;
+    notifyPendingGestures(): void;
+    onGestureEnded(event: HammerInputExt): void;
+    forceInvalidate(event: HammerInputExt): void;
+    cancelEvent(event: HammerInputExt): void;
+    onRawEvent({ isFirst }: HammerInputExt): void;
+    setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any): void;
+    setupEvents(): void;
+    onStart({ deltaX, deltaY, rotation }: HammerInputExt): void;
+    onGestureActivated(ev: HammerInputExt): void;
+    onSuccess(): void;
+    _getPendingGestures(): any[];
+    getHammerConfig(): {
+        pointers: number | undefined;
+    };
+    sync: () => void;
+    simulateCancelEvent(_inputData: any): void;
+}
+export default GestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/IndiscreteGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/IndiscreteGestureHandler.d.ts
new file mode 100644
index 0000000..065f149
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/IndiscreteGestureHandler.d.ts
@@ -0,0 +1,39 @@
+import GestureHandler from './GestureHandler';
+/**
+ * The base class for **Rotation** and **Pinch** gesture handlers.
+ */
+declare abstract class IndiscreteGestureHandler extends GestureHandler {
+    get shouldEnableGestureOnSetup(): boolean;
+    updateGestureConfig({ minPointers, maxPointers, ...props }: {
+        [x: string]: any;
+        minPointers?: number | undefined;
+        maxPointers?: number | undefined;
+    }): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+    isGestureEnabledForEvent({ minPointers, maxPointers }: any, _recognizer: any, { maxPointers: pointerLength }: any): {
+        failed: boolean;
+        success?: undefined;
+    } | {
+        success: boolean;
+        failed?: undefined;
+    };
+}
+export default IndiscreteGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/LongPressGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/LongPressGestureHandler.d.ts
new file mode 100644
index 0000000..a112ab6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/LongPressGestureHandler.d.ts
@@ -0,0 +1,37 @@
+import PressGestureHandler from './PressGestureHandler';
+import { Config } from './GestureHandler';
+import { HammerInputNames } from './constants';
+declare class LongPressGestureHandler extends PressGestureHandler {
+    get minDurationMs(): number;
+    get maxDist(): number | undefined;
+    updateHasCustomActivationCriteria({ maxDistSq }: Config): boolean;
+    getConfig(): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }> | {
+        shouldCancelWhenOutside: boolean;
+        maxDistSq: number;
+    };
+    getHammerConfig(): {
+        time: number;
+        pointers: number | undefined;
+    };
+    getState(type: keyof typeof HammerInputNames): 1 | 4 | 5;
+}
+export default LongPressGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/NativeViewGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/NativeViewGestureHandler.d.ts
new file mode 100644
index 0000000..ee6418a
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/NativeViewGestureHandler.d.ts
@@ -0,0 +1,6 @@
+import { HammerInputExt } from './GestureHandler';
+import PressGestureHandler from './PressGestureHandler';
+declare class NativeViewGestureHandler extends PressGestureHandler {
+    onRawEvent(ev: HammerInputExt): void;
+}
+export default NativeViewGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/NodeManager.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/NodeManager.d.ts
new file mode 100644
index 0000000..e25bb16
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/NodeManager.d.ts
@@ -0,0 +1,8 @@
+import { ValueOf } from '../typeUtils';
+import { Gestures } from '../RNGestureHandlerModule.web';
+export declare function getHandler(tag: number): import("./PanGestureHandler").default | import("./RotationGestureHandler").default | import("./PinchGestureHandler").default | import("./TapGestureHandler").default | import("./NativeViewGestureHandler").default | import("./LongPressGestureHandler").default | import("./FlingGestureHandler").default;
+export declare function createGestureHandler(handlerTag: number, handler: InstanceType<ValueOf<typeof Gestures>>): void;
+export declare function dropGestureHandler(handlerTag: number): void;
+export declare function getNodes(): {
+    [x: number]: import("./PanGestureHandler").default | import("./RotationGestureHandler").default | import("./PinchGestureHandler").default | import("./TapGestureHandler").default | import("./NativeViewGestureHandler").default | import("./LongPressGestureHandler").default | import("./FlingGestureHandler").default;
+};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/PanGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/PanGestureHandler.d.ts
new file mode 100644
index 0000000..4e64948
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/PanGestureHandler.d.ts
@@ -0,0 +1,56 @@
+/// <reference types="hammerjs" />
+import { EventMap } from './constants';
+import DraggingGestureHandler from './DraggingGestureHandler';
+import { State } from '../State';
+import { Config, HammerInputExt } from './GestureHandler';
+declare class PanGestureHandler extends DraggingGestureHandler {
+    get name(): string;
+    get NativeGestureClass(): PanRecognizerStatic;
+    getHammerConfig(): {
+        direction: number;
+        pointers: number | undefined;
+    };
+    getState(type: keyof typeof EventMap): State;
+    getDirection(): number;
+    getConfig(): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+    shouldFailUnderCustomCriteria({ deltaX, deltaY }: HammerInputExt, criteria: any): boolean;
+    shouldActivateUnderCustomCriteria({ deltaX, deltaY, velocity }: any, criteria: any): boolean;
+    shouldMultiFingerPanFail({ pointerLength, scale, deltaRotation, }: {
+        deltaRotation: number;
+        pointerLength: number;
+        scale: number;
+    }): boolean;
+    updateHasCustomActivationCriteria(criteria: Config & {
+        minVelocityX?: number;
+        minVelocityY?: number;
+    }): boolean;
+    isGestureEnabledForEvent(props: any, _recognizer: any, inputData: HammerInputExt & {
+        deltaRotation: number;
+    }): {
+        failed: boolean;
+        success?: undefined;
+    } | {
+        success: boolean;
+        failed?: undefined;
+    };
+}
+export default PanGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/PinchGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/PinchGestureHandler.d.ts
new file mode 100644
index 0000000..6e1f346
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/PinchGestureHandler.d.ts
@@ -0,0 +1,14 @@
+/// <reference types="hammerjs" />
+import { HammerInputExt } from './GestureHandler';
+import IndiscreteGestureHandler from './IndiscreteGestureHandler';
+declare class PinchGestureHandler extends IndiscreteGestureHandler {
+    get name(): string;
+    get NativeGestureClass(): PinchRecognizerStatic;
+    transformNativeEvent({ scale, velocity, center }: HammerInputExt): {
+        focalX: number;
+        focalY: number;
+        velocity: number;
+        scale: number;
+    };
+}
+export default PinchGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/PressGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/PressGestureHandler.d.ts
new file mode 100644
index 0000000..1ff6ef5
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/PressGestureHandler.d.ts
@@ -0,0 +1,82 @@
+/// <reference types="hammerjs" />
+import { State } from '../State';
+import { HammerInputNames } from './constants';
+import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { Config, HammerInputExt } from './GestureHandler';
+declare class PressGestureHandler extends DiscreteGestureHandler {
+    private visualFeedbackTimer;
+    private initialEvent;
+    get name(): string;
+    get minDurationMs(): any;
+    get maxDist(): number | undefined;
+    get NativeGestureClass(): PressRecognizerStatic;
+    shouldDelayTouches: boolean;
+    simulateCancelEvent(inputData: HammerInputExt): void;
+    updateHasCustomActivationCriteria({ shouldCancelWhenOutside, maxDistSq, }: Config & {
+        shouldCancelWhenOutside: boolean;
+    }): boolean;
+    getState(type: keyof typeof HammerInputNames): State;
+    getConfig(): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }> | {
+        shouldCancelWhenOutside: boolean;
+        maxDistSq: number;
+    };
+    getHammerConfig(): {
+        time: any;
+        pointers: number | undefined;
+    };
+    onGestureActivated(ev: HammerInputExt): void;
+    shouldDelayTouchForEvent({ pointerType }: HammerInputExt): boolean;
+    onGestureStart(ev: HammerInputExt): void;
+    sendGestureStartedEvent(ev: HammerInputExt): void;
+    forceInvalidate(event: HammerInputExt): void;
+    onRawEvent(ev: HammerInputExt): void;
+    updateGestureConfig({ shouldActivateOnStart, disallowInterruption, shouldCancelWhenOutside, minDurationMs, maxDist, minPointers, maxPointers, ...props }: {
+        [x: string]: any;
+        shouldActivateOnStart?: boolean | undefined;
+        disallowInterruption?: boolean | undefined;
+        shouldCancelWhenOutside?: boolean | undefined;
+        minDurationMs?: number | undefined;
+        maxDist?: number | undefined;
+        minPointers?: number | undefined;
+        maxPointers?: number | undefined;
+    }): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+}
+export default PressGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/RotationGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/RotationGestureHandler.d.ts
new file mode 100644
index 0000000..c114fb3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/RotationGestureHandler.d.ts
@@ -0,0 +1,14 @@
+/// <reference types="hammerjs" />
+import { HammerInputExt } from './GestureHandler';
+import IndiscreteGestureHandler from './IndiscreteGestureHandler';
+declare class RotationGestureHandler extends IndiscreteGestureHandler {
+    get name(): string;
+    get NativeGestureClass(): RotateRecognizerStatic;
+    transformNativeEvent({ rotation, velocity, center }: HammerInputExt): {
+        rotation: number;
+        anchorX: number;
+        anchorY: number;
+        velocity: number;
+    };
+}
+export default RotationGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/TapGestureHandler.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/TapGestureHandler.d.ts
new file mode 100644
index 0000000..9a8a3a7
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/TapGestureHandler.d.ts
@@ -0,0 +1,57 @@
+/// <reference types="hammerjs" />
+import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { HammerInputExt } from './GestureHandler';
+declare class TapGestureHandler extends DiscreteGestureHandler {
+    private _shouldFireEndEvent;
+    private _timer;
+    private _multiTapTimer;
+    get name(): string;
+    get NativeGestureClass(): TapRecognizerStatic;
+    get maxDelayMs(): any;
+    simulateCancelEvent(inputData: HammerInputExt): void;
+    onGestureActivated(ev: HammerInputExt): void;
+    onSuccessfulTap: (ev: HammerInputExt) => void;
+    onRawEvent(ev: HammerInput): void;
+    getHammerConfig(): {
+        event: string;
+        taps: any;
+        interval: any;
+        time: any;
+        pointers: number | undefined;
+    };
+    updateGestureConfig({ shouldCancelWhenOutside, maxDeltaX, maxDeltaY, numberOfTaps, minDurationMs, maxDelayMs, maxDurationMs, maxDist, minPointers, maxPointers, ...props }: {
+        [x: string]: any;
+        shouldCancelWhenOutside?: boolean | undefined;
+        maxDeltaX?: number | undefined;
+        maxDeltaY?: number | undefined;
+        numberOfTaps?: number | undefined;
+        minDurationMs?: number | undefined;
+        maxDelayMs?: number | undefined;
+        maxDurationMs?: number | undefined;
+        maxDist?: number | undefined;
+        minPointers?: number | undefined;
+        maxPointers?: number | undefined;
+    }): Partial<{
+        enabled: boolean;
+        minPointers: number;
+        maxPointers: number;
+        minDist: number;
+        minDistSq: number;
+        minVelocity: number;
+        minVelocitySq: number;
+        maxDist: number;
+        maxDistSq: number;
+        failOffsetXStart: number;
+        failOffsetYStart: number;
+        failOffsetXEnd: number;
+        failOffsetYEnd: number;
+        activeOffsetXStart: number;
+        activeOffsetXEnd: number;
+        activeOffsetYStart: number;
+        activeOffsetYEnd: number;
+        waitFor: any[] | null;
+    }>;
+    onGestureEnded(...props: any): void;
+    onWaitingEnded(_gesture: any): void;
+}
+export default TapGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/constants.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/constants.d.ts
new file mode 100644
index 0000000..01bf4f0
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/constants.d.ts
@@ -0,0 +1,40 @@
+import Hammer from '@egjs/hammerjs';
+export declare const CONTENT_TOUCHES_DELAY = 240;
+export declare const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;
+export declare const MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD = 0.1;
+export declare const MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD = 7;
+export declare const DEG_RAD: number;
+export declare const EventMap: {
+    readonly 1: 2;
+    readonly 2: 4;
+    readonly 4: 5;
+    readonly 8: 1;
+};
+export declare const Direction: {
+    RIGHT: number;
+    LEFT: number;
+    UP: number;
+    DOWN: number;
+};
+export declare const DirectionMap: {
+    4: number;
+    2: number;
+    8: number;
+    16: number;
+};
+export declare const HammerInputNames: {
+    1: string;
+    2: string;
+    4: string;
+    8: string;
+};
+export declare const HammerDirectionNames: {
+    6: string;
+    8: string;
+    16: string;
+    24: string;
+    1: string;
+    30: string;
+    4: string;
+    2: string;
+};
diff --git a/node_modules/react-native-gesture-handler/lib/typescript/web/utils.d.ts b/node_modules/react-native-gesture-handler/lib/typescript/web/utils.d.ts
new file mode 100644
index 0000000..4d502ca
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/lib/typescript/web/utils.d.ts
@@ -0,0 +1,9 @@
+export declare const isnan: (v: unknown) => boolean;
+export declare const isValidNumber: (v: unknown) => boolean;
+export declare const TEST_MIN_IF_NOT_NAN: (value: number, limit: number) => boolean;
+export declare const VEC_LEN_SQ: ({ x, y }?: {
+    x?: number | undefined;
+    y?: number | undefined;
+}) => number;
+export declare const TEST_MAX_IF_NOT_NAN: (value: number, max: number) => boolean;
+export declare function fireAfterInterval(method: () => void, interval?: number | boolean): number | null;
diff --git a/node_modules/react-native-gesture-handler/react-native-gesture-handler.d.ts b/node_modules/react-native-gesture-handler/react-native-gesture-handler.d.ts
deleted file mode 100644
index ddeab42..0000000
--- a/node_modules/react-native-gesture-handler/react-native-gesture-handler.d.ts
+++ /dev/null
@@ -1,481 +0,0 @@
-// Project: https://github.com/software-mansion/react-native-gesture-handler
-// TypeScript Version: 2.6.2
-
-declare module 'react-native-gesture-handler' {
-  import * as React from 'react';
-  import {
-    Animated,
-    FlatListProperties,
-    ScrollViewProperties,
-    SwitchProperties,
-    TextInputProperties,
-    DrawerLayoutAndroidProperties,
-    TouchableHighlightProperties,
-    TouchableOpacityProperties,
-    TouchableNativeFeedbackProperties,
-    TouchableWithoutFeedbackProperties,
-    Insets,
-    ViewStyle,
-    StyleProp,
-    ViewProps,
-  } from 'react-native';
-
-  /* GESTURE HANDLER STATE */
-
-  export const Directions: {
-    readonly RIGHT: 1
-    readonly LEFT: 2
-    readonly UP: 4
-    readonly DOWN: 8
-  }
-
-  export type Directions = typeof Directions[keyof typeof Directions]
-
-  export const State: {
-    readonly UNDETERMINED: 0
-    readonly FAILED: 1
-    readonly BEGAN: 2
-    readonly CANCELLED: 3
-    readonly ACTIVE: 4
-    readonly END: 5
-  }
-
-  export type State = typeof State[keyof typeof State]
-
-  /* STATE CHANGE EVENTS */
-
-  export interface GestureHandlerGestureEventNativeEvent {
-    handlerTag: number;
-    numberOfPointers: number;
-    state: State;
-  }
-
-  export interface GestureHandlerStateChangeNativeEvent {
-    handlerTag: number;
-    numberOfPointers: number;
-    state: State;
-    oldState: State;
-  }
-
-  export interface GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent;
-  }
-
-  export interface GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent;
-  }
-
-  interface NativeViewGestureHandlerEventExtra {
-    pointerInside: boolean;
-  }
-
-  export interface NativeViewGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      NativeViewGestureHandlerEventExtra;
-  }
-
-  export interface NativeViewGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      NativeViewGestureHandlerEventExtra;
-  }
-
-  interface TapGestureHandlerEventExtra {
-    x: number;
-    y: number;
-    absoluteX: number;
-    absoluteY: number;
-  }
-
-  interface ForceTouchGestureHandlerEventExtra {
-    x: number;
-    y: number;
-    absoluteX: number;
-    absoluteY: number;
-    force: number;
-  }
-
-  export interface TapGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      TapGestureHandlerEventExtra;
-  }
-
-  export interface TapGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      TapGestureHandlerEventExtra;
-  }
-
-  export interface ForceTouchGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      ForceTouchGestureHandlerEventExtra;
-  }
-
-  export interface LongPressGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      LongPressGestureHandlerEventExtra;
-  }
-
-  export interface ForceTouchGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      ForceTouchGestureHandlerEventExtra;
-  }
-
-  interface LongPressGestureHandlerEventExtra {
-    x: number;
-    y: number;
-    absoluteX: number;
-    absoluteY: number;
-  }
-
-  export interface LongPressGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      LongPressGestureHandlerEventExtra;
-  }
-
-  interface PanGestureHandlerEventExtra {
-    x: number;
-    y: number;
-    absoluteX: number;
-    absoluteY: number;
-    translationX: number;
-    translationY: number;
-    velocityX: number;
-    velocityY: number;
-  }
-
-  export interface PanGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      PanGestureHandlerEventExtra;
-  }
-
-  export interface PanGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      PanGestureHandlerEventExtra;
-  }
-
-  interface PinchGestureHandlerEventExtra {
-    scale: number;
-    focalX: number;
-    focalY: number;
-    velocity: number;
-  }
-
-  export interface PinchGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      PinchGestureHandlerEventExtra;
-  }
-
-  export interface PinchGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      PinchGestureHandlerEventExtra;
-  }
-
-  interface RotationGestureHandlerEventExtra {
-    rotation: number;
-    anchorX: number;
-    anchorY: number;
-    velocity: number;
-  }
-
-  export interface RotationGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      RotationGestureHandlerEventExtra;
-  }
-
-  export interface RotationGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent &
-      RotationGestureHandlerEventExtra;
-  }
-
-  export interface FlingGestureHandlerStateChangeEvent
-    extends GestureHandlerStateChangeEvent {
-    nativeEvent: GestureHandlerStateChangeNativeEvent &
-      FlingGestureHandlerEventExtra;
-  }
-
-  export interface FlingGestureHandlerGestureEvent
-    extends GestureHandlerGestureEvent {
-    nativeEvent: GestureHandlerGestureEventNativeEvent;
-  }
-
-  interface FlingGestureHandlerEventExtra {
-    x: number;
-    y: number;
-    absoluteX: number;
-    absoluteY: number;
-  }
-
-  /* GESTURE HANDLERS PROPERTIES */
-
-  export interface GestureHandlerProperties {
-    id?: string;
-    enabled?: boolean;
-    waitFor?: React.Ref<any> | React.Ref<any>[];
-    simultaneousHandlers?: React.Ref<any> | React.Ref<any>[];
-    shouldCancelWhenOutside?: boolean;
-    hitSlop?:
-      | number
-      | {
-          left?: number;
-          right?: number;
-          top?: number;
-          bottom?: number;
-          vertical?: number;
-          horizontal?: number;
-        }
-      | {
-          width: number;
-          left: number;
-        }
-      | {
-          width: number;
-          right: number;
-        }
-      | {
-          height: number;
-          top: number;
-        }
-      | {
-          height: number;
-          bottom: number;
-        };
-  }
-
-  export interface NativeViewGestureHandlerProperties
-    extends GestureHandlerProperties {
-    shouldActivateOnStart?: boolean;
-    disallowInterruption?: boolean;
-    onGestureEvent?: (event: NativeViewGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (
-      event: NativeViewGestureHandlerStateChangeEvent
-    ) => void;
-  }
-
-  export interface TapGestureHandlerProperties extends GestureHandlerProperties {
-    minPointers?: number;
-    maxDurationMs?: number;
-    maxDelayMs?: number;
-    numberOfTaps?: number;
-    maxDeltaX?: number;
-    maxDeltaY?: number;
-    maxDist?: number;
-    onGestureEvent?: (event: TapGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: TapGestureHandlerStateChangeEvent) => void;
-  }
-
-  export interface ForceTouchGestureHandlerProperties extends GestureHandlerProperties {
-    minForce?: number,
-    maxForce?: number,
-    feedbackOnActivation?: boolean,
-    onGestureEvent?: (event: ForceTouchGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: ForceTouchGestureHandlerStateChangeEvent) => void;
-  }
-
-  export interface LongPressGestureHandlerProperties
-    extends GestureHandlerProperties {
-    minDurationMs?: number;
-    maxDist?: number;
-    onGestureEvent?: (event: LongPressGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: LongPressGestureHandlerStateChangeEvent) => void;
-  }
-
-  export interface PanGestureHandlerProperties extends GestureHandlerProperties {
-    /** @deprecated  use activeOffsetX*/
-    minDeltaX?: number;
-    /** @deprecated  use activeOffsetY*/
-    minDeltaY?: number;
-    /** @deprecated  use failOffsetX*/
-    maxDeltaX?: number;
-    /** @deprecated  use failOffsetY*/
-    maxDeltaY?: number;
-    /** @deprecated  use activeOffsetX*/
-    minOffsetX?: number;
-    /** @deprecated  use failOffsetY*/
-    minOffsetY?: number;
-    activeOffsetY?: number | number[];
-    activeOffsetX?: number | number[];
-    failOffsetY?: number | number[];
-    failOffsetX?: number | number[];
-    minDist?: number;
-    minVelocity?: number;
-    minVelocityX?: number;
-    minVelocityY?: number;
-    minPointers?: number;
-    maxPointers?: number;
-    avgTouches?: boolean;
-    enableTrackpadTwoFingerGesture?: boolean;
-    onGestureEvent?: (event: PanGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: PanGestureHandlerStateChangeEvent) => void;
-  }
-
-  export interface PinchGestureHandlerProperties
-    extends GestureHandlerProperties {
-    onGestureEvent?: (event: PinchGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: PinchGestureHandlerStateChangeEvent) => void;
-  }
-
-  export interface RotationGestureHandlerProperties
-    extends GestureHandlerProperties {
-    onGestureEvent?: (event: RotationGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (
-      event: RotationGestureHandlerStateChangeEvent
-    ) => void;
-  }
-
-  export interface FlingGestureHandlerProperties
-    extends GestureHandlerProperties {
-    direction?: number;
-    numberOfPointers?: number;
-    onGestureEvent?: (event: FlingGestureHandlerGestureEvent) => void;
-    onHandlerStateChange?: (event: FlingGestureHandlerStateChangeEvent) => void;
-  }
-
-  /* GESTURE HANDLERS CLASSES */
-
-  export class NativeViewGestureHandler extends React.Component<
-    NativeViewGestureHandlerProperties
-  > {}
-
-  export class TapGestureHandler extends React.Component<
-    TapGestureHandlerProperties
-  > {}
-
-  export class LongPressGestureHandler extends React.Component<
-    LongPressGestureHandlerProperties
-  > {}
-
-  export class PanGestureHandler extends React.Component<
-    PanGestureHandlerProperties
-  > {}
-
-  export class PinchGestureHandler extends React.Component<
-    PinchGestureHandlerProperties
-  > {}
-
-  export class RotationGestureHandler extends React.Component<
-    RotationGestureHandlerProperties
-  > {}
-
-  export class FlingGestureHandler extends React.Component<
-    FlingGestureHandlerProperties
-  > {}
-
-  export class ForceTouchGestureHandler extends React.Component<
-    ForceTouchGestureHandlerProperties
-  > {}
-
-  /* BUTTONS PROPERTIES */
-
-  export interface RawButtonProperties
-    extends NativeViewGestureHandlerProperties {
-    exclusive?: boolean;
-    testID?: string;
-    accessibilityLabel?: string;
-  }
-
-  export interface BaseButtonProperties extends RawButtonProperties {
-    onPress?: (pointerInside: boolean) => void;
-    onActiveStateChange?: (active: boolean) => void;
-    style?: StyleProp<ViewStyle>;
-    rippleColor?: string;
-  }
-
-  export interface RectButtonProperties extends BaseButtonProperties {
-    underlayColor?: string;
-    activeOpacity?: number;
-  }
-
-  export interface BorderlessButtonProperties extends BaseButtonProperties {
-    borderless?: boolean;
-    activeOpacity?: number;
-  }
-
-  /* BUTTONS CLASSES */
-
-  export class RawButton extends React.Component<RawButtonProperties> {}
-
-  export class BaseButton extends React.Component<BaseButtonProperties> {}
-
-  export class RectButton extends React.Component<RectButtonProperties> {}
-
-  export class BorderlessButton extends React.Component<
-    BorderlessButtonProperties
-  > {}
-
-  export interface ContainedTouchableProperties {
-    containerStyle?: StyleProp<ViewStyle>
-  }
-
-  export class TouchableHighlight extends React.Component<
-    TouchableHighlightProperties | ContainedTouchableProperties
-    > {}
-
-  export class TouchableNativeFeedback extends React.Component<
-    TouchableNativeFeedbackProperties | ContainedTouchableProperties
-    > {}
-
-  export class TouchableOpacity extends React.Component<
-    TouchableOpacityProperties | ContainedTouchableProperties
-    > {}
-
-  export class TouchableWithoutFeedback extends React.Component<
-    TouchableWithoutFeedbackProperties | ContainedTouchableProperties
-    > {}
-
-  /* GESTURE HANDLER WRAPPED CLASSES */
-
-  export class ScrollView extends React.Component<
-    NativeViewGestureHandlerProperties & ScrollViewProperties
-  > {
-    scrollTo(y?: number | { x?: number; y?: number; animated?: boolean }, x?: number, animated?: boolean): void;
-    scrollToEnd(options?: { animated: boolean }): void;
-  }
-
-  export class Switch extends React.Component<
-    NativeViewGestureHandlerProperties & SwitchProperties
-  > {}
-
-  export class TextInput extends React.Component<
-    NativeViewGestureHandlerProperties & TextInputProperties
-  > {}
-
-  export class DrawerLayoutAndroid extends React.Component<
-    NativeViewGestureHandlerProperties & DrawerLayoutAndroidProperties
-  > {}
-
-  /* OTHER */
-
-  export class FlatList<ItemT> extends React.Component<
-    NativeViewGestureHandlerProperties & FlatListProperties<ItemT>
-  > {
-    scrollToEnd: (params?: { animated?: boolean }) => void;
-    scrollToIndex: (params: { animated?: boolean; index: number; viewOffset?: number; viewPosition?: number }) => void;
-    scrollToItem: (params: { animated?: boolean; item: ItemT; viewPosition?: number }) => void;
-    scrollToOffset: (params: { animated?: boolean; offset: number }) => void;
-  }
-
-  export const GestureHandlerRootView: React.ComponentType<ViewProps>;
-
-  export function gestureHandlerRootHOC<P = {}>(
-    Component: React.ComponentType<P>,
-    containerStyles?: StyleProp<ViewStyle>
-  ): React.ComponentType<P>;
-
-  export function createNativeWrapper<P = {}>(
-    Component: React.ComponentType<P>,
-    config: NativeViewGestureHandlerProperties
-  ): React.ComponentType<P>;
-}
diff --git a/node_modules/react-native-gesture-handler/src/Directions.ts b/node_modules/react-native-gesture-handler/src/Directions.ts
new file mode 100644
index 0000000..26631c6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/Directions.ts
@@ -0,0 +1,9 @@
+export const Directions = {
+  RIGHT: 1,
+  LEFT: 2,
+  UP: 4,
+  DOWN: 8,
+} as const;
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+export type Directions = typeof Directions[keyof typeof Directions];
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerRootView.android.js b/node_modules/react-native-gesture-handler/src/GestureHandlerRootView.android.tsx
similarity index 71%
rename from node_modules/react-native-gesture-handler/GestureHandlerRootView.android.js
rename to node_modules/react-native-gesture-handler/src/GestureHandlerRootView.android.tsx
index 656480d..706f01e 100644
--- a/node_modules/react-native-gesture-handler/GestureHandlerRootView.android.js
+++ b/node_modules/react-native-gesture-handler/src/GestureHandlerRootView.android.tsx
@@ -1,24 +1,19 @@
-import React from 'react';
-import { View, ViewPropTypes, requireNativeComponent } from 'react-native';
-
-const iface = {
-  name: 'GestureHandlerRootView',
-  propTypes: {
-    ...ViewPropTypes,
-  },
-};
+import * as React from 'react';
+import { PropsWithChildren } from 'react';
+import { View, requireNativeComponent } from 'react-native';
 
 const GestureHandlerRootViewNative = requireNativeComponent(
-  'GestureHandlerRootView',
-  iface
+  'GestureHandlerRootView'
 );
 
 const GestureHandlerRootViewContext = React.createContext(false);
 
-export default function GestureHandlerRootView({ children, ...rest }) {
+type Props = PropsWithChildren<Record<string, unknown>>;
+
+export default function GestureHandlerRootView({ children, ...rest }: Props) {
   return (
     <GestureHandlerRootViewContext.Consumer>
-      {available => {
+      {(available) => {
         if (available) {
           // If we already have a parent wrapped in the gesture handler root view,
           // We don't need to wrap it again in root view
@@ -27,7 +22,7 @@ export default function GestureHandlerRootView({ children, ...rest }) {
         }
 
         return (
-          <GestureHandlerRootViewContext.Provider value={true}>
+          <GestureHandlerRootViewContext.Provider value>
             <GestureHandlerRootViewNative {...rest}>
               {children}
             </GestureHandlerRootViewNative>
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerRootView.android.expo.js b/node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx
similarity index 68%
rename from node_modules/react-native-gesture-handler/GestureHandlerRootView.android.expo.js
rename to node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx
index 9380603..f20f299 100644
--- a/node_modules/react-native-gesture-handler/GestureHandlerRootView.android.expo.js
+++ b/node_modules/react-native-gesture-handler/src/GestureHandlerRootView.tsx
@@ -1,4 +1,3 @@
-import React from 'react';
 import { View } from 'react-native';
 
 export default View;
diff --git a/node_modules/react-native-gesture-handler/src/PlatformConstants.ts b/node_modules/react-native-gesture-handler/src/PlatformConstants.ts
new file mode 100644
index 0000000..cf7ad64
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/PlatformConstants.ts
@@ -0,0 +1,8 @@
+import { NativeModules, Platform } from 'react-native';
+
+type PlatformConstants = {
+  forceTouchAvailable: boolean;
+};
+
+export default (NativeModules?.PlatformConstants ??
+  Platform.constants) as PlatformConstants;
diff --git a/node_modules/react-native-gesture-handler/PlatformConstants.web.js b/node_modules/react-native-gesture-handler/src/PlatformConstants.web.ts
similarity index 100%
rename from node_modules/react-native-gesture-handler/PlatformConstants.web.js
rename to node_modules/react-native-gesture-handler/src/PlatformConstants.web.ts
diff --git a/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts b/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts
new file mode 100644
index 0000000..75897a9
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.ts
@@ -0,0 +1,31 @@
+import { NativeModules } from 'react-native';
+const { RNGestureHandlerModule } = NativeModules;
+
+if (RNGestureHandlerModule == null) {
+  console.error(
+    `react-native-gesture-handler module was not found. Make sure you're running your app on the native platform and your code is linked properly (cd ios && pod install && cd ..).
+
+    For installation instructions, please refer to https://docs.swmansion.com/react-native-gesture-handler/docs/#installation`
+      .split('\n')
+      .map((line) => line.trim())
+      .join('\n')
+  );
+}
+
+export type RNGestureHandlerModuleProps = {
+  handleSetJSResponder: (tag: number, blockNativeResponder: boolean) => void;
+  handleClearJSResponder: () => void;
+  createGestureHandler: (
+    handlerName: string,
+    handlerTag: number,
+    config: Readonly<Record<string, unknown>>
+  ) => void;
+  attachGestureHandler: (handlerTag: number, newView: number) => void;
+  updateGestureHandler: (
+    handlerTag: number,
+    newConfig: Readonly<Record<string, unknown>>
+  ) => void;
+  dropGestureHandler: (handlerTag: number) => void;
+};
+
+export default RNGestureHandlerModule as RNGestureHandlerModuleProps;
diff --git a/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.web.ts b/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.web.ts
new file mode 100644
index 0000000..5024d32
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/RNGestureHandlerModule.web.ts
@@ -0,0 +1,60 @@
+import { Direction } from './web/constants';
+import FlingGestureHandler from './web/FlingGestureHandler';
+import LongPressGestureHandler from './web/LongPressGestureHandler';
+import NativeViewGestureHandler from './web/NativeViewGestureHandler';
+import * as NodeManager from './web/NodeManager';
+import PanGestureHandler from './web/PanGestureHandler';
+import PinchGestureHandler from './web/PinchGestureHandler';
+import RotationGestureHandler from './web/RotationGestureHandler';
+import TapGestureHandler from './web/TapGestureHandler';
+
+export const Gestures = {
+  PanGestureHandler,
+  RotationGestureHandler,
+  PinchGestureHandler,
+  TapGestureHandler,
+  NativeViewGestureHandler,
+  LongPressGestureHandler,
+  FlingGestureHandler,
+  // ForceTouchGestureHandler,
+};
+
+export default {
+  Direction,
+  handleSetJSResponder(tag: number, blockNativeResponder: boolean) {
+    console.warn('handleSetJSResponder: ', tag, blockNativeResponder);
+  },
+  handleClearJSResponder() {
+    console.warn('handleClearJSResponder: ');
+  },
+  createGestureHandler<T>(
+    handlerName: keyof typeof Gestures,
+    handlerTag: number,
+    config: T
+  ) {
+    //TODO(TS) extends config
+    if (!(handlerName in Gestures))
+      throw new Error(
+        `react-native-gesture-handler: ${handlerName} is not supported on web.`
+      );
+    const GestureClass = Gestures[handlerName];
+    NodeManager.createGestureHandler(handlerTag, new GestureClass());
+    this.updateGestureHandler(handlerTag, config);
+  },
+  attachGestureHandler(
+    handlerTag: number,
+    newView: number,
+    propsRef: React.RefObject<unknown>
+  ) {
+    NodeManager.getHandler(handlerTag).setView(newView, propsRef);
+  },
+  updateGestureHandler(handlerTag: number, newConfig: any) {
+    NodeManager.getHandler(handlerTag).updateGestureConfig(newConfig);
+  },
+  getGestureHandlerNode(handlerTag: number) {
+    return NodeManager.getHandler(handlerTag);
+  },
+  dropGestureHandler(handlerTag: number) {
+    NodeManager.dropGestureHandler(handlerTag);
+  },
+};
diff --git a/node_modules/react-native-gesture-handler/src/State.ts b/node_modules/react-native-gesture-handler/src/State.ts
new file mode 100644
index 0000000..a68a62d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/State.ts
@@ -0,0 +1,13 @@
+// TODO use State from RNModule
+
+export const State = {
+  UNDETERMINED: 0,
+  FAILED: 1,
+  BEGAN: 2,
+  CANCELLED: 3,
+  ACTIVE: 4,
+  END: 5,
+} as const;
+
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; it can be used as a type and as a value
+export type State = typeof State[keyof typeof State];
diff --git a/node_modules/react-native-gesture-handler/DrawerLayout.js b/node_modules/react-native-gesture-handler/src/components/DrawerLayout.tsx
similarity index 59%
rename from node_modules/react-native-gesture-handler/DrawerLayout.js
rename to node_modules/react-native-gesture-handler/src/components/DrawerLayout.tsx
index 1ed0245..b95cec1 100644
--- a/node_modules/react-native-gesture-handler/DrawerLayout.js
+++ b/node_modules/react-native-gesture-handler/src/components/DrawerLayout.tsx
@@ -1,5 +1,3 @@
-// @flow
-
 // This component is based on RN's DrawerLayoutAndroid API
 //
 // It perhaps deserves to be put in a separate repo, but since it relies
@@ -8,7 +6,8 @@
 // to move faster and fix issues that may arise in gesture handler library
 // that could be found when using the drawer component
 
-import React, { Component } from 'react';
+import * as React from 'react';
+import { Component } from 'react';
 import invariant from 'invariant';
 import {
   Animated,
@@ -17,61 +16,84 @@ import {
   Keyboard,
   StatusBar,
   I18nManager,
+  StatusBarAnimation,
+  StyleProp,
+  ViewStyle,
+  LayoutChangeEvent,
+  NativeSyntheticEvent,
 } from 'react-native';
 
-import { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';
+import {
+  GestureEvent,
+  PanGestureHandler,
+  PanGestureHandlerEventPayload,
+  TapGestureHandler,
+  HandlerStateChangeEvent,
+  TapGestureHandlerEventPayload,
+} from '../handlers/gestureHandlers';
+import { State } from '../State';
 
 const DRAG_TOSS = 0.05;
 
-const IDLE = 'Idle';
-const DRAGGING = 'Dragging';
-const SETTLING = 'Settling';
-
-export type PropType = {
-  children: any,
-  drawerBackgroundColor?: string,
-  drawerPosition: 'left' | 'right',
-  drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open',
-  drawerWidth: number,
-  keyboardDismissMode?: 'none' | 'on-drag',
-  onDrawerClose?: Function,
-  onDrawerOpen?: Function,
-  onDrawerStateChanged?: Function,
-  renderNavigationView: (progressAnimatedValue: any) => any,
-  useNativeAnimations: boolean,
-
-  // brand new properties
-  drawerType: 'front' | 'back' | 'slide',
-  edgeWidth: number,
-  minSwipeDistance: number,
-  hideStatusBar?: boolean,
-  statusBarAnimation?: 'slide' | 'none' | 'fade',
-  overlayColor: string,
-  drawerContainerStyle?: any,
-  contentContainerStyle?: any,
-  onGestureRef?: Function,
-  enableTrackpadTwoFingerGesture?: boolean,
-
-  // Properties not yet supported
-  // onDrawerSlide?: Function
-};
-
-export type StateType = {
-  dragX: any,
-  touchX: any,
-  drawerTranslation: any,
-  containerWidth: number,
-};
+const IDLE: DrawerState = 'Idle';
+const DRAGGING: DrawerState = 'Dragging';
+const SETTLING: DrawerState = 'Settling';
+
+export type DrawerPosition = 'left' | 'right';
+
+export type DrawerState = 'Idle' | 'Dragging' | 'Settling';
+
+export type DrawerType = 'front' | 'back' | 'slide';
+
+export type DrawerLockMode = 'unlocked' | 'locked-closed' | 'locked-open';
+
+export type DrawerKeyboardDismissMode = 'none' | 'on-drag';
+
+export interface DrawerLayoutProps {
+  renderNavigationView: (
+    progressAnimatedValue: Animated.Value
+  ) => React.ReactNode;
+  drawerPosition?: DrawerPosition;
+  drawerWidth?: number;
+  drawerBackgroundColor?: string;
+  drawerLockMode?: DrawerLockMode;
+  keyboardDismissMode?: DrawerKeyboardDismissMode;
+  onDrawerClose?: () => void;
+  onDrawerOpen?: () => void;
+  onDrawerStateChanged?: (
+    newState: DrawerState,
+    drawerWillShow: boolean
+  ) => void;
+  useNativeAnimations?: boolean;
+
+  drawerType?: DrawerType;
+  edgeWidth?: number;
+  minSwipeDistance?: number;
+  hideStatusBar?: boolean;
+  statusBarAnimation?: StatusBarAnimation;
+  overlayColor?: string;
+  contentContainerStyle?: StyleProp<ViewStyle>;
+  drawerContainerStyle?: StyleProp<ViewStyle>;
+  enableTrackpadTwoFingerGesture?: boolean;
+  onDrawerSlide?: (position: number) => void;
+  onGestureRef?: (ref: PanGestureHandler) => void;
+}
 
-export type EventType = {
-  stopPropagation: Function,
+export type DrawerLayoutState = {
+  dragX: Animated.Value;
+  touchX: Animated.Value;
+  drawerTranslation: Animated.Value;
+  containerWidth: number;
 };
 
-export type DrawerMovementOptionType = {
-  velocity?: number,
+export type DrawerMovementOption = {
+  velocity?: number;
+  speed?: number;
 };
-
-export default class DrawerLayout extends Component<PropType, StateType> {
+export default class DrawerLayout extends Component<
+  DrawerLayoutProps,
+  DrawerLayoutState
+> {
   static defaultProps = {
     drawerWidth: 200,
     drawerPosition: 'left',
@@ -84,19 +106,8 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     enableTrackpadTwoFingerGesture: false,
   };
 
-  static positions = {
-    Left: 'left',
-    Right: 'right',
-  };
-  _openValue: ?Animated.Interpolation;
-  _onGestureEvent: ?Animated.Event;
-  _accessibilityIsModalView = React.createRef();
-  _pointerEventsView = React.createRef();
-  _panGestureHandler = React.createRef();
-  _drawerShown = false;
-
-  constructor(props: PropType, context: any) {
-    super(props, context);
+  constructor(props: DrawerLayoutProps) {
+    super(props);
 
     const dragX = new Animated.Value(0);
     const touchX = new Animated.Value(0);
@@ -109,21 +120,41 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       containerWidth: 0,
     };
 
-    this._updateAnimatedEvent(props, this.state);
+    this.updateAnimatedEvent(props, this.state);
   }
 
-  UNSAFE_componentWillUpdate(props: PropType, state: StateType) {
+  UNSAFE_componentWillUpdate(
+    props: DrawerLayoutProps,
+    state: DrawerLayoutState
+  ) {
     if (
       this.props.drawerPosition !== props.drawerPosition ||
       this.props.drawerWidth !== props.drawerWidth ||
       this.props.drawerType !== props.drawerType ||
       this.state.containerWidth !== state.containerWidth
     ) {
-      this._updateAnimatedEvent(props, state);
+      this.updateAnimatedEvent(props, state);
     }
   }
 
-  _updateAnimatedEvent = (props: PropType, state: StateType) => {
+  private openValue?: Animated.AnimatedInterpolation;
+  private onGestureEvent?: (
+    event: GestureEvent<PanGestureHandlerEventPayload>
+  ) => void;
+  private accessibilityIsModalView = React.createRef<View>();
+  private pointerEventsView = React.createRef<View>();
+  private panGestureHandler = React.createRef<PanGestureHandler | null>();
+  private drawerShown = false;
+
+  static positions = {
+    Left: 'left',
+    Right: 'right',
+  };
+
+  private updateAnimatedEvent = (
+    props: DrawerLayoutProps,
+    state: DrawerLayoutState
+  ) => {
     // Event definition is based on
     const { drawerPosition, drawerWidth, drawerType } = props;
     const {
@@ -144,11 +175,14 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       // touchX is calulcated by subtracing real touchX from the width of the
       // container (such that when touch happens at the right edge the value
       // is simply 0)
-      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);
+      dragX = Animated.multiply(
+        new Animated.Value(-1),
+        dragXValue
+      ) as Animated.Value; // TODO(TS): (for all "as" in this file) make sure we can map this
       touchX = Animated.add(
         new Animated.Value(containerWidth),
         Animated.multiply(new Animated.Value(-1), touchXValue)
-      );
+      ) as Animated.Value; // TODO(TS): make sure we can map this;
       touchXValue.setValue(containerWidth);
     } else {
       touchXValue.setValue(0);
@@ -186,40 +220,64 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       );
 
       const dragOffsetFromOnStartPosition = startPositionX.interpolate({
-        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],
+        inputRange: [drawerWidth! - 1, drawerWidth!, drawerWidth! + 1],
         outputRange: [0, 0, 1],
       });
-      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);
+      translationX = Animated.add(
+        dragX,
+        dragOffsetFromOnStartPosition
+      ) as Animated.Value; // TODO: as above
     }
 
-    this._openValue = Animated.add(translationX, drawerTranslation).interpolate(
-      {
-        inputRange: [0, drawerWidth],
-        outputRange: [0, 1],
-        extrapolate: 'clamp',
-      }
-    );
+    this.openValue = Animated.add(translationX, drawerTranslation).interpolate({
+      inputRange: [0, drawerWidth!],
+      outputRange: [0, 1],
+      extrapolate: 'clamp',
+    });
+
+    const gestureOptions: {
+      useNativeDriver: boolean;
+      // TODO: make sure it is correct
+      listener?: (
+        ev: NativeSyntheticEvent<PanGestureHandlerEventPayload>
+      ) => void;
+    } = {
+      useNativeDriver: props.useNativeAnimations!,
+    };
+
+    if (this.props.onDrawerSlide) {
+      gestureOptions.listener = (ev) => {
+        const translationX = Math.floor(Math.abs(ev.nativeEvent.translationX));
+        const position = translationX / this.state.containerWidth;
 
-    this._onGestureEvent = Animated.event(
+        this.props.onDrawerSlide?.(position);
+      };
+    }
+
+    this.onGestureEvent = Animated.event(
       [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],
-      { useNativeDriver: props.useNativeAnimations }
+      gestureOptions
     );
   };
 
-  _handleContainerLayout = ({ nativeEvent }) => {
+  private handleContainerLayout = ({ nativeEvent }: LayoutChangeEvent) => {
     this.setState({ containerWidth: nativeEvent.layout.width });
   };
 
-  _emitStateChanged = (newState: string, drawerWillShow: boolean) => {
-    this.props.onDrawerStateChanged &&
-      this.props.onDrawerStateChanged(newState, drawerWillShow);
+  private emitStateChanged = (
+    newState: DrawerState,
+    drawerWillShow: boolean
+  ) => {
+    this.props.onDrawerStateChanged?.(newState, drawerWillShow);
   };
 
-  _openingHandlerStateChange = ({ nativeEvent }) => {
+  private openingHandlerStateChange = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {
     if (nativeEvent.oldState === State.ACTIVE) {
-      this._handleRelease(nativeEvent);
+      this.handleRelease({ nativeEvent });
     } else if (nativeEvent.state === State.ACTIVE) {
-      this._emitStateChanged(DRAGGING, false);
+      this.emitStateChanged(DRAGGING, false);
       if (this.props.keyboardDismissMode === 'on-drag') {
         Keyboard.dismiss();
       }
@@ -229,9 +287,11 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     }
   };
 
-  _onTapHandlerStateChange = ({ nativeEvent }) => {
+  private onTapHandlerStateChange = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {
     if (
-      this._drawerShown &&
+      this.drawerShown &&
       nativeEvent.oldState === State.ACTIVE &&
       this.props.drawerLockMode !== 'locked-open'
     ) {
@@ -239,7 +299,9 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     }
   };
 
-  _handleRelease = nativeEvent => {
+  private handleRelease = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<PanGestureHandlerEventPayload>) => {
     const { drawerWidth, drawerPosition, drawerType } = this.props;
     const { containerWidth } = this.state;
     let { translationX: dragX, velocityX, x: touchX } = nativeEvent;
@@ -257,53 +319,56 @@ export default class DrawerLayout extends Component<PropType, StateType> {
 
     if (drawerType === 'front') {
       dragOffsetBasedOnStart =
-        gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;
+        gestureStartX > drawerWidth! ? gestureStartX - drawerWidth! : 0;
     }
 
     const startOffsetX =
-      dragX + dragOffsetBasedOnStart + (this._drawerShown ? drawerWidth : 0);
+      dragX + dragOffsetBasedOnStart + (this.drawerShown ? drawerWidth! : 0);
     const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;
 
-    const shouldOpen = projOffsetX > drawerWidth / 2;
+    const shouldOpen = projOffsetX > drawerWidth! / 2;
 
     if (shouldOpen) {
-      this._animateDrawer(startOffsetX, drawerWidth, velocityX);
+      this.animateDrawer(startOffsetX, drawerWidth!, velocityX);
     } else {
-      this._animateDrawer(startOffsetX, 0, velocityX);
+      this.animateDrawer(startOffsetX, 0, velocityX);
     }
   };
 
-  _updateShowing = (showing: boolean) => {
-    this._drawerShown = showing;
-    this._accessibilityIsModalView.current &&
-      this._accessibilityIsModalView.current.setNativeProps({
-        accessibilityViewIsModal: showing,
-      });
-    this._pointerEventsView.current &&
-      this._pointerEventsView.current.setNativeProps({
-        pointerEvents: showing ? 'auto' : 'none',
-      });
+  private updateShowing = (showing: boolean) => {
+    this.drawerShown = showing;
+    this.accessibilityIsModalView.current?.setNativeProps({
+      accessibilityViewIsModal: showing,
+    });
+    this.pointerEventsView.current?.setNativeProps({
+      pointerEvents: showing ? 'auto' : 'none',
+    });
     const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;
     const fromLeft = drawerPosition === 'left';
     // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise
     // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
     // orientation will be 1.
     const gestureOrientation =
-      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);
+      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);
     // When drawer is closed we want the hitSlop to be horizontally shorter
     // than the container size by the value of SLOP. This will make it only
     // activate when gesture happens not further than SLOP away from the edge
     const hitSlop = fromLeft
       ? { left: 0, width: showing ? undefined : edgeWidth }
       : { right: 0, width: showing ? undefined : edgeWidth };
-    this._panGestureHandler.current &&
-      this._panGestureHandler.current.setNativeProps({
-        hitSlop,
-        activeOffsetX: gestureOrientation * minSwipeDistance,
-      });
+    // @ts-ignore internal API, maybe could be fixed in handler types
+    this.panGestureHandler.current?.setNativeProps({
+      hitSlop,
+      activeOffsetX: gestureOrientation * minSwipeDistance!,
+    });
   };
 
-  _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {
+  private animateDrawer = (
+    fromValue: number | null | undefined,
+    toValue: number,
+    velocity: number,
+    speed?: number
+  ) => {
     this.state.dragX.setValue(0);
     this.state.touchX.setValue(
       this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth
@@ -326,8 +391,8 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     }
 
     const willShow = toValue !== 0;
-    this._updateShowing(willShow);
-    this._emitStateChanged(SETTLING, willShow);
+    this.updateShowing(willShow);
+    this.emitStateChanged(SETTLING, willShow);
     if (this.props.hideStatusBar) {
       StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');
     }
@@ -335,23 +400,25 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       velocity,
       bounciness: 0,
       toValue,
-      useNativeDriver: this.props.useNativeAnimations,
+      useNativeDriver: this.props.useNativeAnimations!,
+      speed: speed ?? undefined,
     }).start(({ finished }) => {
       if (finished) {
-        this._emitStateChanged(IDLE, willShow);
+        this.emitStateChanged(IDLE, willShow);
         if (willShow) {
-          this.props.onDrawerOpen && this.props.onDrawerOpen();
+          this.props.onDrawerOpen?.();
         } else {
-          this.props.onDrawerClose && this.props.onDrawerClose();
+          this.props.onDrawerClose?.();
         }
       }
     });
   };
 
-  openDrawer = (options: DrawerMovementOptionType = {}) => {
-    this._animateDrawer(
+  openDrawer = (options: DrawerMovementOption = {}) => {
+    this.animateDrawer(
+      // TODO: decide if it should be null or undefined is the proper value
       undefined,
-      this.props.drawerWidth,
+      this.props.drawerWidth!,
       options.velocity ? options.velocity : 0
     );
 
@@ -359,17 +426,18 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     this.forceUpdate();
   };
 
-  closeDrawer = (options: DrawerMovementOptionType = {}) => {
-    this._animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);
+  closeDrawer = (options: DrawerMovementOption = {}) => {
+    // TODO: decide if it should be null or undefined is the proper value
+    this.animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);
 
     // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable
     this.forceUpdate();
   };
 
-  _renderOverlay = () => {
+  private renderOverlay = () => {
     /* Overlay styles */
-    invariant(this._openValue, 'should be set');
-    const overlayOpacity = this._openValue.interpolate({
+    invariant(this.openValue, 'should be set');
+    const overlayOpacity = this.openValue.interpolate({
       inputRange: [0, 1],
       outputRange: [0, 1],
       extrapolate: 'clamp',
@@ -380,17 +448,17 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     };
 
     return (
-      <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>
+      <TapGestureHandler onHandlerStateChange={this.onTapHandlerStateChange}>
         <Animated.View
-          pointerEvents={this._drawerShown ? 'auto' : 'none'}
-          ref={this._pointerEventsView}
+          pointerEvents={this.drawerShown ? 'auto' : 'none'}
+          ref={this.pointerEventsView}
           style={[styles.overlay, dynamicOverlayStyles]}
         />
       </TapGestureHandler>
     );
   };
 
-  _renderDrawer = () => {
+  private renderDrawer = () => {
     const {
       drawerBackgroundColor,
       drawerWidth,
@@ -414,14 +482,14 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       backgroundColor: drawerBackgroundColor,
       width: drawerWidth,
     };
-    const openValue = this._openValue;
+    const openValue = this.openValue;
     invariant(openValue, 'should be set');
 
     let containerStyles;
     if (containerSlide) {
       const containerTranslateX = openValue.interpolate({
         inputRange: [0, 1],
-        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],
+        outputRange: fromLeft ? [0, drawerWidth!] : [0, -drawerWidth!],
         extrapolate: 'clamp',
       });
       containerStyles = {
@@ -429,22 +497,25 @@ export default class DrawerLayout extends Component<PropType, StateType> {
       };
     }
 
-    let drawerTranslateX = 0;
+    let drawerTranslateX: number | Animated.AnimatedInterpolation = 0;
     if (drawerSlide) {
-      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;
+      const closedDrawerOffset = fromLeft ? -drawerWidth! : drawerWidth!;
       drawerTranslateX = openValue.interpolate({
         inputRange: [0, 1],
         outputRange: [closedDrawerOffset, 0],
         extrapolate: 'clamp',
       });
     }
-    const drawerStyles = {
+    const drawerStyles: {
+      transform: { translateX: number | Animated.AnimatedInterpolation }[];
+      flexDirection: 'row-reverse' | 'row';
+    } = {
       transform: [{ translateX: drawerTranslateX }],
       flexDirection: reverseContentDirection ? 'row-reverse' : 'row',
     };
 
     return (
-      <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>
+      <Animated.View style={styles.main} onLayout={this.handleContainerLayout}>
         <Animated.View
           style={[
             drawerType === 'front'
@@ -454,29 +525,32 @@ export default class DrawerLayout extends Component<PropType, StateType> {
             contentContainerStyle,
           ]}
           importantForAccessibility={
-            this._drawerShown ? 'no-hide-descendants' : 'yes'
+            this.drawerShown ? 'no-hide-descendants' : 'yes'
           }>
           {typeof this.props.children === 'function'
-            ? this.props.children(this._openValue)
+            ? this.props.children(this.openValue)
             : this.props.children}
-          {this._renderOverlay()}
+          {this.renderOverlay()}
         </Animated.View>
         <Animated.View
           pointerEvents="box-none"
-          ref={this._accessibilityIsModalView}
-          accessibilityViewIsModal={this._drawerShown}
+          ref={this.accessibilityIsModalView}
+          accessibilityViewIsModal={this.drawerShown}
           style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>
           <View style={dynamicDrawerStyles}>
-            {this.props.renderNavigationView(this._openValue)}
+            {this.props.renderNavigationView(this.openValue as Animated.Value)}
           </View>
         </Animated.View>
       </Animated.View>
     );
   };
 
-  _setPanGestureRef = ref => {
-    this._panGestureHandler.current = ref;
-    this.props.onGestureRef && this.props.onGestureRef(ref);
+  private setPanGestureRef = (ref: PanGestureHandler) => {
+    // TODO(TS): make sure it is OK
+    // taken from https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065#issuecomment-596081842
+    (this
+      .panGestureHandler as React.MutableRefObject<PanGestureHandler>).current = ref;
+    this.props.onGestureRef?.(ref);
   };
 
   render() {
@@ -493,30 +567,31 @@ export default class DrawerLayout extends Component<PropType, StateType> {
     // e.g. when drawer is on the left and is closed we expect left to right gesture, thus
     // orientation will be 1.
     const gestureOrientation =
-      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);
+      (fromLeft ? 1 : -1) * (this.drawerShown ? -1 : 1);
 
     // When drawer is closed we want the hitSlop to be horizontally shorter
     // than the container size by the value of SLOP. This will make it only
     // activate when gesture happens not further than SLOP away from the edge
     const hitSlop = fromLeft
-      ? { left: 0, width: this._drawerShown ? undefined : edgeWidth }
-      : { right: 0, width: this._drawerShown ? undefined : edgeWidth };
+      ? { left: 0, width: this.drawerShown ? undefined : edgeWidth }
+      : { right: 0, width: this.drawerShown ? undefined : edgeWidth };
 
     return (
       <PanGestureHandler
-        ref={this._setPanGestureRef}
+        // @ts-ignore could be fixed in handler types
+        ref={this.setPanGestureRef}
         hitSlop={hitSlop}
-        activeOffsetX={gestureOrientation * minSwipeDistance}
+        activeOffsetX={gestureOrientation * minSwipeDistance!}
         failOffsetY={[-15, 15]}
-        onGestureEvent={this._onGestureEvent}
-        onHandlerStateChange={this._openingHandlerStateChange}
+        onGestureEvent={this.onGestureEvent}
+        onHandlerStateChange={this.openingHandlerStateChange}
         enableTrackpadTwoFingerGesture={
           this.props.enableTrackpadTwoFingerGesture
         }
         enabled={
           drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'
         }>
-        {this._renderDrawer()}
+        {this.renderDrawer()}
       </PanGestureHandler>
     );
   }
diff --git a/node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx b/node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx
new file mode 100644
index 0000000..9dc1439
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/GestureButtons.tsx
@@ -0,0 +1,214 @@
+import * as React from 'react';
+import {
+  Animated,
+  Platform,
+  processColor,
+  StyleSheet,
+  StyleProp,
+  ViewStyle,
+} from 'react-native';
+
+import createNativeWrapper from '../handlers/createNativeWrapper';
+import GestureHandlerButton from './GestureHandlerButton';
+import { State } from '../State';
+
+import {
+  GestureEvent,
+  HandlerStateChangeEvent,
+} from '../handlers/gestureHandlers';
+import {
+  NativeViewGestureHandlerPayload,
+  NativeViewGestureHandlerProps,
+} from '../handlers/NativeViewGestureHandler';
+
+export interface RawButtonProps extends NativeViewGestureHandlerProps {
+  exclusive?: boolean;
+  // TODO: we should transform props in `createNativeWrapper`
+  rippleColor?: any; // it was present in BaseButtonProps before but is used here in code
+}
+
+export interface BaseButtonProps extends RawButtonProps {
+  onPress?: (pointerInside: boolean) => void;
+  onActiveStateChange?: (active: boolean) => void;
+  style?: StyleProp<ViewStyle>;
+  testID?: string;
+}
+
+export interface RectButtonProps extends BaseButtonProps {
+  underlayColor?: string;
+  activeOpacity?: number;
+}
+
+export interface BorderlessButtonProps extends BaseButtonProps {
+  borderless?: boolean;
+  activeOpacity?: number;
+}
+
+export const RawButton = createNativeWrapper(GestureHandlerButton, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: false,
+});
+
+export class BaseButton extends React.Component<BaseButtonProps> {
+  private lastActive: boolean;
+
+  constructor(props: BaseButtonProps) {
+    super(props);
+    this.lastActive = false;
+  }
+
+  private handleEvent = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {
+    const { state, oldState, pointerInside } = nativeEvent;
+    const active = pointerInside && state === State.ACTIVE;
+
+    if (active !== this.lastActive && this.props.onActiveStateChange) {
+      this.props.onActiveStateChange(active);
+    }
+
+    if (
+      oldState === State.ACTIVE &&
+      state !== State.CANCELLED &&
+      this.lastActive &&
+      this.props.onPress
+    ) {
+      this.props.onPress(active);
+    }
+
+    this.lastActive = active;
+  };
+
+  // Normally, the parent would execute it's handler first,
+  // then forward the event to listeners. However, here our handler
+  // is virtually only forwarding events to listeners, so we reverse the order
+  // to keep the proper order of the callbacks (from "raw" ones to "processed").
+  private onHandlerStateChange = (
+    e: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>
+  ) => {
+    this.props.onHandlerStateChange?.(e);
+    this.handleEvent(e);
+  };
+
+  private onGestureEvent = (
+    e: GestureEvent<NativeViewGestureHandlerPayload>
+  ) => {
+    this.props.onGestureEvent?.(e);
+    this.handleEvent(
+      e as HandlerStateChangeEvent<NativeViewGestureHandlerPayload>
+    ); // TODO: maybe it is not correct
+  };
+
+  render() {
+    const { rippleColor, ...rest } = this.props;
+
+    return (
+      <RawButton
+        rippleColor={processColor(rippleColor)}
+        {...rest}
+        onGestureEvent={this.onGestureEvent}
+        onHandlerStateChange={this.onHandlerStateChange}
+      />
+    );
+  }
+}
+
+const AnimatedBaseButton = Animated.createAnimatedComponent(BaseButton);
+
+const btnStyles = StyleSheet.create({
+  underlay: {
+    position: 'absolute',
+    left: 0,
+    right: 0,
+    bottom: 0,
+    top: 0,
+  },
+});
+
+export class RectButton extends React.Component<RectButtonProps> {
+  static defaultProps = {
+    activeOpacity: 0.105,
+    underlayColor: 'black',
+  };
+
+  private opacity: Animated.Value;
+
+  constructor(props: RectButtonProps) {
+    super(props);
+    this.opacity = new Animated.Value(0);
+  }
+
+  private onActiveStateChange = (active: boolean) => {
+    if (Platform.OS !== 'android') {
+      this.opacity.setValue(active ? this.props.activeOpacity! : 0);
+    }
+
+    this.props.onActiveStateChange?.(active);
+  };
+
+  render() {
+    const { children, style, ...rest } = this.props;
+
+    const resolvedStyle = StyleSheet.flatten(style ?? {});
+
+    return (
+      <BaseButton
+        {...rest}
+        style={resolvedStyle}
+        onActiveStateChange={this.onActiveStateChange}>
+        <Animated.View
+          style={[
+            btnStyles.underlay,
+            {
+              opacity: this.opacity,
+              backgroundColor: this.props.underlayColor,
+              borderRadius: resolvedStyle.borderRadius,
+              borderTopLeftRadius: resolvedStyle.borderTopLeftRadius,
+              borderTopRightRadius: resolvedStyle.borderTopRightRadius,
+              borderBottomLeftRadius: resolvedStyle.borderBottomLeftRadius,
+              borderBottomRightRadius: resolvedStyle.borderBottomRightRadius,
+            },
+          ]}
+        />
+        {children}
+      </BaseButton>
+    );
+  }
+}
+
+export class BorderlessButton extends React.Component<BorderlessButtonProps> {
+  static defaultProps = {
+    activeOpacity: 0.3,
+    borderless: true,
+  };
+
+  private opacity: Animated.Value;
+
+  constructor(props: BorderlessButtonProps) {
+    super(props);
+    this.opacity = new Animated.Value(1);
+  }
+
+  private onActiveStateChange = (active: boolean) => {
+    if (Platform.OS !== 'android') {
+      this.opacity.setValue(active ? this.props.activeOpacity! : 1);
+    }
+
+    this.props.onActiveStateChange?.(active);
+  };
+
+  render() {
+    const { children, style, ...rest } = this.props;
+
+    return (
+      <AnimatedBaseButton
+        {...rest}
+        onActiveStateChange={this.onActiveStateChange}
+        style={[style, Platform.OS === 'ios' && { opacity: this.opacity }]}>
+        {children}
+      </AnimatedBaseButton>
+    );
+  }
+}
+
+export { default as PureNativeButton } from './GestureHandlerButton';
diff --git a/node_modules/react-native-gesture-handler/src/components/GestureComponents.tsx b/node_modules/react-native-gesture-handler/src/components/GestureComponents.tsx
new file mode 100644
index 0000000..61790b3
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/GestureComponents.tsx
@@ -0,0 +1,86 @@
+import * as React from 'react';
+import { PropsWithChildren } from 'react';
+import {
+  ScrollView as RNScrollView,
+  ScrollViewProps as RNScrollViewProps,
+  Switch as RNSwitch,
+  SwitchProps as RNSwitchProps,
+  TextInput as RNTextInput,
+  TextInputProps as RNTextInputProps,
+  DrawerLayoutAndroid as RNDrawerLayoutAndroid,
+  DrawerLayoutAndroidProps as RNDrawerLayoutAndroidProps,
+  FlatList as RNFlatList,
+  FlatListProps as RNFlatListProps,
+} from 'react-native';
+
+import createNativeWrapper from '../handlers/createNativeWrapper';
+
+import { NativeViewGestureHandlerProps } from '../handlers/NativeViewGestureHandler';
+
+export const ScrollView = createNativeWrapper<
+  PropsWithChildren<RNScrollViewProps>
+>(RNScrollView, {
+  disallowInterruption: true,
+  shouldCancelWhenOutside: false,
+});
+// backward type compatibility with https://github.com/software-mansion/react-native-gesture-handler/blob/db78d3ca7d48e8ba57482d3fe9b0a15aa79d9932/react-native-gesture-handler.d.ts#L440-L457
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export type ScrollView = typeof ScrollView & {
+  scrollTo(
+    y?: number | { x?: number; y?: number; animated?: boolean },
+    x?: number,
+    animated?: boolean
+  ): void;
+  scrollToEnd(options?: { animated: boolean }): void;
+};
+
+export const Switch = createNativeWrapper<RNSwitchProps>(RNSwitch, {
+  shouldCancelWhenOutside: false,
+  shouldActivateOnStart: true,
+  disallowInterruption: true,
+});
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export type Switch = typeof Switch;
+
+export const TextInput = createNativeWrapper<RNTextInputProps>(RNTextInput);
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export type TextInput = typeof TextInput;
+
+export const DrawerLayoutAndroid = createNativeWrapper<
+  PropsWithChildren<RNDrawerLayoutAndroidProps>
+>(RNDrawerLayoutAndroid, { disallowInterruption: true });
+// we use literal object since TS gives error when using RN's `positions`
+// @ts-ignore FIXME(TS) maybe this should be removed?
+DrawerLayoutAndroid.positions = { Left: 'left', Right: 'right' };
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export type DrawerLayoutAndroid = typeof DrawerLayoutAndroid;
+
+export const FlatList = React.forwardRef<RNFlatList<any>, RNFlatListProps<any>>(
+  (props, ref) => (
+    <RNFlatList
+      ref={ref}
+      {...props}
+      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}
+    />
+  )
+);
+// eslint-disable-next-line @typescript-eslint/no-redeclare
+export type FlatList<ItemT> = React.ComponentType<
+  RNFlatListProps<ItemT> &
+    NativeViewGestureHandlerProps &
+    React.RefAttributes<any>
+> & {
+  scrollToEnd: (params?: { animated?: boolean }) => void;
+  scrollToIndex: (params: {
+    animated?: boolean;
+    index: number;
+    viewOffset?: number;
+    viewPosition?: number;
+  }) => void;
+  scrollToItem: (params: {
+    animated?: boolean;
+    item: ItemT;
+    viewPosition?: number;
+  }) => void;
+  scrollToOffset: (params: { animated?: boolean; offset: number }) => void;
+};
diff --git a/node_modules/react-native-gesture-handler/GestureComponents.web.js b/node_modules/react-native-gesture-handler/src/components/GestureComponents.web.tsx
similarity index 61%
rename from node_modules/react-native-gesture-handler/GestureComponents.web.js
rename to node_modules/react-native-gesture-handler/src/components/GestureComponents.web.tsx
index e0c7455..a73004a 100644
--- a/node_modules/react-native-gesture-handler/GestureComponents.web.js
+++ b/node_modules/react-native-gesture-handler/src/components/GestureComponents.web.tsx
@@ -1,13 +1,14 @@
-import React from 'react';
+import * as React from 'react';
 import {
   DrawerLayoutAndroid as RNDrawerLayoutAndroid,
   FlatList as RNFlatList,
   Switch as RNSwitch,
   TextInput as RNTextInput,
   ScrollView as RNScrollView,
+  FlatListProps,
 } from 'react-native';
 
-import createNativeWrapper from './createNativeWrapper';
+import createNativeWrapper from '../handlers/createNativeWrapper';
 
 export const ScrollView = createNativeWrapper(RNScrollView, {
   disallowInterruption: true,
@@ -22,12 +23,15 @@ export const TextInput = createNativeWrapper(RNTextInput);
 export const DrawerLayoutAndroid = createNativeWrapper(RNDrawerLayoutAndroid, {
   disallowInterruption: true,
 });
+// @ts-ignore -- TODO(TS) to investigate if it's needed
 DrawerLayoutAndroid.positions = RNDrawerLayoutAndroid.positions;
 
-export const FlatList = React.forwardRef((props, ref) => (
-  <RNFlatList
-    ref={ref}
-    {...props}
-    renderScrollComponent={scrollProps => <ScrollView {...scrollProps} />}
-  />
-));
+export const FlatList = React.forwardRef(
+  <ItemT extends any>(props: FlatListProps<ItemT>, ref: any) => (
+    <RNFlatList
+      ref={ref}
+      {...props}
+      renderScrollComponent={(scrollProps) => <ScrollView {...scrollProps} />}
+    />
+  )
+);
diff --git a/node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.tsx b/node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.tsx
new file mode 100644
index 0000000..416f69e
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.tsx
@@ -0,0 +1,7 @@
+import { HostComponent, requireNativeComponent } from 'react-native';
+import { RawButtonProps } from './GestureButtons';
+const RNGestureHandlerButton: HostComponent<RawButtonProps> = requireNativeComponent(
+  'RNGestureHandlerButton'
+);
+
+export default RNGestureHandlerButton;
diff --git a/node_modules/react-native-gesture-handler/GestureHandlerButton.web.js b/node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.web.tsx
similarity index 53%
rename from node_modules/react-native-gesture-handler/GestureHandlerButton.web.js
rename to node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.web.tsx
index 4548788..4126c7c 100644
--- a/node_modules/react-native-gesture-handler/GestureHandlerButton.web.js
+++ b/node_modules/react-native-gesture-handler/src/components/GestureHandlerButton.web.tsx
@@ -1,6 +1,6 @@
-import React from 'react';
+import * as React from 'react';
 import { View } from 'react-native';
 
-export default React.forwardRef((props, ref) => (
+export default React.forwardRef<View>((props, ref) => (
   <View ref={ref} accessibilityRole="button" {...props} />
 ));
diff --git a/node_modules/react-native-gesture-handler/Swipeable.js b/node_modules/react-native-gesture-handler/src/components/Swipeable.tsx
similarity index 52%
rename from node_modules/react-native-gesture-handler/Swipeable.js
rename to node_modules/react-native-gesture-handler/src/components/Swipeable.tsx
index 69a569f..77c6084 100644
--- a/node_modules/react-native-gesture-handler/Swipeable.js
+++ b/node_modules/react-native-gesture-handler/src/components/Swipeable.tsx
@@ -1,68 +1,108 @@
-// @flow
-
 // Similarily to the DrawerLayout component this deserves to be put in a
 // separate repo. Although, keeping it here for the time being will allow us
 // to move faster and fix possible issues quicker
 
-import React, { Component } from 'react';
-import { Animated, StyleSheet, View, I18nManager } from 'react-native';
-
-import { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';
+import * as React from 'react';
+import { Component } from 'react';
+import {
+  Animated,
+  StyleSheet,
+  View,
+  I18nManager,
+  LayoutChangeEvent,
+  StyleProp,
+  ViewStyle,
+} from 'react-native';
+
+import {
+  PanGestureHandler,
+  TapGestureHandler,
+  PanGestureHandlerProps,
+  GestureEvent,
+  PanGestureHandlerEventPayload,
+  HandlerStateChangeEvent,
+  TapGestureHandlerEventPayload,
+} from '../handlers/gestureHandlers';
+import { State } from '../State';
 
 const DRAG_TOSS = 0.05;
 
-export type PropType = {
-  children: any,
-  friction: number,
-  leftThreshold?: number,
-  rightThreshold?: number,
-  overshootLeft?: boolean,
-  overshootRight?: boolean,
-  overshootFriction: number,
-  onSwipeableLeftOpen?: Function,
-  onSwipeableRightOpen?: Function,
-  onSwipeableOpen?: Function,
-  onSwipeableClose?: Function,
-  onSwipeableLeftWillOpen?: Function,
-  onSwipeableRightWillOpen?: Function,
-  onSwipeableWillOpen?: Function,
-  onSwipeableWillClose?: Function,
+type SwipeableExcludes = Exclude<
+  keyof PanGestureHandlerProps,
+  'onGestureEvent' | 'onHandlerStateChange'
+>;
+
+interface SwipeableProps
+  extends Pick<PanGestureHandlerProps, SwipeableExcludes> {
+  enableTrackpadTwoFingerGesture?: boolean;
+  friction?: number;
+  leftThreshold?: number;
+  rightThreshold?: number;
+  overshootLeft?: boolean;
+  overshootRight?: boolean;
+  overshootFriction?: number;
+  onSwipeableLeftOpen?: () => void;
+  onSwipeableRightOpen?: () => void;
+  onSwipeableOpen?: () => void;
+  onSwipeableClose?: () => void;
+  onSwipeableLeftWillOpen?: () => void;
+  onSwipeableRightWillOpen?: () => void;
+  onSwipeableWillOpen?: () => void;
+  onSwipeableWillClose?: () => void;
+  /**
+   *
+   * This map describes the values to use as inputRange for extra interpolation:
+   * AnimatedValue: [startValue, endValue]
+   *
+   * progressAnimatedValue: [0, 1]
+   * dragAnimatedValue: [0, +]
+   *
+   * To support `rtl` flexbox layouts use `flexDirection` styling.
+   * */
   renderLeftActions?: (
-    progressAnimatedValue: any,
-    dragAnimatedValue: any
-  ) => any,
+    progressAnimatedValue: Animated.AnimatedInterpolation,
+    dragAnimatedValue: Animated.AnimatedInterpolation
+  ) => React.ReactNode;
+  /**
+   *
+   * This map describes the values to use as inputRange for extra interpolation:
+   * AnimatedValue: [startValue, endValue]
+   *
+   * progressAnimatedValue: [0, 1]
+   * dragAnimatedValue: [0, -]
+   *
+   * To support `rtl` flexbox layouts use `flexDirection` styling.
+   * */
   renderRightActions?: (
-    progressAnimatedValue: any,
-    dragAnimatedValue: any
-  ) => any,
-  useNativeAnimations: boolean,
-  animationOptions?: Object,
-  containerStyle?: Object,
-  childrenContainerStyle?: Object,
-};
-type StateType = {
-  dragX: Animated.Value,
-  rowTranslation: Animated.Value,
-  rowState: number,
-  leftWidth: number | typeof undefined,
-  rightOffset: number | typeof undefined,
-  rowWidth: number | typeof undefined,
+    progressAnimatedValue: Animated.AnimatedInterpolation,
+    dragAnimatedValue: Animated.AnimatedInterpolation
+  ) => React.ReactNode;
+  useNativeAnimations?: boolean;
+  animationOptions?: Record<string, unknown>;
+  containerStyle?: StyleProp<ViewStyle>;
+  childrenContainerStyle?: StyleProp<ViewStyle>;
+}
+
+type SwipeableState = {
+  dragX: Animated.Value;
+  rowTranslation: Animated.Value;
+  rowState: number;
+  leftWidth?: number;
+  rightOffset?: number;
+  rowWidth?: number;
 };
 
-export default class Swipeable extends Component<PropType, StateType> {
+export default class Swipeable extends Component<
+  SwipeableProps,
+  SwipeableState
+> {
   static defaultProps = {
     friction: 1,
     overshootFriction: 1,
     useNativeAnimations: true,
   };
-  _onGestureEvent: ?Animated.Event;
-  _transX: ?Animated.Interpolation;
-  _showLeftAction: ?Animated.Interpolation | ?Animated.Value;
-  _leftActionTranslate: ?Animated.Interpolation;
-  _showRightAction: ?Animated.Interpolation | ?Animated.Value;
-  _rightActionTranslate: ?Animated.Interpolation;
-
-  constructor(props: PropType) {
+
+  constructor(props: SwipeableProps) {
     super(props);
     const dragX = new Animated.Value(0);
     this.state = {
@@ -73,15 +113,15 @@ export default class Swipeable extends Component<PropType, StateType> {
       rightOffset: undefined,
       rowWidth: undefined,
     };
-    this._updateAnimatedEvent(props, this.state);
+    this.updateAnimatedEvent(props, this.state);
 
-    this._onGestureEvent = Animated.event(
+    this.onGestureEvent = Animated.event(
       [{ nativeEvent: { translationX: dragX } }],
-      { useNativeDriver: props.useNativeAnimations }
+      { useNativeDriver: props.useNativeAnimations! }
     );
   }
 
-  UNSAFE_componentWillUpdate(props: PropType, state: StateType) {
+  UNSAFE_componentWillUpdate(props: SwipeableProps, state: SwipeableState) {
     if (
       this.props.friction !== props.friction ||
       this.props.overshootLeft !== props.overshootLeft ||
@@ -91,12 +131,24 @@ export default class Swipeable extends Component<PropType, StateType> {
       this.state.rightOffset !== state.rightOffset ||
       this.state.rowWidth !== state.rowWidth
     ) {
-      this._updateAnimatedEvent(props, state);
+      this.updateAnimatedEvent(props, state);
     }
   }
 
-  _updateAnimatedEvent = (props: PropType, state: StateType) => {
-    const { friction, overshootFriction, useNativeAnimations } = props;
+  private onGestureEvent?: (
+    event: GestureEvent<PanGestureHandlerEventPayload>
+  ) => void;
+  private transX?: Animated.AnimatedInterpolation;
+  private showLeftAction?: Animated.AnimatedInterpolation | Animated.Value;
+  private leftActionTranslate?: Animated.AnimatedInterpolation;
+  private showRightAction?: Animated.AnimatedInterpolation | Animated.Value;
+  private rightActionTranslate?: Animated.AnimatedInterpolation;
+
+  private updateAnimatedEvent = (
+    props: SwipeableProps,
+    state: SwipeableState
+  ) => {
+    const { friction, overshootFriction } = props;
     const { dragX, rowTranslation, leftWidth = 0, rowWidth = 0 } = state;
     const { rightOffset = rowWidth } = state;
     const rightWidth = Math.max(0, rowWidth - rightOffset);
@@ -109,64 +161,70 @@ export default class Swipeable extends Component<PropType, StateType> {
     const transX = Animated.add(
       rowTranslation,
       dragX.interpolate({
-        inputRange: [0, friction],
+        inputRange: [0, friction!],
         outputRange: [0, 1],
       })
     ).interpolate({
       inputRange: [
-        -rightWidth - (overshootRight ? 1 : overshootFriction),
+        -rightWidth - (overshootRight ? 1 : overshootFriction!),
         -rightWidth,
         leftWidth,
-        leftWidth + (overshootLeft ? 1 : overshootFriction),
+        leftWidth + (overshootLeft ? 1 : overshootFriction!),
       ],
       outputRange: [
-        -rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0),
+        -rightWidth - (overshootRight || overshootFriction! > 1 ? 1 : 0),
         -rightWidth,
         leftWidth,
-        leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0),
+        leftWidth + (overshootLeft || overshootFriction! > 1 ? 1 : 0),
       ],
     });
-    this._transX = transX;
-    this._showLeftAction =
+    this.transX = transX;
+    this.showLeftAction =
       leftWidth > 0
         ? transX.interpolate({
             inputRange: [-1, 0, leftWidth],
             outputRange: [0, 0, 1],
           })
         : new Animated.Value(0);
-    this._leftActionTranslate = this._showLeftAction.interpolate({
+    this.leftActionTranslate = this.showLeftAction.interpolate({
       inputRange: [0, Number.MIN_VALUE],
       outputRange: [-10000, 0],
       extrapolate: 'clamp',
     });
-    this._showRightAction =
+    this.showRightAction =
       rightWidth > 0
         ? transX.interpolate({
             inputRange: [-rightWidth, 0, 1],
             outputRange: [1, 0, 0],
           })
         : new Animated.Value(0);
-    this._rightActionTranslate = this._showRightAction.interpolate({
+    this.rightActionTranslate = this.showRightAction.interpolate({
       inputRange: [0, Number.MIN_VALUE],
       outputRange: [-10000, 0],
       extrapolate: 'clamp',
     });
   };
 
-  _onTapHandlerStateChange = ({ nativeEvent }) => {
+  private onTapHandlerStateChange = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<TapGestureHandlerEventPayload>) => {
     if (nativeEvent.oldState === State.ACTIVE) {
       this.close();
     }
   };
 
-  _onHandlerStateChange = ({ nativeEvent }) => {
-    if (nativeEvent.oldState === State.ACTIVE) {
-      this._handleRelease(nativeEvent);
+  private onHandlerStateChange = (
+    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>
+  ) => {
+    if (ev.nativeEvent.oldState === State.ACTIVE) {
+      this.handleRelease(ev);
     }
   };
 
-  _handleRelease = nativeEvent => {
-    const { velocityX, translationX: dragX } = nativeEvent;
+  private handleRelease = (
+    ev: HandlerStateChangeEvent<PanGestureHandlerEventPayload>
+  ) => {
+    const { velocityX, translationX: dragX } = ev.nativeEvent;
     const { leftWidth = 0, rowWidth = 0, rowState } = this.state;
     const { rightOffset = rowWidth } = this.state;
     const rightWidth = rowWidth - rightOffset;
@@ -176,8 +234,8 @@ export default class Swipeable extends Component<PropType, StateType> {
       rightThreshold = rightWidth / 2,
     } = this.props;
 
-    const startOffsetX = this._currentOffset() + dragX / friction;
-    const translationX = (dragX + DRAG_TOSS * velocityX) / friction;
+    const startOffsetX = this.currentOffset() + dragX / friction!;
+    const translationX = (dragX + DRAG_TOSS * velocityX) / friction!;
 
     let toValue = 0;
     if (rowState === 0) {
@@ -198,10 +256,19 @@ export default class Swipeable extends Component<PropType, StateType> {
       }
     }
 
-    this._animateRow(startOffsetX, toValue, velocityX / friction);
+    this.animateRow(startOffsetX, toValue, velocityX / friction!);
   };
 
-  _animateRow = (fromValue, toValue, velocityX) => {
+  private animateRow = (
+    fromValue: number,
+    toValue: number,
+    velocityX?:
+      | number
+      | {
+          x: number;
+          y: number;
+        }
+  ) => {
     const { dragX, rowTranslation } = this.state;
     dragX.setValue(0);
     rowTranslation.setValue(fromValue);
@@ -213,7 +280,7 @@ export default class Swipeable extends Component<PropType, StateType> {
       velocity: velocityX,
       bounciness: 0,
       toValue,
-      useNativeDriver: this.props.useNativeAnimations,
+      useNativeDriver: this.props.useNativeAnimations!,
       ...this.props.animationOptions,
     }).start(({ finished }) => {
       if (finished) {
@@ -224,9 +291,9 @@ export default class Swipeable extends Component<PropType, StateType> {
         }
 
         if (toValue === 0) {
-          this.props.onSwipeableClose && this.props.onSwipeableClose();
+          this.props.onSwipeableClose?.();
         } else {
-          this.props.onSwipeableOpen && this.props.onSwipeableOpen();
+          this.props.onSwipeableOpen?.();
         }
       }
     });
@@ -237,17 +304,17 @@ export default class Swipeable extends Component<PropType, StateType> {
     }
 
     if (toValue === 0) {
-      this.props.onSwipeableWillClose && this.props.onSwipeableWillClose();
+      this.props.onSwipeableWillClose?.();
     } else {
-      this.props.onSwipeableWillOpen && this.props.onSwipeableWillOpen();
+      this.props.onSwipeableWillOpen?.();
     }
   };
 
-  _onRowLayout = ({ nativeEvent }) => {
+  private onRowLayout = ({ nativeEvent }: LayoutChangeEvent) => {
     this.setState({ rowWidth: nativeEvent.layout.width });
   };
 
-  _currentOffset = () => {
+  private currentOffset = () => {
     const { leftWidth = 0, rowWidth = 0, rowState } = this.state;
     const { rightOffset = rowWidth } = this.state;
     const rightWidth = rowWidth - rightOffset;
@@ -260,19 +327,19 @@ export default class Swipeable extends Component<PropType, StateType> {
   };
 
   close = () => {
-    this._animateRow(this._currentOffset(), 0);
+    this.animateRow(this.currentOffset(), 0);
   };
 
   openLeft = () => {
     const { leftWidth = 0 } = this.state;
-    this._animateRow(this._currentOffset(), leftWidth);
+    this.animateRow(this.currentOffset(), leftWidth);
   };
 
   openRight = () => {
     const { rowWidth = 0 } = this.state;
     const { rightOffset = rowWidth } = this.state;
     const rightWidth = rowWidth - rightOffset;
-    this._animateRow(this._currentOffset(), -rightWidth);
+    this.animateRow(this.currentOffset(), -rightWidth);
   };
 
   render() {
@@ -283,9 +350,10 @@ export default class Swipeable extends Component<PropType, StateType> {
       <Animated.View
         style={[
           styles.leftActions,
-          { transform: [{ translateX: this._leftActionTranslate }] },
+          // all those and below parameters can have ! since they are all asigned in constructor in `updateAnimatedEvent` but TS cannot spot it for some reason
+          { transform: [{ translateX: this.leftActionTranslate! }] },
         ]}>
-        {renderLeftActions(this._showLeftAction, this._transX)}
+        {renderLeftActions(this.showLeftAction!, this.transX!)}
         <View
           onLayout={({ nativeEvent }) =>
             this.setState({ leftWidth: nativeEvent.layout.x })
@@ -298,9 +366,9 @@ export default class Swipeable extends Component<PropType, StateType> {
       <Animated.View
         style={[
           styles.rightActions,
-          { transform: [{ translateX: this._rightActionTranslate }] },
+          { transform: [{ translateX: this.rightActionTranslate! }] },
         ]}>
-        {renderRightActions(this._showRightAction, this._transX)}
+        {renderRightActions(this.showRightAction!, this.transX!)}
         <View
           onLayout={({ nativeEvent }) =>
             this.setState({ rightOffset: nativeEvent.layout.x })
@@ -313,21 +381,21 @@ export default class Swipeable extends Component<PropType, StateType> {
       <PanGestureHandler
         activeOffsetX={[-10, 10]}
         {...this.props}
-        onGestureEvent={this._onGestureEvent}
-        onHandlerStateChange={this._onHandlerStateChange}>
+        onGestureEvent={this.onGestureEvent}
+        onHandlerStateChange={this.onHandlerStateChange}>
         <Animated.View
-          onLayout={this._onRowLayout}
+          onLayout={this.onRowLayout}
           style={[styles.container, this.props.containerStyle]}>
           {left}
           {right}
           <TapGestureHandler
             enabled={rowState !== 0}
-            onHandlerStateChange={this._onTapHandlerStateChange}>
+            onHandlerStateChange={this.onTapHandlerStateChange}>
             <Animated.View
               pointerEvents={rowState === 0 ? 'auto' : 'box-only'}
               style={[
                 {
-                  transform: [{ translateX: this._transX }],
+                  transform: [{ translateX: this.transX! }],
                 },
                 this.props.childrenContainerStyle,
               ]}>
@@ -346,7 +414,7 @@ const styles = StyleSheet.create({
   },
   leftActions: {
     ...StyleSheet.absoluteFillObject,
-    flexDirection: I18nManager.isRTL? 'row-reverse': 'row',
+    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row',
   },
   rightActions: {
     ...StyleSheet.absoluteFillObject,
diff --git a/node_modules/react-native-gesture-handler/touchables/GenericTouchable.js b/node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx
similarity index 67%
rename from node_modules/react-native-gesture-handler/touchables/GenericTouchable.js
rename to node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx
index 7993e1c..2072586 100644
--- a/node_modules/react-native-gesture-handler/touchables/GenericTouchable.js
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/GenericTouchable.tsx
@@ -1,7 +1,22 @@
-import React, { Component } from 'react';
-import { Animated, Platform } from 'react-native';
-import { State, BaseButton } from '../GestureHandler';
-import PropTypes from 'prop-types';
+import * as React from 'react';
+import { Component } from 'react';
+import {
+  Animated,
+  Platform,
+  StyleProp,
+  ViewStyle,
+  TouchableWithoutFeedbackProps,
+} from 'react-native';
+
+import { State } from '../../State';
+import { BaseButton } from '../GestureButtons';
+
+import {
+  GestureEvent,
+  HandlerStateChangeEvent,
+} from '../../handlers/gestureHandlers';
+import { NativeViewGestureHandlerPayload } from '../../handlers/NativeViewGestureHandler';
+import { TouchableNativeFeedbackExtraProps } from './TouchableNativeFeedback.android';
 
 /**
  * Each touchable is a states' machine which preforms transitions.
@@ -14,57 +29,44 @@ export const TOUCHABLE_STATE = {
   UNDETERMINED: 0,
   BEGAN: 1,
   MOVED_OUTSIDE: 2,
-};
+} as const;
+
+type TouchableState = typeof TOUCHABLE_STATE[keyof typeof TOUCHABLE_STATE];
 
-const PublicPropTypes = {
+export interface GenericTouchableProps extends TouchableWithoutFeedbackProps {
   // Decided to drop not used fields from RN's implementation.
-  // e.g. onBlur and onFocus as well as deprecated props.
-  accessible: PropTypes.bool,
-  accessibilityLabel: PropTypes.node,
-  accessibilityHint: PropTypes.string,
-  hitSlop: PropTypes.shape({
-    top: PropTypes.number,
-    left: PropTypes.number,
-    bottom: PropTypes.number,
-    right: PropTypes.number,
-  }),
-  disabled: PropTypes.bool,
-  onPress: PropTypes.func,
-  onPressIn: PropTypes.func,
-  onPressOut: PropTypes.func,
-  onLayout: PropTypes.func,
-  onLongPress: PropTypes.func,
-  nativeID: PropTypes.string,
-  testID: PropTypes.string,
-  delayPressIn: PropTypes.number,
-  delayPressOut: PropTypes.number,
-  delayLongPress: PropTypes.number,
-  shouldActivateOnStart: PropTypes.bool,
-  disallowInterruption: PropTypes.bool,
-};
+  // e.g. onBlur and onFocus as well as deprecated props. - TODO: this comment may be unuseful in this moment
+
+  // TODO: in RN these events get native event parameter, which prolly could be used in our implementation too
+  onPress?: () => void;
+  onPressIn?: () => void;
+  onPressOut?: () => void;
+  onLongPress?: () => void;
+
+  nativeID?: string;
+  shouldActivateOnStart?: boolean;
+  disallowInterruption?: boolean;
+
+  containerStyle?: StyleProp<ViewStyle>;
+}
+
+interface InternalProps {
+  extraButtonProps: TouchableNativeFeedbackExtraProps;
+  onStateChange?: (oldState: TouchableState, newState: TouchableState) => void;
+}
 
-const InternalPropTypes = {
-  extraButtonProps: PropTypes.object,
-  onStateChange: PropTypes.func,
-};
+// TODO: maybe can be better
+// TODO: all clearTimeout have ! added, maybe they shouldn't ?
+type Timeout = ReturnType<typeof setTimeout> | null | undefined;
 
 /**
- * GenericTouchable is not intented to be used as it.
+ * GenericTouchable is not intented to be used as it is.
  * Should be treated as a source for the rest of touchables
  */
 
-export default class GenericTouchable extends Component {
-  static publicPropTypes = PublicPropTypes;
-  static internalPropTypes = InternalPropTypes;
-
-  // The prop type collections have to be outside of the class, as metro
-  // at this time does not compile `this.foo` correctly if HMR is enabled.
-  // https://github.com/software-mansion/react-native-gesture-handler/pull/406#issuecomment-453779977
-  static propTypes = {
-    ...InternalPropTypes,
-    ...PublicPropTypes,
-  };
-
+export default class GenericTouchable extends Component<
+  GenericTouchableProps & InternalProps
+> {
   static defaultProps = {
     delayLongPress: 600,
     extraButtonProps: {
@@ -73,9 +75,9 @@ export default class GenericTouchable extends Component {
   };
 
   // timeout handlers
-  pressInTimeout;
-  pressOutTimeout;
-  longPressTimeout;
+  pressInTimeout: Timeout;
+  pressOutTimeout: Timeout;
+  longPressTimeout: Timeout;
 
   // This flag is required since recognition of longPress implies not-invoking onPress
   longPressDetected = false;
@@ -83,7 +85,7 @@ export default class GenericTouchable extends Component {
   pointerInside = true;
 
   // State of touchable
-  STATE = TOUCHABLE_STATE.UNDETERMINED;
+  STATE: TouchableState = TOUCHABLE_STATE.UNDETERMINED;
 
   // handlePressIn in called on first touch on traveling inside component.
   // Handles state transition with delay.
@@ -119,7 +121,7 @@ export default class GenericTouchable extends Component {
 
   // handleGoToUndetermined transits to UNDETERMINED state with proper delay
   handleGoToUndetermined() {
-    clearTimeout(this.pressOutTimeout);
+    clearTimeout(this.pressOutTimeout!); // TODO: maybe it can be undefined
     if (this.props.delayPressOut) {
       this.pressOutTimeout = setTimeout(() => {
         if (this.STATE === TOUCHABLE_STATE.UNDETERMINED) {
@@ -143,41 +145,43 @@ export default class GenericTouchable extends Component {
   reset() {
     this.longPressDetected = false;
     this.pointerInside = true;
-    clearTimeout(this.pressInTimeout);
-    clearTimeout(this.pressOutTimeout);
-    clearTimeout(this.longPressTimeout);
+    clearTimeout(this.pressInTimeout!);
+    clearTimeout(this.pressOutTimeout!);
+    clearTimeout(this.longPressTimeout!);
     this.pressOutTimeout = null;
     this.longPressTimeout = null;
     this.pressInTimeout = null;
   }
 
   // All states' transitions are defined here.
-  moveToState(newState) {
+  moveToState(newState: TouchableState) {
     if (newState === this.STATE) {
       // Ignore dummy transitions
       return;
     }
     if (newState === TOUCHABLE_STATE.BEGAN) {
       // First touch and moving inside
-      this.props.onPressIn && this.props.onPressIn();
+      this.props.onPressIn?.();
     } else if (newState === TOUCHABLE_STATE.MOVED_OUTSIDE) {
       // Moving outside
-      this.props.onPressOut && this.props.onPressOut();
+      this.props.onPressOut?.();
     } else if (newState === TOUCHABLE_STATE.UNDETERMINED) {
       // Need to reset each time on transition to UNDETERMINED
       this.reset();
       if (this.STATE === TOUCHABLE_STATE.BEGAN) {
         // ... and if it happens inside button.
-        this.props.onPressOut && this.props.onPressOut();
+        this.props.onPressOut?.();
       }
     }
     // Finally call lister (used by subclasses)
-    this.props.onStateChange && this.props.onStateChange(this.STATE, newState);
+    this.props.onStateChange?.(this.STATE, newState);
     // ... and make transition.
     this.STATE = newState;
   }
 
-  onGestureEvent = ({ nativeEvent: { pointerInside } }) => {
+  onGestureEvent = ({
+    nativeEvent: { pointerInside },
+  }: GestureEvent<NativeViewGestureHandlerPayload>) => {
     if (this.pointerInside !== pointerInside) {
       if (pointerInside) {
         this.onMoveIn();
@@ -188,7 +192,9 @@ export default class GenericTouchable extends Component {
     this.pointerInside = pointerInside;
   };
 
-  onHandlerStateChange = ({ nativeEvent }) => {
+  onHandlerStateChange = ({
+    nativeEvent,
+  }: HandlerStateChangeEvent<NativeViewGestureHandlerPayload>) => {
     const { state } = nativeEvent;
     if (state === State.CANCELLED || state === State.FAILED) {
       // Need to handle case with external cancellation (e.g. by ScrollView)
@@ -210,14 +216,15 @@ export default class GenericTouchable extends Component {
       this.handleGoToUndetermined();
       if (shouldCallOnPress) {
         // Calls only inside component whether no long press was called previously
-        this.props.onPress && this.props.onPress();
+        this.props.onPress?.();
       }
     }
   };
 
   onLongPressDetected = () => {
     this.longPressDetected = true;
-    this.props.onLongPress();
+    // checked for in the caller of `onLongPressDetected`, but better to check twice
+    this.props.onLongPress?.();
   };
 
   componentWillUnmount() {
@@ -234,7 +241,7 @@ export default class GenericTouchable extends Component {
 
   onMoveOut() {
     // long press should no longer be detected
-    clearTimeout(this.longPressTimeout);
+    clearTimeout(this.longPressTimeout!);
     this.longPressTimeout = null;
     if (this.STATE === TOUCHABLE_STATE.BEGAN) {
       this.handleMoveOutside();
@@ -246,10 +253,10 @@ export default class GenericTouchable extends Component {
       accessible: this.props.accessible !== false,
       accessibilityLabel: this.props.accessibilityLabel,
       accessibilityHint: this.props.accessibilityHint,
-      accessibilityComponentType: this.props.accessibilityComponentType,
       accessibilityRole: this.props.accessibilityRole,
-      accessibilityStates: this.props.accessibilityStates,
-      accessibilityTraits: this.props.accessibilityTraits,
+      // TODO: check if changed to no 's' correctly, also removed 2 props that are no longer available: `accessibilityComponentType` and `accessibilityTraits`,
+      // would be good to check if it is ok for sure, see: https://github.com/facebook/react-native/issues/24016
+      accessibilityState: this.props.accessibilityState,
       nativeID: this.props.nativeID,
       onLayout: this.props.onLayout,
       hitSlop: this.props.hitSlop,
@@ -259,7 +266,8 @@ export default class GenericTouchable extends Component {
       <BaseButton
         style={this.props.containerStyle}
         onHandlerStateChange={
-          this.props.disabled ? null : this.onHandlerStateChange
+          // TODO: not sure if it can be undefined instead of null
+          this.props.disabled ? undefined : this.onHandlerStateChange
         }
         onGestureEvent={this.onGestureEvent}
         hitSlop={this.props.hitSlop}
diff --git a/node_modules/react-native-gesture-handler/touchables/TouchableHighlight.js b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableHighlight.tsx
similarity index 61%
rename from node_modules/react-native-gesture-handler/touchables/TouchableHighlight.js
rename to node_modules/react-native-gesture-handler/src/components/touchables/TouchableHighlight.tsx
index 68dc124..c3bacc1 100644
--- a/node_modules/react-native-gesture-handler/touchables/TouchableHighlight.js
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableHighlight.tsx
@@ -1,12 +1,33 @@
-import React, { Component } from 'react';
-import GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';
-import { StyleSheet, View } from 'react-native';
-import PropTypes from 'prop-types';
+import * as React from 'react';
+import { Component } from 'react';
+import GenericTouchable, {
+  GenericTouchableProps,
+  TOUCHABLE_STATE,
+} from './GenericTouchable';
+import {
+  StyleSheet,
+  View,
+  TouchableHighlightProps,
+  ColorValue,
+  ViewProps,
+} from 'react-native';
+
+interface State {
+  extraChildStyle: null | {
+    opacity?: number;
+  };
+  extraUnderlayStyle: null | {
+    backgroundColor?: ColorValue;
+  };
+}
 
 /**
  * TouchableHighlight follows RN's implementation
  */
-export default class TouchableHighlight extends Component {
+export default class TouchableHighlight extends Component<
+  TouchableHighlightProps & GenericTouchableProps,
+  State
+> {
   static defaultProps = {
     ...GenericTouchable.defaultProps,
     activeOpacity: 0.85,
@@ -14,16 +35,7 @@ export default class TouchableHighlight extends Component {
     underlayColor: 'black',
   };
 
-  static propTypes = {
-    ...GenericTouchable.publicPropTypes,
-    activeOpacity: PropTypes.number,
-    underlayColor: PropTypes.string,
-    style: PropTypes.any,
-    onShowUnderlay: PropTypes.func,
-    onHideUnderlay: PropTypes.func,
-  };
-
-  constructor(props) {
+  constructor(props: TouchableHighlightProps & GenericTouchableProps) {
     super(props);
     this.state = {
       extraChildStyle: null,
@@ -44,7 +56,7 @@ export default class TouchableHighlight extends Component {
         backgroundColor: this.props.underlayColor,
       },
     });
-    this.props.onShowUnderlay && this.props.onShowUnderlay();
+    this.props.onShowUnderlay?.();
   };
 
   hasPressHandler = () =>
@@ -58,7 +70,7 @@ export default class TouchableHighlight extends Component {
       extraChildStyle: null,
       extraUnderlayStyle: null,
     });
-    this.props.onHideUnderlay && this.props.onHideUnderlay();
+    this.props.onHideUnderlay?.();
   };
 
   renderChildren() {
@@ -66,16 +78,15 @@ export default class TouchableHighlight extends Component {
       return <View />;
     }
 
-    const child = React.Children.only(this.props.children);
+    const child = React.Children.only(
+      this.props.children
+    ) as React.ReactElement<ViewProps>; // TODO: not sure if OK but fixes error
     return React.cloneElement(child, {
-      style: StyleSheet.compose(
-        child.props.style,
-        this.state.extraChildStyle
-      ),
+      style: StyleSheet.compose(child.props.style, this.state.extraChildStyle),
     });
   }
 
-  onStateChange = (from, to) => {
+  onStateChange = (_from: number, to: number) => {
     if (to === TOUCHABLE_STATE.BEGAN) {
       this.showUnderlay();
     } else if (
diff --git a/node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.android.tsx b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.android.tsx
new file mode 100644
index 0000000..69b9209
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.android.tsx
@@ -0,0 +1,89 @@
+import {
+  Platform,
+  TouchableNativeFeedbackProps,
+  ColorValue,
+} from 'react-native';
+import * as React from 'react';
+import { Component } from 'react';
+import GenericTouchable, { GenericTouchableProps } from './GenericTouchable';
+
+export type TouchableNativeFeedbackExtraProps = {
+  borderless?: boolean;
+  rippleColor?: number | null;
+  rippleRadius?: number | null;
+  foreground?: boolean;
+};
+
+/**
+ * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.
+ * There's small difference with handling long press ripple since RN's implementation calls
+ * ripple animation via bridge. This solution leaves all animations' handling for native components so
+ * it follows native behaviours.
+ */
+export default class TouchableNativeFeedback extends Component<
+  TouchableNativeFeedbackProps & GenericTouchableProps
+> {
+  static defaultProps = {
+    ...GenericTouchable.defaultProps,
+    useForeground: true,
+    extraButtonProps: {
+      // Disable hiding ripple on Android
+      rippleColor: null,
+    },
+  };
+
+  // could be taken as RNTouchableNativeFeedback.SelectableBackground etc. but the API may change
+  static SelectableBackground = (rippleRadius?: number) => ({
+    type: 'ThemeAttrAndroid',
+    // I added `attribute` prop to clone the implementation of RN and be able to use only 2 types
+    attribute: 'selectableItemBackground',
+    rippleRadius,
+  });
+  static SelectableBackgroundBorderless = (rippleRadius?: number) => ({
+    type: 'ThemeAttrAndroid',
+    attribute: 'selectableItemBackgroundBorderless',
+    rippleRadius,
+  });
+  static Ripple = (
+    color: ColorValue,
+    borderless: boolean,
+    rippleRadius?: number
+  ) => ({
+    type: 'RippleAndroid',
+    color,
+    borderless,
+    rippleRadius,
+  });
+
+  static canUseNativeForeground = () => Platform.Version >= 23;
+
+  getExtraButtonProps() {
+    const extraProps: TouchableNativeFeedbackExtraProps = {};
+    const { background } = this.props;
+    if (background) {
+      // I changed type values to match those used in RN
+      // TODO(TS): check if it works the same as previous implementation - looks like it works the same as RN component, so it should be ok
+      if (background.type === 'RippleAndroid') {
+        extraProps['borderless'] = background.borderless;
+        extraProps['rippleColor'] = background.color;
+      } else if (background.type === 'ThemeAttrAndroid') {
+        extraProps['borderless'] =
+          background.attribute === 'selectableItemBackgroundBorderless';
+      }
+      // I moved it from above since it should be available in all options
+      extraProps['rippleRadius'] = background.rippleRadius;
+    }
+    extraProps['foreground'] = this.props.useForeground;
+    return extraProps;
+  }
+  render() {
+    const { style = {}, ...rest } = this.props;
+    return (
+      <GenericTouchable
+        {...rest}
+        style={style}
+        extraButtonProps={this.getExtraButtonProps()}
+      />
+    );
+  }
+}
diff --git a/node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.js b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.tsx
similarity index 100%
rename from node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.js
rename to node_modules/react-native-gesture-handler/src/components/touchables/TouchableNativeFeedback.tsx
diff --git a/node_modules/react-native-gesture-handler/touchables/TouchableOpacity.js b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableOpacity.tsx
similarity index 66%
rename from node_modules/react-native-gesture-handler/touchables/TouchableOpacity.js
rename to node_modules/react-native-gesture-handler/src/components/touchables/TouchableOpacity.tsx
index 61ce711..ee9230e 100644
--- a/node_modules/react-native-gesture-handler/touchables/TouchableOpacity.js
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableOpacity.tsx
@@ -1,23 +1,28 @@
-import { Animated, Easing, StyleSheet, View } from 'react-native';
-import GenericTouchable, { TOUCHABLE_STATE } from './GenericTouchable';
-import React, { Component } from 'react';
-import PropTypes from 'prop-types';
+import {
+  Animated,
+  Easing,
+  StyleSheet,
+  View,
+  TouchableOpacityProps,
+} from 'react-native';
+import GenericTouchable, {
+  TOUCHABLE_STATE,
+  GenericTouchableProps,
+} from './GenericTouchable';
+import * as React from 'react';
+import { Component } from 'react';
 
 /**
  * TouchableOpacity bases on timing animation which has been used in RN's core
  */
-export default class TouchableOpacity extends Component {
+export default class TouchableOpacity extends Component<
+  TouchableOpacityProps & GenericTouchableProps
+> {
   static defaultProps = {
     ...GenericTouchable.defaultProps,
     activeOpacity: 0.2,
   };
 
-  static propTypes = {
-    ...GenericTouchable.publicPropTypes,
-    style: PropTypes.any,
-    activeOpacity: PropTypes.number,
-  };
-
   // opacity is 1 one by default but could be overwritten
   getChildStyleOpacityWithDefault = () => {
     const childStyle = StyleSheet.flatten(this.props.style) || {};
@@ -26,7 +31,7 @@ export default class TouchableOpacity extends Component {
 
   opacity = new Animated.Value(this.getChildStyleOpacityWithDefault());
 
-  setOpacityTo = (value, duration) => {
+  setOpacityTo = (value: number, duration: number) => {
     Animated.timing(this.opacity, {
       toValue: value,
       duration: duration,
@@ -35,9 +40,9 @@ export default class TouchableOpacity extends Component {
     }).start();
   };
 
-  onStateChange = (from, to) => {
+  onStateChange = (_from: number, to: number) => {
     if (to === TOUCHABLE_STATE.BEGAN) {
-      this.setOpacityTo(this.props.activeOpacity, 0);
+      this.setOpacityTo(this.props.activeOpacity!, 0);
     } else if (
       to === TOUCHABLE_STATE.UNDETERMINED ||
       to === TOUCHABLE_STATE.MOVED_OUTSIDE
@@ -54,7 +59,7 @@ export default class TouchableOpacity extends Component {
         style={[
           style,
           {
-            opacity: this.opacity,
+            opacity: (this.opacity as unknown) as number, // TODO: fix this
           },
         ]}
         onStateChange={this.onStateChange}>
diff --git a/node_modules/react-native-gesture-handler/src/components/touchables/TouchableWithoutFeedback.tsx b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableWithoutFeedback.tsx
new file mode 100644
index 0000000..7ece5e6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/TouchableWithoutFeedback.tsx
@@ -0,0 +1,12 @@
+import * as React from 'react';
+import { PropsWithChildren } from 'react';
+import GenericTouchable, { GenericTouchableProps } from './GenericTouchable';
+
+const TouchableWithoutFeedback = React.forwardRef<
+  GenericTouchable,
+  PropsWithChildren<GenericTouchableProps>
+>((props, ref) => <GenericTouchable ref={ref} {...props} />);
+
+TouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;
+
+export default TouchableWithoutFeedback;
diff --git a/node_modules/react-native-gesture-handler/src/components/touchables/index.ts b/node_modules/react-native-gesture-handler/src/components/touchables/index.ts
new file mode 100644
index 0000000..fa9ae12
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/components/touchables/index.ts
@@ -0,0 +1,4 @@
+export { default as TouchableNativeFeedback } from './TouchableNativeFeedback';
+export { default as TouchableWithoutFeedback } from './TouchableWithoutFeedback';
+export { default as TouchableOpacity } from './TouchableOpacity';
+export { default as TouchableHighlight } from './TouchableHighlight';
diff --git a/node_modules/react-native-gesture-handler/gestureHandlerRootHOC.js b/node_modules/react-native-gesture-handler/src/gestureHandlerRootHOC.tsx
similarity index 52%
rename from node_modules/react-native-gesture-handler/gestureHandlerRootHOC.js
rename to node_modules/react-native-gesture-handler/src/gestureHandlerRootHOC.tsx
index 43d1b44..1df83e0 100644
--- a/node_modules/react-native-gesture-handler/gestureHandlerRootHOC.js
+++ b/node_modules/react-native-gesture-handler/src/gestureHandlerRootHOC.tsx
@@ -1,13 +1,13 @@
-import React from 'react';
-import { StyleSheet } from 'react-native';
+import * as React from 'react';
+import { StyleSheet, StyleProp, ViewStyle } from 'react-native';
 import hoistNonReactStatics from 'hoist-non-react-statics';
 import GestureHandlerRootView from './GestureHandlerRootView';
 
-export default function gestureHandlerRootHOC(
-  Component,
-  containerStyles = undefined
-) {
-  function Wrapper(props) {
+export default function gestureHandlerRootHOC<P>(
+  Component: React.ComponentType<P>,
+  containerStyles?: StyleProp<ViewStyle>
+): React.ComponentType<P> {
+  function Wrapper(props: P) {
     return (
       <GestureHandlerRootView style={[styles.container, containerStyles]}>
         <Component {...props} />
@@ -15,8 +15,9 @@ export default function gestureHandlerRootHOC(
     );
   }
 
-  Wrapper.displayName = `gestureHandlerRootHOC(${Component.displayName ||
-    Component.name})`;
+  Wrapper.displayName = `gestureHandlerRootHOC(${
+    Component.displayName || Component.name
+  })`;
 
   hoistNonReactStatics(Wrapper, Component);
 
diff --git a/node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts b/node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts
new file mode 100644
index 0000000..5fd1f2b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/handlers/NativeViewGestureHandler.ts
@@ -0,0 +1,29 @@
+import createHandler from './createHandler';
+import { BaseGestureHandlerProps, baseProps } from './gestureHandlers';
+
+export interface NativeViewGestureHandlerProps
+  extends BaseGestureHandlerProps<NativeViewGestureHandlerPayload> {
+  shouldActivateOnStart?: boolean;
+  disallowInterruption?: boolean;
+}
+
+export type NativeViewGestureHandlerPayload = {
+  pointerInside: boolean;
+};
+
+export const nativeViewProps = [
+  ...baseProps,
+  'shouldActivateOnStart',
+  'disallowInterruption',
+] as const;
+
+export type NativeViewGestureHandler = typeof NativeViewGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of gestureHandlers.ts file
+export const NativeViewGestureHandler = createHandler<
+  NativeViewGestureHandlerProps,
+  NativeViewGestureHandlerPayload
+>({
+  name: 'NativeViewGestureHandler',
+  allowedProps: nativeViewProps,
+  config: {},
+});
diff --git a/node_modules/react-native-gesture-handler/src/handlers/createHandler.ts b/node_modules/react-native-gesture-handler/src/handlers/createHandler.ts
new file mode 100644
index 0000000..38b32ea
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/handlers/createHandler.ts
@@ -0,0 +1,455 @@
+import * as React from 'react';
+import {
+  findNodeHandle as findNodeHandleRN,
+  NativeModules,
+  Platform,
+  Touchable,
+} from 'react-native';
+// @ts-ignore - it isn't typed by TS & don't have definitelyTyped types
+import deepEqual from 'fbjs/lib/areEqual';
+import RNGestureHandlerModule from '../RNGestureHandlerModule';
+import type RNGestureHandlerModuleWeb from '../RNGestureHandlerModule.web';
+import { State } from '../State';
+
+import {
+  BaseGestureHandlerProps,
+  GestureEvent,
+  HandlerStateChangeEvent,
+} from './gestureHandlers';
+import { ValueOf } from '../typeUtils';
+
+function findNodeHandle(
+  node: null | number | React.Component<any, any> | React.ComponentClass<any>
+): null | number | React.Component<any, any> | React.ComponentClass<any> {
+  if (Platform.OS === 'web') return node;
+  return findNodeHandleRN(node);
+}
+
+const { UIManager = {} } = NativeModules;
+
+const customGHEventsConfig = {
+  onGestureHandlerEvent: { registrationName: 'onGestureHandlerEvent' },
+  onGestureHandlerStateChange: {
+    registrationName: 'onGestureHandlerStateChange',
+  },
+};
+
+// Add gesture specific events to genericDirectEventTypes object exported from UIManager
+// native module.
+// Once new event types are registered with react it is possible to dispatch these
+// events to all kind of native views.
+UIManager.genericDirectEventTypes = {
+  ...UIManager.genericDirectEventTypes,
+  ...customGHEventsConfig,
+};
+// In newer versions of RN the `genericDirectEventTypes` is located in the object
+// returned by UIManager.getViewManagerConfig('getConstants') or in older RN UIManager.getConstants(), we need to add it there as well to make
+// it compatible with RN 61+
+const UIManagerConstants =
+  UIManager.getViewManagerConfig?.('getConstants') ??
+  UIManager.getConstants?.();
+
+if (UIManagerConstants) {
+  UIManagerConstants.genericDirectEventTypes = {
+    ...UIManagerConstants.genericDirectEventTypes,
+    ...customGHEventsConfig,
+  };
+}
+
+// Wrap JS responder calls and notify gesture handler manager
+const {
+  setJSResponder: oldSetJSResponder = () => {
+    //no operation
+  },
+  clearJSResponder: oldClearJSResponder = () => {
+    //no operation
+  },
+} = UIManager;
+UIManager.setJSResponder = (tag: number, blockNativeResponder: boolean) => {
+  RNGestureHandlerModule.handleSetJSResponder(tag, blockNativeResponder);
+  oldSetJSResponder(tag, blockNativeResponder);
+};
+UIManager.clearJSResponder = () => {
+  RNGestureHandlerModule.handleClearJSResponder();
+  oldClearJSResponder();
+};
+
+let handlerTag = 1;
+const handlerIDToTag: Record<string, number> = {};
+
+function isConfigParam(param: unknown, name: string) {
+  // param !== Object(param) returns false if `param` is a function
+  // or an object and returns true if `param` is null
+  return (
+    param !== undefined &&
+    (param !== Object(param) ||
+      !('__isNative' in (param as Record<string, unknown>))) &&
+    name !== 'onHandlerStateChange' &&
+    name !== 'onGestureEvent'
+  );
+}
+
+function filterConfig(
+  props: Record<string, unknown>,
+  validProps: string[],
+  defaults: Record<string, unknown> = {}
+) {
+  const res = { ...defaults };
+  validProps.forEach((key) => {
+    const value = props[key];
+    if (isConfigParam(value, key)) {
+      let value = props[key];
+      if (key === 'simultaneousHandlers' || key === 'waitFor') {
+        value = transformIntoHandlerTags(props[key]);
+      } else if (key === 'hitSlop') {
+        if (typeof value !== 'object') {
+          value = { top: value, left: value, bottom: value, right: value };
+        }
+      }
+      res[key] = value;
+    }
+  });
+  return res;
+}
+
+function transformIntoHandlerTags(handlerIDs: any) {
+  if (!Array.isArray(handlerIDs)) {
+    handlerIDs = [handlerIDs];
+  }
+
+  if (Platform.OS === 'web') {
+    return handlerIDs
+      .map(({ current }: { current: any }) => current)
+      .filter((handle: any) => handle);
+  }
+  // converts handler string IDs into their numeric tags
+  return handlerIDs
+    .map(
+      (handlerID: any) =>
+        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1
+    )
+    .filter((handlerTag: number) => handlerTag > 0);
+}
+
+type HandlerProps<T extends Record<string, unknown>> = Readonly<
+  React.PropsWithChildren<BaseGestureHandlerProps<T>>
+>;
+function hasUnresolvedRefs<T extends Record<string, unknown>>(
+  props: HandlerProps<T>
+) {
+  // TODO(TS) - add type for extract arg
+  const extract = (refs: any | any[]) => {
+    if (!Array.isArray(refs)) {
+      return refs && refs.current === null;
+    }
+    return refs.some((r) => r && r.current === null);
+  };
+  return extract(props['simultaneousHandlers']) || extract(props['waitFor']);
+}
+
+const stateToPropMappings = {
+  [State.UNDETERMINED]: undefined,
+  [State.BEGAN]: 'onBegan',
+  [State.FAILED]: 'onFailed',
+  [State.CANCELLED]: 'onCancelled',
+  [State.ACTIVE]: 'onActivated',
+  [State.END]: 'onEnded',
+} as const;
+
+type CreateHandlerArgs<
+  HandlerPropsT extends Record<string, unknown>
+> = Readonly<{
+  name: string;
+  allowedProps: Readonly<Extract<keyof HandlerPropsT, string>[]>;
+  config: Readonly<Record<string, unknown>>;
+  transformProps?: (props: HandlerPropsT) => HandlerPropsT;
+  customNativeProps?: Readonly<string[]>;
+}>;
+
+// TODO(TS) fix event types
+type InternalEventHandlers = {
+  onGestureHandlerEvent?: (event: any) => void;
+  onGestureHandlerStateChange?: (event: any) => void;
+};
+
+// TODO(TS) - make sure that BaseGestureHandlerProps doesn't need other generic parameter to work with custom properties.
+export default function createHandler<
+  T extends BaseGestureHandlerProps<U>,
+  U extends Record<string, unknown>
+>({
+  name,
+  allowedProps = [],
+  config = {},
+  transformProps,
+  customNativeProps = [],
+}: CreateHandlerArgs<T>): React.ComponentType<T & React.RefAttributes<any>> {
+  class Handler extends React.Component<T & InternalEventHandlers> {
+    static displayName = name;
+
+    private handlerTag: number;
+    private config: Record<string, unknown>;
+    private propsRef: React.MutableRefObject<unknown>;
+    private viewNode: any;
+    private viewTag?: number;
+    private updateEnqueued: ReturnType<typeof setImmediate> | null = null;
+
+    constructor(props: T & InternalEventHandlers) {
+      super(props);
+      this.handlerTag = handlerTag++;
+      this.config = {};
+      this.propsRef = React.createRef();
+      if (props.id) {
+        if (handlerIDToTag[props.id] !== undefined) {
+          throw new Error(`Handler with ID "${props.id}" already registered`);
+        }
+        handlerIDToTag[props.id] = this.handlerTag;
+      }
+    }
+
+    componentDidMount() {
+      const props: HandlerProps<U> = this.props;
+      if (hasUnresolvedRefs(props)) {
+        // If there are unresolved refs (e.g. ".current" has not yet been set)
+        // passed as `simultaneousHandlers` or `waitFor`, we enqueue a call to
+        // _update method that will try to update native handler props using
+        // setImmediate. This makes it so _update function gets called after all
+        // react components are mounted and we expect the missing ref object to
+        // be resolved by then.
+        this.updateEnqueued = setImmediate(() => {
+          this.updateEnqueued = null;
+          this.update();
+        });
+      }
+
+      this.createGestureHandler(
+        filterConfig(
+          transformProps ? transformProps(this.props) : this.props,
+          [...allowedProps, ...customNativeProps],
+          config
+        )
+      );
+
+      this.attachGestureHandler(findNodeHandle(this.viewNode) as number); // TODO(TS) - check if this can be null
+    }
+
+    componentDidUpdate() {
+      const viewTag = findNodeHandle(this.viewNode);
+      if (this.viewTag !== viewTag) {
+        this.attachGestureHandler(viewTag as number); // TODO(TS) - check interaction between _viewTag & findNodeHandle
+      }
+      this.update();
+    }
+
+    componentWillUnmount() {
+      RNGestureHandlerModule.dropGestureHandler(this.handlerTag);
+      if (this.updateEnqueued) {
+        clearImmediate(this.updateEnqueued);
+      }
+      // We can't use this.props.id directly due to TS generic type narrowing bug, see https://github.com/microsoft/TypeScript/issues/13995 for more context
+      const handlerID: string | undefined = this.props.id;
+      if (handlerID) {
+        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+        delete handlerIDToTag[handlerID];
+      }
+    }
+
+    private onGestureHandlerEvent = (event: GestureEvent<U>) => {
+      if (event.nativeEvent.handlerTag === this.handlerTag) {
+        this.props.onGestureEvent?.(event);
+      } else {
+        this.props.onGestureHandlerEvent?.(event);
+      }
+    };
+
+    // TODO(TS) - make sure this is right type for event
+    private onGestureHandlerStateChange = (
+      event: HandlerStateChangeEvent<U>
+    ) => {
+      if (event.nativeEvent.handlerTag === this.handlerTag) {
+        this.props.onHandlerStateChange?.(event);
+
+        const state: ValueOf<typeof State> = event.nativeEvent.state;
+        const stateEventName = stateToPropMappings[state];
+        const eventHandler = stateEventName && this.props[stateEventName];
+        if (eventHandler && typeof eventHandler === 'function') {
+          eventHandler(event);
+        }
+      } else {
+        this.props.onGestureHandlerStateChange?.(event);
+      }
+    };
+
+    private refHandler = (node: any) => {
+      this.viewNode = node;
+
+      const child = React.Children.only(this.props.children);
+      // TODO(TS) fix ref type
+      const { ref }: any = child;
+      if (ref !== null) {
+        if (typeof ref === 'function') {
+          ref(node);
+        } else {
+          ref.current = node;
+        }
+      }
+    };
+
+    private createGestureHandler = (
+      newConfig: Readonly<Record<string, unknown>>
+    ) => {
+      this.config = newConfig;
+
+      RNGestureHandlerModule.createGestureHandler(
+        name,
+        this.handlerTag,
+        newConfig
+      );
+    };
+
+    private attachGestureHandler = (newViewTag: number) => {
+      this.viewTag = newViewTag;
+
+      if (Platform.OS === 'web') {
+        // typecast due to dynamic resolution, attachGestureHandler should have web version signature in this branch
+        (RNGestureHandlerModule.attachGestureHandler as typeof RNGestureHandlerModuleWeb.attachGestureHandler)(
+          this.handlerTag,
+          newViewTag,
+          this.propsRef
+        );
+      } else {
+        RNGestureHandlerModule.attachGestureHandler(
+          this.handlerTag,
+          newViewTag
+        );
+      }
+    };
+
+    private updateGestureHandler = (
+      newConfig: Readonly<Record<string, unknown>>
+    ) => {
+      this.config = newConfig;
+
+      RNGestureHandlerModule.updateGestureHandler(this.handlerTag, newConfig);
+    };
+
+    private update() {
+      const newConfig = filterConfig(
+        transformProps ? transformProps(this.props) : this.props,
+        [...allowedProps, ...customNativeProps],
+        config
+      );
+      if (!deepEqual(this.config, newConfig)) {
+        this.updateGestureHandler(newConfig);
+      }
+    }
+
+    setNativeProps(updates: any) {
+      const mergedProps = { ...this.props, ...updates };
+      const newConfig = filterConfig(
+        transformProps ? transformProps(mergedProps) : mergedProps,
+        [...allowedProps, ...customNativeProps],
+        config
+      );
+      this.updateGestureHandler(newConfig);
+    }
+
+    render() {
+      let gestureEventHandler = this.onGestureHandlerEvent;
+      // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+      type OnGestureEventHandlers = {
+        onGestureEvent?: BaseGestureHandlerProps<U>['onGestureEvent'];
+        onGestureHandlerEvent?: InternalEventHandlers['onGestureHandlerEvent'];
+      };
+      const {
+        onGestureEvent,
+        onGestureHandlerEvent,
+      }: OnGestureEventHandlers = this.props;
+      if (onGestureEvent && typeof onGestureEvent !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerEvent) {
+          throw new Error(
+            'Nesting touch handlers with native animated driver is not supported yet'
+          );
+        }
+        gestureEventHandler = onGestureEvent;
+      } else {
+        if (
+          onGestureHandlerEvent &&
+          typeof onGestureHandlerEvent !== 'function'
+        ) {
+          throw new Error(
+            'Nesting touch handlers with native animated driver is not supported yet'
+          );
+        }
+      }
+
+      let gestureStateEventHandler = this.onGestureHandlerStateChange;
+      // Another instance of https://github.com/microsoft/TypeScript/issues/13995
+      type OnGestureStateChangeHandlers = {
+        onHandlerStateChange?: BaseGestureHandlerProps<U>['onHandlerStateChange'];
+        onGestureHandlerStateChange?: InternalEventHandlers['onGestureHandlerStateChange'];
+      };
+      const {
+        onHandlerStateChange,
+        onGestureHandlerStateChange,
+      }: OnGestureStateChangeHandlers = this.props;
+      if (onHandlerStateChange && typeof onHandlerStateChange !== 'function') {
+        // If it's not a method it should be an native Animated.event
+        // object. We set it directly as the handler for the view
+        // In this case nested handlers are not going to be supported
+        if (onGestureHandlerStateChange) {
+          throw new Error(
+            'Nesting touch handlers with native animated driver is not supported yet'
+          );
+        }
+        gestureStateEventHandler = onHandlerStateChange;
+      } else {
+        if (
+          onGestureHandlerStateChange &&
+          typeof onGestureHandlerStateChange !== 'function'
+        ) {
+          throw new Error(
+            'Nesting touch handlers with native animated driver is not supported yet'
+          );
+        }
+      }
+      const events = {
+        onGestureHandlerEvent: gestureEventHandler,
+        onGestureHandlerStateChange: gestureStateEventHandler,
+      };
+
+      this.propsRef.current = events;
+
+      const child: any = React.Children.only(this.props.children);
+      let grandChildren = child.props.children;
+      if (
+        Touchable.TOUCH_TARGET_DEBUG &&
+        child.type &&
+        (child.type === 'RNGestureHandlerButton' ||
+          child.type.name === 'View' ||
+          child.type.displayName === 'View')
+      ) {
+        grandChildren = React.Children.toArray(grandChildren);
+        grandChildren.push(
+          Touchable.renderDebugView({
+            color: 'mediumspringgreen',
+            hitSlop: child.props.hitSlop,
+          })
+        );
+      }
+
+      return React.cloneElement(
+        child,
+        {
+          ref: this.refHandler,
+          collapsable: false,
+          ...events,
+        },
+        grandChildren
+      );
+    }
+  }
+  return Handler;
+}
diff --git a/node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx b/node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx
new file mode 100644
index 0000000..f90b23b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/handlers/createNativeWrapper.tsx
@@ -0,0 +1,74 @@
+import * as React from 'react';
+import { useImperativeHandle, useRef } from 'react';
+
+import {
+  NativeViewGestureHandler,
+  NativeViewGestureHandlerProps,
+  nativeViewProps,
+} from './NativeViewGestureHandler';
+
+/*
+ * This array should consist of:
+ *   - All keys in propTypes from NativeGestureHandler
+ *     (and all keys in GestureHandlerPropTypes)
+ *   - 'onGestureHandlerEvent'
+ *   - 'onGestureHandlerStateChange'
+ */
+const NATIVE_WRAPPER_PROPS_FILTER = [
+  ...nativeViewProps,
+  'onGestureHandlerEvent',
+  'onGestureHandlerStateChange',
+] as const;
+
+export default function createNativeWrapper<P>(
+  Component: React.ComponentType<P>,
+  config: Readonly<NativeViewGestureHandlerProps> = {}
+) {
+  const ComponentWrapper = React.forwardRef<
+    React.ComponentType<any>,
+    P & NativeViewGestureHandlerProps
+  >((props, ref) => {
+    // filter out props that should be passed to gesture handler wrapper
+    const gestureHandlerProps = Object.keys(props).reduce(
+      (res, key) => {
+        // TS being overly protective with it's types, see https://github.com/microsoft/TypeScript/issues/26255#issuecomment-458013731 for more info
+        const allowedKeys: readonly string[] = NATIVE_WRAPPER_PROPS_FILTER;
+        if (allowedKeys.includes(key)) {
+          // @ts-ignore FIXME(TS)
+          res[key] = props[key];
+        }
+        return res;
+      },
+      { ...config } // watch out not to modify config
+    );
+    const _ref = useRef<React.ComponentType<P>>();
+    const _gestureHandlerRef = useRef<React.ComponentType<P>>();
+    useImperativeHandle(
+      ref,
+      // @ts-ignore TODO(TS) decide how nulls work in this context
+      () => {
+        const node = _gestureHandlerRef.current;
+        // add handlerTag for relations config
+        if (_ref.current && node) {
+          // @ts-ignore FIXME(TS) think about createHandler return type
+          _ref.current.handlerTag = node.handlerTag;
+          return _ref.current;
+        }
+        return null;
+      },
+      [_ref, _gestureHandlerRef]
+    );
+    return (
+      <NativeViewGestureHandler
+        {...gestureHandlerProps}
+        // @ts-ignore TODO(TS)
+        ref={_gestureHandlerRef}>
+        <Component {...props} ref={_ref} />
+      </NativeViewGestureHandler>
+    );
+  });
+
+  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';
+
+  return ComponentWrapper;
+}
diff --git a/node_modules/react-native-gesture-handler/src/handlers/gestureHandlerTypesCompat.ts b/node_modules/react-native-gesture-handler/src/handlers/gestureHandlerTypesCompat.ts
new file mode 100644
index 0000000..00d756b
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/handlers/gestureHandlerTypesCompat.ts
@@ -0,0 +1,75 @@
+import {
+  BaseButtonProps,
+  BorderlessButtonProps,
+  RawButtonProps,
+  RectButtonProps,
+} from '../components/GestureButtons';
+import {
+  FlingGestureHandlerEventPayload,
+  FlingGestureHandlerProps,
+  ForceTouchGestureHandlerEventPayload,
+  ForceTouchGestureHandlerProps,
+  GestureEvent,
+  GestureEventPayload,
+  HandlerStateChangeEvent,
+  HandlerStateChangeEventPayload,
+  LongPressGestureHandlerEventPayload,
+  LongPressGestureHandlerProps,
+  PanGestureHandlerEventPayload,
+  PanGestureHandlerProps,
+  PinchGestureHandlerEventPayload,
+  PinchGestureHandlerProps,
+  RotationGestureHandlerEventPayload,
+  RotationGestureHandlerProps,
+  TapGestureHandlerEventPayload,
+  TapGestureHandlerProps,
+} from './gestureHandlers';
+import {
+  NativeViewGestureHandlerPayload,
+  NativeViewGestureHandlerProps,
+} from './NativeViewGestureHandler';
+
+// events
+export type GestureHandlerGestureEventNativeEvent = GestureEventPayload;
+export type GestureHandlerStateChangeNativeEvent = HandlerStateChangeEventPayload;
+export type GestureHandlerGestureEvent = GestureEvent;
+export type GestureHandlerStateChangeEvent = HandlerStateChangeEvent;
+// gesture handlers events
+export type NativeViewGestureHandlerGestureEvent = GestureEvent<NativeViewGestureHandlerPayload>;
+export type NativeViewGestureHandlerStateChangeEvent = HandlerStateChangeEvent<NativeViewGestureHandlerPayload>;
+
+export type TapGestureHandlerGestureEvent = GestureEvent<TapGestureHandlerEventPayload>;
+export type TapGestureHandlerStateChangeEvent = HandlerStateChangeEvent<TapGestureHandlerEventPayload>;
+
+export type ForceTouchGestureHandlerGestureEvent = GestureEvent<ForceTouchGestureHandlerEventPayload>;
+export type ForceTouchGestureHandlerStateChangeEvent = HandlerStateChangeEvent<ForceTouchGestureHandlerEventPayload>;
+
+export type LongPressGestureHandlerGestureEvent = GestureEvent<LongPressGestureHandlerEventPayload>;
+export type LongPressGestureHandlerStateChangeEvent = HandlerStateChangeEvent<LongPressGestureHandlerEventPayload>;
+
+export type PanGestureHandlerGestureEvent = GestureEvent<PanGestureHandlerEventPayload>;
+export type PanGestureHandlerStateChangeEvent = HandlerStateChangeEvent<PanGestureHandlerEventPayload>;
+
+export type PinchGestureHandlerGestureEvent = GestureEvent<PinchGestureHandlerEventPayload>;
+export type PinchGestureHandlerStateChangeEvent = HandlerStateChangeEvent<PinchGestureHandlerEventPayload>;
+
+export type RotationGestureHandlerGestureEvent = GestureEvent<RotationGestureHandlerEventPayload>;
+export type RotationGestureHandlerStateChangeEvent = HandlerStateChangeEvent<RotationGestureHandlerEventPayload>;
+
+export type FlingGestureHandlerGestureEvent = GestureEvent<FlingGestureHandlerEventPayload>;
+export type FlingGestureHandlerStateChangeEvent = HandlerStateChangeEvent<FlingGestureHandlerEventPayload>;
+
+// handlers properties
+export type NativeViewGestureHandlerProperties = NativeViewGestureHandlerProps;
+export type TapGestureHandlerProperties = TapGestureHandlerProps;
+export type LongPressGestureHandlerProperties = LongPressGestureHandlerProps;
+export type PanGestureHandlerProperties = PanGestureHandlerProps;
+export type PinchGestureHandlerProperties = PinchGestureHandlerProps;
+export type RotationGestureHandlerProperties = RotationGestureHandlerProps;
+export type FlingGestureHandlerProperties = FlingGestureHandlerProps;
+export type ForceTouchGestureHandlerProperties = ForceTouchGestureHandlerProps;
+// button props
+export type RawButtonProperties = RawButtonProps;
+export type BaseButtonProperties = BaseButtonProps;
+export type RectButtonProperties = RectButtonProps;
+export type BorderlessButtonProperties = BorderlessButtonProps;
diff --git a/node_modules/react-native-gesture-handler/src/handlers/gestureHandlers.ts b/node_modules/react-native-gesture-handler/src/handlers/gestureHandlers.ts
new file mode 100644
index 0000000..d2be2b4
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/handlers/gestureHandlers.ts
@@ -0,0 +1,511 @@
+// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.
+// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof
+// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.
+// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.
+import * as React from 'react';
+
+import createHandler from './createHandler';
+import PlatformConstants from '../PlatformConstants';
+import { State } from '../State';
+import { ValueOf } from '../typeUtils';
+
+export interface GestureEventPayload {
+  handlerTag: number;
+  numberOfPointers: number;
+  state: ValueOf<typeof State>;
+}
+
+export interface HandlerStateChangeEventPayload {
+  handlerTag: number;
+  numberOfPointers: number;
+  state: ValueOf<typeof State>;
+  oldState: ValueOf<typeof State>;
+}
+
+//TODO(TS) events in handlers
+
+export interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {
+  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;
+}
+export interface HandlerStateChangeEvent<
+  ExtraEventPayloadT = Record<string, unknown>
+> {
+  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;
+}
+
+// Events payloads are types instead of interfaces due to TS limitation.
+// See https://github.com/microsoft/TypeScript/issues/15300 for more info.
+export type BaseGestureHandlerProps<
+  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>
+> = {
+  id?: string;
+  enabled?: boolean;
+  minPointers?: number;
+  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];
+  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];
+  shouldCancelWhenOutside?: boolean;
+  hitSlop?:
+    | number
+    // TODO(TS) take into consideration types from GestureHandler#setHitSlop
+    | Partial<
+        Record<
+          'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',
+          number
+        >
+      >
+    | Record<'width' | 'left', number>
+    | Record<'width' | 'right', number>
+    | Record<'height' | 'top', number>
+    | Record<'height' | 'bottom', number>;
+  // TODO(TS) - fix event types
+  onBegan?: (event: HandlerStateChangeEvent) => void;
+  onFailed?: (event: HandlerStateChangeEvent) => void;
+  onCancelled?: (event: HandlerStateChangeEvent) => void;
+  onActivated?: (event: HandlerStateChangeEvent) => void;
+  onEnded?: (event: HandlerStateChangeEvent) => void;
+
+  //TODO(TS) consider using NativeSyntheticEvent
+  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;
+  onHandlerStateChange?: (
+    event: HandlerStateChangeEvent<ExtraEventPayloadT>
+  ) => void;
+};
+
+export const baseProps = [
+  'id',
+  'enabled',
+  'minPointers',
+  'waitFor',
+  'simultaneousHandlers',
+  'shouldCancelWhenOutside',
+  'hitSlop',
+  'onBegan',
+  'onFailed',
+  'onCancelled',
+  'onActivated',
+  'onEnded',
+  'onGestureEvent',
+  'onHandlerStateChange',
+] as const;
+
+export type TapGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+  absoluteX: number;
+  absoluteY: number;
+};
+
+export interface TapGestureHandlerProps
+  extends BaseGestureHandlerProps<TapGestureHandlerEventPayload> {
+  minPointers?: number;
+  maxDurationMs?: number;
+  maxDelayMs?: number;
+  numberOfTaps?: number;
+  maxDeltaX?: number;
+  maxDeltaY?: number;
+  maxDist?: number;
+}
+
+export type TapGestureHandler = typeof TapGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const TapGestureHandler = createHandler<
+  TapGestureHandlerProps,
+  TapGestureHandlerEventPayload
+>({
+  name: 'TapGestureHandler',
+  allowedProps: [
+    ...baseProps,
+    'maxDurationMs',
+    'maxDelayMs',
+    'numberOfTaps',
+    'maxDeltaX',
+    'maxDeltaY',
+    'maxDist',
+    'minPointers',
+  ] as const,
+  config: {},
+});
+
+export type FlingGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+  absoluteX: number;
+  absoluteY: number;
+};
+
+export interface FlingGestureHandlerProps
+  extends BaseGestureHandlerProps<FlingGestureHandlerEventPayload> {
+  direction?: number;
+  numberOfPointers?: number;
+}
+
+export type FlingGestureHandler = typeof FlingGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const FlingGestureHandler = createHandler<
+  FlingGestureHandlerProps,
+  FlingGestureHandlerEventPayload
+>({
+  name: 'FlingGestureHandler',
+  allowedProps: [...baseProps, 'numberOfPointers', 'direction'] as const,
+  config: {},
+});
+
+class ForceTouchFallback extends React.Component {
+  static forceTouchAvailable = false;
+  componentDidMount() {
+    console.warn(
+      'ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase'
+    );
+  }
+  render() {
+    return this.props.children;
+  }
+}
+
+export type ForceTouchGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+  absoluteX: number;
+  absoluteY: number;
+  force: number;
+};
+
+export interface ForceTouchGestureHandlerProps
+  extends BaseGestureHandlerProps<ForceTouchGestureHandlerEventPayload> {
+  minForce?: number;
+  maxForce?: number;
+  feedbackOnActivation?: boolean;
+}
+
+export type ForceTouchGestureHandler = typeof ForceTouchGestureHandler & {
+  forceTouchAvailable: boolean;
+};
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const ForceTouchGestureHandler = PlatformConstants?.forceTouchAvailable
+  ? createHandler<
+      ForceTouchGestureHandlerProps,
+      ForceTouchGestureHandlerEventPayload
+    >({
+      name: 'ForceTouchGestureHandler',
+      allowedProps: [
+        ...baseProps,
+        'minForce',
+        'maxForce',
+        'feedbackOnActivation',
+      ] as const,
+      config: {},
+    })
+  : ForceTouchFallback;
+
+(ForceTouchGestureHandler as ForceTouchGestureHandler).forceTouchAvailable =
+  PlatformConstants?.forceTouchAvailable || false;
+
+export type LongPressGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+  absoluteX: number;
+  absoluteY: number;
+};
+
+export interface LongPressGestureHandlerProps
+  extends BaseGestureHandlerProps<LongPressGestureHandlerEventPayload> {
+  minDurationMs?: number;
+  maxDist?: number;
+}
+
+export type LongPressGestureHandler = typeof LongPressGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const LongPressGestureHandler = createHandler<
+  LongPressGestureHandlerProps,
+  LongPressGestureHandlerEventPayload
+>({
+  name: 'LongPressGestureHandler',
+  allowedProps: [...baseProps, 'minDurationMs', 'maxDist'] as const,
+  config: {},
+});
+
+function validatePanGestureHandlerProps(props: PanGestureHandlerProps) {
+  if (props.minDeltaX && props.activeOffsetX) {
+    throw new Error(
+      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`
+    );
+  }
+  if (props.maxDeltaX && props.failOffsetX) {
+    throw new Error(
+      `It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd`
+    );
+  }
+  if (props.minDeltaY && props.activeOffsetY) {
+    throw new Error(
+      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`
+    );
+  }
+  if (props.maxDeltaY && props.failOffsetY) {
+    throw new Error(
+      `It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd`
+    );
+  }
+  if (
+    Array.isArray(props.activeOffsetX) &&
+    (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)
+  ) {
+    throw new Error(
+      `First element of activeOffsetX should be negative, a the second one should be positive`
+    );
+  }
+
+  if (
+    Array.isArray(props.activeOffsetY) &&
+    (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)
+  ) {
+    throw new Error(
+      `First element of activeOffsetY should be negative, a the second one should be positive`
+    );
+  }
+
+  if (
+    Array.isArray(props.failOffsetX) &&
+    (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)
+  ) {
+    throw new Error(
+      `First element of failOffsetX should be negative, a the second one should be positive`
+    );
+  }
+
+  if (
+    Array.isArray(props.failOffsetY) &&
+    (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)
+  ) {
+    throw new Error(
+      `First element of failOffsetY should be negative, a the second one should be positive`
+    );
+  }
+}
+
+function transformPanGestureHandlerProps(props: PanGestureHandlerProps) {
+  type InternalPanGHKeys =
+    | 'activeOffsetXStart'
+    | 'activeOffsetXEnd'
+    | 'failOffsetXStart'
+    | 'failOffsetXEnd'
+    | 'activeOffsetYStart'
+    | 'activeOffsetYEnd'
+    | 'failOffsetYStart'
+    | 'failOffsetYEnd';
+  type PanGestureHandlerInternalProps = PanGestureHandlerProps &
+    Partial<Record<InternalPanGHKeys, number>>;
+
+  const res: PanGestureHandlerInternalProps = { ...props };
+  if (props.minDeltaX !== undefined) {
+    delete res.minDeltaX;
+    res.activeOffsetXStart = -props.minDeltaX;
+    res.activeOffsetXEnd = props.minDeltaX;
+  }
+  if (props.maxDeltaX !== undefined) {
+    delete res.maxDeltaX;
+    res.failOffsetXStart = -props.maxDeltaX;
+    res.failOffsetXEnd = props.maxDeltaX;
+  }
+  if (props.minOffsetX !== undefined) {
+    delete res.minOffsetX;
+    if (props.minOffsetX < 0) {
+      res.activeOffsetXStart = props.minOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.minOffsetX;
+    }
+  }
+
+  if (props.minDeltaY !== undefined) {
+    delete res.minDeltaY;
+    res.activeOffsetYStart = -props.minDeltaY;
+    res.activeOffsetYEnd = props.minDeltaY;
+  }
+  if (props.maxDeltaY !== undefined) {
+    delete res.maxDeltaY;
+    res.failOffsetYStart = -props.maxDeltaY;
+    res.failOffsetYEnd = props.maxDeltaY;
+  }
+
+  if (props.minOffsetY !== undefined) {
+    delete res.minOffsetY;
+    if (props.minOffsetY < 0) {
+      res.activeOffsetYStart = props.minOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.minOffsetY;
+    }
+  }
+
+  if (props.activeOffsetX !== undefined) {
+    delete res.activeOffsetX;
+    if (Array.isArray(props.activeOffsetX)) {
+      res.activeOffsetXStart = props.activeOffsetX[0];
+      res.activeOffsetXEnd = props.activeOffsetX[1];
+    } else if (props.activeOffsetX < 0) {
+      res.activeOffsetXStart = props.activeOffsetX;
+    } else {
+      res.activeOffsetXEnd = props.activeOffsetX;
+    }
+  }
+
+  if (props.activeOffsetY !== undefined) {
+    delete res.activeOffsetY;
+    if (Array.isArray(props.activeOffsetY)) {
+      res.activeOffsetYStart = props.activeOffsetY[0];
+      res.activeOffsetYEnd = props.activeOffsetY[1];
+    } else if (props.activeOffsetY < 0) {
+      res.activeOffsetYStart = props.activeOffsetY;
+    } else {
+      res.activeOffsetYEnd = props.activeOffsetY;
+    }
+  }
+
+  if (props.failOffsetX !== undefined) {
+    delete res.failOffsetX;
+    if (Array.isArray(props.failOffsetX)) {
+      res.failOffsetXStart = props.failOffsetX[0];
+      res.failOffsetXEnd = props.failOffsetX[1];
+    } else if (props.failOffsetX < 0) {
+      res.failOffsetXStart = props.failOffsetX;
+    } else {
+      res.failOffsetXEnd = props.failOffsetX;
+    }
+  }
+
+  if (props.failOffsetY !== undefined) {
+    delete res.failOffsetY;
+    if (Array.isArray(props.failOffsetY)) {
+      res.failOffsetYStart = props.failOffsetY[0];
+      res.failOffsetYEnd = props.failOffsetY[1];
+    } else if (props.failOffsetY < 0) {
+      res.failOffsetYStart = props.failOffsetY;
+    } else {
+      res.failOffsetYEnd = props.failOffsetY;
+    }
+  }
+
+  return res;
+}
+
+function managePanProps(props: PanGestureHandlerProps) {
+  if (__DEV__) {
+    validatePanGestureHandlerProps(props);
+  }
+  return transformPanGestureHandlerProps(props);
+}
+
+export type PanGestureHandlerEventPayload = {
+  x: number;
+  y: number;
+  absoluteX: number;
+  absoluteY: number;
+  translationX: number;
+  translationY: number;
+  velocityX: number;
+  velocityY: number;
+};
+
+export interface PanGestureHandlerProps
+  extends BaseGestureHandlerProps<PanGestureHandlerEventPayload> {
+  /** @deprecated  use activeOffsetX*/
+  minDeltaX?: number;
+  /** @deprecated  use activeOffsetY*/
+  minDeltaY?: number;
+  /** @deprecated  use failOffsetX*/
+  maxDeltaX?: number;
+  /** @deprecated  use failOffsetY*/
+  maxDeltaY?: number;
+  /** @deprecated  use activeOffsetX*/
+  minOffsetX?: number;
+  /** @deprecated  use failOffsetY*/
+  minOffsetY?: number;
+  activeOffsetY?: number | number[];
+  activeOffsetX?: number | number[];
+  failOffsetY?: number | number[];
+  failOffsetX?: number | number[];
+  minDist?: number;
+  minVelocity?: number;
+  minVelocityX?: number;
+  minVelocityY?: number;
+  minPointers?: number;
+  maxPointers?: number;
+  avgTouches?: boolean;
+  enableTrackpadTwoFingerGesture?: boolean;
+}
+
+export type PanGestureHandler = typeof PanGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const PanGestureHandler = createHandler<
+  PanGestureHandlerProps,
+  PanGestureHandlerEventPayload
+>({
+  name: 'PanGestureHandler',
+  allowedProps: [
+    ...baseProps,
+    'activeOffsetY',
+    'activeOffsetX',
+    'failOffsetY',
+    'failOffsetX',
+    'minDist',
+    'minVelocity',
+    'minVelocityX',
+    'minVelocityY',
+    'minPointers',
+    'maxPointers',
+    'avgTouches',
+    'enableTrackpadTwoFingerGesture',
+  ] as const,
+  config: {},
+  transformProps: managePanProps,
+  customNativeProps: [
+    'activeOffsetYStart',
+    'activeOffsetYEnd',
+    'activeOffsetXStart',
+    'activeOffsetXEnd',
+    'failOffsetYStart',
+    'failOffsetYEnd',
+    'failOffsetXStart',
+    'failOffsetXEnd',
+  ],
+});
+
+export type PinchGestureHandlerEventPayload = {
+  scale: number;
+  focalX: number;
+  focalY: number;
+  velocity: number;
+};
+
+export interface PinchGestureHandlerProps
+  extends BaseGestureHandlerProps<PinchGestureHandlerEventPayload> {}
+
+export type PinchGestureHandler = typeof PinchGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const PinchGestureHandler = createHandler<
+  PinchGestureHandlerProps,
+  PinchGestureHandlerEventPayload
+>({
+  name: 'PinchGestureHandler',
+  allowedProps: baseProps,
+  config: {},
+});
+
+export type RotationGestureHandlerEventPayload = {
+  rotation: number;
+  anchorX: number;
+  anchorY: number;
+  velocity: number;
+};
+
+export interface RotationGestureHandlerProps
+  extends BaseGestureHandlerProps<RotationGestureHandlerEventPayload> {}
+
+export type RotationGestureHandler = typeof RotationGestureHandler;
+// eslint-disable-next-line @typescript-eslint/no-redeclare -- backward compatibility; see description on the top of this file
+export const RotationGestureHandler = createHandler<
+  RotationGestureHandlerProps,
+  RotationGestureHandlerEventPayload
+>({
+  name: 'RotationGestureHandler',
+  allowedProps: baseProps,
+  config: {},
+});
diff --git a/node_modules/react-native-gesture-handler/src/index.ts b/node_modules/react-native-gesture-handler/src/index.ts
new file mode 100644
index 0000000..4fb626d
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/index.ts
@@ -0,0 +1,116 @@
+export { Directions } from './Directions';
+export { State } from './State';
+export { default as gestureHandlerRootHOC } from './gestureHandlerRootHOC';
+export { default as GestureHandlerRootView } from './GestureHandlerRootView';
+export type {
+  // event types
+  GestureEvent,
+  HandlerStateChangeEvent,
+  // event payloads types
+  GestureEventPayload,
+  HandlerStateChangeEventPayload,
+  TapGestureHandlerEventPayload,
+  ForceTouchGestureHandlerEventPayload,
+  LongPressGestureHandlerEventPayload,
+  PanGestureHandlerEventPayload,
+  PinchGestureHandlerEventPayload,
+  RotationGestureHandlerEventPayload,
+  FlingGestureHandlerEventPayload,
+  // gesture handlers props types
+  TapGestureHandlerProps,
+  ForceTouchGestureHandlerProps,
+  LongPressGestureHandlerProps,
+  PanGestureHandlerProps,
+  PinchGestureHandlerProps,
+  RotationGestureHandlerProps,
+  FlingGestureHandlerProps,
+} from './handlers/gestureHandlers';
+export {
+  TapGestureHandler,
+  ForceTouchGestureHandler,
+  LongPressGestureHandler,
+  PanGestureHandler,
+  PinchGestureHandler,
+  RotationGestureHandler,
+  FlingGestureHandler,
+} from './handlers/gestureHandlers';
+export { default as createNativeWrapper } from './handlers/createNativeWrapper';
+export type {
+  NativeViewGestureHandlerPayload,
+  NativeViewGestureHandlerProps,
+} from './handlers/NativeViewGestureHandler';
+export { NativeViewGestureHandler } from './handlers/NativeViewGestureHandler';
+export type {
+  RawButtonProps,
+  BaseButtonProps,
+  RectButtonProps,
+  BorderlessButtonProps,
+} from './components/GestureButtons';
+export {
+  RawButton,
+  BaseButton,
+  RectButton,
+  BorderlessButton,
+} from './components/GestureButtons';
+export {
+  TouchableHighlight,
+  TouchableNativeFeedback,
+  TouchableOpacity,
+  TouchableWithoutFeedback,
+} from './components/touchables';
+export {
+  ScrollView,
+  Switch,
+  TextInput,
+  DrawerLayoutAndroid,
+  FlatList,
+} from './components/GestureComponents';
+export type {
+  //events
+  GestureHandlerGestureEvent,
+  GestureHandlerStateChangeEvent,
+  //event payloads
+  GestureHandlerGestureEventNativeEvent,
+  GestureHandlerStateChangeNativeEvent,
+  NativeViewGestureHandlerGestureEvent,
+  NativeViewGestureHandlerStateChangeEvent,
+  TapGestureHandlerGestureEvent,
+  TapGestureHandlerStateChangeEvent,
+  ForceTouchGestureHandlerGestureEvent,
+  ForceTouchGestureHandlerStateChangeEvent,
+  LongPressGestureHandlerGestureEvent,
+  LongPressGestureHandlerStateChangeEvent,
+  PanGestureHandlerGestureEvent,
+  PanGestureHandlerStateChangeEvent,
+  PinchGestureHandlerGestureEvent,
+  PinchGestureHandlerStateChangeEvent,
+  RotationGestureHandlerGestureEvent,
+  RotationGestureHandlerStateChangeEvent,
+  FlingGestureHandlerGestureEvent,
+  FlingGestureHandlerStateChangeEvent,
+  // handlers props
+  NativeViewGestureHandlerProperties,
+  TapGestureHandlerProperties,
+  LongPressGestureHandlerProperties,
+  PanGestureHandlerProperties,
+  PinchGestureHandlerProperties,
+  RotationGestureHandlerProperties,
+  FlingGestureHandlerProperties,
+  ForceTouchGestureHandlerProperties,
+  // buttons props
+  RawButtonProperties,
+  BaseButtonProperties,
+  RectButtonProperties,
+  BorderlessButtonProperties,
+} from './handlers/gestureHandlerTypesCompat';
+
+export { default as Swipeable } from './components/Swipeable';
+export type {
+  DrawerLayoutProps,
+  DrawerPosition,
+  DrawerState,
+  DrawerType,
+  DrawerLockMode,
+  DrawerKeyboardDismissMode,
+} from './components/DrawerLayout';
+export { default as DrawerLayout } from './components/DrawerLayout';
diff --git a/node_modules/react-native-gesture-handler/src/mocks.ts b/node_modules/react-native-gesture-handler/src/mocks.ts
new file mode 100644
index 0000000..7d63107
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/mocks.ts
@@ -0,0 +1,25 @@
+import { View, ScrollView as RNScrollView } from 'react-native';
+import { State } from './State';
+import { Directions } from './Directions';
+
+const NOOP = () => {
+  // do nothing
+};
+const ScrollView = RNScrollView;
+const PanGestureHandler = View;
+const attachGestureHandler = NOOP;
+const createGestureHandler = NOOP;
+const dropGestureHandler = NOOP;
+const updateGestureHandler = NOOP;
+
+export default {
+  ScrollView,
+  PanGestureHandler,
+  attachGestureHandler,
+  createGestureHandler,
+  dropGestureHandler,
+  updateGestureHandler,
+  // probably can be removed
+  Directions,
+  State,
+} as const;
diff --git a/node_modules/react-native-gesture-handler/src/typeUtils.ts b/node_modules/react-native-gesture-handler/src/typeUtils.ts
new file mode 100644
index 0000000..5f2cf2c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/typeUtils.ts
@@ -0,0 +1 @@
+export type ValueOf<T> = T[keyof T];
diff --git a/node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/DiscreteGestureHandler.ts
similarity index 64%
rename from node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/DiscreteGestureHandler.ts
index 6e607b2..cd2b603 100644
--- a/node_modules/react-native-gesture-handler/web/DiscreteGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/DiscreteGestureHandler.ts
@@ -1,7 +1,9 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+/* eslint-disable */
 import GestureHandler from './GestureHandler';
 import { TEST_MAX_IF_NOT_NAN } from './utils';
 
-class DiscreteGestureHandler extends GestureHandler {
+abstract class DiscreteGestureHandler extends GestureHandler {
   get isDiscrete() {
     return true;
   }
@@ -11,8 +13,8 @@ class DiscreteGestureHandler extends GestureHandler {
   }
 
   shouldFailUnderCustomCriteria(
-    { x, y, deltaX, deltaY },
-    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }
+    { x, y, deltaX, deltaY }: any,
+    { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }: any
   ) {
     if (shouldCancelWhenOutside) {
       if (!this.isPointInView({ x, y })) {
@@ -22,12 +24,16 @@ class DiscreteGestureHandler extends GestureHandler {
     return (
       TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||
       TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||
-      TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq)
+      TEST_MAX_IF_NOT_NAN(
+        Math.abs(deltaY * deltaY + deltaX * deltaX),
+        maxDistSq
+      )
     );
   }
 
-  transformNativeEvent({ center: { x, y } }) {
-    const rect = this.view.getBoundingClientRect();
+  transformNativeEvent({ center: { x, y } }: any) {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view!.getBoundingClientRect();
 
     return {
       absoluteX: x,
@@ -38,11 +44,19 @@ class DiscreteGestureHandler extends GestureHandler {
   }
 
   isGestureEnabledForEvent(
-    { minPointers, maxPointers, maxDist, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside },
-    recognizer,
-    { maxPointers: pointerLength, center, deltaX, deltaY, ...props }
+    {
+      minPointers,
+      maxPointers,
+      maxDeltaX,
+      maxDeltaY,
+      maxDistSq,
+      shouldCancelWhenOutside,
+    }: any,
+    _recognizer: any,
+    { maxPointers: pointerLength, center, deltaX, deltaY }: any
   ) {
-    const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;
+    const validPointerCount =
+      pointerLength >= minPointers && pointerLength <= maxPointers;
 
     if (
       this.shouldFailUnderCustomCriteria(
diff --git a/node_modules/react-native-gesture-handler/src/web/DraggingGestureHandler.ts b/node_modules/react-native-gesture-handler/src/web/DraggingGestureHandler.ts
new file mode 100644
index 0000000..e93e3c6
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/web/DraggingGestureHandler.ts
@@ -0,0 +1,34 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+/* eslint-disable */
+import GestureHandler, { HammerInputExt } from './GestureHandler';
+import { PixelRatio } from 'react-native';
+
+abstract class DraggingGestureHandler extends GestureHandler {
+  get shouldEnableGestureOnSetup() {
+    return true;
+  }
+
+  transformNativeEvent({
+    deltaX,
+    deltaY,
+    velocityX,
+    velocityY,
+    center: { x, y },
+  }: HammerInputExt) {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view!.getBoundingClientRect();
+    const ratio = PixelRatio.get();
+    return {
+      translationX: deltaX - (this.__initialX || 0),
+      translationY: deltaY - (this.__initialY || 0),
+      absoluteX: x,
+      absoluteY: y,
+      velocityX: velocityX * ratio,
+      velocityY: velocityY * ratio,
+      x: x - rect.left,
+      y: y - rect.top,
+    };
+  }
+}
+
+export default DraggingGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/src/web/Errors.ts b/node_modules/react-native-gesture-handler/src/web/Errors.ts
new file mode 100644
index 0000000..a0e1a52
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/web/Errors.ts
@@ -0,0 +1,7 @@
+export class GesturePropError extends Error {
+  constructor(name: string, value: unknown, expectedType: string) {
+    super(
+      `Invalid property \`${name}: ${value}\` expected \`${expectedType}\``
+    );
+  }
+}
diff --git a/node_modules/react-native-gesture-handler/web/FlingGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/FlingGestureHandler.ts
similarity index 86%
rename from node_modules/react-native-gesture-handler/web/FlingGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/FlingGestureHandler.ts
index 2b3d878..e358200 100644
--- a/node_modules/react-native-gesture-handler/web/FlingGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/FlingGestureHandler.ts
@@ -1,9 +1,12 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+/* eslint-disable */
 import Hammer from '@egjs/hammerjs';
 
 import { Direction } from './constants';
 import { GesturePropError } from './Errors';
 import DraggingGestureHandler from './DraggingGestureHandler';
 import { isnan } from './utils';
+import { HammerInputExt } from './GestureHandler';
 
 class FlingGestureHandler extends DraggingGestureHandler {
   get name() {
@@ -14,7 +17,7 @@ class FlingGestureHandler extends DraggingGestureHandler {
     return Hammer.Swipe;
   }
 
-  onGestureActivated(event) {
+  onGestureActivated(event: HammerInputExt) {
     this.sendEvent({
       ...event,
       eventType: Hammer.INPUT_MOVE,
@@ -30,7 +33,7 @@ class FlingGestureHandler extends DraggingGestureHandler {
     });
   }
 
-  onRawEvent(ev) {
+  onRawEvent(ev: HammerInputExt) {
     super.onRawEvent(ev);
     if (this.hasGestureFailed) {
       return;
@@ -45,7 +48,8 @@ class FlingGestureHandler extends DraggingGestureHandler {
       });
     } else if (!this.hasGestureFailed && !this.isGestureRunning) {
       // Tap Gesture start event
-      const gesture = this.hammer.get(this.name);
+      const gesture = this.hammer!.get(this.name);
+      // @ts-ignore FIXME(TS)
       if (gesture.options.enable(gesture, ev)) {
         this.onStart(ev);
         this.sendEvent(ev);
@@ -55,12 +59,13 @@ class FlingGestureHandler extends DraggingGestureHandler {
 
   getHammerConfig() {
     return {
+      // @ts-ignore FIXME(TS)
       pointers: this.config.numberOfPointers,
       direction: this.getDirection(),
     };
   }
 
-  getTargetDirections(direction) {
+  getTargetDirections(direction: number) {
     const directions = [];
     if (direction & Direction.RIGHT) {
       directions.push(Hammer.DIRECTION_RIGHT);
@@ -79,6 +84,7 @@ class FlingGestureHandler extends DraggingGestureHandler {
   }
 
   getDirection() {
+    // @ts-ignore FIXME(TS)
     const { direction } = this.getConfig();
 
     let directions = [];
@@ -102,18 +108,9 @@ class FlingGestureHandler extends DraggingGestureHandler {
   }
 
   isGestureEnabledForEvent(
-    {
-      minPointers,
-      maxPointers,
-      numberOfPointers,
-      maxDist,
-      maxDeltaX,
-      maxDeltaY,
-      maxDistSq,
-      shouldCancelWhenOutside,
-    },
-    recognizer,
-    { maxPointers: pointerLength, deltaX: dx, deltaY: dy, ...props }
+    { numberOfPointers }: any,
+    _recognizer: any,
+    { maxPointers: pointerLength }: any
   ) {
     const validPointerCount = pointerLength === numberOfPointers;
     if (!validPointerCount && this.isGestureRunning) {
@@ -122,7 +119,7 @@ class FlingGestureHandler extends DraggingGestureHandler {
     return { success: validPointerCount };
   }
 
-  updateGestureConfig({ numberOfPointers = 1, direction, ...props }) {
+  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {
     if (isnan(direction) || typeof direction !== 'number') {
       throw new GesturePropError('direction', direction, 'number');
     }
diff --git a/node_modules/react-native-gesture-handler/web/GestureHandler.js b/node_modules/react-native-gesture-handler/src/web/GestureHandler.ts
similarity index 62%
rename from node_modules/react-native-gesture-handler/web/GestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/GestureHandler.ts
index 8a09e71..5f3f9f4 100644
--- a/node_modules/react-native-gesture-handler/web/GestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/GestureHandler.ts
@@ -1,66 +1,106 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+/* eslint-disable */
 import Hammer from '@egjs/hammerjs';
 import { findNodeHandle } from 'react-native';
 
-import State from '../State';
+import { State } from '../State';
 import { EventMap } from './constants';
 import * as NodeManager from './NodeManager';
 
-let _gestureInstances = 0;
-
-class GestureHandler {
-  isGestureRunning = false;
-  hasGestureFailed = false;
-  view = null;
-  config = {};
-  hammer = null;
-  pendingGestures = {};
-  oldState = State.UNDETERMINED;
-  previousState = State.UNDETERMINED;
-  lastSentState = null;
+// TODO(TS) Replace with HammerInput if https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438/files is merged
+export type HammerInputExt = Omit<HammerInput, 'destroy' | 'handler' | 'init'>;
+
+export type Config = Partial<{
+  enabled: boolean;
+  minPointers: number;
+  maxPointers: number;
+  minDist: number;
+  minDistSq: number;
+  minVelocity: number;
+  minVelocitySq: number;
+  maxDist: number;
+  maxDistSq: number;
+  failOffsetXStart: number;
+  failOffsetYStart: number;
+  failOffsetXEnd: number;
+  failOffsetYEnd: number;
+  activeOffsetXStart: number;
+  activeOffsetXEnd: number;
+  activeOffsetYStart: number;
+  activeOffsetYEnd: number;
+  waitFor: any[] | null;
+}>;
+
+type NativeEvent = ReturnType<GestureHandler['transformEventData']>;
+
+let gestureInstances = 0;
+
+abstract class GestureHandler {
+  public handlerTag: any;
+  public isGestureRunning = false;
+  public view: number | null = null;
+  protected hasCustomActivationCriteria: boolean;
+  protected hasGestureFailed = false;
+  protected hammer: HammerManager | null = null;
+  protected initialRotation: number | null = null;
+  protected __initialX: any;
+  protected __initialY: any;
+  protected config: Config = {};
+  protected previousState: State = State.UNDETERMINED;
+  private pendingGestures: Record<string, this> = {};
+  private oldState: State = State.UNDETERMINED;
+  private lastSentState: State | null = null;
+  private gestureInstance: number;
+  private _stillWaiting: any;
+  private propsRef: any;
+  private ref: any;
+
+  abstract get name(): string;
 
   get id() {
-    return `${this.name}${this._gestureInstance}`;
+    return `${this.name}${this.gestureInstance}`;
   }
 
   get isDiscrete() {
     return false;
   }
 
-  get shouldEnableGestureOnSetup() {
+  get shouldEnableGestureOnSetup(): boolean {
     throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');
   }
 
   constructor() {
-    this._gestureInstance = _gestureInstances++;
+    this.gestureInstance = gestureInstances++;
+    this.hasCustomActivationCriteria = false;
   }
 
   getConfig() {
     return this.config;
   }
 
-  onWaitingEnded(gesture) {}
+  onWaitingEnded(_gesture: this) {}
 
-  removePendingGesture(id) {
+  removePendingGesture(id: string) {
     delete this.pendingGestures[id];
   }
 
-  addPendingGesture(gesture) {
+  addPendingGesture(gesture: this) {
     this.pendingGestures[gesture.id] = gesture;
   }
 
-  isGestureEnabledForEvent() {
+  isGestureEnabledForEvent(
+    _config: any,
+    _recognizer: any,
+    _event: any
+  ): { failed?: boolean; success?: boolean } {
     return { success: true };
   }
 
-  parseNativeEvent(nativeEvent) {
-    return nativeEvent;
-  }
-
-  get NativeGestureClass() {
+  get NativeGestureClass(): RecognizerStatic {
     throw new Error('Must override GestureHandler.NativeGestureClass');
   }
 
-  updateHasCustomActivationCriteria(config) {
+  updateHasCustomActivationCriteria(_config: Config) {
     return true;
   }
 
@@ -76,7 +116,7 @@ class GestureHandler {
     this.clearSelfAsPending();
 
     this.config = ensureConfig({ enabled, ...props });
-    this._hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(
+    this.hasCustomActivationCriteria = this.updateHasCustomActivationCriteria(
       this.config
     );
     if (Array.isArray(this.config.waitFor)) {
@@ -95,24 +135,29 @@ class GestureHandler {
     this.clearSelfAsPending();
 
     if (this.hammer) {
-      this.hammer.stop();
+      this.hammer.stop(false);
       this.hammer.destroy();
     }
     this.hammer = null;
   };
 
-  isPointInView = ({ x, y }) => {
-    const rect = this.view.getBoundingClientRect();
+  isPointInView = ({ x, y }: { x: number; y: number }) => {
+    // @ts-ignore FIXME(TS)
+    const rect = this.view!.getBoundingClientRect();
     const pointerInside =
       x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
     return pointerInside;
   };
 
-  getState(type) {
+  getState(type: keyof typeof EventMap): State {
+    // @ts-ignore TODO(TS) check if this is needed
+    if (type == 0) {
+      return 0;
+    }
     return EventMap[type];
   }
 
-  transformEventData(event) {
+  transformEventData(event: HammerInputExt) {
     const { eventType, maxPointers: numberOfPointers } = event;
     // const direction = DirectionMap[ev.direction];
     const changedTouch = event.changedPointers[0];
@@ -121,7 +166,8 @@ class GestureHandler {
       y: changedTouch.clientY,
     });
 
-    const state = this.getState(eventType);
+    // TODO(TS) Remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50966 is merged.
+    const state = this.getState(eventType as 1 | 2 | 4 | 8);
     if (state !== this.previousState) {
       this.oldState = this.previousState;
       this.previousState = state;
@@ -142,11 +188,11 @@ class GestureHandler {
     };
   }
 
-  transformNativeEvent(event) {
+  transformNativeEvent(_event: HammerInputExt) {
     return {};
   }
 
-  sendEvent = nativeEvent => {
+  sendEvent = (nativeEvent: HammerInputExt) => {
     const {
       onGestureHandlerEvent,
       onGestureHandlerStateChange,
@@ -154,18 +200,14 @@ class GestureHandler {
 
     const event = this.transformEventData(nativeEvent);
 
-    invokeNullableMethod('onGestureEvent', onGestureHandlerEvent, event);
+    invokeNullableMethod(onGestureHandlerEvent, event);
     if (this.lastSentState !== event.nativeEvent.state) {
-      this.lastSentState = event.nativeEvent.state;
-      invokeNullableMethod(
-        'onHandlerStateChange',
-        onGestureHandlerStateChange,
-        event
-      );
+      this.lastSentState = event.nativeEvent.state as State;
+      invokeNullableMethod(onGestureHandlerStateChange, event);
     }
   };
 
-  cancelPendingGestures(event) {
+  cancelPendingGestures(event: HammerInputExt) {
     for (const gesture of Object.values(this.pendingGestures)) {
       if (gesture && gesture.isGestureRunning) {
         gesture.hasGestureFailed = true;
@@ -182,19 +224,20 @@ class GestureHandler {
     }
   }
 
-  onGestureEnded(event) {
+  // FIXME event is undefined in runtime when firstly invoked (see Draggable example), check other functions taking event as input
+  onGestureEnded(event: HammerInputExt) {
     this.isGestureRunning = false;
     this.cancelPendingGestures(event);
   }
 
-  forceInvalidate(event) {
+  forceInvalidate(event: HammerInputExt) {
     if (this.isGestureRunning) {
       this.hasGestureFailed = true;
       this.cancelEvent(event);
     }
   }
 
-  cancelEvent(event) {
+  cancelEvent(event: HammerInputExt) {
     this.notifyPendingGestures();
     this.sendEvent({
       ...event,
@@ -204,13 +247,13 @@ class GestureHandler {
     this.onGestureEnded(event);
   }
 
-  onRawEvent({ isFirst }) {
+  onRawEvent({ isFirst }: HammerInputExt) {
     if (isFirst) {
       this.hasGestureFailed = false;
     }
   }
 
-  setView(ref, propsRef) {
+  setView(ref: Parameters<typeof findNodeHandle>['0'], propsRef: any) {
     if (ref == null) {
       this.destroy();
       this.view = null;
@@ -221,24 +264,25 @@ class GestureHandler {
     this.ref = ref;
 
     this.view = findNodeHandle(ref);
-    this.hammer = new Hammer.Manager(this.view);
+    this.hammer = new Hammer.Manager(this.view as any);
 
     this.oldState = State.UNDETERMINED;
     this.previousState = State.UNDETERMINED;
     this.lastSentState = null;
 
     const { NativeGestureClass } = this;
+    // @ts-ignore TODO(TS)
     const gesture = new NativeGestureClass(this.getHammerConfig());
     this.hammer.add(gesture);
 
-    this.hammer.on('hammer.input', ev => {
+    this.hammer.on('hammer.input', (ev: HammerInput) => {
       if (!this.config.enabled) {
         this.hasGestureFailed = false;
         this.isGestureRunning = false;
         return;
       }
 
-      this.onRawEvent(ev);
+      this.onRawEvent((ev as unknown) as HammerInputExt);
 
       // TODO: Bacon: Check against something other than null
       // The isFirst value is not called when the first rotation is calculated.
@@ -259,16 +303,24 @@ class GestureHandler {
   }
 
   setupEvents() {
+    // TODO(TS) Hammer types aren't exactly that what we get in runtime
     if (!this.isDiscrete) {
-      this.hammer.on(`${this.name}start`, event => this.onStart(event));
-      this.hammer.on(`${this.name}end ${this.name}cancel`, event =>
-        this.onGestureEnded(event)
+      this.hammer!.on(`${this.name}start`, (event: HammerInput) =>
+        this.onStart((event as unknown) as HammerInputExt)
+      );
+      this.hammer!.on(
+        `${this.name}end ${this.name}cancel`,
+        (event: HammerInput) => {
+          this.onGestureEnded((event as unknown) as HammerInputExt);
+        }
       );
     }
-    this.hammer.on(this.name, ev => this.onGestureActivated(ev));
+    this.hammer!.on(this.name, (ev: HammerInput) =>
+      this.onGestureActivated((ev as unknown) as HammerInputExt)
+    ); // TODO(TS) remove cast after https://github.com/DefinitelyTyped/DefinitelyTyped/pull/50438 is merged
   }
 
-  onStart({ deltaX, deltaY, rotation }) {
+  onStart({ deltaX, deltaY, rotation }: HammerInputExt) {
     // Reset the state for the next gesture
     this.oldState = State.UNDETERMINED;
     this.previousState = State.UNDETERMINED;
@@ -280,7 +332,7 @@ class GestureHandler {
     this.initialRotation = rotation;
   }
 
-  onGestureActivated(ev) {
+  onGestureActivated(ev: HammerInputExt) {
     this.sendEvent(ev);
   }
 
@@ -309,10 +361,10 @@ class GestureHandler {
   }
 
   sync = () => {
-    const gesture = this.hammer.get(this.name);
+    const gesture = this.hammer!.get(this.name);
     if (!gesture) return;
 
-    const enable = (recognizer, inputData) => {
+    const enable = (recognizer: any, inputData: any) => {
       if (!this.config.enabled) {
         this.isGestureRunning = false;
         this.hasGestureFailed = false;
@@ -357,7 +409,7 @@ class GestureHandler {
       }
 
       // Use default behaviour
-      if (!this._hasCustomActivationCriteria) {
+      if (!this.hasCustomActivationCriteria) {
         return true;
       }
 
@@ -365,6 +417,7 @@ class GestureHandler {
         this.initialRotation == null
           ? 0
           : inputData.rotation - this.initialRotation;
+      // @ts-ignore FIXME(TS)
       const { success, failed } = this.isGestureEnabledForEvent(
         this.getConfig(),
         recognizer,
@@ -382,14 +435,22 @@ class GestureHandler {
     };
 
     const params = this.getHammerConfig();
+    // @ts-ignore FIXME(TS)
     gesture.set({ ...params, enable });
   };
 
-  simulateCancelEvent(inputData) {}
+  simulateCancelEvent(_inputData: any) {}
 }
 
+// TODO(TS) investigate this method
 // Used for sending data to a callback or AnimatedEvent
-function invokeNullableMethod(name, method, event) {
+function invokeNullableMethod(
+  method:
+    | ((event: NativeEvent) => void)
+    | { __getHandler: () => (event: NativeEvent) => void }
+    | { __nodeConfig: { argMapping: any } },
+  event: NativeEvent
+) {
   if (method) {
     if (typeof method === 'function') {
       method(event);
@@ -400,7 +461,7 @@ function invokeNullableMethod(name, method, event) {
         typeof method.__getHandler === 'function'
       ) {
         const handler = method.__getHandler();
-        invokeNullableMethod(name, handler, event);
+        invokeNullableMethod(handler, event);
       } else {
         if ('__nodeConfig' in method) {
           const { argMapping } = method.__nodeConfig;
@@ -408,6 +469,7 @@ function invokeNullableMethod(name, method, event) {
             for (const index in argMapping) {
               const [key, value] = argMapping[index];
               if (key in event.nativeEvent) {
+                // @ts-ignore fix method type
                 const nativeValue = event.nativeEvent[key];
                 if (value && value.setValue) {
                   // Reanimated API
@@ -426,30 +488,33 @@ function invokeNullableMethod(name, method, event) {
 }
 
 // Validate the props
-function ensureConfig(config) {
+function ensureConfig(config: Config): Required<Config> {
   const props = { ...config };
 
+  // TODO(TS) We use ! to assert that if property is present then value is not empty (null, undefined)
   if ('minDist' in config) {
     props.minDist = config.minDist;
-    props.minDistSq = props.minDist * props.minDist;
+    props.minDistSq = props.minDist! * props.minDist!;
   }
   if ('minVelocity' in config) {
     props.minVelocity = config.minVelocity;
-    props.minVelocitySq = props.minVelocity * props.minVelocity;
+    props.minVelocitySq = props.minVelocity! * props.minVelocity!;
   }
   if ('maxDist' in config) {
     props.maxDist = config.maxDist;
-    props.maxDistSq = config.maxDist * config.maxDist;
+    props.maxDistSq = config.maxDist! * config.maxDist!;
   }
   if ('waitFor' in config) {
     props.waitFor = asArray(config.waitFor)
-      .map(({ _handlerTag }) => NodeManager.getHandler(_handlerTag))
-      .filter(v => v);
+      .map(({ handlerTag }: { handlerTag: number }) =>
+        NodeManager.getHandler(handlerTag)
+      )
+      .filter((v) => v);
   } else {
     props.waitFor = null;
   }
 
-  [
+  const configProps = [
     'minPointers',
     'maxPointers',
     'minDist',
@@ -466,15 +531,17 @@ function ensureConfig(config) {
     'activeOffsetXEnd',
     'activeOffsetYStart',
     'activeOffsetYEnd',
-  ].forEach(prop => {
+  ] as const;
+  configProps.forEach((prop: typeof configProps[number]) => {
     if (typeof props[prop] === 'undefined') {
       props[prop] = Number.NaN;
     }
   });
-  return props;
+  return props as Required<Config>; // TODO(TS) how to convince TS that props are filled?
 }
 
-function asArray(value) {
+function asArray<T>(value: T | T[]) {
+  // TODO(TS) use config.waitFor type
   return value == null ? [] : Array.isArray(value) ? value : [value];
 }
 
diff --git a/node_modules/react-native-gesture-handler/web/IndiscreteGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/IndiscreteGestureHandler.ts
similarity index 79%
rename from node_modules/react-native-gesture-handler/web/IndiscreteGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/IndiscreteGestureHandler.ts
index 8b88e13..d63ba2f 100644
--- a/node_modules/react-native-gesture-handler/web/IndiscreteGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/IndiscreteGestureHandler.ts
@@ -3,7 +3,7 @@ import GestureHandler from './GestureHandler';
 /**
  * The base class for **Rotation** and **Pinch** gesture handlers.
  */
-class IndiscreteGestureHandler extends GestureHandler {
+abstract class IndiscreteGestureHandler extends GestureHandler {
   get shouldEnableGestureOnSetup() {
     return false;
   }
@@ -17,9 +17,9 @@ class IndiscreteGestureHandler extends GestureHandler {
   }
 
   isGestureEnabledForEvent(
-    { minPointers, maxPointers },
-    recognizer,
-    { maxPointers: pointerLength }
+    { minPointers, maxPointers }: any,
+    _recognizer: any,
+    { maxPointers: pointerLength }: any
   ) {
     if (pointerLength > maxPointers) {
       return { failed: true };
diff --git a/node_modules/react-native-gesture-handler/web/LongPressGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/LongPressGestureHandler.ts
similarity index 70%
rename from node_modules/react-native-gesture-handler/web/LongPressGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/LongPressGestureHandler.ts
index f64fb1a..7dcf41a 100644
--- a/node_modules/react-native-gesture-handler/web/LongPressGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/LongPressGestureHandler.ts
@@ -1,24 +1,30 @@
+/* eslint-disable eslint-comments/no-unlimited-disable */
+/* eslint-disable */
 import Hammer from '@egjs/hammerjs';
 
-import State from '../State';
+import { State } from '../State';
 import PressGestureHandler from './PressGestureHandler';
 import { isnan, isValidNumber } from './utils';
+import { Config } from './GestureHandler';
+import { HammerInputNames } from './constants';
 
 class LongPressGestureHandler extends PressGestureHandler {
-  get minDurationMs() {
+  get minDurationMs(): number {
+    // @ts-ignore FIXNE(TS)
     return isnan(this.config.minDurationMs) ? 251 : this.config.minDurationMs;
   }
 
   get maxDist() {
+    // @ts-ignore FIXNE(TS)
     return isnan(this.config.maxDist) ? 9 : this.config.maxDist;
   }
 
-  updateHasCustomActivationCriteria({ maxDistSq }) {
+  updateHasCustomActivationCriteria({ maxDistSq }: Config) {
     return !isValidNumber(maxDistSq);
   }
 
   getConfig() {
-    if (!this._hasCustomActivationCriteria) {
+    if (!this.hasCustomActivationCriteria) {
       // Default config
       // If no params have been defined then this config should emulate the native gesture as closely as possible.
       return {
@@ -37,7 +43,7 @@ class LongPressGestureHandler extends PressGestureHandler {
     };
   }
 
-  getState(type) {
+  getState(type: keyof typeof HammerInputNames) {
     return {
       [Hammer.INPUT_START]: State.ACTIVE,
       [Hammer.INPUT_MOVE]: State.ACTIVE,
diff --git a/node_modules/react-native-gesture-handler/web/NativeViewGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/NativeViewGestureHandler.ts
similarity index 50%
rename from node_modules/react-native-gesture-handler/web/NativeViewGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/NativeViewGestureHandler.ts
index 2705638..37c0af5 100644
--- a/node_modules/react-native-gesture-handler/web/NativeViewGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/NativeViewGestureHandler.ts
@@ -1,29 +1,34 @@
 import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { HammerInputExt } from './GestureHandler';
 import * as NodeManager from './NodeManager';
 import PressGestureHandler from './PressGestureHandler';
 import { TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';
 
 class NativeViewGestureHandler extends PressGestureHandler {
-  onRawEvent(ev) {
+  onRawEvent(ev: HammerInputExt) {
     super.onRawEvent(ev);
     if (!ev.isFinal) {
       // if (this.ref instanceof ScrollView) {
       if (TEST_MIN_IF_NOT_NAN(VEC_LEN_SQ({ x: ev.deltaX, y: ev.deltaY }), 10)) {
+        // @ts-ignore FIXME(TS) config type
         if (this.config.disallowInterruption) {
-          const gestures = Object.values(NodeManager.getNodes()).filter(gesture => {
-            const { handlerTag, view, isGestureRunning } = gesture;
-            return (
-              // Check if this gesture isn't self
-              handlerTag !== this.handlerTag &&
-              // Ensure the gesture needs to be cancelled
-              isGestureRunning &&
-              // ScrollView can cancel discrete gestures like taps and presses
-              gesture instanceof DiscreteGestureHandler &&
-              // Ensure a view exists and is a child of the current view
-              view &&
-              this.view.contains(view)
-            );
-          });
+          const gestures = Object.values(NodeManager.getNodes()).filter(
+            (gesture) => {
+              const { handlerTag, view, isGestureRunning } = gesture;
+              return (
+                // Check if this gesture isn't self
+                handlerTag !== this.handlerTag &&
+                // Ensure the gesture needs to be cancelled
+                isGestureRunning &&
+                // ScrollView can cancel discrete gestures like taps and presses
+                gesture instanceof DiscreteGestureHandler &&
+                // Ensure a view exists and is a child of the current view
+                view &&
+                // @ts-ignore FIXME(TS) view type
+                this.view.contains(view)
+              );
+            }
+          );
           // Cancel all of the gestures that passed the filter
           for (const gesture of gestures) {
             // TODO: Bacon: Send some cached event.
diff --git a/node_modules/react-native-gesture-handler/src/web/NodeManager.ts b/node_modules/react-native-gesture-handler/src/web/NodeManager.ts
new file mode 100644
index 0000000..ef82a89
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/web/NodeManager.ts
@@ -0,0 +1,32 @@
+import { ValueOf } from '../typeUtils';
+import { Gestures } from '../RNGestureHandlerModule.web';
+
+const gestures: Record<number, InstanceType<ValueOf<typeof Gestures>>> = {};
+
+export function getHandler(tag: number) {
+  if (tag in gestures) return gestures[tag];
+
+  throw new Error(`No handler for tag ${tag}`);
+}
+
+export function createGestureHandler(
+  handlerTag: number,
+  handler: InstanceType<ValueOf<typeof Gestures>>
+) {
+  if (handlerTag in gestures) {
+    throw new Error(`Handler with tag ${handlerTag} already exists`);
+  }
+  gestures[handlerTag] = handler;
+  // @ts-ignore no types for web handlers yet
+  gestures[handlerTag].handlerTag = handlerTag;
+}
+
+export function dropGestureHandler(handlerTag: number) {
+  getHandler(handlerTag).destroy();
+  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
+  delete gestures[handlerTag];
+}
+
+export function getNodes() {
+  return { ...gestures };
+}
diff --git a/node_modules/react-native-gesture-handler/web/PanGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/PanGestureHandler.ts
similarity index 76%
rename from node_modules/react-native-gesture-handler/web/PanGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/PanGestureHandler.ts
index e31d0ae..b588d69 100644
--- a/node_modules/react-native-gesture-handler/web/PanGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/PanGestureHandler.ts
@@ -1,13 +1,15 @@
 import Hammer from '@egjs/hammerjs';
 
 import {
+  EventMap,
   MULTI_FINGER_PAN_MAX_PINCH_THRESHOLD,
   MULTI_FINGER_PAN_MAX_ROTATION_THRESHOLD,
 } from './constants';
 import DraggingGestureHandler from './DraggingGestureHandler';
 import { isValidNumber, isnan, TEST_MIN_IF_NOT_NAN, VEC_LEN_SQ } from './utils';
-import State from '../State';
+import { State } from '../State';
 
+import { Config, HammerInputExt } from './GestureHandler';
 class PanGestureHandler extends DraggingGestureHandler {
   get name() {
     return 'pan';
@@ -24,7 +26,7 @@ class PanGestureHandler extends DraggingGestureHandler {
     };
   }
 
-  getState(type) {
+  getState(type: keyof typeof EventMap) {
     const nextState = super.getState(type);
     // Ensure that the first state sent is `BEGAN` and not `ACTIVE`
     if (
@@ -45,7 +47,7 @@ class PanGestureHandler extends DraggingGestureHandler {
       activeOffsetYEnd,
       minDist,
     } = config;
-    let directions = [];
+    let directions: number[] = [];
     let horizontalDirections = [];
 
     if (!isnan(minDist)) {
@@ -89,7 +91,7 @@ class PanGestureHandler extends DraggingGestureHandler {
   }
 
   getConfig() {
-    if (!this._hasCustomActivationCriteria) {
+    if (!this.hasCustomActivationCriteria) {
       // Default config
       // If no params have been defined then this config should emulate the native gesture as closely as possible.
       return {
@@ -99,7 +101,10 @@ class PanGestureHandler extends DraggingGestureHandler {
     return this.config;
   }
 
-  shouldFailUnderCustomCriteria({ deltaX, deltaY }, criteria) {
+  shouldFailUnderCustomCriteria(
+    { deltaX, deltaY }: HammerInputExt,
+    criteria: any
+  ) {
     return (
       (!isnan(criteria.failOffsetXStart) &&
         deltaX < criteria.failOffsetXStart) ||
@@ -110,7 +115,10 @@ class PanGestureHandler extends DraggingGestureHandler {
     );
   }
 
-  shouldActivateUnderCustomCriteria({ deltaX, deltaY, velocity }, criteria) {
+  shouldActivateUnderCustomCriteria(
+    { deltaX, deltaY, velocity }: any,
+    criteria: any
+  ) {
     return (
       (!isnan(criteria.activeOffsetXStart) &&
         deltaX < criteria.activeOffsetXStart) ||
@@ -130,7 +138,15 @@ class PanGestureHandler extends DraggingGestureHandler {
     );
   }
 
-  shouldMultiFingerPanFail({ pointerLength, scale, deltaRotation }) {
+  shouldMultiFingerPanFail({
+    pointerLength,
+    scale,
+    deltaRotation,
+  }: {
+    deltaRotation: number;
+    pointerLength: number;
+    scale: number;
+  }) {
     if (pointerLength <= 1) {
       return false;
     }
@@ -152,7 +168,9 @@ class PanGestureHandler extends DraggingGestureHandler {
     return false;
   }
 
-  updateHasCustomActivationCriteria(criteria) {
+  updateHasCustomActivationCriteria(
+    criteria: Config & { minVelocityX?: number; minVelocityY?: number }
+  ) {
     return (
       isValidNumber(criteria.minDistSq) ||
       isValidNumber(criteria.minVelocityX) ||
@@ -165,14 +183,18 @@ class PanGestureHandler extends DraggingGestureHandler {
     );
   }
 
-  isGestureEnabledForEvent(props, recognizer, inputData) {
+  isGestureEnabledForEvent(
+    props: any,
+    _recognizer: any,
+    inputData: HammerInputExt & { deltaRotation: number }
+  ) {
     if (this.shouldFailUnderCustomCriteria(inputData, props)) {
       return { failed: true };
     }
 
     const velocity = { x: inputData.velocityX, y: inputData.velocityY };
     if (
-      this._hasCustomActivationCriteria &&
+      this.hasCustomActivationCriteria &&
       this.shouldActivateUnderCustomCriteria(
         { deltaX: inputData.deltaX, deltaY: inputData.deltaY, velocity },
         props
@@ -195,47 +217,4 @@ class PanGestureHandler extends DraggingGestureHandler {
   }
 }
 
-function validateConfig(config = {}) {
-  const isNum = v => isnan(v) || typeof v === 'number';
-  const isBool = v => typeof v === 'boolean';
-
-  const valid = {
-    enabled: isBool,
-    minDistSq: isNum,
-    minVelocityX: isNum,
-    minVelocityY: isNum,
-    // TODO: Bacon: remove `minVelocity`
-    minVelocity: isNum,
-    minVelocitySq: isNum,
-    activeOffsetXStart: isNum,
-    activeOffsetXEnd: isNum,
-    failOffsetXStart: isNum,
-    failOffsetXEnd: isNum,
-    activeOffsetYStart: isNum,
-    activeOffsetYEnd: isNum,
-    failOffsetYStart: isNum,
-    failOffsetYEnd: isNum,
-    hasCustomActivationCriteria: isBool,
-    minPointers: isNum,
-    maxPointers: isNum,
-  };
-  const keys = Object.keys(valid);
-
-  let invalidKeys = [];
-  for (const key of Object.keys(config)) {
-    if (keys.includes(key)) {
-      if (valid[key](config[key])) {
-        console.warn('Invalid type: ' + key + ': ' + config[key]);
-      }
-    } else {
-      invalidKeys.push(key);
-    }
-  }
-
-  if (invalidKeys.length) {
-    throw new Error('Invalid config props found: ' + invalidKeys.join(', '));
-  }
-  return config;
-}
-
 export default PanGestureHandler;
diff --git a/node_modules/react-native-gesture-handler/web/PinchGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/PinchGestureHandler.ts
similarity index 77%
rename from node_modules/react-native-gesture-handler/web/PinchGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/PinchGestureHandler.ts
index 6ecc7ba..3adf5b9 100644
--- a/node_modules/react-native-gesture-handler/web/PinchGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/PinchGestureHandler.ts
@@ -1,4 +1,5 @@
 import Hammer from '@egjs/hammerjs';
+import { HammerInputExt } from './GestureHandler';
 
 import IndiscreteGestureHandler from './IndiscreteGestureHandler';
 
@@ -11,7 +12,7 @@ class PinchGestureHandler extends IndiscreteGestureHandler {
     return Hammer.Pinch;
   }
 
-  transformNativeEvent({ scale, velocity, center }) {
+  transformNativeEvent({ scale, velocity, center }: HammerInputExt) {
     return {
       focalX: center.x,
       focalY: center.y,
diff --git a/node_modules/react-native-gesture-handler/web/PressGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/PressGestureHandler.ts
similarity index 78%
rename from node_modules/react-native-gesture-handler/web/PressGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/PressGestureHandler.ts
index f3dbea1..3852ed6 100644
--- a/node_modules/react-native-gesture-handler/web/PressGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/PressGestureHandler.ts
@@ -1,19 +1,24 @@
 import Hammer from '@egjs/hammerjs';
 
-import State from '../State';
+import { State } from '../State';
 import {
   CONTENT_TOUCHES_DELAY,
   CONTENT_TOUCHES_QUICK_TAP_END_DELAY,
+  HammerInputNames,
 } from './constants';
 import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { Config, HammerInputExt } from './GestureHandler';
 import { fireAfterInterval, isValidNumber, isnan } from './utils';
 
 class PressGestureHandler extends DiscreteGestureHandler {
+  private visualFeedbackTimer: any;
+  private initialEvent: HammerInputExt | null = null;
   get name() {
     return 'press';
   }
 
   get minDurationMs() {
+    // @ts-ignore FIXME(TS)
     return isnan(this.config.minDurationMs) ? 5 : this.config.minDurationMs;
   }
 
@@ -27,17 +32,20 @@ class PressGestureHandler extends DiscreteGestureHandler {
 
   shouldDelayTouches = true;
 
-  simulateCancelEvent(inputData) {
+  simulateCancelEvent(inputData: HammerInputExt) {
     // Long press never starts so we can't rely on the running event boolean.
     this.hasGestureFailed = true;
     this.cancelEvent(inputData);
   }
 
-  updateHasCustomActivationCriteria({ shouldCancelWhenOutside, maxDistSq }) {
+  updateHasCustomActivationCriteria({
+    shouldCancelWhenOutside,
+    maxDistSq,
+  }: Config & { shouldCancelWhenOutside: boolean }) {
     return shouldCancelWhenOutside || !isValidNumber(maxDistSq);
   }
 
-  getState(type) {
+  getState(type: keyof typeof HammerInputNames): State {
     return {
       [Hammer.INPUT_START]: State.BEGAN,
       [Hammer.INPUT_MOVE]: State.ACTIVE,
@@ -47,7 +55,7 @@ class PressGestureHandler extends DiscreteGestureHandler {
   }
 
   getConfig() {
-    if (!this._hasCustomActivationCriteria) {
+    if (!this.hasCustomActivationCriteria) {
       // Default config
       // If no params have been defined then this config should emulate the native gesture as closely as possible.
       return {
@@ -66,26 +74,26 @@ class PressGestureHandler extends DiscreteGestureHandler {
     };
   }
 
-  onGestureActivated(ev) {
+  onGestureActivated(ev: HammerInputExt) {
     this.onGestureStart(ev);
   }
 
-  shouldDelayTouchForEvent({ pointerType }) {
+  shouldDelayTouchForEvent({ pointerType }: HammerInputExt) {
     // Don't disable event for mouse input
     return this.shouldDelayTouches && pointerType === 'touch';
   }
 
-  onGestureStart(ev) {
+  onGestureStart(ev: HammerInputExt) {
     this.isGestureRunning = true;
     clearTimeout(this.visualFeedbackTimer);
     this.initialEvent = ev;
     this.visualFeedbackTimer = fireAfterInterval(() => {
-      this.sendGestureStartedEvent(this.initialEvent);
+      this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);
       this.initialEvent = null;
     }, this.shouldDelayTouchForEvent(ev) && CONTENT_TOUCHES_DELAY);
   }
 
-  sendGestureStartedEvent(ev) {
+  sendGestureStartedEvent(ev: HammerInputExt) {
     clearTimeout(this.visualFeedbackTimer);
     this.visualFeedbackTimer = null;
     this.sendEvent({
@@ -95,14 +103,14 @@ class PressGestureHandler extends DiscreteGestureHandler {
     });
   }
 
-  forceInvalidate(event) {
+  forceInvalidate(event: HammerInputExt) {
     super.forceInvalidate(event);
     clearTimeout(this.visualFeedbackTimer);
     this.visualFeedbackTimer = null;
     this.initialEvent = null;
   }
 
-  onRawEvent(ev) {
+  onRawEvent(ev: HammerInputExt) {
     super.onRawEvent(ev);
     if (this.isGestureRunning) {
       if (ev.isFinal) {
@@ -112,7 +120,7 @@ class PressGestureHandler extends DiscreteGestureHandler {
           // We haven't activated the tap right away to emulate iOS `delaysContentTouches`
           // Now we must send the initial activation event and wait a set amount of time before firing the end event.
           timeout = CONTENT_TOUCHES_QUICK_TAP_END_DELAY;
-          this.sendGestureStartedEvent(this.initialEvent);
+          this.sendGestureStartedEvent(this.initialEvent as HammerInputExt);
           this.initialEvent = null;
         }
         fireAfterInterval(() => {
@@ -121,6 +129,7 @@ class PressGestureHandler extends DiscreteGestureHandler {
             eventType: Hammer.INPUT_END,
             isFinal: true,
           });
+          // @ts-ignore -- this should explicitly support undefined
           this.onGestureEnded();
         }, timeout);
       } else {
diff --git a/node_modules/react-native-gesture-handler/web/RotationGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/RotationGestureHandler.ts
similarity index 69%
rename from node_modules/react-native-gesture-handler/web/RotationGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/RotationGestureHandler.ts
index 908a7d8..c140436 100644
--- a/node_modules/react-native-gesture-handler/web/RotationGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/RotationGestureHandler.ts
@@ -1,6 +1,7 @@
 import Hammer from '@egjs/hammerjs';
 
 import { DEG_RAD } from './constants';
+import { HammerInputExt } from './GestureHandler';
 import IndiscreteGestureHandler from './IndiscreteGestureHandler';
 
 class RotationGestureHandler extends IndiscreteGestureHandler {
@@ -12,9 +13,9 @@ class RotationGestureHandler extends IndiscreteGestureHandler {
     return Hammer.Rotate;
   }
 
-  transformNativeEvent({ rotation, velocity, center }) {
+  transformNativeEvent({ rotation, velocity, center }: HammerInputExt) {
     return {
-      rotation: (rotation - this.initialRotation) * DEG_RAD,
+      rotation: (rotation - (this.initialRotation ?? 0)) * DEG_RAD,
       anchorX: center.x,
       anchorY: center.y,
       velocity,
diff --git a/node_modules/react-native-gesture-handler/web/TapGestureHandler.js b/node_modules/react-native-gesture-handler/src/web/TapGestureHandler.ts
similarity index 78%
rename from node_modules/react-native-gesture-handler/web/TapGestureHandler.js
rename to node_modules/react-native-gesture-handler/src/web/TapGestureHandler.ts
index ae8abae..312049c 100644
--- a/node_modules/react-native-gesture-handler/web/TapGestureHandler.js
+++ b/node_modules/react-native-gesture-handler/src/web/TapGestureHandler.ts
@@ -1,9 +1,13 @@
 import Hammer from '@egjs/hammerjs';
 
 import DiscreteGestureHandler from './DiscreteGestureHandler';
+import { HammerInputExt } from './GestureHandler';
 import { isnan } from './utils';
 
 class TapGestureHandler extends DiscreteGestureHandler {
+  private _shouldFireEndEvent: HammerInputExt | null = null;
+  private _timer: any;
+  private _multiTapTimer: any; // TODO unused?
   get name() {
     return 'tap';
   }
@@ -13,22 +17,23 @@ class TapGestureHandler extends DiscreteGestureHandler {
   }
 
   get maxDelayMs() {
+    // @ts-ignore TODO(TS) trace down config
     return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;
   }
 
-  simulateCancelEvent(inputData) {
+  simulateCancelEvent(inputData: HammerInputExt) {
     if (this.isGestureRunning) {
       this.cancelEvent(inputData);
     }
   }
 
-  onGestureActivated(ev) {
+  onGestureActivated(ev: HammerInputExt) {
     if (this.isGestureRunning) {
       this.onSuccessfulTap(ev);
     }
   }
 
-  onSuccessfulTap = ev => {
+  onSuccessfulTap = (ev: HammerInputExt) => {
     if (this._getPendingGestures().length) {
       this._shouldFireEndEvent = ev;
       return;
@@ -41,7 +46,7 @@ class TapGestureHandler extends DiscreteGestureHandler {
     this.onGestureEnded(ev);
   };
 
-  onRawEvent(ev) {
+  onRawEvent(ev: HammerInput) {
     super.onRawEvent(ev);
 
     // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.
@@ -52,7 +57,8 @@ class TapGestureHandler extends DiscreteGestureHandler {
       !ev.isFinal
     ) {
       // Tap Gesture start event
-      const gesture = this.hammer.get(this.name);
+      const gesture = this.hammer!.get(this.name);
+      // @ts-ignore TODO(TS) trace down config
       if (gesture.options.enable(gesture, ev)) {
         clearTimeout(this._multiTapTimer);
 
@@ -95,7 +101,8 @@ class TapGestureHandler extends DiscreteGestureHandler {
       }, this.maxDelayMs);
     } else if (!this.hasGestureFailed && !this.isGestureRunning) {
       // Tap Gesture start event
-      const gesture = this.hammer.get(this.name);
+      const gesture = this.hammer!.get(this.name);
+      // @ts-ignore TODO(TS) trace down config
       if (gesture.options.enable(gesture, ev)) {
         clearTimeout(this._multiTapTimer);
 
@@ -109,12 +116,15 @@ class TapGestureHandler extends DiscreteGestureHandler {
     return {
       ...super.getHammerConfig(),
       event: this.name,
+      // @ts-ignore TODO(TS) trace down config
       taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,
       interval: this.maxDelayMs,
       time:
+        // @ts-ignore TODO(TS) trace down config
         isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null
           ? 250
-          : this.config.maxDurationMs,
+          : // @ts-ignore TODO(TS) trace down config
+            this.config.maxDurationMs,
     };
   }
 
@@ -125,6 +135,7 @@ class TapGestureHandler extends DiscreteGestureHandler {
     numberOfTaps = 1,
     minDurationMs = 525,
     maxDelayMs = Number.NaN,
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO possibly forgotten to use in updateGestureConfig?
     maxDurationMs = Number.NaN,
     maxDist = 2,
     minPointers = 1,
@@ -145,12 +156,13 @@ class TapGestureHandler extends DiscreteGestureHandler {
     });
   }
 
-  onGestureEnded(...props) {
+  onGestureEnded(...props: any) {
     clearTimeout(this._timer);
+    // @ts-ignore TODO(TS) check how onGestureEnded works
     super.onGestureEnded(...props);
   }
 
-  onWaitingEnded(gesture) {
+  onWaitingEnded(_gesture: any) {
     if (this._shouldFireEndEvent) {
       this.onSuccessfulTap(this._shouldFireEndEvent);
       this._shouldFireEndEvent = null;
diff --git a/node_modules/react-native-gesture-handler/web/constants.js b/node_modules/react-native-gesture-handler/src/web/constants.ts
similarity index 96%
rename from node_modules/react-native-gesture-handler/web/constants.js
rename to node_modules/react-native-gesture-handler/src/web/constants.ts
index 3e0f85e..71b792b 100644
--- a/node_modules/react-native-gesture-handler/web/constants.js
+++ b/node_modules/react-native-gesture-handler/src/web/constants.ts
@@ -1,6 +1,6 @@
 import Hammer from '@egjs/hammerjs';
 
-import State from '../State';
+import { State } from '../State';
 
 export const CONTENT_TOUCHES_DELAY = 240;
 export const CONTENT_TOUCHES_QUICK_TAP_END_DELAY = 50;
@@ -14,7 +14,7 @@ export const EventMap = {
   [Hammer.INPUT_MOVE]: State.ACTIVE,
   [Hammer.INPUT_END]: State.END,
   [Hammer.INPUT_CANCEL]: State.FAILED,
-};
+} as const;
 
 export const Direction = {
   RIGHT: 1,
diff --git a/node_modules/react-native-gesture-handler/src/web/utils.ts b/node_modules/react-native-gesture-handler/src/web/utils.ts
new file mode 100644
index 0000000..caf029c
--- /dev/null
+++ b/node_modules/react-native-gesture-handler/src/web/utils.ts
@@ -0,0 +1,24 @@
+// TODO(TS) remove if not necessary after rewrite
+export const isnan = (v: unknown) => Number.isNaN(v);
+
+// TODO(TS) remove if not necessary after rewrite
+export const isValidNumber = (v: unknown) =>
+  typeof v === 'number' && !Number.isNaN(v);
+
+export const TEST_MIN_IF_NOT_NAN = (value: number, limit: number): boolean =>
+  !isnan(limit) &&
+  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));
+export const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;
+export const TEST_MAX_IF_NOT_NAN = (value: number, max: number) =>
+  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));
+
+export function fireAfterInterval(
+  method: () => void,
+  interval?: number | boolean
+) {
+  if (!interval) {
+    method();
+    return null;
+  }
+  return setTimeout(() => method(), interval);
+}
diff --git a/node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.android.js b/node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.android.js
deleted file mode 100644
index 774111f..0000000
--- a/node_modules/react-native-gesture-handler/touchables/TouchableNativeFeedback.android.js
+++ /dev/null
@@ -1,72 +0,0 @@
-import { Platform } from 'react-native';
-import React, { Component } from 'react';
-import PropTypes from 'prop-types';
-import GenericTouchable from './GenericTouchable';
-
-/**
- * TouchableNativeFeedback behaves slightly different than RN's TouchableNativeFeedback.
- * There's small difference with handling long press ripple since RN's implementation calls
- * ripple animation via bridge. This solution leaves all animations' handling for native components so
- * it follows native behaviours.
- */
-export default class TouchableNativeFeedback extends Component {
-  static SelectableBackground = rippleRadius => ({
-    type: 'SelectableBackground',
-    rippleRadius,
-  });
-  static SelectableBackgroundBorderless = rippleRadius => ({
-    type: 'SelectableBackgroundBorderless',
-    rippleRadius,
-  });
-  static Ripple = (color, borderless, rippleRadius) => ({
-    type: 'Ripple',
-    color,
-    borderless,
-    rippleRadius,
-  });
-
-  static canUseNativeForeground = () => Platform.Version >= 23;
-
-  static defaultProps = {
-    ...GenericTouchable.defaultProps,
-    useForeground: true,
-    extraButtonProps: {
-      // Disable hiding ripple on Android
-      rippleColor: null,
-    },
-  };
-
-  static propTypes = {
-    ...GenericTouchable.publicPropTypes,
-    useForeground: PropTypes.bool,
-    background: PropTypes.object,
-    style: PropTypes.any,
-  };
-
-  getExtraButtonProps() {
-    const extraProps = {};
-    const { background } = this.props;
-    if (background) {
-      if (background.type === 'Ripple') {
-        extraProps['borderless'] = background.borderless;
-        extraProps['rippleColor'] = background.color;
-        extraProps['rippleRadius'] = background.rippleRadius;
-      } else if (background.type === 'SelectableBackgroundBorderless') {
-        extraProps['borderless'] = true;
-        extraProps['rippleRadius'] = background.rippleRadius;
-      }
-    }
-    extraProps['foreground'] = this.props.useForeground;
-    return extraProps;
-  }
-  render() {
-    const { style = {}, ...rest } = this.props;
-    return (
-      <GenericTouchable
-        {...rest}
-        style={style}
-        extraButtonProps={this.getExtraButtonProps()}
-      />
-    );
-  }
-}
diff --git a/node_modules/react-native-gesture-handler/touchables/TouchableWithoutFeedback.js b/node_modules/react-native-gesture-handler/touchables/TouchableWithoutFeedback.js
deleted file mode 100644
index 755e090..0000000
--- a/node_modules/react-native-gesture-handler/touchables/TouchableWithoutFeedback.js
+++ /dev/null
@@ -1,12 +0,0 @@
-import React from 'react';
-import GenericTouchable from './GenericTouchable';
-
-const TouchableWithoutFeedback = React.forwardRef((props, ref) => (
-  <GenericTouchable ref={ref} {...props} />
-));
-
-TouchableWithoutFeedback.defaultProps = GenericTouchable.defaultProps;
-
-TouchableWithoutFeedback.propTypes = GenericTouchable.publicPropTypes;
-
-export default TouchableWithoutFeedback;
diff --git a/node_modules/react-native-gesture-handler/web/Errors.js b/node_modules/react-native-gesture-handler/web/Errors.js
deleted file mode 100644
index 29f1540..0000000
--- a/node_modules/react-native-gesture-handler/web/Errors.js
+++ /dev/null
@@ -1,5 +0,0 @@
-export class GesturePropError extends Error {
-  constructor(name, value, expectedType) {
-    super(`Invalid property \`${name}: ${value}\` expected \`${expectedType}\``);
-  }
-}
diff --git a/node_modules/react-native-gesture-handler/web/NodeManager.js b/node_modules/react-native-gesture-handler/web/NodeManager.js
deleted file mode 100644
index 99fba18..0000000
--- a/node_modules/react-native-gesture-handler/web/NodeManager.js
+++ /dev/null
@@ -1,24 +0,0 @@
-let gestures = {};
-
-export function getHandler(tag) {
-  if (tag in gestures) return gestures[tag];
-
-  throw new Error('No handler for tag ' + tag);
-}
-
-export function createGestureHandler(handlerTag, handler) {
-  if (handlerTag in gestures) {
-    throw new Error('Handler with tag ' + handlerTag + ' already exists');
-  }
-  gestures[handlerTag] = handler;
-  gestures[handlerTag].handlerTag = handlerTag;
-}
-
-export function dropGestureHandler(handlerTag) {
-  getHandler(handlerTag).destroy();
-  delete gestures[handlerTag];
-}
-
-export function getNodes() {
-  return { ...gestures };
-}
diff --git a/node_modules/react-native-gesture-handler/web/utils.js b/node_modules/react-native-gesture-handler/web/utils.js
deleted file mode 100644
index b72cdb4..0000000
--- a/node_modules/react-native-gesture-handler/web/utils.js
+++ /dev/null
@@ -1,18 +0,0 @@
-export const isnan = v => Number.isNaN(v);
-
-export const isValidNumber = v => typeof v === 'number' && !Number.isNaN(v);
-
-export const TEST_MIN_IF_NOT_NAN = (value, limit) =>
-  !isnan(limit) &&
-  ((limit < 0 && value <= limit) || (limit >= 0 && value >= limit));
-export const VEC_LEN_SQ = ({ x = 0, y = 0 } = {}) => x * x + y * y;
-export const TEST_MAX_IF_NOT_NAN = (value, max) =>
-  !isnan(max) && ((max < 0 && value < max) || (max >= 0 && value > max));
-
-export function fireAfterInterval(method, interval) {
-  if (!interval) {
-    method();
-    return null;
-  }
-  return setTimeout(() => method(), interval);
-}
