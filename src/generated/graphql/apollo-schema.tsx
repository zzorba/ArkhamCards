import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  _text: { input: any; output: any; }
  bigint: { input: any; output: any; }
  float8: { input: any; output: any; }
  json: { input: any; output: any; }
  jsonb: { input: any; output: any; }
  timestamp: { input: any; output: any; }
  timestamptz: { input: any; output: any; }
  uuid: { input: any; output: any; }
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export type CreateCampaignInput = {
  campaignId: Scalars['String']['input'];
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<LinkedCampaignId>;
};

export type CreateCampaignOutput = {
  __typename?: 'CreateCampaignOutput';
  campaignId: Scalars['Int']['output'];
  campaignIdA?: Maybe<Scalars['Int']['output']>;
  campaignIdB?: Maybe<Scalars['Int']['output']>;
};

export type CreateDeckInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  ignoreDeckLimitSlots: Scalars['jsonb']['input'];
  investigator: Scalars['String']['input'];
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name: Scalars['String']['input'];
  problem?: InputMaybe<Scalars['String']['input']>;
  slots: Scalars['jsonb']['input'];
  tabooSetId?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

export type CreateDeckOutput = {
  __typename?: 'CreateDeckOutput';
  deck?: Maybe<Arkhamdb_Deck>;
  deckId: Scalars['String']['output'];
};

export type DeckId = {
  __typename?: 'DeckId';
  campaignId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
};

export type DeleteCampaignInput = {
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
};

export type DeleteCampaignOutput = {
  __typename?: 'DeleteCampaignOutput';
  campaignId: Scalars['Int']['output'];
};

export type DeleteDeckInput = {
  deckId: Scalars['Int']['input'];
  deleteAllVersions: Scalars['Boolean']['input'];
};

export type DeleteDeckOutput = {
  __typename?: 'DeleteDeckOutput';
  success: Scalars['Boolean']['output'];
};

export enum EditAccessAction {
  Grant = 'grant',
  Revoke = 'revoke'
}

export type EditCampaignAccessInput = {
  action: EditAccessAction;
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
  users: Array<Scalars['String']['input']>;
};

export type EditCampaignAccessOutput = {
  __typename?: 'EditCampaignAccessOutput';
  campaignId: Scalars['Int']['output'];
};

export enum FriendRequestAction {
  Request = 'request',
  Revoke = 'revoke'
}

export type FriendRequestInput = {
  action: FriendRequestAction;
  userId: Scalars['String']['input'];
};

export type FriendRequestOutput = {
  __typename?: 'FriendRequestOutput';
  success: Scalars['Boolean']['output'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

export type LinkedCampaignId = {
  campaignIdA: Scalars['String']['input'];
  campaignIdB: Scalars['String']['input'];
};

export type LoginInput = {
  code: Scalars['String']['input'];
  redirectUri: Scalars['String']['input'];
  state: Scalars['String']['input'];
};

export type LoginOutput = {
  __typename?: 'LoginOutput';
  success: Scalars['Boolean']['output'];
};

export type LogoutOutput = {
  __typename?: 'LogoutOutput';
  success: Scalars['Boolean']['output'];
};

export type MigrateLoginInput = {
  accessToken: Scalars['String']['input'];
  refreshToken: Scalars['String']['input'];
};

export type MigrateLoginOutput = {
  __typename?: 'MigrateLoginOutput';
  success: Scalars['Boolean']['output'];
};

export type RefreshDecksInput = {
  force: Scalars['Boolean']['input'];
};

export type RefreshDecksOutput = {
  __typename?: 'RefreshDecksOutput';
  updated: Scalars['Boolean']['output'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateHandleInput = {
  handle: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['String']['input']>;
};

export type UpdateHandleOutput = {
  __typename?: 'UpdateHandleOutput';
  success: Scalars['Boolean']['output'];
  user?: Maybe<Users>;
  userId: Scalars['String']['output'];
};

export type UpgradeDeckInput = {
  deckId: Scalars['Int']['input'];
  exiles?: InputMaybe<Scalars['jsonb']['input']>;
  xp: Scalars['Int']['input'];
};

export type UpgradeDeckOutput = {
  __typename?: 'UpgradeDeckOutput';
  deckId: Scalars['Int']['output'];
  upgradedDeckId: Scalars['Int']['output'];
};

export type UploadLocalCampaignDeckInput = {
  arkhamDbId: Scalars['Int']['input'];
  localDeckId: Scalars['String']['input'];
};

export type UploadLocalCampaignDeckOutput = {
  __typename?: 'UploadLocalCampaignDeckOutput';
  deckIds: Array<DeckId>;
};

export type UserSearchResult = {
  __typename?: 'UserSearchResult';
  handle: Scalars['String']['output'];
  id: Scalars['String']['output'];
};

export type UsersSearchInput = {
  continueToken?: InputMaybe<Scalars['String']['input']>;
  search: Scalars['String']['input'];
};

export type UsersSearchOutput = {
  __typename?: 'UsersSearchOutput';
  hasMore: Scalars['String']['output'];
  users: Array<UserSearchResult>;
};

/** columns and relationships of "all_card" */
export type All_Card = {
  __typename?: 'all_card';
  alt_art_investigator?: Maybe<Scalars['Boolean']['output']>;
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  clues_fixed?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  customization_options?: Maybe<Scalars['jsonb']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  encounter_sets: Array<Card_Encounter_Set>;
  /** An aggregate relationship */
  encounter_sets_aggregate: Card_Encounter_Set_Aggregate;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code: Scalars['String']['output'];
  gender?: Maybe<Gender_Enum>;
  heals_damage?: Maybe<Scalars['Boolean']['output']>;
  heals_horror?: Maybe<Scalars['Boolean']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  health_per_investigator?: Maybe<Scalars['Boolean']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  linked?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  linked_card?: Maybe<All_Card>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  official: Scalars['Boolean']['output'];
  /** An object relationship */
  pack: Pack;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  preview?: Maybe<Scalars['Boolean']['output']>;
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  side_deck_options?: Maybe<Scalars['jsonb']['output']>;
  side_deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_placeholder?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  taboo_set?: Maybe<Taboo_Set>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  tags?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  translations: Array<All_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: All_Card_Text_Aggregate;
  /** An object relationship */
  type: Card_Type_Code;
  type_code: Card_Type_Code_Enum;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version: Scalars['Int']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "all_card" */
export type All_CardCustomization_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardEncounter_SetsArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardEncounter_Sets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardSide_Deck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardSide_Deck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "all_card" */
export type All_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


/** columns and relationships of "all_card" */
export type All_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};

/** aggregated selection of "all_card" */
export type All_Card_Aggregate = {
  __typename?: 'all_card_aggregate';
  aggregate?: Maybe<All_Card_Aggregate_Fields>;
  nodes: Array<All_Card>;
};

export type All_Card_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<All_Card_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<All_Card_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<All_Card_Aggregate_Bool_Exp_Count>;
};

export type All_Card_Aggregate_Bool_Exp_Bool_And = {
  arguments: All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type All_Card_Aggregate_Bool_Exp_Bool_Or = {
  arguments: All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type All_Card_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<All_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "all_card" */
export type All_Card_Aggregate_Fields = {
  __typename?: 'all_card_aggregate_fields';
  avg?: Maybe<All_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Max_Fields>;
  min?: Maybe<All_Card_Min_Fields>;
  stddev?: Maybe<All_Card_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Sum_Fields>;
  var_pop?: Maybe<All_Card_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Variance_Fields>;
};


/** aggregate fields of "all_card" */
export type All_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "all_card" */
export type All_Card_Aggregate_Order_By = {
  avg?: InputMaybe<All_Card_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<All_Card_Max_Order_By>;
  min?: InputMaybe<All_Card_Min_Order_By>;
  stddev?: InputMaybe<All_Card_Stddev_Order_By>;
  stddev_pop?: InputMaybe<All_Card_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<All_Card_Stddev_Samp_Order_By>;
  sum?: InputMaybe<All_Card_Sum_Order_By>;
  var_pop?: InputMaybe<All_Card_Var_Pop_Order_By>;
  var_samp?: InputMaybe<All_Card_Var_Samp_Order_By>;
  variance?: InputMaybe<All_Card_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type All_Card_Append_Input = {
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "all_card" */
export type All_Card_Arr_Rel_Insert_Input = {
  data: Array<All_Card_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};

/** aggregate avg on columns */
export type All_Card_Avg_Fields = {
  __typename?: 'all_card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "all_card" */
export type All_Card_Avg_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "all_card". All fields are combined with a logical 'AND'. */
export type All_Card_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Bool_Exp>>;
  alt_art_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  alternate_of_code?: InputMaybe<String_Comparison_Exp>;
  alternate_required_code?: InputMaybe<String_Comparison_Exp>;
  back_illustrator?: InputMaybe<String_Comparison_Exp>;
  back_link_id?: InputMaybe<String_Comparison_Exp>;
  backimagesrc?: InputMaybe<String_Comparison_Exp>;
  backimageurl?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  clues_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  customization_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  duplicate_of_code?: InputMaybe<String_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  errata_date?: InputMaybe<String_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction2_code?: InputMaybe<String_Comparison_Exp>;
  faction3_code?: InputMaybe<String_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  gender?: InputMaybe<Gender_Enum_Comparison_Exp>;
  heals_damage?: InputMaybe<Boolean_Comparison_Exp>;
  heals_horror?: InputMaybe<Boolean_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  health_per_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  imageurl?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  linked?: InputMaybe<Boolean_Comparison_Exp>;
  linked_card?: InputMaybe<All_Card_Bool_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  pack?: InputMaybe<Pack_Bool_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preview?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_back_traits?: InputMaybe<String_Comparison_Exp>;
  real_customization_change?: InputMaybe<String_Comparison_Exp>;
  real_customization_text?: InputMaybe<String_Comparison_Exp>;
  real_encounter_set_name?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_taboo_original_back_text?: InputMaybe<String_Comparison_Exp>;
  real_taboo_original_text?: InputMaybe<String_Comparison_Exp>;
  real_taboo_text_change?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  side_deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  side_deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  taboo_placeholder?: InputMaybe<Boolean_Comparison_Exp>;
  taboo_set?: InputMaybe<Taboo_Set_Bool_Exp>;
  taboo_set_id?: InputMaybe<Int_Comparison_Exp>;
  taboo_xp?: InputMaybe<Int_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  translations?: InputMaybe<All_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<All_Card_Text_Aggregate_Bool_Exp>;
  type?: InputMaybe<Card_Type_Code_Bool_Exp>;
  type_code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vengeance?: InputMaybe<Int_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
  xp?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card" */
export enum All_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  AllCardIdKey = 'all_card_id_key',
  /** unique or primary key constraint on columns "id" */
  AllCardPkey = 'all_card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type All_Card_Delete_At_Path_Input = {
  customization_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
  side_deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  side_deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type All_Card_Delete_Elem_Input = {
  customization_options?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['Int']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type All_Card_Delete_Key_Input = {
  customization_options?: InputMaybe<Scalars['String']['input']>;
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
  side_deck_options?: InputMaybe<Scalars['String']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "all_card" */
export type All_Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card" */
export type All_Card_Insert_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Arr_Rel_Insert_Input>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  linked_card?: InputMaybe<All_Card_Obj_Rel_Insert_Input>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack?: InputMaybe<Pack_Obj_Rel_Insert_Input>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set?: InputMaybe<Taboo_Set_Obj_Rel_Insert_Input>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  translations?: InputMaybe<All_Card_Text_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Card_Type_Code_Obj_Rel_Insert_Input>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type All_Card_Max_Fields = {
  __typename?: 'all_card_max_fields';
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "all_card" */
export type All_Card_Max_Order_By = {
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type All_Card_Min_Fields = {
  __typename?: 'all_card_min_fields';
  alternate_of_code?: Maybe<Scalars['String']['output']>;
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_illustrator?: Maybe<Scalars['String']['output']>;
  back_link_id?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  backimageurl?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  duplicate_of_code?: Maybe<Scalars['String']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  errata_date?: Maybe<Scalars['String']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  imageurl?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_customization_change?: Maybe<Scalars['String']['output']>;
  real_customization_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  real_taboo_original_text?: Maybe<Scalars['String']['output']>;
  real_taboo_text_change?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "all_card" */
export type All_Card_Min_Order_By = {
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "all_card" */
export type All_Card_Mutation_Response = {
  __typename?: 'all_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card>;
};

/** input type for inserting object relation for remote table "all_card" */
export type All_Card_Obj_Rel_Insert_Input = {
  data: All_Card_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};

/** on_conflict condition type for table "all_card" */
export type All_Card_On_Conflict = {
  constraint: All_Card_Constraint;
  update_columns?: Array<All_Card_Update_Column>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card". */
export type All_Card_Order_By = {
  alt_art_investigator?: InputMaybe<Order_By>;
  alternate_of_code?: InputMaybe<Order_By>;
  alternate_required_code?: InputMaybe<Order_By>;
  back_illustrator?: InputMaybe<Order_By>;
  back_link_id?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  backimageurl?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  clues_fixed?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  customization_options?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  duplicate_of_code?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  errata_date?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  gender?: InputMaybe<Order_By>;
  heals_damage?: InputMaybe<Order_By>;
  heals_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  health_per_investigator?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  imageurl?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  linked?: InputMaybe<Order_By>;
  linked_card?: InputMaybe<All_Card_Order_By>;
  myriad?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  pack?: InputMaybe<Pack_Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preview?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_customization_change?: InputMaybe<Order_By>;
  real_customization_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_taboo_original_back_text?: InputMaybe<Order_By>;
  real_taboo_original_text?: InputMaybe<Order_By>;
  real_taboo_text_change?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  side_deck_options?: InputMaybe<Order_By>;
  side_deck_requirements?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  taboo_placeholder?: InputMaybe<Order_By>;
  taboo_set?: InputMaybe<Taboo_Set_Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<All_Card_Text_Aggregate_Order_By>;
  type?: InputMaybe<Card_Type_Code_Order_By>;
  type_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card */
export type All_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type All_Card_Prepend_Input = {
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "all_card" */
export enum All_Card_Select_Column {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  AlternateOfCode = 'alternate_of_code',
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackIllustrator = 'back_illustrator',
  /** column name */
  BackLinkId = 'back_link_id',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CustomizationOptions = 'customization_options',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  DuplicateOfCode = 'duplicate_of_code',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  ErrataDate = 'errata_date',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Gender = 'gender',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Preview = 'preview',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealCustomizationChange = 'real_customization_change',
  /** column name */
  RealCustomizationText = 'real_customization_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealTabooOriginalBackText = 'real_taboo_original_back_text',
  /** column name */
  RealTabooOriginalText = 'real_taboo_original_text',
  /** column name */
  RealTabooTextChange = 'real_taboo_text_change',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SideDeckOptions = 'side_deck_options',
  /** column name */
  SideDeckRequirements = 'side_deck_requirements',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  TabooXp = 'taboo_xp',
  /** column name */
  Tags = 'tags',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** select "all_card_aggregate_bool_exp_bool_and_arguments_columns" columns of table "all_card" */
export enum All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Preview = 'preview',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder'
}

/** select "all_card_aggregate_bool_exp_bool_or_arguments_columns" columns of table "all_card" */
export enum All_Card_Select_Column_All_Card_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Preview = 'preview',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder'
}

/** input type for updating data in table "all_card" */
export type All_Card_Set_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Stddev_Fields = {
  __typename?: 'all_card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "all_card" */
export type All_Card_Stddev_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Stddev_Pop_Fields = {
  __typename?: 'all_card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "all_card" */
export type All_Card_Stddev_Pop_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Stddev_Samp_Fields = {
  __typename?: 'all_card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "all_card" */
export type All_Card_Stddev_Samp_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "all_card" */
export type All_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Stream_Cursor_Value_Input = {
  alt_art_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  alternate_of_code?: InputMaybe<Scalars['String']['input']>;
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_illustrator?: InputMaybe<Scalars['String']['input']>;
  back_link_id?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  backimageurl?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  customization_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  duplicate_of_code?: InputMaybe<Scalars['String']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  errata_date?: InputMaybe<Scalars['String']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  gender?: InputMaybe<Gender_Enum>;
  heals_damage?: InputMaybe<Scalars['Boolean']['input']>;
  heals_horror?: InputMaybe<Scalars['Boolean']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  imageurl?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preview?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_customization_change?: InputMaybe<Scalars['String']['input']>;
  real_customization_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  real_taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  side_deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  side_deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  taboo_placeholder?: InputMaybe<Scalars['Boolean']['input']>;
  taboo_set_id?: InputMaybe<Scalars['Int']['input']>;
  taboo_xp?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Sum_Fields = {
  __typename?: 'all_card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  taboo_set_id?: Maybe<Scalars['Int']['output']>;
  taboo_xp?: Maybe<Scalars['Int']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "all_card" */
export type All_Card_Sum_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** columns and relationships of "all_card_text" */
export type All_Card_Text = {
  __typename?: 'all_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "all_card_text" */
export type All_Card_Text_Aggregate = {
  __typename?: 'all_card_text_aggregate';
  aggregate?: Maybe<All_Card_Text_Aggregate_Fields>;
  nodes: Array<All_Card_Text>;
};

export type All_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<All_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type All_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<All_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "all_card_text" */
export type All_Card_Text_Aggregate_Fields = {
  __typename?: 'all_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Text_Max_Fields>;
  min?: Maybe<All_Card_Text_Min_Fields>;
};


/** aggregate fields of "all_card_text" */
export type All_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "all_card_text" */
export type All_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<All_Card_Text_Max_Order_By>;
  min?: InputMaybe<All_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "all_card_text" */
export type All_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<All_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "all_card_text". All fields are combined with a logical 'AND'. */
export type All_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  customization_change?: InputMaybe<String_Comparison_Exp>;
  customization_text?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  taboo_original_back_text?: InputMaybe<String_Comparison_Exp>;
  taboo_original_text?: InputMaybe<String_Comparison_Exp>;
  taboo_text_change?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card_text" */
export enum All_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AllCardTextPkey = 'all_card_text_pkey'
}

/** input type for inserting data into table "all_card_text" */
export type All_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type All_Card_Text_Max_Fields = {
  __typename?: 'all_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "all_card_text" */
export type All_Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type All_Card_Text_Min_Fields = {
  __typename?: 'all_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  customization_change?: Maybe<Scalars['String']['output']>;
  customization_text?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  taboo_original_back_text?: Maybe<Scalars['String']['output']>;
  taboo_original_text?: Maybe<Scalars['String']['output']>;
  taboo_text_change?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "all_card_text" */
export type All_Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "all_card_text" */
export type All_Card_Text_Mutation_Response = {
  __typename?: 'all_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Text>;
};

/** on_conflict condition type for table "all_card_text" */
export type All_Card_Text_On_Conflict = {
  constraint: All_Card_Text_Constraint;
  update_columns?: Array<All_Card_Text_Update_Column>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_text". */
export type All_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  customization_change?: InputMaybe<Order_By>;
  customization_text?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  taboo_original_back_text?: InputMaybe<Order_By>;
  taboo_original_text?: InputMaybe<Order_By>;
  taboo_text_change?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_text */
export type All_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "all_card_text" */
export enum All_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  CustomizationChange = 'customization_change',
  /** column name */
  CustomizationText = 'customization_text',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  TabooOriginalBackText = 'taboo_original_back_text',
  /** column name */
  TabooOriginalText = 'taboo_original_text',
  /** column name */
  TabooTextChange = 'taboo_text_change',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "all_card_text" */
export type All_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "all_card_text" */
export type All_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  customization_change?: InputMaybe<Scalars['String']['input']>;
  customization_text?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  taboo_original_back_text?: InputMaybe<Scalars['String']['input']>;
  taboo_original_text?: InputMaybe<Scalars['String']['input']>;
  taboo_text_change?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "all_card_text" */
export enum All_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  CustomizationChange = 'customization_change',
  /** column name */
  CustomizationText = 'customization_text',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  TabooOriginalBackText = 'taboo_original_back_text',
  /** column name */
  TabooOriginalText = 'taboo_original_text',
  /** column name */
  TabooTextChange = 'taboo_text_change',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type All_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Text_Bool_Exp;
};

/** update columns of table "all_card" */
export enum All_Card_Update_Column {
  /** column name */
  AltArtInvestigator = 'alt_art_investigator',
  /** column name */
  AlternateOfCode = 'alternate_of_code',
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackIllustrator = 'back_illustrator',
  /** column name */
  BackLinkId = 'back_link_id',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Backimageurl = 'backimageurl',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  CustomizationOptions = 'customization_options',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  DuplicateOfCode = 'duplicate_of_code',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  ErrataDate = 'errata_date',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Gender = 'gender',
  /** column name */
  HealsDamage = 'heals_damage',
  /** column name */
  HealsHorror = 'heals_horror',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Imageurl = 'imageurl',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Linked = 'linked',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  Official = 'official',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Preview = 'preview',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealCustomizationChange = 'real_customization_change',
  /** column name */
  RealCustomizationText = 'real_customization_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealTabooOriginalBackText = 'real_taboo_original_back_text',
  /** column name */
  RealTabooOriginalText = 'real_taboo_original_text',
  /** column name */
  RealTabooTextChange = 'real_taboo_text_change',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SideDeckOptions = 'side_deck_options',
  /** column name */
  SideDeckRequirements = 'side_deck_requirements',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TabooPlaceholder = 'taboo_placeholder',
  /** column name */
  TabooSetId = 'taboo_set_id',
  /** column name */
  TabooXp = 'taboo_xp',
  /** column name */
  Tags = 'tags',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** columns and relationships of "all_card_updated" */
export type All_Card_Updated = {
  __typename?: 'all_card_updated';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at: Scalars['timestamp']['output'];
  locale: Scalars['String']['output'];
  translation_updated_at: Scalars['timestamp']['output'];
};

/** aggregated selection of "all_card_updated" */
export type All_Card_Updated_Aggregate = {
  __typename?: 'all_card_updated_aggregate';
  aggregate?: Maybe<All_Card_Updated_Aggregate_Fields>;
  nodes: Array<All_Card_Updated>;
};

/** aggregate fields of "all_card_updated" */
export type All_Card_Updated_Aggregate_Fields = {
  __typename?: 'all_card_updated_aggregate_fields';
  avg?: Maybe<All_Card_Updated_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Updated_Max_Fields>;
  min?: Maybe<All_Card_Updated_Min_Fields>;
  stddev?: Maybe<All_Card_Updated_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Updated_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Updated_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Updated_Sum_Fields>;
  var_pop?: Maybe<All_Card_Updated_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Updated_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Updated_Variance_Fields>;
};


/** aggregate fields of "all_card_updated" */
export type All_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type All_Card_Updated_Avg_Fields = {
  __typename?: 'all_card_updated_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "all_card_updated". All fields are combined with a logical 'AND'. */
export type All_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Updated_Bool_Exp>>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  translation_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** columns and relationships of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version = {
  __typename?: 'all_card_updated_by_version';
  card_count: Scalars['Int']['output'];
  cards_updated_at: Scalars['timestamp']['output'];
  locale: Scalars['String']['output'];
  translation_updated_at: Scalars['timestamp']['output'];
  version: Scalars['Int']['output'];
};

/** aggregated selection of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate = {
  __typename?: 'all_card_updated_by_version_aggregate';
  aggregate?: Maybe<All_Card_Updated_By_Version_Aggregate_Fields>;
  nodes: Array<All_Card_Updated_By_Version>;
};

/** aggregate fields of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate_Fields = {
  __typename?: 'all_card_updated_by_version_aggregate_fields';
  avg?: Maybe<All_Card_Updated_By_Version_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<All_Card_Updated_By_Version_Max_Fields>;
  min?: Maybe<All_Card_Updated_By_Version_Min_Fields>;
  stddev?: Maybe<All_Card_Updated_By_Version_Stddev_Fields>;
  stddev_pop?: Maybe<All_Card_Updated_By_Version_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<All_Card_Updated_By_Version_Stddev_Samp_Fields>;
  sum?: Maybe<All_Card_Updated_By_Version_Sum_Fields>;
  var_pop?: Maybe<All_Card_Updated_By_Version_Var_Pop_Fields>;
  var_samp?: Maybe<All_Card_Updated_By_Version_Var_Samp_Fields>;
  variance?: Maybe<All_Card_Updated_By_Version_Variance_Fields>;
};


/** aggregate fields of "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type All_Card_Updated_By_Version_Avg_Fields = {
  __typename?: 'all_card_updated_by_version_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "all_card_updated_by_version". All fields are combined with a logical 'AND'. */
export type All_Card_Updated_By_Version_Bool_Exp = {
  _and?: InputMaybe<Array<All_Card_Updated_By_Version_Bool_Exp>>;
  _not?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
  _or?: InputMaybe<Array<All_Card_Updated_By_Version_Bool_Exp>>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  translation_updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Constraint {
  /** unique or primary key constraint on columns "locale", "version" */
  AllCardUpdatedByVersionPkey = 'all_card_updated_by_version_pkey'
}

/** input type for incrementing numeric columns in table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Insert_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type All_Card_Updated_By_Version_Max_Fields = {
  __typename?: 'all_card_updated_by_version_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type All_Card_Updated_By_Version_Min_Fields = {
  __typename?: 'all_card_updated_by_version_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Mutation_Response = {
  __typename?: 'all_card_updated_by_version_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Updated_By_Version>;
};

/** on_conflict condition type for table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_On_Conflict = {
  constraint: All_Card_Updated_By_Version_Constraint;
  update_columns?: Array<All_Card_Updated_By_Version_Update_Column>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_updated_by_version". */
export type All_Card_Updated_By_Version_Order_By = {
  card_count?: InputMaybe<Order_By>;
  cards_updated_at?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  translation_updated_at?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_updated_by_version */
export type All_Card_Updated_By_Version_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};

/** select columns of table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Select_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Set_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Updated_By_Version_Stddev_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Updated_By_Version_Stddev_Pop_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Updated_By_Version_Stddev_Samp_Fields = {
  __typename?: 'all_card_updated_by_version_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "all_card_updated_by_version" */
export type All_Card_Updated_By_Version_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Updated_By_Version_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Updated_By_Version_Stream_Cursor_Value_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Updated_By_Version_Sum_Fields = {
  __typename?: 'all_card_updated_by_version_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "all_card_updated_by_version" */
export enum All_Card_Updated_By_Version_Update_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at',
  /** column name */
  Version = 'version'
}

export type All_Card_Updated_By_Version_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Updated_By_Version_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Updated_By_Version_Var_Pop_Fields = {
  __typename?: 'all_card_updated_by_version_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type All_Card_Updated_By_Version_Var_Samp_Fields = {
  __typename?: 'all_card_updated_by_version_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type All_Card_Updated_By_Version_Variance_Fields = {
  __typename?: 'all_card_updated_by_version_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** unique or primary key constraints on table "all_card_updated" */
export enum All_Card_Updated_Constraint {
  /** unique or primary key constraint on columns "locale" */
  AllCardUpdatedPkey = 'all_card_updated_pkey'
}

/** input type for incrementing numeric columns in table "all_card_updated" */
export type All_Card_Updated_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "all_card_updated" */
export type All_Card_Updated_Insert_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type All_Card_Updated_Max_Fields = {
  __typename?: 'all_card_updated_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** aggregate min on columns */
export type All_Card_Updated_Min_Fields = {
  __typename?: 'all_card_updated_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  cards_updated_at?: Maybe<Scalars['timestamp']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  translation_updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** response of any mutation on the table "all_card_updated" */
export type All_Card_Updated_Mutation_Response = {
  __typename?: 'all_card_updated_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<All_Card_Updated>;
};

/** on_conflict condition type for table "all_card_updated" */
export type All_Card_Updated_On_Conflict = {
  constraint: All_Card_Updated_Constraint;
  update_columns?: Array<All_Card_Updated_Update_Column>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};

/** Ordering options when selecting data from "all_card_updated". */
export type All_Card_Updated_Order_By = {
  card_count?: InputMaybe<Order_By>;
  cards_updated_at?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  translation_updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: all_card_updated */
export type All_Card_Updated_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
};

/** select columns of table "all_card_updated" */
export enum All_Card_Updated_Select_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at'
}

/** input type for updating data in table "all_card_updated" */
export type All_Card_Updated_Set_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate stddev on columns */
export type All_Card_Updated_Stddev_Fields = {
  __typename?: 'all_card_updated_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type All_Card_Updated_Stddev_Pop_Fields = {
  __typename?: 'all_card_updated_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type All_Card_Updated_Stddev_Samp_Fields = {
  __typename?: 'all_card_updated_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "all_card_updated" */
export type All_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: All_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type All_Card_Updated_Stream_Cursor_Value_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  translation_updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate sum on columns */
export type All_Card_Updated_Sum_Fields = {
  __typename?: 'all_card_updated_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "all_card_updated" */
export enum All_Card_Updated_Update_Column {
  /** column name */
  CardCount = 'card_count',
  /** column name */
  CardsUpdatedAt = 'cards_updated_at',
  /** column name */
  Locale = 'locale',
  /** column name */
  TranslationUpdatedAt = 'translation_updated_at'
}

export type All_Card_Updated_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Updated_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Updated_Var_Pop_Fields = {
  __typename?: 'all_card_updated_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type All_Card_Updated_Var_Samp_Fields = {
  __typename?: 'all_card_updated_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type All_Card_Updated_Variance_Fields = {
  __typename?: 'all_card_updated_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
};

export type All_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<All_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<All_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<All_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: All_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type All_Card_Var_Pop_Fields = {
  __typename?: 'all_card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "all_card" */
export type All_Card_Var_Pop_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type All_Card_Var_Samp_Fields = {
  __typename?: 'all_card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "all_card" */
export type All_Card_Var_Samp_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type All_Card_Variance_Fields = {
  __typename?: 'all_card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  taboo_set_id?: Maybe<Scalars['Float']['output']>;
  taboo_xp?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "all_card" */
export type All_Card_Variance_Order_By = {
  clues?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  taboo_set_id?: InputMaybe<Order_By>;
  taboo_xp?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** columns and relationships of "arkhamdb_auth" */
export type Arkhamdb_Auth = {
  __typename?: 'arkhamdb_auth';
  access_token: Scalars['String']['output'];
  access_token_expiration: Scalars['timestamptz']['output'];
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  reauthorization_required: Scalars['Boolean']['output'];
  refresh_token: Scalars['String']['output'];
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate = {
  __typename?: 'arkhamdb_auth_aggregate';
  aggregate?: Maybe<Arkhamdb_Auth_Aggregate_Fields>;
  nodes: Array<Arkhamdb_Auth>;
};

/** aggregate fields of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate_Fields = {
  __typename?: 'arkhamdb_auth_aggregate_fields';
  avg?: Maybe<Arkhamdb_Auth_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arkhamdb_Auth_Max_Fields>;
  min?: Maybe<Arkhamdb_Auth_Min_Fields>;
  stddev?: Maybe<Arkhamdb_Auth_Stddev_Fields>;
  stddev_pop?: Maybe<Arkhamdb_Auth_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arkhamdb_Auth_Stddev_Samp_Fields>;
  sum?: Maybe<Arkhamdb_Auth_Sum_Fields>;
  var_pop?: Maybe<Arkhamdb_Auth_Var_Pop_Fields>;
  var_samp?: Maybe<Arkhamdb_Auth_Var_Samp_Fields>;
  variance?: Maybe<Arkhamdb_Auth_Variance_Fields>;
};


/** aggregate fields of "arkhamdb_auth" */
export type Arkhamdb_Auth_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Arkhamdb_Auth_Avg_Fields = {
  __typename?: 'arkhamdb_auth_avg_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "arkhamdb_auth". All fields are combined with a logical 'AND'. */
export type Arkhamdb_Auth_Bool_Exp = {
  _and?: InputMaybe<Array<Arkhamdb_Auth_Bool_Exp>>;
  _not?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
  _or?: InputMaybe<Array<Arkhamdb_Auth_Bool_Exp>>;
  access_token?: InputMaybe<String_Comparison_Exp>;
  access_token_expiration?: InputMaybe<Timestamptz_Comparison_Exp>;
  account_id?: InputMaybe<Int_Comparison_Exp>;
  account_name?: InputMaybe<String_Comparison_Exp>;
  decks_cache_key?: InputMaybe<String_Comparison_Exp>;
  reauthorization_required?: InputMaybe<Boolean_Comparison_Exp>;
  refresh_token?: InputMaybe<String_Comparison_Exp>;
  refresh_token_expiration?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  ArkhamdbAuthPkey = 'arkhamdb_auth_pkey'
}

/** input type for incrementing numeric columns in table "arkhamdb_auth" */
export type Arkhamdb_Auth_Inc_Input = {
  account_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "arkhamdb_auth" */
export type Arkhamdb_Auth_Insert_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Arkhamdb_Auth_Max_Fields = {
  __typename?: 'arkhamdb_auth_max_fields';
  access_token?: Maybe<Scalars['String']['output']>;
  access_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  refresh_token?: Maybe<Scalars['String']['output']>;
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Arkhamdb_Auth_Min_Fields = {
  __typename?: 'arkhamdb_auth_min_fields';
  access_token?: Maybe<Scalars['String']['output']>;
  access_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  account_id?: Maybe<Scalars['Int']['output']>;
  account_name?: Maybe<Scalars['String']['output']>;
  decks_cache_key?: Maybe<Scalars['String']['output']>;
  refresh_token?: Maybe<Scalars['String']['output']>;
  refresh_token_expiration?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "arkhamdb_auth" */
export type Arkhamdb_Auth_Mutation_Response = {
  __typename?: 'arkhamdb_auth_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arkhamdb_Auth>;
};

/** on_conflict condition type for table "arkhamdb_auth" */
export type Arkhamdb_Auth_On_Conflict = {
  constraint: Arkhamdb_Auth_Constraint;
  update_columns?: Array<Arkhamdb_Auth_Update_Column>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};

/** Ordering options when selecting data from "arkhamdb_auth". */
export type Arkhamdb_Auth_Order_By = {
  access_token?: InputMaybe<Order_By>;
  access_token_expiration?: InputMaybe<Order_By>;
  account_id?: InputMaybe<Order_By>;
  account_name?: InputMaybe<Order_By>;
  decks_cache_key?: InputMaybe<Order_By>;
  reauthorization_required?: InputMaybe<Order_By>;
  refresh_token?: InputMaybe<Order_By>;
  refresh_token_expiration?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arkhamdb_auth */
export type Arkhamdb_Auth_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** select columns of table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Select_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  AccessTokenExpiration = 'access_token_expiration',
  /** column name */
  AccountId = 'account_id',
  /** column name */
  AccountName = 'account_name',
  /** column name */
  DecksCacheKey = 'decks_cache_key',
  /** column name */
  ReauthorizationRequired = 'reauthorization_required',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  RefreshTokenExpiration = 'refresh_token_expiration',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "arkhamdb_auth" */
export type Arkhamdb_Auth_Set_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Arkhamdb_Auth_Stddev_Fields = {
  __typename?: 'arkhamdb_auth_stddev_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Arkhamdb_Auth_Stddev_Pop_Fields = {
  __typename?: 'arkhamdb_auth_stddev_pop_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Arkhamdb_Auth_Stddev_Samp_Fields = {
  __typename?: 'arkhamdb_auth_stddev_samp_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "arkhamdb_auth" */
export type Arkhamdb_Auth_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arkhamdb_Auth_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arkhamdb_Auth_Stream_Cursor_Value_Input = {
  access_token?: InputMaybe<Scalars['String']['input']>;
  access_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  account_id?: InputMaybe<Scalars['Int']['input']>;
  account_name?: InputMaybe<Scalars['String']['input']>;
  decks_cache_key?: InputMaybe<Scalars['String']['input']>;
  reauthorization_required?: InputMaybe<Scalars['Boolean']['input']>;
  refresh_token?: InputMaybe<Scalars['String']['input']>;
  refresh_token_expiration?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Arkhamdb_Auth_Sum_Fields = {
  __typename?: 'arkhamdb_auth_sum_fields';
  account_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "arkhamdb_auth" */
export enum Arkhamdb_Auth_Update_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  AccessTokenExpiration = 'access_token_expiration',
  /** column name */
  AccountId = 'account_id',
  /** column name */
  AccountName = 'account_name',
  /** column name */
  DecksCacheKey = 'decks_cache_key',
  /** column name */
  ReauthorizationRequired = 'reauthorization_required',
  /** column name */
  RefreshToken = 'refresh_token',
  /** column name */
  RefreshTokenExpiration = 'refresh_token_expiration',
  /** column name */
  UserId = 'user_id'
}

export type Arkhamdb_Auth_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arkhamdb_Auth_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arkhamdb_Auth_Var_Pop_Fields = {
  __typename?: 'arkhamdb_auth_var_pop_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Arkhamdb_Auth_Var_Samp_Fields = {
  __typename?: 'arkhamdb_auth_var_samp_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Arkhamdb_Auth_Variance_Fields = {
  __typename?: 'arkhamdb_auth_variance_fields';
  account_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_Deck = {
  __typename?: 'arkhamdb_deck';
  archived?: Maybe<Scalars['Boolean']['output']>;
  created_at: Scalars['timestamptz']['output'];
  deleted: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  ignore_deck_limit_slots: Scalars['jsonb']['output'];
  investigator: Scalars['String']['output'];
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  next_deck?: Maybe<Arkhamdb_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  /** An object relationship */
  previous_deck?: Maybe<Arkhamdb_Deck>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  tags: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckIgnore_Deck_Limit_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "arkhamdb_deck" */
export type Arkhamdb_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate = {
  __typename?: 'arkhamdb_deck_aggregate';
  aggregate?: Maybe<Arkhamdb_Deck_Aggregate_Fields>;
  nodes: Array<Arkhamdb_Deck>;
};

/** aggregate fields of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate_Fields = {
  __typename?: 'arkhamdb_deck_aggregate_fields';
  avg?: Maybe<Arkhamdb_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Arkhamdb_Deck_Max_Fields>;
  min?: Maybe<Arkhamdb_Deck_Min_Fields>;
  stddev?: Maybe<Arkhamdb_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Arkhamdb_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Arkhamdb_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Arkhamdb_Deck_Sum_Fields>;
  var_pop?: Maybe<Arkhamdb_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Arkhamdb_Deck_Var_Samp_Fields>;
  variance?: Maybe<Arkhamdb_Deck_Variance_Fields>;
};


/** aggregate fields of "arkhamdb_deck" */
export type Arkhamdb_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Arkhamdb_Deck_Append_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Arkhamdb_Deck_Avg_Fields = {
  __typename?: 'arkhamdb_deck_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "arkhamdb_deck". All fields are combined with a logical 'AND'. */
export type Arkhamdb_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Arkhamdb_Deck_Bool_Exp>>;
  _not?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Arkhamdb_Deck_Bool_Exp>>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deleted?: InputMaybe<Boolean_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  ignore_deck_limit_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Constraint {
  /** unique or primary key constraint on columns "next_deck_id" */
  DeckNextDeckIdKey = 'deck_next_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey1 = 'deck_pkey1'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Arkhamdb_Deck_Delete_At_Path_Input = {
  ignore_deck_limit_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Arkhamdb_Deck_Delete_Elem_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Arkhamdb_Deck_Delete_Key_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "arkhamdb_deck" */
export type Arkhamdb_Deck_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "arkhamdb_deck" */
export type Arkhamdb_Deck_Insert_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Arkhamdb_Deck_Max_Fields = {
  __typename?: 'arkhamdb_deck_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Arkhamdb_Deck_Min_Fields = {
  __typename?: 'arkhamdb_deck_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "arkhamdb_deck" */
export type Arkhamdb_Deck_Mutation_Response = {
  __typename?: 'arkhamdb_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Arkhamdb_Deck>;
};

/** input type for inserting object relation for remote table "arkhamdb_deck" */
export type Arkhamdb_Deck_Obj_Rel_Insert_Input = {
  data: Arkhamdb_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};

/** on_conflict condition type for table "arkhamdb_deck" */
export type Arkhamdb_Deck_On_Conflict = {
  constraint: Arkhamdb_Deck_Constraint;
  update_columns?: Array<Arkhamdb_Deck_Update_Column>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "arkhamdb_deck". */
export type Arkhamdb_Deck_Order_By = {
  archived?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deleted?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ignore_deck_limit_slots?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Arkhamdb_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  previous_deck?: InputMaybe<Arkhamdb_Deck_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: arkhamdb_deck */
export type Arkhamdb_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Arkhamdb_Deck_Prepend_Input = {
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IgnoreDeckLimitSlots = 'ignore_deck_limit_slots',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "arkhamdb_deck" */
export type Arkhamdb_Deck_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Arkhamdb_Deck_Stddev_Fields = {
  __typename?: 'arkhamdb_deck_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Arkhamdb_Deck_Stddev_Pop_Fields = {
  __typename?: 'arkhamdb_deck_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Arkhamdb_Deck_Stddev_Samp_Fields = {
  __typename?: 'arkhamdb_deck_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "arkhamdb_deck" */
export type Arkhamdb_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Arkhamdb_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Arkhamdb_Deck_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  ignore_deck_limit_slots?: InputMaybe<Scalars['jsonb']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Arkhamdb_Deck_Sum_Fields = {
  __typename?: 'arkhamdb_deck_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "arkhamdb_deck" */
export enum Arkhamdb_Deck_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  IgnoreDeckLimitSlots = 'ignore_deck_limit_slots',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Arkhamdb_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Arkhamdb_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Arkhamdb_Deck_Var_Pop_Fields = {
  __typename?: 'arkhamdb_deck_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Arkhamdb_Deck_Var_Samp_Fields = {
  __typename?: 'arkhamdb_deck_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Arkhamdb_Deck_Variance_Fields = {
  __typename?: 'arkhamdb_deck_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "base_decks" */
export type Base_Decks = {
  __typename?: 'base_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "base_decks" */
export type Base_Decks_Aggregate = {
  __typename?: 'base_decks_aggregate';
  aggregate?: Maybe<Base_Decks_Aggregate_Fields>;
  nodes: Array<Base_Decks>;
};

export type Base_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Base_Decks_Aggregate_Bool_Exp_Count>;
};

export type Base_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Base_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Base_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "base_decks" */
export type Base_Decks_Aggregate_Fields = {
  __typename?: 'base_decks_aggregate_fields';
  avg?: Maybe<Base_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Base_Decks_Max_Fields>;
  min?: Maybe<Base_Decks_Min_Fields>;
  stddev?: Maybe<Base_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Base_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Base_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Base_Decks_Sum_Fields>;
  var_pop?: Maybe<Base_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Base_Decks_Var_Samp_Fields>;
  variance?: Maybe<Base_Decks_Variance_Fields>;
};


/** aggregate fields of "base_decks" */
export type Base_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Base_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "base_decks" */
export type Base_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Base_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Base_Decks_Max_Order_By>;
  min?: InputMaybe<Base_Decks_Min_Order_By>;
  stddev?: InputMaybe<Base_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Base_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Base_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Base_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Base_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Base_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Base_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "base_decks" */
export type Base_Decks_Arr_Rel_Insert_Input = {
  data: Array<Base_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Base_Decks_Avg_Fields = {
  __typename?: 'base_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "base_decks" */
export type Base_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "base_decks". All fields are combined with a logical 'AND'. */
export type Base_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Base_Decks_Bool_Exp>>;
  _not?: InputMaybe<Base_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Base_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "base_decks" */
export type Base_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "base_decks" */
export type Base_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Base_Decks_Max_Fields = {
  __typename?: 'base_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "base_decks" */
export type Base_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Base_Decks_Min_Fields = {
  __typename?: 'base_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "base_decks" */
export type Base_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "base_decks" */
export type Base_Decks_Mutation_Response = {
  __typename?: 'base_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Base_Decks>;
};

/** Ordering options when selecting data from "base_decks". */
export type Base_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
};

/** select columns of table "base_decks" */
export enum Base_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "base_decks" */
export type Base_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Base_Decks_Stddev_Fields = {
  __typename?: 'base_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "base_decks" */
export type Base_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Base_Decks_Stddev_Pop_Fields = {
  __typename?: 'base_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "base_decks" */
export type Base_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Base_Decks_Stddev_Samp_Fields = {
  __typename?: 'base_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "base_decks" */
export type Base_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "base_decks" */
export type Base_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Base_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Base_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Base_Decks_Sum_Fields = {
  __typename?: 'base_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "base_decks" */
export type Base_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Base_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Base_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Base_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Base_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Base_Decks_Var_Pop_Fields = {
  __typename?: 'base_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "base_decks" */
export type Base_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Base_Decks_Var_Samp_Fields = {
  __typename?: 'base_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "base_decks" */
export type Base_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Base_Decks_Variance_Fields = {
  __typename?: 'base_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "base_decks" */
export type Base_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']['input']>;
  _gt?: InputMaybe<Scalars['bigint']['input']>;
  _gte?: InputMaybe<Scalars['bigint']['input']>;
  _in?: InputMaybe<Array<Scalars['bigint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['bigint']['input']>;
  _lte?: InputMaybe<Scalars['bigint']['input']>;
  _neq?: InputMaybe<Scalars['bigint']['input']>;
  _nin?: InputMaybe<Array<Scalars['bigint']['input']>>;
};

/** columns and relationships of "campaign" */
export type Campaign = {
  __typename?: 'campaign';
  /** An array relationship */
  access: Array<Campaign_Access>;
  /** An aggregate relationship */
  access_aggregate: Campaign_Access_Aggregate;
  archived?: Maybe<Scalars['Boolean']['output']>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  campaignNotes?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  campaign_guide?: Maybe<Campaign_Guide>;
  chaosBag?: Maybe<Scalars['jsonb']['output']>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  cycleCode?: Maybe<Scalars['String']['output']>;
  deleted?: Maybe<Scalars['Boolean']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  guided?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** An array relationship */
  investigators: Array<Campaign_Investigator>;
  /** An aggregate relationship */
  investigators_aggregate: Campaign_Investigator_Aggregate;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** An object relationship */
  link_a_campaign?: Maybe<Campaign>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  link_b_campaign?: Maybe<Campaign>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  linked_campaign?: Maybe<Campaign>;
  name?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  scenarioResults?: Maybe<Scalars['jsonb']['output']>;
  showInterludes?: Maybe<Scalars['Boolean']['output']>;
  standaloneId?: Maybe<Scalars['jsonb']['output']>;
  tarot_reading?: Maybe<Scalars['jsonb']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  uuid: Scalars['String']['output'];
  weaknessSet?: Maybe<Scalars['jsonb']['output']>;
};


/** columns and relationships of "campaign" */
export type CampaignAccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignCampaignNotesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignChaosBagArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigatorsArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignInvestigators_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "campaign" */
export type CampaignScenarioResultsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignStandaloneIdArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignTarot_ReadingArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign" */
export type CampaignWeaknessSetArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "campaign_access" */
export type Campaign_Access = {
  __typename?: 'campaign_access';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  hidden?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "campaign_access" */
export type Campaign_Access_Aggregate = {
  __typename?: 'campaign_access_aggregate';
  aggregate?: Maybe<Campaign_Access_Aggregate_Fields>;
  nodes: Array<Campaign_Access>;
};

export type Campaign_Access_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Access_Aggregate_Bool_Exp_Bool_And = {
  arguments: Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Access_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Access_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_access" */
export type Campaign_Access_Aggregate_Fields = {
  __typename?: 'campaign_access_aggregate_fields';
  avg?: Maybe<Campaign_Access_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Access_Max_Fields>;
  min?: Maybe<Campaign_Access_Min_Fields>;
  stddev?: Maybe<Campaign_Access_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Access_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Access_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Access_Sum_Fields>;
  var_pop?: Maybe<Campaign_Access_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Access_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Access_Variance_Fields>;
};


/** aggregate fields of "campaign_access" */
export type Campaign_Access_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_access" */
export type Campaign_Access_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Access_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Access_Max_Order_By>;
  min?: InputMaybe<Campaign_Access_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Access_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Access_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Access_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Access_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Access_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Access_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Access_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "campaign_access" */
export type Campaign_Access_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Access_Avg_Fields = {
  __typename?: 'campaign_access_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_access" */
export type Campaign_Access_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_access". All fields are combined with a logical 'AND'. */
export type Campaign_Access_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Access_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Access_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Access_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_access" */
export enum Campaign_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignAccessPkey = 'campaign_access_pkey',
  /** unique or primary key constraint on columns "campaign_id", "user_id" */
  CampaignAccessUserIdCampaignIdKey = 'campaign_access_user_id_campaign_id_key'
}

/** input type for incrementing numeric columns in table "campaign_access" */
export type Campaign_Access_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_access" */
export type Campaign_Access_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Access_Max_Fields = {
  __typename?: 'campaign_access_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "campaign_access" */
export type Campaign_Access_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Access_Min_Fields = {
  __typename?: 'campaign_access_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "campaign_access" */
export type Campaign_Access_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_access" */
export type Campaign_Access_Mutation_Response = {
  __typename?: 'campaign_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Access>;
};

/** on_conflict condition type for table "campaign_access" */
export type Campaign_Access_On_Conflict = {
  constraint: Campaign_Access_Constraint;
  update_columns?: Array<Campaign_Access_Update_Column>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_access". */
export type Campaign_Access_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_access */
export type Campaign_Access_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "campaign_access" */
export enum Campaign_Access_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

/** select "campaign_access_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_access" */
export enum Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Hidden = 'hidden'
}

/** select "campaign_access_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_access" */
export enum Campaign_Access_Select_Column_Campaign_Access_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Hidden = 'hidden'
}

/** input type for updating data in table "campaign_access" */
export type Campaign_Access_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Access_Stddev_Fields = {
  __typename?: 'campaign_access_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Access_Stddev_Pop_Fields = {
  __typename?: 'campaign_access_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Access_Stddev_Samp_Fields = {
  __typename?: 'campaign_access_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_access" */
export type Campaign_Access_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_access" */
export type Campaign_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Access_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Access_Sum_Fields = {
  __typename?: 'campaign_access_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_access" */
export type Campaign_Access_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_access" */
export enum Campaign_Access_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

export type Campaign_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Access_Var_Pop_Fields = {
  __typename?: 'campaign_access_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_access" */
export type Campaign_Access_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Access_Var_Samp_Fields = {
  __typename?: 'campaign_access_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_access" */
export type Campaign_Access_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Access_Variance_Fields = {
  __typename?: 'campaign_access_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_access" */
export type Campaign_Access_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregated selection of "campaign" */
export type Campaign_Aggregate = {
  __typename?: 'campaign_aggregate';
  aggregate?: Maybe<Campaign_Aggregate_Fields>;
  nodes: Array<Campaign>;
};

/** aggregate fields of "campaign" */
export type Campaign_Aggregate_Fields = {
  __typename?: 'campaign_aggregate_fields';
  avg?: Maybe<Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Max_Fields>;
  min?: Maybe<Campaign_Min_Fields>;
  stddev?: Maybe<Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Sum_Fields>;
  var_pop?: Maybe<Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Variance_Fields>;
};


/** aggregate fields of "campaign" */
export type Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Append_Input = {
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Campaign_Avg_Fields = {
  __typename?: 'campaign_avg_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaign". All fields are combined with a logical 'AND'. */
export type Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Bool_Exp>>;
  access?: InputMaybe<Campaign_Access_Bool_Exp>;
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  base_decks?: InputMaybe<Base_Decks_Bool_Exp>;
  base_decks_aggregate?: InputMaybe<Base_Decks_Aggregate_Bool_Exp>;
  campaignNotes?: InputMaybe<Jsonb_Comparison_Exp>;
  campaign_guide?: InputMaybe<Campaign_Guide_Bool_Exp>;
  chaosBag?: InputMaybe<Jsonb_Comparison_Exp>;
  chaos_bag_result?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  chaos_bag_result_aggregate?: InputMaybe<Chaos_Bag_Result_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  cycleCode?: InputMaybe<String_Comparison_Exp>;
  deleted?: InputMaybe<Boolean_Comparison_Exp>;
  difficulty?: InputMaybe<String_Comparison_Exp>;
  guide_version?: InputMaybe<Int_Comparison_Exp>;
  guided?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  investigator_data?: InputMaybe<Investigator_Data_Bool_Exp>;
  investigator_data_aggregate?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp>;
  investigators?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  investigators_aggregate?: InputMaybe<Campaign_Investigator_Aggregate_Bool_Exp>;
  latest_decks?: InputMaybe<Latest_Decks_Bool_Exp>;
  latest_decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp>;
  link_a_campaign?: InputMaybe<Campaign_Bool_Exp>;
  link_a_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  link_b_campaign?: InputMaybe<Campaign_Bool_Exp>;
  link_b_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  link_campaign_id?: InputMaybe<Int_Comparison_Exp>;
  linked_campaign?: InputMaybe<Campaign_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  scenarioResults?: InputMaybe<Jsonb_Comparison_Exp>;
  showInterludes?: InputMaybe<Boolean_Comparison_Exp>;
  standaloneId?: InputMaybe<Jsonb_Comparison_Exp>;
  tarot_reading?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<String_Comparison_Exp>;
  weaknessSet?: InputMaybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign" */
export enum Campaign_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignDataPkey = 'campaign_data_pkey'
}

/** columns and relationships of "campaign_deck" */
export type Campaign_Deck = {
  __typename?: 'campaign_deck';
  archived?: Maybe<Scalars['Boolean']['output']>;
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  base?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  content?: Maybe<Scalars['jsonb']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  investigator: Scalars['String']['output'];
  /** An object relationship */
  investigator_data?: Maybe<Investigator_Data>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  next_deck?: Maybe<Campaign_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  other_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  other_decks_aggregate: Campaign_Deck_Aggregate;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['String']['output'];
  /** An object relationship */
  previous_deck?: Maybe<Campaign_Deck>;
  /** An array relationship */
  previous_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  previous_decks_aggregate: Campaign_Deck_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckContentArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckOther_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckOther_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckPrevious_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "campaign_deck" */
export type Campaign_DeckPrevious_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};

/** aggregated selection of "campaign_deck" */
export type Campaign_Deck_Aggregate = {
  __typename?: 'campaign_deck_aggregate';
  aggregate?: Maybe<Campaign_Deck_Aggregate_Fields>;
  nodes: Array<Campaign_Deck>;
};

export type Campaign_Deck_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Bool_And = {
  arguments: Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Campaign_Deck_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Deck_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_deck" */
export type Campaign_Deck_Aggregate_Fields = {
  __typename?: 'campaign_deck_aggregate_fields';
  avg?: Maybe<Campaign_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Deck_Max_Fields>;
  min?: Maybe<Campaign_Deck_Min_Fields>;
  stddev?: Maybe<Campaign_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Deck_Sum_Fields>;
  var_pop?: Maybe<Campaign_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Deck_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Deck_Variance_Fields>;
};


/** aggregate fields of "campaign_deck" */
export type Campaign_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_deck" */
export type Campaign_Deck_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Deck_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Deck_Max_Order_By>;
  min?: InputMaybe<Campaign_Deck_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Deck_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Deck_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Deck_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Deck_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Deck_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Deck_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Deck_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Deck_Append_Input = {
  content?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "campaign_deck" */
export type Campaign_Deck_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Deck_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Deck_Avg_Fields = {
  __typename?: 'campaign_deck_avg_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_deck" */
export type Campaign_Deck_Avg_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_deck". All fields are combined with a logical 'AND'. */
export type Campaign_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Deck_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Deck_Bool_Exp>>;
  archived?: InputMaybe<Boolean_Comparison_Exp>;
  arkhamdb_id?: InputMaybe<Int_Comparison_Exp>;
  arkhamdb_user?: InputMaybe<Int_Comparison_Exp>;
  base?: InputMaybe<Boolean_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  content?: InputMaybe<Jsonb_Comparison_Exp>;
  content_hash?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  investigator_data?: InputMaybe<Investigator_Data_Bool_Exp>;
  local_uuid?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  other_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  other_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  owner?: InputMaybe<Users_Bool_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
  previous_deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  previous_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  previous_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_deck" */
export enum Campaign_Deck_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "arkhamdb_id" */
  DeckArkhamdbIdCampaignIdKey = 'deck_arkhamdb_id_campaign_id_key',
  /** unique or primary key constraint on columns "campaign_id", "local_uuid" */
  DeckLocalUuidCampaignIdKey = 'deck_local_uuid_campaign_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Campaign_Deck_Delete_At_Path_Input = {
  content?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Campaign_Deck_Delete_Elem_Input = {
  content?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Campaign_Deck_Delete_Key_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "campaign_deck" */
export type Campaign_Deck_Inc_Input = {
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_deck" */
export type Campaign_Deck_Insert_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  investigator_data?: InputMaybe<Investigator_Data_Obj_Rel_Insert_Input>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  other_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  previous_deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  previous_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Campaign_Deck_Max_Fields = {
  __typename?: 'campaign_deck_max_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "campaign_deck" */
export type Campaign_Deck_Max_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Deck_Min_Fields = {
  __typename?: 'campaign_deck_min_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  content_hash?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  local_uuid?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "campaign_deck" */
export type Campaign_Deck_Min_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_deck" */
export type Campaign_Deck_Mutation_Response = {
  __typename?: 'campaign_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Deck>;
};

/** input type for inserting object relation for remote table "campaign_deck" */
export type Campaign_Deck_Obj_Rel_Insert_Input = {
  data: Campaign_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};

/** on_conflict condition type for table "campaign_deck" */
export type Campaign_Deck_On_Conflict = {
  constraint: Campaign_Deck_Constraint;
  update_columns?: Array<Campaign_Deck_Update_Column>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_deck". */
export type Campaign_Deck_Order_By = {
  archived?: InputMaybe<Order_By>;
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  base?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  content?: InputMaybe<Order_By>;
  content_hash?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  investigator_data?: InputMaybe<Investigator_Data_Order_By>;
  local_uuid?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Campaign_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  other_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  previous_deck?: InputMaybe<Campaign_Deck_Order_By>;
  previous_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_deck */
export type Campaign_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Deck_Prepend_Input = {
  content?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  ArkhamdbId = 'arkhamdb_id',
  /** column name */
  ArkhamdbUser = 'arkhamdb_user',
  /** column name */
  Base = 'base',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Content = 'content',
  /** column name */
  ContentHash = 'content_hash',
  /** column name */
  Id = 'id',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  LocalUuid = 'local_uuid',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "campaign_deck_aggregate_bool_exp_bool_and_arguments_columns" columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Archived = 'archived',
  /** column name */
  Base = 'base'
}

/** select "campaign_deck_aggregate_bool_exp_bool_or_arguments_columns" columns of table "campaign_deck" */
export enum Campaign_Deck_Select_Column_Campaign_Deck_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Archived = 'archived',
  /** column name */
  Base = 'base'
}

/** input type for updating data in table "campaign_deck" */
export type Campaign_Deck_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Deck_Stddev_Fields = {
  __typename?: 'campaign_deck_stddev_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Deck_Stddev_Pop_Fields = {
  __typename?: 'campaign_deck_stddev_pop_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Pop_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Deck_Stddev_Samp_Fields = {
  __typename?: 'campaign_deck_stddev_samp_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_deck" */
export type Campaign_Deck_Stddev_Samp_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_deck" */
export type Campaign_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Deck_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  base?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  content?: InputMaybe<Scalars['jsonb']['input']>;
  content_hash?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Deck_Sum_Fields = {
  __typename?: 'campaign_deck_sum_fields';
  arkhamdb_id?: Maybe<Scalars['Int']['output']>;
  arkhamdb_user?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_deck" */
export type Campaign_Deck_Sum_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_deck" */
export enum Campaign_Deck_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  ArkhamdbId = 'arkhamdb_id',
  /** column name */
  ArkhamdbUser = 'arkhamdb_user',
  /** column name */
  Base = 'base',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Content = 'content',
  /** column name */
  ContentHash = 'content_hash',
  /** column name */
  Id = 'id',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  LocalUuid = 'local_uuid',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Campaign_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Deck_Var_Pop_Fields = {
  __typename?: 'campaign_deck_var_pop_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_deck" */
export type Campaign_Deck_Var_Pop_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Deck_Var_Samp_Fields = {
  __typename?: 'campaign_deck_var_samp_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_deck" */
export type Campaign_Deck_Var_Samp_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Deck_Variance_Fields = {
  __typename?: 'campaign_deck_variance_fields';
  arkhamdb_id?: Maybe<Scalars['Float']['output']>;
  arkhamdb_user?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_deck" */
export type Campaign_Deck_Variance_Order_By = {
  arkhamdb_id?: InputMaybe<Order_By>;
  arkhamdb_user?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Campaign_Delete_At_Path_Input = {
  campaignNotes?: InputMaybe<Array<Scalars['String']['input']>>;
  chaosBag?: InputMaybe<Array<Scalars['String']['input']>>;
  scenarioResults?: InputMaybe<Array<Scalars['String']['input']>>;
  standaloneId?: InputMaybe<Array<Scalars['String']['input']>>;
  tarot_reading?: InputMaybe<Array<Scalars['String']['input']>>;
  weaknessSet?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Campaign_Delete_Elem_Input = {
  campaignNotes?: InputMaybe<Scalars['Int']['input']>;
  chaosBag?: InputMaybe<Scalars['Int']['input']>;
  scenarioResults?: InputMaybe<Scalars['Int']['input']>;
  standaloneId?: InputMaybe<Scalars['Int']['input']>;
  tarot_reading?: InputMaybe<Scalars['Int']['input']>;
  weaknessSet?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Campaign_Delete_Key_Input = {
  campaignNotes?: InputMaybe<Scalars['String']['input']>;
  chaosBag?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['String']['input']>;
  standaloneId?: InputMaybe<Scalars['String']['input']>;
  tarot_reading?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "campaign_difficulty" */
export type Campaign_Difficulty = {
  __typename?: 'campaign_difficulty';
  value: Scalars['String']['output'];
};

/** aggregated selection of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate = {
  __typename?: 'campaign_difficulty_aggregate';
  aggregate?: Maybe<Campaign_Difficulty_Aggregate_Fields>;
  nodes: Array<Campaign_Difficulty>;
};

/** aggregate fields of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate_Fields = {
  __typename?: 'campaign_difficulty_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Difficulty_Max_Fields>;
  min?: Maybe<Campaign_Difficulty_Min_Fields>;
};


/** aggregate fields of "campaign_difficulty" */
export type Campaign_Difficulty_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "campaign_difficulty". All fields are combined with a logical 'AND'. */
export type Campaign_Difficulty_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Difficulty_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Difficulty_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_difficulty" */
export enum Campaign_Difficulty_Constraint {
  /** unique or primary key constraint on columns "value" */
  CampaignDifficultyPkey = 'campaign_difficulty_pkey'
}

export enum Campaign_Difficulty_Enum {
  Easy = 'easy',
  Expert = 'expert',
  Hard = 'hard',
  Standard = 'standard'
}

/** Boolean expression to compare columns of type "campaign_difficulty_enum". All fields are combined with logical 'AND'. */
export type Campaign_Difficulty_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Campaign_Difficulty_Enum>;
  _in?: InputMaybe<Array<Campaign_Difficulty_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Campaign_Difficulty_Enum>;
  _nin?: InputMaybe<Array<Campaign_Difficulty_Enum>>;
};

/** input type for inserting data into table "campaign_difficulty" */
export type Campaign_Difficulty_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Difficulty_Max_Fields = {
  __typename?: 'campaign_difficulty_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Difficulty_Min_Fields = {
  __typename?: 'campaign_difficulty_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign_difficulty" */
export type Campaign_Difficulty_Mutation_Response = {
  __typename?: 'campaign_difficulty_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Difficulty>;
};

/** on_conflict condition type for table "campaign_difficulty" */
export type Campaign_Difficulty_On_Conflict = {
  constraint: Campaign_Difficulty_Constraint;
  update_columns?: Array<Campaign_Difficulty_Update_Column>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_difficulty". */
export type Campaign_Difficulty_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_difficulty */
export type Campaign_Difficulty_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "campaign_difficulty" */
export enum Campaign_Difficulty_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "campaign_difficulty" */
export type Campaign_Difficulty_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "campaign_difficulty" */
export type Campaign_Difficulty_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Difficulty_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Difficulty_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "campaign_difficulty" */
export enum Campaign_Difficulty_Update_Column {
  /** column name */
  Value = 'value'
}

export type Campaign_Difficulty_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Difficulty_Bool_Exp;
};

/** columns and relationships of "campaign_guide" */
export type Campaign_Guide = {
  __typename?: 'campaign_guide';
  /** An array relationship */
  access: Array<Campaign_Access>;
  /** An aggregate relationship */
  access_aggregate: Campaign_Access_Aggregate;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An array relationship */
  guide_achievements: Array<Guide_Achievement>;
  /** An aggregate relationship */
  guide_achievements_aggregate: Guide_Achievement_Aggregate;
  /** An array relationship */
  guide_inputs: Array<Guide_Input>;
  /** An aggregate relationship */
  guide_inputs_aggregate: Guide_Input_Aggregate;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideAccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_AchievementsArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_Achievements_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_InputsArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


/** columns and relationships of "campaign_guide" */
export type Campaign_GuideGuide_Inputs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};

/** aggregated selection of "campaign_guide" */
export type Campaign_Guide_Aggregate = {
  __typename?: 'campaign_guide_aggregate';
  aggregate?: Maybe<Campaign_Guide_Aggregate_Fields>;
  nodes: Array<Campaign_Guide>;
};

/** aggregate fields of "campaign_guide" */
export type Campaign_Guide_Aggregate_Fields = {
  __typename?: 'campaign_guide_aggregate_fields';
  avg?: Maybe<Campaign_Guide_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Guide_Max_Fields>;
  min?: Maybe<Campaign_Guide_Min_Fields>;
  stddev?: Maybe<Campaign_Guide_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Guide_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Guide_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Guide_Sum_Fields>;
  var_pop?: Maybe<Campaign_Guide_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Guide_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Guide_Variance_Fields>;
};


/** aggregate fields of "campaign_guide" */
export type Campaign_Guide_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Campaign_Guide_Avg_Fields = {
  __typename?: 'campaign_guide_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaign_guide". All fields are combined with a logical 'AND'. */
export type Campaign_Guide_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Guide_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Guide_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Guide_Bool_Exp>>;
  access?: InputMaybe<Campaign_Access_Bool_Exp>;
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  guide_achievements?: InputMaybe<Guide_Achievement_Bool_Exp>;
  guide_achievements_aggregate?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp>;
  guide_inputs?: InputMaybe<Guide_Input_Bool_Exp>;
  guide_inputs_aggregate?: InputMaybe<Guide_Input_Aggregate_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  uuid?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "campaign_guide" */
export type Campaign_Guide_Inc_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_guide" */
export type Campaign_Guide_Insert_Input = {
  access?: InputMaybe<Campaign_Access_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  guide_achievements?: InputMaybe<Guide_Achievement_Arr_Rel_Insert_Input>;
  guide_inputs?: InputMaybe<Guide_Input_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Campaign_Guide_Max_Fields = {
  __typename?: 'campaign_guide_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Guide_Min_Fields = {
  __typename?: 'campaign_guide_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign_guide" */
export type Campaign_Guide_Mutation_Response = {
  __typename?: 'campaign_guide_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Guide>;
};

/** input type for inserting object relation for remote table "campaign_guide" */
export type Campaign_Guide_Obj_Rel_Insert_Input = {
  data: Campaign_Guide_Insert_Input;
};

/** Ordering options when selecting data from "campaign_guide". */
export type Campaign_Guide_Order_By = {
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  guide_achievements_aggregate?: InputMaybe<Guide_Achievement_Aggregate_Order_By>;
  guide_inputs_aggregate?: InputMaybe<Guide_Input_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  owner?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** select columns of table "campaign_guide" */
export enum Campaign_Guide_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Owner = 'owner',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "campaign_guide" */
export type Campaign_Guide_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Guide_Stddev_Fields = {
  __typename?: 'campaign_guide_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Guide_Stddev_Pop_Fields = {
  __typename?: 'campaign_guide_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Guide_Stddev_Samp_Fields = {
  __typename?: 'campaign_guide_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaign_guide" */
export type Campaign_Guide_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Guide_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Guide_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Guide_Sum_Fields = {
  __typename?: 'campaign_guide_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
};

export type Campaign_Guide_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Guide_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Guide_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Guide_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Guide_Var_Pop_Fields = {
  __typename?: 'campaign_guide_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaign_Guide_Var_Samp_Fields = {
  __typename?: 'campaign_guide_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaign_Guide_Variance_Fields = {
  __typename?: 'campaign_guide_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "campaign" */
export type Campaign_Inc_Input = {
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign" */
export type Campaign_Insert_Input = {
  access?: InputMaybe<Campaign_Access_Arr_Rel_Insert_Input>;
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  base_decks?: InputMaybe<Base_Decks_Arr_Rel_Insert_Input>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  campaign_guide?: InputMaybe<Campaign_Guide_Obj_Rel_Insert_Input>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  chaos_bag_result?: InputMaybe<Chaos_Bag_Result_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  investigator_data?: InputMaybe<Investigator_Data_Arr_Rel_Insert_Input>;
  investigators?: InputMaybe<Campaign_Investigator_Arr_Rel_Insert_Input>;
  latest_decks?: InputMaybe<Latest_Decks_Arr_Rel_Insert_Input>;
  link_a_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  linked_campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "campaign_investigator" */
export type Campaign_Investigator = {
  __typename?: 'campaign_investigator';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "campaign_investigator" */
export type Campaign_Investigator_Aggregate = {
  __typename?: 'campaign_investigator_aggregate';
  aggregate?: Maybe<Campaign_Investigator_Aggregate_Fields>;
  nodes: Array<Campaign_Investigator>;
};

export type Campaign_Investigator_Aggregate_Bool_Exp = {
  count?: InputMaybe<Campaign_Investigator_Aggregate_Bool_Exp_Count>;
};

export type Campaign_Investigator_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "campaign_investigator" */
export type Campaign_Investigator_Aggregate_Fields = {
  __typename?: 'campaign_investigator_aggregate_fields';
  avg?: Maybe<Campaign_Investigator_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaign_Investigator_Max_Fields>;
  min?: Maybe<Campaign_Investigator_Min_Fields>;
  stddev?: Maybe<Campaign_Investigator_Stddev_Fields>;
  stddev_pop?: Maybe<Campaign_Investigator_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaign_Investigator_Stddev_Samp_Fields>;
  sum?: Maybe<Campaign_Investigator_Sum_Fields>;
  var_pop?: Maybe<Campaign_Investigator_Var_Pop_Fields>;
  var_samp?: Maybe<Campaign_Investigator_Var_Samp_Fields>;
  variance?: Maybe<Campaign_Investigator_Variance_Fields>;
};


/** aggregate fields of "campaign_investigator" */
export type Campaign_Investigator_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "campaign_investigator" */
export type Campaign_Investigator_Aggregate_Order_By = {
  avg?: InputMaybe<Campaign_Investigator_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Campaign_Investigator_Max_Order_By>;
  min?: InputMaybe<Campaign_Investigator_Min_Order_By>;
  stddev?: InputMaybe<Campaign_Investigator_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Campaign_Investigator_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Campaign_Investigator_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Campaign_Investigator_Sum_Order_By>;
  var_pop?: InputMaybe<Campaign_Investigator_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Campaign_Investigator_Var_Samp_Order_By>;
  variance?: InputMaybe<Campaign_Investigator_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "campaign_investigator" */
export type Campaign_Investigator_Arr_Rel_Insert_Input = {
  data: Array<Campaign_Investigator_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};

/** aggregate avg on columns */
export type Campaign_Investigator_Avg_Fields = {
  __typename?: 'campaign_investigator_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "campaign_investigator". All fields are combined with a logical 'AND'. */
export type Campaign_Investigator_Bool_Exp = {
  _and?: InputMaybe<Array<Campaign_Investigator_Bool_Exp>>;
  _not?: InputMaybe<Campaign_Investigator_Bool_Exp>;
  _or?: InputMaybe<Array<Campaign_Investigator_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "campaign_investigator" */
export enum Campaign_Investigator_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  CampaignInvestigatorCampaignIdInvestigatorKey = 'campaign_investigator_campaign_id_investigator_key',
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  CampaignInvestigatorPkey = 'campaign_investigator_pkey'
}

/** input type for incrementing numeric columns in table "campaign_investigator" */
export type Campaign_Investigator_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "campaign_investigator" */
export type Campaign_Investigator_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Campaign_Investigator_Max_Fields = {
  __typename?: 'campaign_investigator_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Campaign_Investigator_Min_Fields = {
  __typename?: 'campaign_investigator_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "campaign_investigator_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "campaign_investigator" */
export type Campaign_Investigator_Mutation_Response = {
  __typename?: 'campaign_investigator_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign_Investigator>;
};

/** on_conflict condition type for table "campaign_investigator" */
export type Campaign_Investigator_On_Conflict = {
  constraint: Campaign_Investigator_Constraint;
  update_columns?: Array<Campaign_Investigator_Update_Column>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign_investigator". */
export type Campaign_Investigator_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign_investigator */
export type Campaign_Investigator_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};

/** select columns of table "campaign_investigator" */
export enum Campaign_Investigator_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "campaign_investigator" */
export type Campaign_Investigator_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Investigator_Stddev_Fields = {
  __typename?: 'campaign_investigator_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Investigator_Stddev_Pop_Fields = {
  __typename?: 'campaign_investigator_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Investigator_Stddev_Samp_Fields = {
  __typename?: 'campaign_investigator_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "campaign_investigator" */
export type Campaign_Investigator_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Investigator_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Investigator_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Investigator_Sum_Fields = {
  __typename?: 'campaign_investigator_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** update columns of table "campaign_investigator" */
export enum Campaign_Investigator_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Campaign_Investigator_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Investigator_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Investigator_Var_Pop_Fields = {
  __typename?: 'campaign_investigator_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Campaign_Investigator_Var_Samp_Fields = {
  __typename?: 'campaign_investigator_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Campaign_Investigator_Variance_Fields = {
  __typename?: 'campaign_investigator_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "campaign_investigator" */
export type Campaign_Investigator_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type Campaign_Max_Fields = {
  __typename?: 'campaign_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  cycleCode?: Maybe<Scalars['String']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaign_Min_Fields = {
  __typename?: 'campaign_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  cycleCode?: Maybe<Scalars['String']['output']>;
  difficulty?: Maybe<Scalars['String']['output']>;
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  uuid?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "campaign" */
export type Campaign_Mutation_Response = {
  __typename?: 'campaign_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Campaign>;
};

/** input type for inserting object relation for remote table "campaign" */
export type Campaign_Obj_Rel_Insert_Input = {
  data: Campaign_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};

/** on_conflict condition type for table "campaign" */
export type Campaign_On_Conflict = {
  constraint: Campaign_Constraint;
  update_columns?: Array<Campaign_Update_Column>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};

/** Ordering options when selecting data from "campaign". */
export type Campaign_Order_By = {
  access_aggregate?: InputMaybe<Campaign_Access_Aggregate_Order_By>;
  archived?: InputMaybe<Order_By>;
  base_decks_aggregate?: InputMaybe<Base_Decks_Aggregate_Order_By>;
  campaignNotes?: InputMaybe<Order_By>;
  campaign_guide?: InputMaybe<Campaign_Guide_Order_By>;
  chaosBag?: InputMaybe<Order_By>;
  chaos_bag_result_aggregate?: InputMaybe<Chaos_Bag_Result_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  cycleCode?: InputMaybe<Order_By>;
  deleted?: InputMaybe<Order_By>;
  difficulty?: InputMaybe<Order_By>;
  guide_version?: InputMaybe<Order_By>;
  guided?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  investigator_data_aggregate?: InputMaybe<Investigator_Data_Aggregate_Order_By>;
  investigators_aggregate?: InputMaybe<Campaign_Investigator_Aggregate_Order_By>;
  latest_decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Order_By>;
  link_a_campaign?: InputMaybe<Campaign_Order_By>;
  link_a_campaign_id?: InputMaybe<Order_By>;
  link_b_campaign?: InputMaybe<Campaign_Order_By>;
  link_b_campaign_id?: InputMaybe<Order_By>;
  link_campaign_id?: InputMaybe<Order_By>;
  linked_campaign?: InputMaybe<Campaign_Order_By>;
  name?: InputMaybe<Order_By>;
  owner?: InputMaybe<Users_Order_By>;
  owner_id?: InputMaybe<Order_By>;
  scenarioResults?: InputMaybe<Order_By>;
  showInterludes?: InputMaybe<Order_By>;
  standaloneId?: InputMaybe<Order_By>;
  tarot_reading?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
  weaknessSet?: InputMaybe<Order_By>;
};

/** primary key columns input for table: campaign */
export type Campaign_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Campaign_Prepend_Input = {
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "campaign" */
export enum Campaign_Select_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CampaignNotes = 'campaignNotes',
  /** column name */
  ChaosBag = 'chaosBag',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CycleCode = 'cycleCode',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  GuideVersion = 'guide_version',
  /** column name */
  Guided = 'guided',
  /** column name */
  Id = 'id',
  /** column name */
  LinkACampaignId = 'link_a_campaign_id',
  /** column name */
  LinkBCampaignId = 'link_b_campaign_id',
  /** column name */
  LinkCampaignId = 'link_campaign_id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ScenarioResults = 'scenarioResults',
  /** column name */
  ShowInterludes = 'showInterludes',
  /** column name */
  StandaloneId = 'standaloneId',
  /** column name */
  TarotReading = 'tarot_reading',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WeaknessSet = 'weaknessSet'
}

/** input type for updating data in table "campaign" */
export type Campaign_Set_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate stddev on columns */
export type Campaign_Stddev_Fields = {
  __typename?: 'campaign_stddev_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaign_Stddev_Pop_Fields = {
  __typename?: 'campaign_stddev_pop_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaign_Stddev_Samp_Fields = {
  __typename?: 'campaign_stddev_samp_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaign" */
export type Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaign_Stream_Cursor_Value_Input = {
  archived?: InputMaybe<Scalars['Boolean']['input']>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  cycleCode?: InputMaybe<Scalars['String']['input']>;
  deleted?: InputMaybe<Scalars['Boolean']['input']>;
  difficulty?: InputMaybe<Scalars['String']['input']>;
  guide_version?: InputMaybe<Scalars['Int']['input']>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  link_a_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_b_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  link_campaign_id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  tarot_reading?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  uuid?: InputMaybe<Scalars['String']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate sum on columns */
export type Campaign_Sum_Fields = {
  __typename?: 'campaign_sum_fields';
  guide_version?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Int']['output']>;
  link_campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "campaign" */
export enum Campaign_Update_Column {
  /** column name */
  Archived = 'archived',
  /** column name */
  CampaignNotes = 'campaignNotes',
  /** column name */
  ChaosBag = 'chaosBag',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CycleCode = 'cycleCode',
  /** column name */
  Deleted = 'deleted',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  GuideVersion = 'guide_version',
  /** column name */
  Guided = 'guided',
  /** column name */
  Id = 'id',
  /** column name */
  LinkACampaignId = 'link_a_campaign_id',
  /** column name */
  LinkBCampaignId = 'link_b_campaign_id',
  /** column name */
  LinkCampaignId = 'link_campaign_id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ScenarioResults = 'scenarioResults',
  /** column name */
  ShowInterludes = 'showInterludes',
  /** column name */
  StandaloneId = 'standaloneId',
  /** column name */
  TarotReading = 'tarot_reading',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Uuid = 'uuid',
  /** column name */
  WeaknessSet = 'weaknessSet'
}

export type Campaign_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Campaign_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Campaign_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Campaign_Set_Input>;
  /** filter the rows which have to be updated */
  where: Campaign_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Campaign_Var_Pop_Fields = {
  __typename?: 'campaign_var_pop_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaign_Var_Samp_Fields = {
  __typename?: 'campaign_var_samp_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaign_Variance_Fields = {
  __typename?: 'campaign_variance_fields';
  guide_version?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  link_a_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_b_campaign_id?: Maybe<Scalars['Float']['output']>;
  link_campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "campaigns_by_cycle" */
export type Campaigns_By_Cycle = {
  __typename?: 'campaigns_by_cycle';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate = {
  __typename?: 'campaigns_by_cycle_aggregate';
  aggregate?: Maybe<Campaigns_By_Cycle_Aggregate_Fields>;
  nodes: Array<Campaigns_By_Cycle>;
};

/** aggregate fields of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate_Fields = {
  __typename?: 'campaigns_by_cycle_aggregate_fields';
  avg?: Maybe<Campaigns_By_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Campaigns_By_Cycle_Max_Fields>;
  min?: Maybe<Campaigns_By_Cycle_Min_Fields>;
  stddev?: Maybe<Campaigns_By_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Campaigns_By_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Campaigns_By_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Campaigns_By_Cycle_Sum_Fields>;
  var_pop?: Maybe<Campaigns_By_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Campaigns_By_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Campaigns_By_Cycle_Variance_Fields>;
};


/** aggregate fields of "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Campaigns_By_Cycle_Avg_Fields = {
  __typename?: 'campaigns_by_cycle_avg_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "campaigns_by_cycle". All fields are combined with a logical 'AND'. */
export type Campaigns_By_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Campaigns_By_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Campaigns_By_Cycle_Bool_Exp>>;
  count?: InputMaybe<Bigint_Comparison_Exp>;
  cyclecode?: InputMaybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Campaigns_By_Cycle_Max_Fields = {
  __typename?: 'campaigns_by_cycle_max_fields';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Campaigns_By_Cycle_Min_Fields = {
  __typename?: 'campaigns_by_cycle_min_fields';
  count?: Maybe<Scalars['bigint']['output']>;
  cyclecode?: Maybe<Scalars['String']['output']>;
};

/** Ordering options when selecting data from "campaigns_by_cycle". */
export type Campaigns_By_Cycle_Order_By = {
  count?: InputMaybe<Order_By>;
  cyclecode?: InputMaybe<Order_By>;
};

/** select columns of table "campaigns_by_cycle" */
export enum Campaigns_By_Cycle_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  Cyclecode = 'cyclecode'
}

/** aggregate stddev on columns */
export type Campaigns_By_Cycle_Stddev_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Campaigns_By_Cycle_Stddev_Pop_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Campaigns_By_Cycle_Stddev_Samp_Fields = {
  __typename?: 'campaigns_by_cycle_stddev_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "campaigns_by_cycle" */
export type Campaigns_By_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Campaigns_By_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Campaigns_By_Cycle_Stream_Cursor_Value_Input = {
  count?: InputMaybe<Scalars['bigint']['input']>;
  cyclecode?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Campaigns_By_Cycle_Sum_Fields = {
  __typename?: 'campaigns_by_cycle_sum_fields';
  count?: Maybe<Scalars['bigint']['output']>;
};

/** aggregate var_pop on columns */
export type Campaigns_By_Cycle_Var_Pop_Fields = {
  __typename?: 'campaigns_by_cycle_var_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Campaigns_By_Cycle_Var_Samp_Fields = {
  __typename?: 'campaigns_by_cycle_var_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Campaigns_By_Cycle_Variance_Fields = {
  __typename?: 'campaigns_by_cycle_variance_fields';
  count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "card" */
export type Card = {
  __typename?: 'card';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction_code: Scalars['String']['output'];
  health?: Maybe<Scalars['Int']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Card_Text_Aggregate;
  type_code: Scalars['String']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "card" */
export type CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "card" */
export type CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


/** columns and relationships of "card" */
export type CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};

/** aggregated selection of "card" */
export type Card_Aggregate = {
  __typename?: 'card_aggregate';
  aggregate?: Maybe<Card_Aggregate_Fields>;
  nodes: Array<Card>;
};

/** aggregate fields of "card" */
export type Card_Aggregate_Fields = {
  __typename?: 'card_aggregate_fields';
  avg?: Maybe<Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Max_Fields>;
  min?: Maybe<Card_Min_Fields>;
  stddev?: Maybe<Card_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Sum_Fields>;
  var_pop?: Maybe<Card_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Var_Samp_Fields>;
  variance?: Maybe<Card_Variance_Fields>;
};


/** aggregate fields of "card" */
export type Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Card_Append_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Card_Avg_Fields = {
  __typename?: 'card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "card". All fields are combined with a logical 'AND'. */
export type Card_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Bool_Exp>>;
  _not?: InputMaybe<Card_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Bool_Exp>>;
  back_link?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Card_Text_Aggregate_Bool_Exp>;
  type_code?: InputMaybe<String_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card" */
export enum Card_Constraint {
  /** unique or primary key constraint on columns "code" */
  CardPkey = 'card_pkey'
}

/** columns and relationships of "card_cycle" */
export type Card_Cycle = {
  __typename?: 'card_cycle';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  position: Scalars['Int']['output'];
};


/** columns and relationships of "card_cycle" */
export type Card_CyclePacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "card_cycle" */
export type Card_CyclePacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};

/** aggregated selection of "card_cycle" */
export type Card_Cycle_Aggregate = {
  __typename?: 'card_cycle_aggregate';
  aggregate?: Maybe<Card_Cycle_Aggregate_Fields>;
  nodes: Array<Card_Cycle>;
};

/** aggregate fields of "card_cycle" */
export type Card_Cycle_Aggregate_Fields = {
  __typename?: 'card_cycle_aggregate_fields';
  avg?: Maybe<Card_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Cycle_Max_Fields>;
  min?: Maybe<Card_Cycle_Min_Fields>;
  stddev?: Maybe<Card_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Cycle_Sum_Fields>;
  var_pop?: Maybe<Card_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Card_Cycle_Variance_Fields>;
};


/** aggregate fields of "card_cycle" */
export type Card_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Card_Cycle_Avg_Fields = {
  __typename?: 'card_cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "card_cycle". All fields are combined with a logical 'AND'. */
export type Card_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Card_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Cycle_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_cycle" */
export enum Card_Cycle_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardCyclePkey = 'card_cycle_pkey'
}

/** input type for incrementing numeric columns in table "card_cycle" */
export type Card_Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card_cycle" */
export type Card_Cycle_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Cycle_Max_Fields = {
  __typename?: 'card_cycle_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Card_Cycle_Min_Fields = {
  __typename?: 'card_cycle_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "card_cycle" */
export type Card_Cycle_Mutation_Response = {
  __typename?: 'card_cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Cycle>;
};

/** input type for inserting object relation for remote table "card_cycle" */
export type Card_Cycle_Obj_Rel_Insert_Input = {
  data: Card_Cycle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};

/** on_conflict condition type for table "card_cycle" */
export type Card_Cycle_On_Conflict = {
  constraint: Card_Cycle_Constraint;
  update_columns?: Array<Card_Cycle_Update_Column>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "card_cycle". */
export type Card_Cycle_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_cycle */
export type Card_Cycle_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_cycle" */
export enum Card_Cycle_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

/** input type for updating data in table "card_cycle" */
export type Card_Cycle_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Cycle_Stddev_Fields = {
  __typename?: 'card_cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Card_Cycle_Stddev_Pop_Fields = {
  __typename?: 'card_cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Card_Cycle_Stddev_Samp_Fields = {
  __typename?: 'card_cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "card_cycle" */
export type Card_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Cycle_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Card_Cycle_Sum_Fields = {
  __typename?: 'card_cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "card_cycle" */
export enum Card_Cycle_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

export type Card_Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Cycle_Var_Pop_Fields = {
  __typename?: 'card_cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Card_Cycle_Var_Samp_Fields = {
  __typename?: 'card_cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Card_Cycle_Variance_Fields = {
  __typename?: 'card_cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Card_Delete_At_Path_Input = {
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Card_Delete_Elem_Input = {
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Card_Delete_Key_Input = {
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_Set = {
  __typename?: 'card_encounter_set';
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
};


/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_SetCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "card_encounter_set" */
export type Card_Encounter_SetCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** aggregated selection of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate = {
  __typename?: 'card_encounter_set_aggregate';
  aggregate?: Maybe<Card_Encounter_Set_Aggregate_Fields>;
  nodes: Array<Card_Encounter_Set>;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp_Count>;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And = {
  arguments: Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Encounter_Set_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_Fields = {
  __typename?: 'card_encounter_set_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Encounter_Set_Max_Fields>;
  min?: Maybe<Card_Encounter_Set_Min_Fields>;
};


/** aggregate fields of "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_encounter_set" */
export type Card_Encounter_Set_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Encounter_Set_Max_Order_By>;
  min?: InputMaybe<Card_Encounter_Set_Min_Order_By>;
};

/** input type for inserting array relation for remote table "card_encounter_set" */
export type Card_Encounter_Set_Arr_Rel_Insert_Input = {
  data: Array<Card_Encounter_Set_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};

/** Boolean expression to filter rows from the table "card_encounter_set". All fields are combined with a logical 'AND'. */
export type Card_Encounter_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Encounter_Set_Bool_Exp>>;
  _not?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Encounter_Set_Bool_Exp>>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_encounter_set" */
export enum Card_Encounter_Set_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardEncounterSetPkey = 'card_encounter_set_pkey'
}

/** input type for inserting data into table "card_encounter_set" */
export type Card_Encounter_Set_Insert_Input = {
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate max on columns */
export type Card_Encounter_Set_Max_Fields = {
  __typename?: 'card_encounter_set_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "card_encounter_set" */
export type Card_Encounter_Set_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Encounter_Set_Min_Fields = {
  __typename?: 'card_encounter_set_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "card_encounter_set" */
export type Card_Encounter_Set_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_encounter_set" */
export type Card_Encounter_Set_Mutation_Response = {
  __typename?: 'card_encounter_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Encounter_Set>;
};

/** on_conflict condition type for table "card_encounter_set" */
export type Card_Encounter_Set_On_Conflict = {
  constraint: Card_Encounter_Set_Constraint;
  update_columns?: Array<Card_Encounter_Set_Update_Column>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "card_encounter_set". */
export type Card_Encounter_Set_Order_By = {
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_encounter_set */
export type Card_Encounter_Set_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official'
}

/** select "card_encounter_set_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "card_encounter_set_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Select_Column_Card_Encounter_Set_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "card_encounter_set" */
export type Card_Encounter_Set_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Streaming cursor of the table "card_encounter_set" */
export type Card_Encounter_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Encounter_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Encounter_Set_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
};

/** update columns of table "card_encounter_set" */
export enum Card_Encounter_Set_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official'
}

export type Card_Encounter_Set_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Encounter_Set_Bool_Exp;
};

/** input type for incrementing numeric columns in table "card" */
export type Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card" */
export type Card_Insert_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Card_Text_Arr_Rel_Insert_Input>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Max_Fields = {
  __typename?: 'card_max_fields';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  type_code?: Maybe<Scalars['String']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Card_Min_Fields = {
  __typename?: 'card_min_fields';
  back_link?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  type_code?: Maybe<Scalars['String']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "card" */
export type Card_Mutation_Response = {
  __typename?: 'card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card>;
};

/** on_conflict condition type for table "card" */
export type Card_On_Conflict = {
  constraint: Card_Constraint;
  update_columns?: Array<Card_Update_Column>;
  where?: InputMaybe<Card_Bool_Exp>;
};

/** Ordering options when selecting data from "card". */
export type Card_Order_By = {
  back_link?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  myriad?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Card_Text_Aggregate_Order_By>;
  type_code?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
};

/** columns and relationships of "card_pack" */
export type Card_Pack = {
  __typename?: 'card_pack';
  code: Scalars['String']['output'];
  /** An object relationship */
  cycle?: Maybe<Card_Cycle>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  position?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "card_pack" */
export type Card_Pack_Aggregate = {
  __typename?: 'card_pack_aggregate';
  aggregate?: Maybe<Card_Pack_Aggregate_Fields>;
  nodes: Array<Card_Pack>;
};

export type Card_Pack_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Card_Pack_Aggregate_Bool_Exp_Count>;
};

export type Card_Pack_Aggregate_Bool_Exp_Bool_And = {
  arguments: Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Pack_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Card_Pack_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Pack_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_pack" */
export type Card_Pack_Aggregate_Fields = {
  __typename?: 'card_pack_aggregate_fields';
  avg?: Maybe<Card_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Pack_Max_Fields>;
  min?: Maybe<Card_Pack_Min_Fields>;
  stddev?: Maybe<Card_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Card_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Card_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Card_Pack_Sum_Fields>;
  var_pop?: Maybe<Card_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Card_Pack_Var_Samp_Fields>;
  variance?: Maybe<Card_Pack_Variance_Fields>;
};


/** aggregate fields of "card_pack" */
export type Card_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_pack" */
export type Card_Pack_Aggregate_Order_By = {
  avg?: InputMaybe<Card_Pack_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Pack_Max_Order_By>;
  min?: InputMaybe<Card_Pack_Min_Order_By>;
  stddev?: InputMaybe<Card_Pack_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Card_Pack_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Card_Pack_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Card_Pack_Sum_Order_By>;
  var_pop?: InputMaybe<Card_Pack_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Card_Pack_Var_Samp_Order_By>;
  variance?: InputMaybe<Card_Pack_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "card_pack" */
export type Card_Pack_Arr_Rel_Insert_Input = {
  data: Array<Card_Pack_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};

/** aggregate avg on columns */
export type Card_Pack_Avg_Fields = {
  __typename?: 'card_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "card_pack" */
export type Card_Pack_Avg_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "card_pack". All fields are combined with a logical 'AND'. */
export type Card_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Pack_Bool_Exp>>;
  _not?: InputMaybe<Card_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Pack_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  cycle?: InputMaybe<Card_Cycle_Bool_Exp>;
  cycle_code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_pack" */
export enum Card_Pack_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardPackPkey = 'card_pack_pkey'
}

/** input type for incrementing numeric columns in table "card_pack" */
export type Card_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "card_pack" */
export type Card_Pack_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle?: InputMaybe<Card_Cycle_Obj_Rel_Insert_Input>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Card_Pack_Max_Fields = {
  __typename?: 'card_pack_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "card_pack" */
export type Card_Pack_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Pack_Min_Fields = {
  __typename?: 'card_pack_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "card_pack" */
export type Card_Pack_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_pack" */
export type Card_Pack_Mutation_Response = {
  __typename?: 'card_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Pack>;
};

/** on_conflict condition type for table "card_pack" */
export type Card_Pack_On_Conflict = {
  constraint: Card_Pack_Constraint;
  update_columns?: Array<Card_Pack_Update_Column>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "card_pack". */
export type Card_Pack_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle?: InputMaybe<Card_Cycle_Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_pack */
export type Card_Pack_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_pack" */
export enum Card_Pack_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

/** select "card_pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "card_pack" */
export enum Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "card_pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "card_pack" */
export enum Card_Pack_Select_Column_Card_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "card_pack" */
export type Card_Pack_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Pack_Stddev_Fields = {
  __typename?: 'card_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "card_pack" */
export type Card_Pack_Stddev_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Card_Pack_Stddev_Pop_Fields = {
  __typename?: 'card_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "card_pack" */
export type Card_Pack_Stddev_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Card_Pack_Stddev_Samp_Fields = {
  __typename?: 'card_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "card_pack" */
export type Card_Pack_Stddev_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "card_pack" */
export type Card_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Pack_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Card_Pack_Sum_Fields = {
  __typename?: 'card_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "card_pack" */
export type Card_Pack_Sum_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** update columns of table "card_pack" */
export enum Card_Pack_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position'
}

export type Card_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Pack_Var_Pop_Fields = {
  __typename?: 'card_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "card_pack" */
export type Card_Pack_Var_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Card_Pack_Var_Samp_Fields = {
  __typename?: 'card_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "card_pack" */
export type Card_Pack_Var_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Card_Pack_Variance_Fields = {
  __typename?: 'card_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "card_pack" */
export type Card_Pack_Variance_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card */
export type Card_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Card_Prepend_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "card" */
export enum Card_Select_Column {
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Clues = 'clues',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  Victory = 'victory'
}

/** input type for updating data in table "card" */
export type Card_Set_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Card_Stddev_Fields = {
  __typename?: 'card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Card_Stddev_Pop_Fields = {
  __typename?: 'card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Card_Stddev_Samp_Fields = {
  __typename?: 'card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "card" */
export type Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Stream_Cursor_Value_Input = {
  back_link?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Scalars['String']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "card_subtype_name" */
export type Card_Subtype_Name = {
  __typename?: 'card_subtype_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate = {
  __typename?: 'card_subtype_name_aggregate';
  aggregate?: Maybe<Card_Subtype_Name_Aggregate_Fields>;
  nodes: Array<Card_Subtype_Name>;
};

/** aggregate fields of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate_Fields = {
  __typename?: 'card_subtype_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Subtype_Name_Max_Fields>;
  min?: Maybe<Card_Subtype_Name_Min_Fields>;
};


/** aggregate fields of "card_subtype_name" */
export type Card_Subtype_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_subtype_name". All fields are combined with a logical 'AND'. */
export type Card_Subtype_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Subtype_Name_Bool_Exp>>;
  _not?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Subtype_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_subtype_name" */
export enum Card_Subtype_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardSubtypeNamePkey = 'card_subtype_name_pkey'
}

/** input type for inserting data into table "card_subtype_name" */
export type Card_Subtype_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Subtype_Name_Max_Fields = {
  __typename?: 'card_subtype_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Subtype_Name_Min_Fields = {
  __typename?: 'card_subtype_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_subtype_name" */
export type Card_Subtype_Name_Mutation_Response = {
  __typename?: 'card_subtype_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Subtype_Name>;
};

/** on_conflict condition type for table "card_subtype_name" */
export type Card_Subtype_Name_On_Conflict = {
  constraint: Card_Subtype_Name_Constraint;
  update_columns?: Array<Card_Subtype_Name_Update_Column>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "card_subtype_name". */
export type Card_Subtype_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_subtype_name */
export type Card_Subtype_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_subtype_name" */
export enum Card_Subtype_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "card_subtype_name" */
export type Card_Subtype_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_subtype_name" */
export type Card_Subtype_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Subtype_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Subtype_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_subtype_name" */
export enum Card_Subtype_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Card_Subtype_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Subtype_Name_Bool_Exp;
};

/** aggregate sum on columns */
export type Card_Sum_Fields = {
  __typename?: 'card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "card_text" */
export type Card_Text = {
  __typename?: 'card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "card_text" */
export type Card_Text_Aggregate = {
  __typename?: 'card_text_aggregate';
  aggregate?: Maybe<Card_Text_Aggregate_Fields>;
  nodes: Array<Card_Text>;
};

export type Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "card_text" */
export type Card_Text_Aggregate_Fields = {
  __typename?: 'card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Text_Max_Fields>;
  min?: Maybe<Card_Text_Min_Fields>;
};


/** aggregate fields of "card_text" */
export type Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "card_text" */
export type Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Card_Text_Max_Order_By>;
  min?: InputMaybe<Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "card_text" */
export type Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "card_text". All fields are combined with a logical 'AND'. */
export type Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_text" */
export enum Card_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CardTextCodeLocaleKey = 'card_text_code_locale_key',
  /** unique or primary key constraint on columns "locale", "code" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "card_text" */
export type Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Text_Max_Fields = {
  __typename?: 'card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "card_text" */
export type Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Card_Text_Min_Fields = {
  __typename?: 'card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "card_text" */
export type Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "card_text" */
export type Card_Text_Mutation_Response = {
  __typename?: 'card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Text>;
};

/** on_conflict condition type for table "card_text" */
export type Card_Text_On_Conflict = {
  constraint: Card_Text_Constraint;
  update_columns?: Array<Card_Text_Update_Column>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "card_text". */
export type Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_text */
export type Card_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "card_text" */
export enum Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

/** input type for updating data in table "card_text" */
export type Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_text" */
export type Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_text" */
export enum Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

export type Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Text_Bool_Exp;
};

/** columns and relationships of "card_type_code" */
export type Card_Type_Code = {
  __typename?: 'card_type_code';
  code: Scalars['String']['output'];
};

/** aggregated selection of "card_type_code" */
export type Card_Type_Code_Aggregate = {
  __typename?: 'card_type_code_aggregate';
  aggregate?: Maybe<Card_Type_Code_Aggregate_Fields>;
  nodes: Array<Card_Type_Code>;
};

/** aggregate fields of "card_type_code" */
export type Card_Type_Code_Aggregate_Fields = {
  __typename?: 'card_type_code_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Type_Code_Max_Fields>;
  min?: Maybe<Card_Type_Code_Min_Fields>;
};


/** aggregate fields of "card_type_code" */
export type Card_Type_Code_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_type_code". All fields are combined with a logical 'AND'. */
export type Card_Type_Code_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Type_Code_Bool_Exp>>;
  _not?: InputMaybe<Card_Type_Code_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Type_Code_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_type_code" */
export enum Card_Type_Code_Constraint {
  /** unique or primary key constraint on columns "code" */
  CardTypeCodePkey = 'card_type_code_pkey'
}

export enum Card_Type_Code_Enum {
  Act = 'act',
  Agenda = 'agenda',
  Asset = 'asset',
  Enemy = 'enemy',
  EnemyLocation = 'enemy_location',
  Event = 'event',
  Investigator = 'investigator',
  Key = 'key',
  Location = 'location',
  Scenario = 'scenario',
  Skill = 'skill',
  Story = 'story',
  Treachery = 'treachery'
}

/** Boolean expression to compare columns of type "card_type_code_enum". All fields are combined with logical 'AND'. */
export type Card_Type_Code_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Card_Type_Code_Enum>;
  _in?: InputMaybe<Array<Card_Type_Code_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Card_Type_Code_Enum>;
  _nin?: InputMaybe<Array<Card_Type_Code_Enum>>;
};

/** input type for inserting data into table "card_type_code" */
export type Card_Type_Code_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Type_Code_Max_Fields = {
  __typename?: 'card_type_code_max_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Type_Code_Min_Fields = {
  __typename?: 'card_type_code_min_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_type_code" */
export type Card_Type_Code_Mutation_Response = {
  __typename?: 'card_type_code_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Type_Code>;
};

/** input type for inserting object relation for remote table "card_type_code" */
export type Card_Type_Code_Obj_Rel_Insert_Input = {
  data: Card_Type_Code_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};

/** on_conflict condition type for table "card_type_code" */
export type Card_Type_Code_On_Conflict = {
  constraint: Card_Type_Code_Constraint;
  update_columns?: Array<Card_Type_Code_Update_Column>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};

/** Ordering options when selecting data from "card_type_code". */
export type Card_Type_Code_Order_By = {
  code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_type_code */
export type Card_Type_Code_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "card_type_code" */
export enum Card_Type_Code_Select_Column {
  /** column name */
  Code = 'code'
}

/** input type for updating data in table "card_type_code" */
export type Card_Type_Code_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_type_code" */
export type Card_Type_Code_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Type_Code_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Type_Code_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_type_code" */
export enum Card_Type_Code_Update_Column {
  /** column name */
  Code = 'code'
}

export type Card_Type_Code_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Type_Code_Bool_Exp;
};

/** columns and relationships of "card_type_name" */
export type Card_Type_Name = {
  __typename?: 'card_type_name';
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "card_type_name" */
export type Card_Type_Name_Aggregate = {
  __typename?: 'card_type_name_aggregate';
  aggregate?: Maybe<Card_Type_Name_Aggregate_Fields>;
  nodes: Array<Card_Type_Name>;
};

/** aggregate fields of "card_type_name" */
export type Card_Type_Name_Aggregate_Fields = {
  __typename?: 'card_type_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Card_Type_Name_Max_Fields>;
  min?: Maybe<Card_Type_Name_Min_Fields>;
};


/** aggregate fields of "card_type_name" */
export type Card_Type_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "card_type_name". All fields are combined with a logical 'AND'. */
export type Card_Type_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Card_Type_Name_Bool_Exp>>;
  _not?: InputMaybe<Card_Type_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Card_Type_Name_Bool_Exp>>;
  code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "card_type_name" */
export enum Card_Type_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  TypeNamePkey = 'type_name_pkey'
}

/** input type for inserting data into table "card_type_name" */
export type Card_Type_Name_Insert_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Card_Type_Name_Max_Fields = {
  __typename?: 'card_type_name_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Card_Type_Name_Min_Fields = {
  __typename?: 'card_type_name_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "card_type_name" */
export type Card_Type_Name_Mutation_Response = {
  __typename?: 'card_type_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Card_Type_Name>;
};

/** on_conflict condition type for table "card_type_name" */
export type Card_Type_Name_On_Conflict = {
  constraint: Card_Type_Name_Constraint;
  update_columns?: Array<Card_Type_Name_Update_Column>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "card_type_name". */
export type Card_Type_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: card_type_name */
export type Card_Type_Name_Pk_Columns_Input = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};

/** select columns of table "card_type_name" */
export enum Card_Type_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "card_type_name" */
export type Card_Type_Name_Set_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "card_type_name" */
export type Card_Type_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Card_Type_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Card_Type_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Card_Type_Code_Enum>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "card_type_name" */
export enum Card_Type_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Card_Type_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Type_Name_Bool_Exp;
};

/** update columns of table "card" */
export enum Card_Update_Column {
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Clues = 'clues',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  Victory = 'victory'
}

export type Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Card_Var_Pop_Fields = {
  __typename?: 'card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Card_Var_Samp_Fields = {
  __typename?: 'card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Card_Variance_Fields = {
  __typename?: 'card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_Result = {
  __typename?: 'chaos_bag_result';
  bless: Scalars['Int']['output'];
  /** An object relationship */
  campaign: Campaign;
  created_at: Scalars['timestamptz']['output'];
  curse: Scalars['Int']['output'];
  difficulty?: Maybe<Campaign_Difficulty_Enum>;
  drawn: Scalars['jsonb']['output'];
  history: Scalars['jsonb']['output'];
  id: Scalars['Int']['output'];
  sealed: Scalars['jsonb']['output'];
  tarot?: Maybe<Chaos_Bag_Tarot_Mode_Enum>;
  /** An object relationship */
  tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultDrawnArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultHistoryArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "chaos_bag_result" */
export type Chaos_Bag_ResultSealedArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate = {
  __typename?: 'chaos_bag_result_aggregate';
  aggregate?: Maybe<Chaos_Bag_Result_Aggregate_Fields>;
  nodes: Array<Chaos_Bag_Result>;
};

export type Chaos_Bag_Result_Aggregate_Bool_Exp = {
  count?: InputMaybe<Chaos_Bag_Result_Aggregate_Bool_Exp_Count>;
};

export type Chaos_Bag_Result_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_Fields = {
  __typename?: 'chaos_bag_result_aggregate_fields';
  avg?: Maybe<Chaos_Bag_Result_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Chaos_Bag_Result_Max_Fields>;
  min?: Maybe<Chaos_Bag_Result_Min_Fields>;
  stddev?: Maybe<Chaos_Bag_Result_Stddev_Fields>;
  stddev_pop?: Maybe<Chaos_Bag_Result_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Chaos_Bag_Result_Stddev_Samp_Fields>;
  sum?: Maybe<Chaos_Bag_Result_Sum_Fields>;
  var_pop?: Maybe<Chaos_Bag_Result_Var_Pop_Fields>;
  var_samp?: Maybe<Chaos_Bag_Result_Var_Samp_Fields>;
  variance?: Maybe<Chaos_Bag_Result_Variance_Fields>;
};


/** aggregate fields of "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "chaos_bag_result" */
export type Chaos_Bag_Result_Aggregate_Order_By = {
  avg?: InputMaybe<Chaos_Bag_Result_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Chaos_Bag_Result_Max_Order_By>;
  min?: InputMaybe<Chaos_Bag_Result_Min_Order_By>;
  stddev?: InputMaybe<Chaos_Bag_Result_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Chaos_Bag_Result_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Chaos_Bag_Result_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Chaos_Bag_Result_Sum_Order_By>;
  var_pop?: InputMaybe<Chaos_Bag_Result_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Chaos_Bag_Result_Var_Samp_Order_By>;
  variance?: InputMaybe<Chaos_Bag_Result_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chaos_Bag_Result_Append_Input = {
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "chaos_bag_result" */
export type Chaos_Bag_Result_Arr_Rel_Insert_Input = {
  data: Array<Chaos_Bag_Result_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};

/** aggregate avg on columns */
export type Chaos_Bag_Result_Avg_Fields = {
  __typename?: 'chaos_bag_result_avg_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Avg_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chaos_bag_result". All fields are combined with a logical 'AND'. */
export type Chaos_Bag_Result_Bool_Exp = {
  _and?: InputMaybe<Array<Chaos_Bag_Result_Bool_Exp>>;
  _not?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
  _or?: InputMaybe<Array<Chaos_Bag_Result_Bool_Exp>>;
  bless?: InputMaybe<Int_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  curse?: InputMaybe<Int_Comparison_Exp>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum_Comparison_Exp>;
  drawn?: InputMaybe<Jsonb_Comparison_Exp>;
  history?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  sealed?: InputMaybe<Jsonb_Comparison_Exp>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum_Comparison_Exp>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
  totalDrawn?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chaos_bag_result" */
export enum Chaos_Bag_Result_Constraint {
  /** unique or primary key constraint on columns "id" */
  ChaosBagPkey = 'chaos_bag_pkey',
  /** unique or primary key constraint on columns "id" */
  ChaosBagResultsCampaignIdKey = 'chaos_bag_results_campaign_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chaos_Bag_Result_Delete_At_Path_Input = {
  drawn?: InputMaybe<Array<Scalars['String']['input']>>;
  history?: InputMaybe<Array<Scalars['String']['input']>>;
  sealed?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chaos_Bag_Result_Delete_Elem_Input = {
  drawn?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chaos_Bag_Result_Delete_Key_Input = {
  drawn?: InputMaybe<Scalars['String']['input']>;
  history?: InputMaybe<Scalars['String']['input']>;
  sealed?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "chaos_bag_result" */
export type Chaos_Bag_Result_Inc_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "chaos_bag_result" */
export type Chaos_Bag_Result_Insert_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Obj_Rel_Insert_Input>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Chaos_Bag_Result_Max_Fields = {
  __typename?: 'chaos_bag_result_max_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Max_Order_By = {
  bless?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Chaos_Bag_Result_Min_Fields = {
  __typename?: 'chaos_bag_result_min_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Min_Order_By = {
  bless?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "chaos_bag_result" */
export type Chaos_Bag_Result_Mutation_Response = {
  __typename?: 'chaos_bag_result_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chaos_Bag_Result>;
};

/** on_conflict condition type for table "chaos_bag_result" */
export type Chaos_Bag_Result_On_Conflict = {
  constraint: Chaos_Bag_Result_Constraint;
  update_columns?: Array<Chaos_Bag_Result_Update_Column>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};

/** Ordering options when selecting data from "chaos_bag_result". */
export type Chaos_Bag_Result_Order_By = {
  bless?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  created_at?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  difficulty?: InputMaybe<Order_By>;
  drawn?: InputMaybe<Order_By>;
  history?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  sealed?: InputMaybe<Order_By>;
  tarot?: InputMaybe<Order_By>;
  tarot_mode?: InputMaybe<Chaos_Bag_Tarot_Mode_Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chaos_bag_result */
export type Chaos_Bag_Result_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chaos_Bag_Result_Prepend_Input = {
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "chaos_bag_result" */
export enum Chaos_Bag_Result_Select_Column {
  /** column name */
  Bless = 'bless',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Curse = 'curse',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  Drawn = 'drawn',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Sealed = 'sealed',
  /** column name */
  Tarot = 'tarot',
  /** column name */
  TotalDrawn = 'totalDrawn',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chaos_bag_result" */
export type Chaos_Bag_Result_Set_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Chaos_Bag_Result_Stddev_Fields = {
  __typename?: 'chaos_bag_result_stddev_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chaos_Bag_Result_Stddev_Pop_Fields = {
  __typename?: 'chaos_bag_result_stddev_pop_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Pop_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chaos_Bag_Result_Stddev_Samp_Fields = {
  __typename?: 'chaos_bag_result_stddev_samp_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Stddev_Samp_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "chaos_bag_result" */
export type Chaos_Bag_Result_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chaos_Bag_Result_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chaos_Bag_Result_Stream_Cursor_Value_Input = {
  bless?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  curse?: InputMaybe<Scalars['Int']['input']>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
  drawn?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sealed?: InputMaybe<Scalars['jsonb']['input']>;
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  totalDrawn?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Chaos_Bag_Result_Sum_Fields = {
  __typename?: 'chaos_bag_result_sum_fields';
  bless?: Maybe<Scalars['Int']['output']>;
  curse?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  totalDrawn?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Sum_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** update columns of table "chaos_bag_result" */
export enum Chaos_Bag_Result_Update_Column {
  /** column name */
  Bless = 'bless',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Curse = 'curse',
  /** column name */
  Difficulty = 'difficulty',
  /** column name */
  Drawn = 'drawn',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Sealed = 'sealed',
  /** column name */
  Tarot = 'tarot',
  /** column name */
  TotalDrawn = 'totalDrawn',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Chaos_Bag_Result_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chaos_Bag_Result_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Chaos_Bag_Result_Var_Pop_Fields = {
  __typename?: 'chaos_bag_result_var_pop_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Var_Pop_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chaos_Bag_Result_Var_Samp_Fields = {
  __typename?: 'chaos_bag_result_var_samp_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Var_Samp_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Chaos_Bag_Result_Variance_Fields = {
  __typename?: 'chaos_bag_result_variance_fields';
  bless?: Maybe<Scalars['Float']['output']>;
  curse?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  totalDrawn?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "chaos_bag_result" */
export type Chaos_Bag_Result_Variance_Order_By = {
  bless?: InputMaybe<Order_By>;
  curse?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  totalDrawn?: InputMaybe<Order_By>;
};

/** columns and relationships of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode = {
  __typename?: 'chaos_bag_tarot_mode';
  value: Scalars['String']['output'];
};

/** aggregated selection of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate = {
  __typename?: 'chaos_bag_tarot_mode_aggregate';
  aggregate?: Maybe<Chaos_Bag_Tarot_Mode_Aggregate_Fields>;
  nodes: Array<Chaos_Bag_Tarot_Mode>;
};

/** aggregate fields of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate_Fields = {
  __typename?: 'chaos_bag_tarot_mode_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Chaos_Bag_Tarot_Mode_Max_Fields>;
  min?: Maybe<Chaos_Bag_Tarot_Mode_Min_Fields>;
};


/** aggregate fields of "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "chaos_bag_tarot_mode". All fields are combined with a logical 'AND'. */
export type Chaos_Bag_Tarot_Mode_Bool_Exp = {
  _and?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Bool_Exp>>;
  _not?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
  _or?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Constraint {
  /** unique or primary key constraint on columns "value" */
  ChaosBagTarotModePkey = 'chaos_bag_tarot_mode_pkey'
}

export enum Chaos_Bag_Tarot_Mode_Enum {
  Judgement = 'judgement',
  JudgementInverted = 'judgement_inverted'
}

/** Boolean expression to compare columns of type "chaos_bag_tarot_mode_enum". All fields are combined with logical 'AND'. */
export type Chaos_Bag_Tarot_Mode_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  _in?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  _nin?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Enum>>;
};

/** input type for inserting data into table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Chaos_Bag_Tarot_Mode_Max_Fields = {
  __typename?: 'chaos_bag_tarot_mode_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Chaos_Bag_Tarot_Mode_Min_Fields = {
  __typename?: 'chaos_bag_tarot_mode_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Mutation_Response = {
  __typename?: 'chaos_bag_tarot_mode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Chaos_Bag_Tarot_Mode>;
};

/** input type for inserting object relation for remote table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Obj_Rel_Insert_Input = {
  data: Chaos_Bag_Tarot_Mode_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};

/** on_conflict condition type for table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_On_Conflict = {
  constraint: Chaos_Bag_Tarot_Mode_Constraint;
  update_columns?: Array<Chaos_Bag_Tarot_Mode_Update_Column>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};

/** Ordering options when selecting data from "chaos_bag_tarot_mode". */
export type Chaos_Bag_Tarot_Mode_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: chaos_bag_tarot_mode */
export type Chaos_Bag_Tarot_Mode_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "chaos_bag_tarot_mode" */
export type Chaos_Bag_Tarot_Mode_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Chaos_Bag_Tarot_Mode_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Chaos_Bag_Tarot_Mode_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "chaos_bag_tarot_mode" */
export enum Chaos_Bag_Tarot_Mode_Update_Column {
  /** column name */
  Value = 'value'
}

export type Chaos_Bag_Tarot_Mode_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  /** filter the rows which have to be updated */
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};

/** columns and relationships of "conquest.card" */
export type Conquest_Card = {
  __typename?: 'conquest_card';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_rules?: Maybe<Scalars['jsonb']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  horizontal?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  pack_id: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  preparation: Scalars['Boolean']['output'];
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id: Scalars['String']['output'];
  unique: Scalars['Boolean']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "conquest.card" */
export type Conquest_CardDeck_RulesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.card" */
export type Conquest_Card_Aggregate = {
  __typename?: 'conquest_card_aggregate';
  aggregate?: Maybe<Conquest_Card_Aggregate_Fields>;
  nodes: Array<Conquest_Card>;
};

/** aggregate fields of "conquest.card" */
export type Conquest_Card_Aggregate_Fields = {
  __typename?: 'conquest_card_aggregate_fields';
  avg?: Maybe<Conquest_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Max_Fields>;
  min?: Maybe<Conquest_Card_Min_Fields>;
  stddev?: Maybe<Conquest_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Card_Sum_Fields>;
  var_pop?: Maybe<Conquest_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Card_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Card_Variance_Fields>;
};


/** aggregate fields of "conquest.card" */
export type Conquest_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Card_Append_Input = {
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Card_Avg_Fields = {
  __typename?: 'conquest_card_avg_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.card". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Bool_Exp>>;
  attack?: InputMaybe<Int_Comparison_Exp>;
  back_attack?: InputMaybe<Int_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_health?: InputMaybe<Int_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  back_tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  command_hammers?: InputMaybe<Int_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_rules?: InputMaybe<Jsonb_Comparison_Exp>;
  faction_id?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  horizontal?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  loyalty_id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preparation?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  shields?: InputMaybe<Int_Comparison_Exp>;
  signature_id?: InputMaybe<Int_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  tts_sheet_position?: InputMaybe<Int_Comparison_Exp>;
  tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  unique?: InputMaybe<Boolean_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.card" */
export enum Conquest_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  CardPkey = 'card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conquest_Card_Delete_At_Path_Input = {
  deck_rules?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conquest_Card_Delete_Elem_Input = {
  deck_rules?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conquest_Card_Delete_Key_Input = {
  deck_rules?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "conquest.card" */
export type Conquest_Card_Inc_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.card" */
export type Conquest_Card_Insert_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.card_localized" */
export type Conquest_Card_Localized = {
  __typename?: 'conquest_card_localized';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_rules?: Maybe<Scalars['jsonb']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  horizontal?: Maybe<Scalars['Boolean']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  preparation?: Maybe<Scalars['Boolean']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  unique?: Maybe<Scalars['Boolean']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "conquest.card_localized" */
export type Conquest_Card_LocalizedDeck_RulesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate = {
  __typename?: 'conquest_card_localized_aggregate';
  aggregate?: Maybe<Conquest_Card_Localized_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Localized>;
};

/** aggregate fields of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate_Fields = {
  __typename?: 'conquest_card_localized_aggregate_fields';
  avg?: Maybe<Conquest_Card_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Localized_Max_Fields>;
  min?: Maybe<Conquest_Card_Localized_Min_Fields>;
  stddev?: Maybe<Conquest_Card_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Card_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Card_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Card_Localized_Sum_Fields>;
  var_pop?: Maybe<Conquest_Card_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Card_Localized_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Card_Localized_Variance_Fields>;
};


/** aggregate fields of "conquest.card_localized" */
export type Conquest_Card_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Card_Localized_Avg_Fields = {
  __typename?: 'conquest_card_localized_avg_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.card_localized". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Localized_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Localized_Bool_Exp>>;
  attack?: InputMaybe<Int_Comparison_Exp>;
  back_attack?: InputMaybe<Int_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_health?: InputMaybe<Int_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  command_hammers?: InputMaybe<Int_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_rules?: InputMaybe<Jsonb_Comparison_Exp>;
  faction_id?: InputMaybe<String_Comparison_Exp>;
  faction_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  horizontal?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  loyalty_id?: InputMaybe<String_Comparison_Exp>;
  loyalty_name?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  pack_cycle_id?: InputMaybe<String_Comparison_Exp>;
  pack_cycle_name?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  pack_name?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  preparation?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_back_traits?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_keywords?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  shields?: InputMaybe<Int_Comparison_Exp>;
  signature_id?: InputMaybe<Int_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  tts_sheet_position?: InputMaybe<Int_Comparison_Exp>;
  tts_sheet_url?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  unique?: InputMaybe<Boolean_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Conquest_Card_Localized_Max_Fields = {
  __typename?: 'conquest_card_localized_max_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Localized_Min_Fields = {
  __typename?: 'conquest_card_localized_min_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  faction_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  loyalty_name?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_cycle_id?: Maybe<Scalars['String']['output']>;
  pack_cycle_name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_imagesrc?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_back_traits?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_keywords?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "conquest.card_localized". */
export type Conquest_Card_Localized_Order_By = {
  attack?: InputMaybe<Order_By>;
  back_attack?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  back_flavor?: InputMaybe<Order_By>;
  back_health?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  command_hammers?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_rules?: InputMaybe<Order_By>;
  faction_id?: InputMaybe<Order_By>;
  faction_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  horizontal?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  loyalty_id?: InputMaybe<Order_By>;
  loyalty_name?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_cycle_id?: InputMaybe<Order_By>;
  pack_cycle_name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  pack_name?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preparation?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_imagesrc?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_back_traits?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_imagesrc?: InputMaybe<Order_By>;
  real_keywords?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  shields?: InputMaybe<Order_By>;
  signature_id?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  tts_sheet_position?: InputMaybe<Order_By>;
  tts_sheet_url?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  unique?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "conquest.card_localized" */
export enum Conquest_Card_Localized_Select_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  FactionName = 'faction_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  LoyaltyName = 'loyalty_name',
  /** column name */
  Name = 'name',
  /** column name */
  PackCycleId = 'pack_cycle_id',
  /** column name */
  PackCycleName = 'pack_cycle_name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  PackName = 'pack_name',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackImagesrc = 'real_back_imagesrc',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealBackTraits = 'real_back_traits',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealImagesrc = 'real_imagesrc',
  /** column name */
  RealKeywords = 'real_keywords',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Conquest_Card_Localized_Stddev_Fields = {
  __typename?: 'conquest_card_localized_stddev_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Card_Localized_Stddev_Pop_Fields = {
  __typename?: 'conquest_card_localized_stddev_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Card_Localized_Stddev_Samp_Fields = {
  __typename?: 'conquest_card_localized_stddev_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_card_localized" */
export type Conquest_Card_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Localized_Stream_Cursor_Value_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  faction_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  loyalty_name?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_cycle_id?: InputMaybe<Scalars['String']['input']>;
  pack_cycle_name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  pack_name?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_back_traits?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_keywords?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Card_Localized_Sum_Fields = {
  __typename?: 'conquest_card_localized_sum_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Conquest_Card_Localized_Var_Pop_Fields = {
  __typename?: 'conquest_card_localized_var_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Card_Localized_Var_Samp_Fields = {
  __typename?: 'conquest_card_localized_var_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Card_Localized_Variance_Fields = {
  __typename?: 'conquest_card_localized_variance_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Conquest_Card_Max_Fields = {
  __typename?: 'conquest_card_max_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Min_Fields = {
  __typename?: 'conquest_card_min_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  back_tts_sheet_url?: Maybe<Scalars['String']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  faction_id?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  loyalty_id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
  tts_sheet_url?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.card" */
export type Conquest_Card_Mutation_Response = {
  __typename?: 'conquest_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Card>;
};

/** on_conflict condition type for table "conquest.card" */
export type Conquest_Card_On_Conflict = {
  constraint: Conquest_Card_Constraint;
  update_columns?: Array<Conquest_Card_Update_Column>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.card". */
export type Conquest_Card_Order_By = {
  attack?: InputMaybe<Order_By>;
  back_attack?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  back_flavor?: InputMaybe<Order_By>;
  back_health?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  back_tts_sheet_url?: InputMaybe<Order_By>;
  command_hammers?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_rules?: InputMaybe<Order_By>;
  faction_id?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  horizontal?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  loyalty_id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  preparation?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  shields?: InputMaybe<Order_By>;
  signature_id?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  tts_sheet_position?: InputMaybe<Order_By>;
  tts_sheet_url?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  unique?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.card */
export type Conquest_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Card_Prepend_Input = {
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "conquest.card" */
export enum Conquest_Card_Select_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  BackTtsSheetUrl = 'back_tts_sheet_url',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.card" */
export type Conquest_Card_Set_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Card_Stddev_Fields = {
  __typename?: 'conquest_card_stddev_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Card_Stddev_Pop_Fields = {
  __typename?: 'conquest_card_stddev_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Card_Stddev_Samp_Fields = {
  __typename?: 'conquest_card_stddev_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_card" */
export type Conquest_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Stream_Cursor_Value_Input = {
  attack?: InputMaybe<Scalars['Int']['input']>;
  back_attack?: InputMaybe<Scalars['Int']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_health?: InputMaybe<Scalars['Int']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  back_tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  command_hammers?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_rules?: InputMaybe<Scalars['jsonb']['input']>;
  faction_id?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  horizontal?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  loyalty_id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  preparation?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  shields?: InputMaybe<Scalars['Int']['input']>;
  signature_id?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  tts_sheet_position?: InputMaybe<Scalars['Int']['input']>;
  tts_sheet_url?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  unique?: InputMaybe<Scalars['Boolean']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Card_Sum_Fields = {
  __typename?: 'conquest_card_sum_fields';
  attack?: Maybe<Scalars['Int']['output']>;
  back_attack?: Maybe<Scalars['Int']['output']>;
  back_health?: Maybe<Scalars['Int']['output']>;
  command_hammers?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  shields?: Maybe<Scalars['Int']['output']>;
  signature_id?: Maybe<Scalars['Int']['output']>;
  tts_sheet_position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.card_text" */
export type Conquest_Card_Text = {
  __typename?: 'conquest_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate = {
  __typename?: 'conquest_card_text_aggregate';
  aggregate?: Maybe<Conquest_Card_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Text>;
};

/** aggregate fields of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate_Fields = {
  __typename?: 'conquest_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Text_Max_Fields>;
  min?: Maybe<Conquest_Card_Text_Min_Fields>;
};


/** aggregate fields of "conquest.card_text" */
export type Conquest_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.card_text". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_imagesrc?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  back_traits?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  keywords?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.card_text" */
export enum Conquest_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "conquest.card_text" */
export type Conquest_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Card_Text_Max_Fields = {
  __typename?: 'conquest_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Text_Min_Fields = {
  __typename?: 'conquest_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_imagesrc?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  back_traits?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  keywords?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.card_text" */
export type Conquest_Card_Text_Mutation_Response = {
  __typename?: 'conquest_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Card_Text>;
};

/** on_conflict condition type for table "conquest.card_text" */
export type Conquest_Card_Text_On_Conflict = {
  constraint: Conquest_Card_Text_Constraint;
  update_columns?: Array<Conquest_Card_Text_Update_Column>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.card_text". */
export type Conquest_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_imagesrc?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  back_traits?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  keywords?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.card_text */
export type Conquest_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.card_text" */
export enum Conquest_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.card_text" */
export type Conquest_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_card_text" */
export type Conquest_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_imagesrc?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  back_traits?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  keywords?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.card_text" */
export enum Conquest_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Card_Text_Bool_Exp;
};

/** update columns of table "conquest.card" */
export enum Conquest_Card_Update_Column {
  /** column name */
  Attack = 'attack',
  /** column name */
  BackAttack = 'back_attack',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackHealth = 'back_health',
  /** column name */
  BackImagesrc = 'back_imagesrc',
  /** column name */
  BackText = 'back_text',
  /** column name */
  BackTraits = 'back_traits',
  /** column name */
  BackTtsSheetUrl = 'back_tts_sheet_url',
  /** column name */
  CommandHammers = 'command_hammers',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckRules = 'deck_rules',
  /** column name */
  FactionId = 'faction_id',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Health = 'health',
  /** column name */
  Horizontal = 'horizontal',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Keywords = 'keywords',
  /** column name */
  LoyaltyId = 'loyalty_id',
  /** column name */
  Name = 'name',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Preparation = 'preparation',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Shields = 'shields',
  /** column name */
  SignatureId = 'signature_id',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  TtsSheetPosition = 'tts_sheet_position',
  /** column name */
  TtsSheetUrl = 'tts_sheet_url',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  Unique = 'unique',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "conquest.card_updated" */
export type Conquest_Card_Updated = {
  __typename?: 'conquest_card_updated';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate = {
  __typename?: 'conquest_card_updated_aggregate';
  aggregate?: Maybe<Conquest_Card_Updated_Aggregate_Fields>;
  nodes: Array<Conquest_Card_Updated>;
};

/** aggregate fields of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate_Fields = {
  __typename?: 'conquest_card_updated_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Card_Updated_Max_Fields>;
  min?: Maybe<Conquest_Card_Updated_Min_Fields>;
};


/** aggregate fields of "conquest.card_updated" */
export type Conquest_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.card_updated". All fields are combined with a logical 'AND'. */
export type Conquest_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Card_Updated_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Conquest_Card_Updated_Max_Fields = {
  __typename?: 'conquest_card_updated_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Card_Updated_Min_Fields = {
  __typename?: 'conquest_card_updated_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "conquest.card_updated". */
export type Conquest_Card_Updated_Order_By = {
  locale?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "conquest.card_updated" */
export enum Conquest_Card_Updated_Select_Column {
  /** column name */
  Locale = 'locale',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "conquest_card_updated" */
export type Conquest_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Card_Updated_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

export type Conquest_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Card_Var_Pop_Fields = {
  __typename?: 'conquest_card_var_pop_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Card_Var_Samp_Fields = {
  __typename?: 'conquest_card_var_samp_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Card_Variance_Fields = {
  __typename?: 'conquest_card_variance_fields';
  attack?: Maybe<Scalars['Float']['output']>;
  back_attack?: Maybe<Scalars['Float']['output']>;
  back_health?: Maybe<Scalars['Float']['output']>;
  command_hammers?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  shields?: Maybe<Scalars['Float']['output']>;
  signature_id?: Maybe<Scalars['Float']['output']>;
  tts_sheet_position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.comment" */
export type Conquest_Comment = {
  __typename?: 'conquest_comment';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck?: Maybe<Conquest_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  response_count: Scalars['Int']['output'];
  /** An array relationship */
  responses: Array<Conquest_Comment>;
  /** An aggregate relationship */
  responses_aggregate: Conquest_Comment_Aggregate;
  text?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "conquest.comment" */
export type Conquest_CommentResponsesArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.comment" */
export type Conquest_CommentResponses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};

/** aggregated selection of "conquest.comment" */
export type Conquest_Comment_Aggregate = {
  __typename?: 'conquest_comment_aggregate';
  aggregate?: Maybe<Conquest_Comment_Aggregate_Fields>;
  nodes: Array<Conquest_Comment>;
};

export type Conquest_Comment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp_Count>;
};

export type Conquest_Comment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_Comment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "conquest.comment" */
export type Conquest_Comment_Aggregate_Fields = {
  __typename?: 'conquest_comment_aggregate_fields';
  avg?: Maybe<Conquest_Comment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Comment_Max_Fields>;
  min?: Maybe<Conquest_Comment_Min_Fields>;
  stddev?: Maybe<Conquest_Comment_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Comment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Comment_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Comment_Sum_Fields>;
  var_pop?: Maybe<Conquest_Comment_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Comment_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Comment_Variance_Fields>;
};


/** aggregate fields of "conquest.comment" */
export type Conquest_Comment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "conquest.comment" */
export type Conquest_Comment_Aggregate_Order_By = {
  avg?: InputMaybe<Conquest_Comment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Conquest_Comment_Max_Order_By>;
  min?: InputMaybe<Conquest_Comment_Min_Order_By>;
  stddev?: InputMaybe<Conquest_Comment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Conquest_Comment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Conquest_Comment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Conquest_Comment_Sum_Order_By>;
  var_pop?: InputMaybe<Conquest_Comment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Conquest_Comment_Var_Samp_Order_By>;
  variance?: InputMaybe<Conquest_Comment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "conquest.comment" */
export type Conquest_Comment_Arr_Rel_Insert_Input = {
  data: Array<Conquest_Comment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};

/** aggregate avg on columns */
export type Conquest_Comment_Avg_Fields = {
  __typename?: 'conquest_comment_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "conquest.comment" */
export type Conquest_Comment_Avg_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "conquest.comment". All fields are combined with a logical 'AND'. */
export type Conquest_Comment_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Comment_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Comment_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Comment_Bool_Exp>>;
  comment_id?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  response_count?: InputMaybe<Int_Comparison_Exp>;
  responses?: InputMaybe<Conquest_Comment_Bool_Exp>;
  responses_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.comment" */
export enum Conquest_Comment_Constraint {
  /** unique or primary key constraint on columns "id" */
  CommentPkey = 'comment_pkey'
}

/** input type for incrementing numeric columns in table "conquest.comment" */
export type Conquest_Comment_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.comment" */
export type Conquest_Comment_Insert_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  responses?: InputMaybe<Conquest_Comment_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Comment_Max_Fields = {
  __typename?: 'conquest_comment_max_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "conquest.comment" */
export type Conquest_Comment_Max_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Conquest_Comment_Min_Fields = {
  __typename?: 'conquest_comment_min_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "conquest.comment" */
export type Conquest_Comment_Min_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "conquest.comment" */
export type Conquest_Comment_Mutation_Response = {
  __typename?: 'conquest_comment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Comment>;
};

/** on_conflict condition type for table "conquest.comment" */
export type Conquest_Comment_On_Conflict = {
  constraint: Conquest_Comment_Constraint;
  update_columns?: Array<Conquest_Comment_Update_Column>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.comment". */
export type Conquest_Comment_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Conquest_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  responses_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.comment */
export type Conquest_Comment_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "conquest.comment" */
export enum Conquest_Comment_Select_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.comment" */
export type Conquest_Comment_Set_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Comment_Stddev_Fields = {
  __typename?: 'conquest_comment_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Comment_Stddev_Pop_Fields = {
  __typename?: 'conquest_comment_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Comment_Stddev_Samp_Fields = {
  __typename?: 'conquest_comment_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "conquest.comment" */
export type Conquest_Comment_Stddev_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "conquest_comment" */
export type Conquest_Comment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Comment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Comment_Stream_Cursor_Value_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Comment_Sum_Fields = {
  __typename?: 'conquest_comment_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "conquest.comment" */
export type Conquest_Comment_Sum_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** update columns of table "conquest.comment" */
export enum Conquest_Comment_Update_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Comment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Comment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Comment_Var_Pop_Fields = {
  __typename?: 'conquest_comment_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "conquest.comment" */
export type Conquest_Comment_Var_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Conquest_Comment_Var_Samp_Fields = {
  __typename?: 'conquest_comment_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "conquest.comment" */
export type Conquest_Comment_Var_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Conquest_Comment_Variance_Fields = {
  __typename?: 'conquest_comment_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "conquest.comment" */
export type Conquest_Comment_Variance_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** columns and relationships of "conquest.cycle" */
export type Conquest_Cycle = {
  __typename?: 'conquest_cycle';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.cycle" */
export type Conquest_Cycle_Aggregate = {
  __typename?: 'conquest_cycle_aggregate';
  aggregate?: Maybe<Conquest_Cycle_Aggregate_Fields>;
  nodes: Array<Conquest_Cycle>;
};

/** aggregate fields of "conquest.cycle" */
export type Conquest_Cycle_Aggregate_Fields = {
  __typename?: 'conquest_cycle_aggregate_fields';
  avg?: Maybe<Conquest_Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Cycle_Max_Fields>;
  min?: Maybe<Conquest_Cycle_Min_Fields>;
  stddev?: Maybe<Conquest_Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Cycle_Sum_Fields>;
  var_pop?: Maybe<Conquest_Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Cycle_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Cycle_Variance_Fields>;
};


/** aggregate fields of "conquest.cycle" */
export type Conquest_Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Cycle_Avg_Fields = {
  __typename?: 'conquest_cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.cycle". All fields are combined with a logical 'AND'. */
export type Conquest_Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Cycle_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Cycle_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.cycle" */
export enum Conquest_Cycle_Constraint {
  /** unique or primary key constraint on columns "id" */
  CyclePkey = 'cycle_pkey'
}

/** input type for incrementing numeric columns in table "conquest.cycle" */
export type Conquest_Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.cycle" */
export type Conquest_Cycle_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Cycle_Max_Fields = {
  __typename?: 'conquest_cycle_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Cycle_Min_Fields = {
  __typename?: 'conquest_cycle_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.cycle" */
export type Conquest_Cycle_Mutation_Response = {
  __typename?: 'conquest_cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Cycle>;
};

/** on_conflict condition type for table "conquest.cycle" */
export type Conquest_Cycle_On_Conflict = {
  constraint: Conquest_Cycle_Constraint;
  update_columns?: Array<Conquest_Cycle_Update_Column>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.cycle". */
export type Conquest_Cycle_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.cycle */
export type Conquest_Cycle_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.cycle" */
export enum Conquest_Cycle_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.cycle" */
export type Conquest_Cycle_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Cycle_Stddev_Fields = {
  __typename?: 'conquest_cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Cycle_Stddev_Pop_Fields = {
  __typename?: 'conquest_cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Cycle_Stddev_Samp_Fields = {
  __typename?: 'conquest_cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_cycle" */
export type Conquest_Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Cycle_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Cycle_Sum_Fields = {
  __typename?: 'conquest_cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.cycle_text" */
export type Conquest_Cycle_Text = {
  __typename?: 'conquest_cycle_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate = {
  __typename?: 'conquest_cycle_text_aggregate';
  aggregate?: Maybe<Conquest_Cycle_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Cycle_Text>;
};

/** aggregate fields of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate_Fields = {
  __typename?: 'conquest_cycle_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Cycle_Text_Max_Fields>;
  min?: Maybe<Conquest_Cycle_Text_Min_Fields>;
};


/** aggregate fields of "conquest.cycle_text" */
export type Conquest_Cycle_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.cycle_text". All fields are combined with a logical 'AND'. */
export type Conquest_Cycle_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Cycle_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Cycle_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CycleTextPkey = 'cycle_text_pkey'
}

/** input type for inserting data into table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Cycle_Text_Max_Fields = {
  __typename?: 'conquest_cycle_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Cycle_Text_Min_Fields = {
  __typename?: 'conquest_cycle_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Mutation_Response = {
  __typename?: 'conquest_cycle_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Cycle_Text>;
};

/** on_conflict condition type for table "conquest.cycle_text" */
export type Conquest_Cycle_Text_On_Conflict = {
  constraint: Conquest_Cycle_Text_Constraint;
  update_columns?: Array<Conquest_Cycle_Text_Update_Column>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.cycle_text". */
export type Conquest_Cycle_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.cycle_text */
export type Conquest_Cycle_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.cycle_text" */
export type Conquest_Cycle_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_cycle_text" */
export type Conquest_Cycle_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Cycle_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Cycle_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.cycle_text" */
export enum Conquest_Cycle_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Cycle_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Cycle_Text_Bool_Exp;
};

/** update columns of table "conquest.cycle" */
export enum Conquest_Cycle_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Cycle_Var_Pop_Fields = {
  __typename?: 'conquest_cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Cycle_Var_Samp_Fields = {
  __typename?: 'conquest_cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Cycle_Variance_Fields = {
  __typename?: 'conquest_cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.deck" */
export type Conquest_Deck = {
  __typename?: 'conquest_deck';
  comment_count: Scalars['Int']['output'];
  /** An array relationship */
  comments: Array<Conquest_Comment>;
  /** An aggregate relationship */
  comments_aggregate: Conquest_Comment_Aggregate;
  copy_count: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  like_count: Scalars['Int']['output'];
  /** A computed field, executes function "conquest.deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  original_deck?: Maybe<Conquest_Deck_Copy>;
  published?: Maybe<Scalars['Boolean']['output']>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  tags: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckCommentsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckComments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "conquest.deck" */
export type Conquest_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "conquest.deck" */
export type Conquest_Deck_Aggregate = {
  __typename?: 'conquest_deck_aggregate';
  aggregate?: Maybe<Conquest_Deck_Aggregate_Fields>;
  nodes: Array<Conquest_Deck>;
};

/** aggregate fields of "conquest.deck" */
export type Conquest_Deck_Aggregate_Fields = {
  __typename?: 'conquest_deck_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Max_Fields>;
  min?: Maybe<Conquest_Deck_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Variance_Fields>;
};


/** aggregate fields of "conquest.deck" */
export type Conquest_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Deck_Append_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Avg_Fields = {
  __typename?: 'conquest_deck_avg_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Bool_Exp>>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  comments?: InputMaybe<Conquest_Comment_Bool_Exp>;
  comments_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Bool_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck" */
export enum Conquest_Deck_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** columns and relationships of "conquest.deck_copy" */
export type Conquest_Deck_Copy = {
  __typename?: 'conquest_deck_copy';
  copy_deck_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Conquest_Deck;
  /** An object relationship */
  deck_copy: Conquest_Deck;
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Conquest_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate = {
  __typename?: 'conquest_deck_copy_aggregate';
  aggregate?: Maybe<Conquest_Deck_Copy_Aggregate_Fields>;
  nodes: Array<Conquest_Deck_Copy>;
};

/** aggregate fields of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate_Fields = {
  __typename?: 'conquest_deck_copy_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Copy_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Copy_Max_Fields>;
  min?: Maybe<Conquest_Deck_Copy_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Copy_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Copy_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Copy_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Copy_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Copy_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Copy_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Copy_Variance_Fields>;
};


/** aggregate fields of "conquest.deck_copy" */
export type Conquest_Deck_Copy_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Copy_Avg_Fields = {
  __typename?: 'conquest_deck_copy_avg_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck_copy". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Copy_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Copy_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Copy_Bool_Exp>>;
  copy_deck_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_copy?: InputMaybe<Conquest_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Conquest_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Constraint {
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyPkey = 'deck_copy_pkey'
}

/** input type for incrementing numeric columns in table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Inc_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Insert_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_copy?: InputMaybe<Conquest_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Copy_Max_Fields = {
  __typename?: 'conquest_deck_copy_max_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Copy_Min_Fields = {
  __typename?: 'conquest_deck_copy_min_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Mutation_Response = {
  __typename?: 'conquest_deck_copy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck_Copy>;
};

/** input type for inserting object relation for remote table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Obj_Rel_Insert_Input = {
  data: Conquest_Deck_Copy_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};

/** on_conflict condition type for table "conquest.deck_copy" */
export type Conquest_Deck_Copy_On_Conflict = {
  constraint: Conquest_Deck_Copy_Constraint;
  update_columns?: Array<Conquest_Deck_Copy_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck_copy". */
export type Conquest_Deck_Copy_Order_By = {
  copy_deck_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Conquest_Deck_Order_By>;
  deck_copy?: InputMaybe<Conquest_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck_copy */
export type Conquest_Deck_Copy_Pk_Columns_Input = {
  copy_deck_id: Scalars['Int']['input'];
};

/** select columns of table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Select_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck_copy" */
export type Conquest_Deck_Copy_Set_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Copy_Stddev_Fields = {
  __typename?: 'conquest_deck_copy_stddev_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Copy_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_copy_stddev_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Copy_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_copy_stddev_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck_copy" */
export type Conquest_Deck_Copy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Copy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Copy_Stream_Cursor_Value_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Copy_Sum_Fields = {
  __typename?: 'conquest_deck_copy_sum_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck_copy" */
export enum Conquest_Deck_Copy_Update_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Copy_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Copy_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Copy_Var_Pop_Fields = {
  __typename?: 'conquest_deck_copy_var_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Copy_Var_Samp_Fields = {
  __typename?: 'conquest_deck_copy_var_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Copy_Variance_Fields = {
  __typename?: 'conquest_deck_copy_variance_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conquest_Deck_Delete_At_Path_Input = {
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conquest_Deck_Delete_Elem_Input = {
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conquest_Deck_Delete_Key_Input = {
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "conquest.deck" */
export type Conquest_Deck_Inc_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck" */
export type Conquest_Deck_Insert_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  comments?: InputMaybe<Conquest_Comment_Arr_Rel_Insert_Input>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Obj_Rel_Insert_Input>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Conquest_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "conquest.deck_like" */
export type Conquest_Deck_Like = {
  __typename?: 'conquest_deck_like';
  created_at: Scalars['timestamptz']['output'];
  deck_id: Scalars['Int']['output'];
  liked: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate = {
  __typename?: 'conquest_deck_like_aggregate';
  aggregate?: Maybe<Conquest_Deck_Like_Aggregate_Fields>;
  nodes: Array<Conquest_Deck_Like>;
};

/** aggregate fields of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate_Fields = {
  __typename?: 'conquest_deck_like_aggregate_fields';
  avg?: Maybe<Conquest_Deck_Like_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Deck_Like_Max_Fields>;
  min?: Maybe<Conquest_Deck_Like_Min_Fields>;
  stddev?: Maybe<Conquest_Deck_Like_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Deck_Like_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Deck_Like_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Deck_Like_Sum_Fields>;
  var_pop?: Maybe<Conquest_Deck_Like_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Deck_Like_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Deck_Like_Variance_Fields>;
};


/** aggregate fields of "conquest.deck_like" */
export type Conquest_Deck_Like_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Deck_Like_Avg_Fields = {
  __typename?: 'conquest_deck_like_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.deck_like". All fields are combined with a logical 'AND'. */
export type Conquest_Deck_Like_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Deck_Like_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Deck_Like_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  liked?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.deck_like" */
export enum Conquest_Deck_Like_Constraint {
  /** unique or primary key constraint on columns "user_id", "deck_id" */
  DeckLikePkey = 'deck_like_pkey'
}

/** input type for incrementing numeric columns in table "conquest.deck_like" */
export type Conquest_Deck_Like_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.deck_like" */
export type Conquest_Deck_Like_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Like_Max_Fields = {
  __typename?: 'conquest_deck_like_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Like_Min_Fields = {
  __typename?: 'conquest_deck_like_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck_like" */
export type Conquest_Deck_Like_Mutation_Response = {
  __typename?: 'conquest_deck_like_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck_Like>;
};

/** on_conflict condition type for table "conquest.deck_like" */
export type Conquest_Deck_Like_On_Conflict = {
  constraint: Conquest_Deck_Like_Constraint;
  update_columns?: Array<Conquest_Deck_Like_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck_like". */
export type Conquest_Deck_Like_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  liked?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck_like */
export type Conquest_Deck_Like_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "conquest.deck_like" */
export enum Conquest_Deck_Like_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck_like" */
export type Conquest_Deck_Like_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Like_Stddev_Fields = {
  __typename?: 'conquest_deck_like_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Like_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_like_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Like_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_like_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck_like" */
export type Conquest_Deck_Like_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Like_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Like_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Like_Sum_Fields = {
  __typename?: 'conquest_deck_like_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck_like" */
export enum Conquest_Deck_Like_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Like_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Like_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Like_Var_Pop_Fields = {
  __typename?: 'conquest_deck_like_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Like_Var_Samp_Fields = {
  __typename?: 'conquest_deck_like_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Like_Variance_Fields = {
  __typename?: 'conquest_deck_like_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Conquest_Deck_Max_Fields = {
  __typename?: 'conquest_deck_max_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_Deck_Min_Fields = {
  __typename?: 'conquest_deck_min_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.deck" */
export type Conquest_Deck_Mutation_Response = {
  __typename?: 'conquest_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Deck>;
};

/** input type for inserting object relation for remote table "conquest.deck" */
export type Conquest_Deck_Obj_Rel_Insert_Input = {
  data: Conquest_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};

/** on_conflict condition type for table "conquest.deck" */
export type Conquest_Deck_On_Conflict = {
  constraint: Conquest_Deck_Constraint;
  update_columns?: Array<Conquest_Deck_Update_Column>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.deck". */
export type Conquest_Deck_Order_By = {
  comment_count?: InputMaybe<Order_By>;
  comments_aggregate?: InputMaybe<Conquest_Comment_Aggregate_Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  original_deck?: InputMaybe<Conquest_Deck_Copy_Order_By>;
  published?: InputMaybe<Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Conquest_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.deck */
export type Conquest_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conquest_Deck_Prepend_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "conquest.deck" */
export enum Conquest_Deck_Select_Column {
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "conquest.deck" */
export type Conquest_Deck_Set_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Deck_Stddev_Fields = {
  __typename?: 'conquest_deck_stddev_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Deck_Stddev_Pop_Fields = {
  __typename?: 'conquest_deck_stddev_pop_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Deck_Stddev_Samp_Fields = {
  __typename?: 'conquest_deck_stddev_samp_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_deck" */
export type Conquest_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Deck_Stream_Cursor_Value_Input = {
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Deck_Sum_Fields = {
  __typename?: 'conquest_deck_sum_fields';
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "conquest.deck" */
export enum Conquest_Deck_Update_Column {
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Deck_Var_Pop_Fields = {
  __typename?: 'conquest_deck_var_pop_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Deck_Var_Samp_Fields = {
  __typename?: 'conquest_deck_var_samp_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Deck_Variance_Fields = {
  __typename?: 'conquest_deck_variance_fields';
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "conquest.faction" */
export type Conquest_Faction = {
  __typename?: 'conquest_faction';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.faction" */
export type Conquest_Faction_Aggregate = {
  __typename?: 'conquest_faction_aggregate';
  aggregate?: Maybe<Conquest_Faction_Aggregate_Fields>;
  nodes: Array<Conquest_Faction>;
};

/** aggregate fields of "conquest.faction" */
export type Conquest_Faction_Aggregate_Fields = {
  __typename?: 'conquest_faction_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Faction_Max_Fields>;
  min?: Maybe<Conquest_Faction_Min_Fields>;
};


/** aggregate fields of "conquest.faction" */
export type Conquest_Faction_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.faction". All fields are combined with a logical 'AND'. */
export type Conquest_Faction_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Faction_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Faction_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Faction_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.faction" */
export enum Conquest_Faction_Constraint {
  /** unique or primary key constraint on columns "id" */
  FactionPkey = 'faction_pkey'
}

/** input type for inserting data into table "conquest.faction" */
export type Conquest_Faction_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Faction_Max_Fields = {
  __typename?: 'conquest_faction_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Faction_Min_Fields = {
  __typename?: 'conquest_faction_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.faction" */
export type Conquest_Faction_Mutation_Response = {
  __typename?: 'conquest_faction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Faction>;
};

/** on_conflict condition type for table "conquest.faction" */
export type Conquest_Faction_On_Conflict = {
  constraint: Conquest_Faction_Constraint;
  update_columns?: Array<Conquest_Faction_Update_Column>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.faction". */
export type Conquest_Faction_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.faction */
export type Conquest_Faction_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.faction" */
export enum Conquest_Faction_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.faction" */
export type Conquest_Faction_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_faction" */
export type Conquest_Faction_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Faction_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Faction_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.faction_text" */
export type Conquest_Faction_Text = {
  __typename?: 'conquest_faction_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate = {
  __typename?: 'conquest_faction_text_aggregate';
  aggregate?: Maybe<Conquest_Faction_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Faction_Text>;
};

/** aggregate fields of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate_Fields = {
  __typename?: 'conquest_faction_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Faction_Text_Max_Fields>;
  min?: Maybe<Conquest_Faction_Text_Min_Fields>;
};


/** aggregate fields of "conquest.faction_text" */
export type Conquest_Faction_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.faction_text". All fields are combined with a logical 'AND'. */
export type Conquest_Faction_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Faction_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Faction_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.faction_text" */
export enum Conquest_Faction_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  FactionTextPkey = 'faction_text_pkey'
}

/** input type for inserting data into table "conquest.faction_text" */
export type Conquest_Faction_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Faction_Text_Max_Fields = {
  __typename?: 'conquest_faction_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Faction_Text_Min_Fields = {
  __typename?: 'conquest_faction_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.faction_text" */
export type Conquest_Faction_Text_Mutation_Response = {
  __typename?: 'conquest_faction_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Faction_Text>;
};

/** on_conflict condition type for table "conquest.faction_text" */
export type Conquest_Faction_Text_On_Conflict = {
  constraint: Conquest_Faction_Text_Constraint;
  update_columns?: Array<Conquest_Faction_Text_Update_Column>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.faction_text". */
export type Conquest_Faction_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.faction_text */
export type Conquest_Faction_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.faction_text" */
export enum Conquest_Faction_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.faction_text" */
export type Conquest_Faction_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_faction_text" */
export type Conquest_Faction_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Faction_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Faction_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.faction_text" */
export enum Conquest_Faction_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Faction_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Faction_Text_Bool_Exp;
};

/** update columns of table "conquest.faction" */
export enum Conquest_Faction_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Faction_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Faction_Bool_Exp;
};

/** columns and relationships of "conquest.loyalty" */
export type Conquest_Loyalty = {
  __typename?: 'conquest_loyalty';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate = {
  __typename?: 'conquest_loyalty_aggregate';
  aggregate?: Maybe<Conquest_Loyalty_Aggregate_Fields>;
  nodes: Array<Conquest_Loyalty>;
};

/** aggregate fields of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate_Fields = {
  __typename?: 'conquest_loyalty_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Loyalty_Max_Fields>;
  min?: Maybe<Conquest_Loyalty_Min_Fields>;
};


/** aggregate fields of "conquest.loyalty" */
export type Conquest_Loyalty_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.loyalty". All fields are combined with a logical 'AND'. */
export type Conquest_Loyalty_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Loyalty_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Loyalty_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.loyalty" */
export enum Conquest_Loyalty_Constraint {
  /** unique or primary key constraint on columns "id" */
  LoyaltyPkey = 'loyalty_pkey'
}

/** input type for inserting data into table "conquest.loyalty" */
export type Conquest_Loyalty_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Loyalty_Max_Fields = {
  __typename?: 'conquest_loyalty_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Loyalty_Min_Fields = {
  __typename?: 'conquest_loyalty_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.loyalty" */
export type Conquest_Loyalty_Mutation_Response = {
  __typename?: 'conquest_loyalty_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Loyalty>;
};

/** on_conflict condition type for table "conquest.loyalty" */
export type Conquest_Loyalty_On_Conflict = {
  constraint: Conquest_Loyalty_Constraint;
  update_columns?: Array<Conquest_Loyalty_Update_Column>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.loyalty". */
export type Conquest_Loyalty_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.loyalty */
export type Conquest_Loyalty_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.loyalty" */
export enum Conquest_Loyalty_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.loyalty" */
export type Conquest_Loyalty_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_loyalty" */
export type Conquest_Loyalty_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Loyalty_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Loyalty_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text = {
  __typename?: 'conquest_loyalty_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate = {
  __typename?: 'conquest_loyalty_text_aggregate';
  aggregate?: Maybe<Conquest_Loyalty_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Loyalty_Text>;
};

/** aggregate fields of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate_Fields = {
  __typename?: 'conquest_loyalty_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Loyalty_Text_Max_Fields>;
  min?: Maybe<Conquest_Loyalty_Text_Min_Fields>;
};


/** aggregate fields of "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.loyalty_text". All fields are combined with a logical 'AND'. */
export type Conquest_Loyalty_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Loyalty_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Loyalty_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  LoyaltyTextPkey = 'loyalty_text_pkey'
}

/** input type for inserting data into table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Loyalty_Text_Max_Fields = {
  __typename?: 'conquest_loyalty_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Loyalty_Text_Min_Fields = {
  __typename?: 'conquest_loyalty_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Mutation_Response = {
  __typename?: 'conquest_loyalty_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Loyalty_Text>;
};

/** on_conflict condition type for table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_On_Conflict = {
  constraint: Conquest_Loyalty_Text_Constraint;
  update_columns?: Array<Conquest_Loyalty_Text_Update_Column>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.loyalty_text". */
export type Conquest_Loyalty_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.loyalty_text */
export type Conquest_Loyalty_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.loyalty_text" */
export type Conquest_Loyalty_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_loyalty_text" */
export type Conquest_Loyalty_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Loyalty_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Loyalty_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.loyalty_text" */
export enum Conquest_Loyalty_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Loyalty_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Loyalty_Text_Bool_Exp;
};

/** update columns of table "conquest.loyalty" */
export enum Conquest_Loyalty_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Loyalty_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Loyalty_Bool_Exp;
};

/** columns and relationships of "conquest.pack" */
export type Conquest_Pack = {
  __typename?: 'conquest_pack';
  cycle_id: Scalars['String']['output'];
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.pack" */
export type Conquest_Pack_Aggregate = {
  __typename?: 'conquest_pack_aggregate';
  aggregate?: Maybe<Conquest_Pack_Aggregate_Fields>;
  nodes: Array<Conquest_Pack>;
};

/** aggregate fields of "conquest.pack" */
export type Conquest_Pack_Aggregate_Fields = {
  __typename?: 'conquest_pack_aggregate_fields';
  avg?: Maybe<Conquest_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Pack_Max_Fields>;
  min?: Maybe<Conquest_Pack_Min_Fields>;
  stddev?: Maybe<Conquest_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Conquest_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Conquest_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Conquest_Pack_Sum_Fields>;
  var_pop?: Maybe<Conquest_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Conquest_Pack_Var_Samp_Fields>;
  variance?: Maybe<Conquest_Pack_Variance_Fields>;
};


/** aggregate fields of "conquest.pack" */
export type Conquest_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Conquest_Pack_Avg_Fields = {
  __typename?: 'conquest_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "conquest.pack". All fields are combined with a logical 'AND'. */
export type Conquest_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Pack_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Pack_Bool_Exp>>;
  cycle_id?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.pack" */
export enum Conquest_Pack_Constraint {
  /** unique or primary key constraint on columns "id" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "conquest.pack" */
export type Conquest_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "conquest.pack" */
export type Conquest_Pack_Insert_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Pack_Max_Fields = {
  __typename?: 'conquest_pack_max_fields';
  cycle_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Pack_Min_Fields = {
  __typename?: 'conquest_pack_min_fields';
  cycle_id?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.pack" */
export type Conquest_Pack_Mutation_Response = {
  __typename?: 'conquest_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Pack>;
};

/** on_conflict condition type for table "conquest.pack" */
export type Conquest_Pack_On_Conflict = {
  constraint: Conquest_Pack_Constraint;
  update_columns?: Array<Conquest_Pack_Update_Column>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.pack". */
export type Conquest_Pack_Order_By = {
  cycle_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.pack */
export type Conquest_Pack_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.pack" */
export enum Conquest_Pack_Select_Column {
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.pack" */
export type Conquest_Pack_Set_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Conquest_Pack_Stddev_Fields = {
  __typename?: 'conquest_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Conquest_Pack_Stddev_Pop_Fields = {
  __typename?: 'conquest_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Conquest_Pack_Stddev_Samp_Fields = {
  __typename?: 'conquest_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "conquest_pack" */
export type Conquest_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Pack_Stream_Cursor_Value_Input = {
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Conquest_Pack_Sum_Fields = {
  __typename?: 'conquest_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "conquest.pack_text" */
export type Conquest_Pack_Text = {
  __typename?: 'conquest_pack_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate = {
  __typename?: 'conquest_pack_text_aggregate';
  aggregate?: Maybe<Conquest_Pack_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Pack_Text>;
};

/** aggregate fields of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate_Fields = {
  __typename?: 'conquest_pack_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Pack_Text_Max_Fields>;
  min?: Maybe<Conquest_Pack_Text_Min_Fields>;
};


/** aggregate fields of "conquest.pack_text" */
export type Conquest_Pack_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.pack_text". All fields are combined with a logical 'AND'. */
export type Conquest_Pack_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Pack_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Pack_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.pack_text" */
export enum Conquest_Pack_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  PackTextPkey = 'pack_text_pkey'
}

/** input type for inserting data into table "conquest.pack_text" */
export type Conquest_Pack_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Pack_Text_Max_Fields = {
  __typename?: 'conquest_pack_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Pack_Text_Min_Fields = {
  __typename?: 'conquest_pack_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.pack_text" */
export type Conquest_Pack_Text_Mutation_Response = {
  __typename?: 'conquest_pack_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Pack_Text>;
};

/** on_conflict condition type for table "conquest.pack_text" */
export type Conquest_Pack_Text_On_Conflict = {
  constraint: Conquest_Pack_Text_Constraint;
  update_columns?: Array<Conquest_Pack_Text_Update_Column>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.pack_text". */
export type Conquest_Pack_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.pack_text */
export type Conquest_Pack_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.pack_text" */
export enum Conquest_Pack_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.pack_text" */
export type Conquest_Pack_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_pack_text" */
export type Conquest_Pack_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Pack_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Pack_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.pack_text" */
export enum Conquest_Pack_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Pack_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Pack_Text_Bool_Exp;
};

/** update columns of table "conquest.pack" */
export enum Conquest_Pack_Update_Column {
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Conquest_Pack_Var_Pop_Fields = {
  __typename?: 'conquest_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Conquest_Pack_Var_Samp_Fields = {
  __typename?: 'conquest_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Conquest_Pack_Variance_Fields = {
  __typename?: 'conquest_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

export type Conquest_Publish_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "conquest.type" */
export type Conquest_Type = {
  __typename?: 'conquest_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "conquest.type" */
export type Conquest_Type_Aggregate = {
  __typename?: 'conquest_type_aggregate';
  aggregate?: Maybe<Conquest_Type_Aggregate_Fields>;
  nodes: Array<Conquest_Type>;
};

/** aggregate fields of "conquest.type" */
export type Conquest_Type_Aggregate_Fields = {
  __typename?: 'conquest_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Type_Max_Fields>;
  min?: Maybe<Conquest_Type_Min_Fields>;
};


/** aggregate fields of "conquest.type" */
export type Conquest_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.type". All fields are combined with a logical 'AND'. */
export type Conquest_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Type_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.type" */
export enum Conquest_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  TypePkey = 'type_pkey'
}

/** input type for inserting data into table "conquest.type" */
export type Conquest_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Type_Max_Fields = {
  __typename?: 'conquest_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Type_Min_Fields = {
  __typename?: 'conquest_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.type" */
export type Conquest_Type_Mutation_Response = {
  __typename?: 'conquest_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Type>;
};

/** on_conflict condition type for table "conquest.type" */
export type Conquest_Type_On_Conflict = {
  constraint: Conquest_Type_Constraint;
  update_columns?: Array<Conquest_Type_Update_Column>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.type". */
export type Conquest_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.type */
export type Conquest_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.type" */
export enum Conquest_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.type" */
export type Conquest_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_type" */
export type Conquest_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "conquest.type_text" */
export type Conquest_Type_Text = {
  __typename?: 'conquest_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate = {
  __typename?: 'conquest_type_text_aggregate';
  aggregate?: Maybe<Conquest_Type_Text_Aggregate_Fields>;
  nodes: Array<Conquest_Type_Text>;
};

/** aggregate fields of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate_Fields = {
  __typename?: 'conquest_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Type_Text_Max_Fields>;
  min?: Maybe<Conquest_Type_Text_Min_Fields>;
};


/** aggregate fields of "conquest.type_text" */
export type Conquest_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.type_text". All fields are combined with a logical 'AND'. */
export type Conquest_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.type_text" */
export enum Conquest_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TypeTextPkey = 'type_text_pkey'
}

/** input type for inserting data into table "conquest.type_text" */
export type Conquest_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Type_Text_Max_Fields = {
  __typename?: 'conquest_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Type_Text_Min_Fields = {
  __typename?: 'conquest_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.type_text" */
export type Conquest_Type_Text_Mutation_Response = {
  __typename?: 'conquest_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Type_Text>;
};

/** on_conflict condition type for table "conquest.type_text" */
export type Conquest_Type_Text_On_Conflict = {
  constraint: Conquest_Type_Text_Constraint;
  update_columns?: Array<Conquest_Type_Text_Update_Column>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.type_text". */
export type Conquest_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.type_text */
export type Conquest_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "conquest.type_text" */
export enum Conquest_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.type_text" */
export type Conquest_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_type_text" */
export type Conquest_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.type_text" */
export enum Conquest_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Type_Text_Bool_Exp;
};

/** update columns of table "conquest.type" */
export enum Conquest_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Type_Bool_Exp;
};

/** columns and relationships of "conquest.user_role" */
export type Conquest_User_Role = {
  __typename?: 'conquest_user_role';
  id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.user_role" */
export type Conquest_User_Role_Aggregate = {
  __typename?: 'conquest_user_role_aggregate';
  aggregate?: Maybe<Conquest_User_Role_Aggregate_Fields>;
  nodes: Array<Conquest_User_Role>;
};

/** aggregate fields of "conquest.user_role" */
export type Conquest_User_Role_Aggregate_Fields = {
  __typename?: 'conquest_user_role_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_User_Role_Max_Fields>;
  min?: Maybe<Conquest_User_Role_Min_Fields>;
};


/** aggregate fields of "conquest.user_role" */
export type Conquest_User_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.user_role". All fields are combined with a logical 'AND'. */
export type Conquest_User_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_User_Role_Bool_Exp>>;
  _not?: InputMaybe<Conquest_User_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_User_Role_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.user_role" */
export enum Conquest_User_Role_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolePkey = 'user_role_pkey'
}

export enum Conquest_User_Role_Enum {
  Admin = 'admin',
  Moderator = 'moderator'
}

/** Boolean expression to compare columns of type "conquest_user_role_enum". All fields are combined with logical 'AND'. */
export type Conquest_User_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Conquest_User_Role_Enum>;
  _in?: InputMaybe<Array<Conquest_User_Role_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Conquest_User_Role_Enum>;
  _nin?: InputMaybe<Array<Conquest_User_Role_Enum>>;
};

/** input type for inserting data into table "conquest.user_role" */
export type Conquest_User_Role_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_User_Role_Max_Fields = {
  __typename?: 'conquest_user_role_max_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Conquest_User_Role_Min_Fields = {
  __typename?: 'conquest_user_role_min_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "conquest.user_role" */
export type Conquest_User_Role_Mutation_Response = {
  __typename?: 'conquest_user_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_User_Role>;
};

/** on_conflict condition type for table "conquest.user_role" */
export type Conquest_User_Role_On_Conflict = {
  constraint: Conquest_User_Role_Constraint;
  update_columns?: Array<Conquest_User_Role_Update_Column>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.user_role". */
export type Conquest_User_Role_Order_By = {
  id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.user_role */
export type Conquest_User_Role_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.user_role" */
export enum Conquest_User_Role_Select_Column {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "conquest.user_role" */
export type Conquest_User_Role_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "conquest_user_role" */
export type Conquest_User_Role_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_User_Role_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_User_Role_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "conquest.user_role" */
export enum Conquest_User_Role_Update_Column {
  /** column name */
  Id = 'id'
}

export type Conquest_User_Role_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_User_Role_Bool_Exp;
};

/** columns and relationships of "conquest.user_settings" */
export type Conquest_User_Settings = {
  __typename?: 'conquest_user_settings';
  private_decks: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate = {
  __typename?: 'conquest_user_settings_aggregate';
  aggregate?: Maybe<Conquest_User_Settings_Aggregate_Fields>;
  nodes: Array<Conquest_User_Settings>;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp_Count>;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And = {
  arguments: Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Conquest_User_Settings_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_Fields = {
  __typename?: 'conquest_user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_User_Settings_Max_Fields>;
  min?: Maybe<Conquest_User_Settings_Min_Fields>;
};


/** aggregate fields of "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "conquest.user_settings" */
export type Conquest_User_Settings_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Conquest_User_Settings_Max_Order_By>;
  min?: InputMaybe<Conquest_User_Settings_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conquest.user_settings" */
export type Conquest_User_Settings_Arr_Rel_Insert_Input = {
  data: Array<Conquest_User_Settings_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conquest.user_settings". All fields are combined with a logical 'AND'. */
export type Conquest_User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_User_Settings_Bool_Exp>>;
  _not?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_User_Settings_Bool_Exp>>;
  private_decks?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.user_settings" */
export enum Conquest_User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** input type for inserting data into table "conquest.user_settings" */
export type Conquest_User_Settings_Insert_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Conquest_User_Settings_Max_Fields = {
  __typename?: 'conquest_user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "conquest.user_settings" */
export type Conquest_User_Settings_Max_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Conquest_User_Settings_Min_Fields = {
  __typename?: 'conquest_user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "conquest.user_settings" */
export type Conquest_User_Settings_Min_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "conquest.user_settings" */
export type Conquest_User_Settings_Mutation_Response = {
  __typename?: 'conquest_user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_User_Settings>;
};

/** on_conflict condition type for table "conquest.user_settings" */
export type Conquest_User_Settings_On_Conflict = {
  constraint: Conquest_User_Settings_Constraint;
  update_columns?: Array<Conquest_User_Settings_Update_Column>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.user_settings". */
export type Conquest_User_Settings_Order_By = {
  private_decks?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.user_settings */
export type Conquest_User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** select columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

/** select "conquest_user_settings_aggregate_bool_exp_bool_and_arguments_columns" columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  PrivateDecks = 'private_decks'
}

/** select "conquest_user_settings_aggregate_bool_exp_bool_or_arguments_columns" columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Select_Column_Conquest_User_Settings_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  PrivateDecks = 'private_decks'
}

/** input type for updating data in table "conquest.user_settings" */
export type Conquest_User_Settings_Set_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "conquest_user_settings" */
export type Conquest_User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_User_Settings_Stream_Cursor_Value_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "conquest.user_settings" */
export enum Conquest_User_Settings_Update_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

export type Conquest_User_Settings_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_User_Settings_Bool_Exp;
};

/** columns and relationships of "conquest.users" */
export type Conquest_Users = {
  __typename?: 'conquest_users';
  created_at: Scalars['timestamptz']['output'];
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  normalized_handle?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Conquest_User_Role_Enum>;
  /** An array relationship */
  settings: Array<Conquest_User_Settings>;
  /** An aggregate relationship */
  settings_aggregate: Conquest_User_Settings_Aggregate;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "conquest.users" */
export type Conquest_UsersSettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


/** columns and relationships of "conquest.users" */
export type Conquest_UsersSettings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};

/** aggregated selection of "conquest.users" */
export type Conquest_Users_Aggregate = {
  __typename?: 'conquest_users_aggregate';
  aggregate?: Maybe<Conquest_Users_Aggregate_Fields>;
  nodes: Array<Conquest_Users>;
};

/** aggregate fields of "conquest.users" */
export type Conquest_Users_Aggregate_Fields = {
  __typename?: 'conquest_users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Conquest_Users_Max_Fields>;
  min?: Maybe<Conquest_Users_Min_Fields>;
};


/** aggregate fields of "conquest.users" */
export type Conquest_Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "conquest.users". All fields are combined with a logical 'AND'. */
export type Conquest_Users_Bool_Exp = {
  _and?: InputMaybe<Array<Conquest_Users_Bool_Exp>>;
  _not?: InputMaybe<Conquest_Users_Bool_Exp>;
  _or?: InputMaybe<Array<Conquest_Users_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  role?: InputMaybe<Conquest_User_Role_Enum_Comparison_Exp>;
  settings?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
  settings_aggregate?: InputMaybe<Conquest_User_Settings_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conquest.users" */
export enum Conquest_Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "conquest.users" */
export type Conquest_Users_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  settings?: InputMaybe<Conquest_User_Settings_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Conquest_Users_Max_Fields = {
  __typename?: 'conquest_users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Conquest_Users_Min_Fields = {
  __typename?: 'conquest_users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "conquest.users" */
export type Conquest_Users_Mutation_Response = {
  __typename?: 'conquest_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Conquest_Users>;
};

/** input type for inserting object relation for remote table "conquest.users" */
export type Conquest_Users_Obj_Rel_Insert_Input = {
  data: Conquest_Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};

/** on_conflict condition type for table "conquest.users" */
export type Conquest_Users_On_Conflict = {
  constraint: Conquest_Users_Constraint;
  update_columns?: Array<Conquest_Users_Update_Column>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};

/** Ordering options when selecting data from "conquest.users". */
export type Conquest_Users_Order_By = {
  created_at?: InputMaybe<Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  settings_aggregate?: InputMaybe<Conquest_User_Settings_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: conquest.users */
export type Conquest_Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "conquest.users" */
export enum Conquest_Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "conquest.users" */
export type Conquest_Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "conquest_users" */
export type Conquest_Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Conquest_Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Conquest_Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Conquest_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "conquest.users" */
export enum Conquest_Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Conquest_Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Conquest_Users_Bool_Exp;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "cycle" */
export type Cycle = {
  __typename?: 'cycle';
  code: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  /** An array relationship */
  packs: Array<Pack>;
  /** An aggregate relationship */
  packs_aggregate: Pack_Aggregate;
  position: Scalars['Int']['output'];
  real_name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Cycle_Name>;
  /** An aggregate relationship */
  translations_aggregate: Cycle_Name_Aggregate;
};


/** columns and relationships of "cycle" */
export type CyclePacksArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CyclePacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CycleTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


/** columns and relationships of "cycle" */
export type CycleTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};

/** aggregated selection of "cycle" */
export type Cycle_Aggregate = {
  __typename?: 'cycle_aggregate';
  aggregate?: Maybe<Cycle_Aggregate_Fields>;
  nodes: Array<Cycle>;
};

/** aggregate fields of "cycle" */
export type Cycle_Aggregate_Fields = {
  __typename?: 'cycle_aggregate_fields';
  avg?: Maybe<Cycle_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Cycle_Max_Fields>;
  min?: Maybe<Cycle_Min_Fields>;
  stddev?: Maybe<Cycle_Stddev_Fields>;
  stddev_pop?: Maybe<Cycle_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Cycle_Stddev_Samp_Fields>;
  sum?: Maybe<Cycle_Sum_Fields>;
  var_pop?: Maybe<Cycle_Var_Pop_Fields>;
  var_samp?: Maybe<Cycle_Var_Samp_Fields>;
  variance?: Maybe<Cycle_Variance_Fields>;
};


/** aggregate fields of "cycle" */
export type Cycle_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cycle_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Cycle_Avg_Fields = {
  __typename?: 'cycle_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "cycle". All fields are combined with a logical 'AND'. */
export type Cycle_Bool_Exp = {
  _and?: InputMaybe<Array<Cycle_Bool_Exp>>;
  _not?: InputMaybe<Cycle_Bool_Exp>;
  _or?: InputMaybe<Array<Cycle_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  packs?: InputMaybe<Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Pack_Aggregate_Bool_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Cycle_Name_Bool_Exp>;
  translations_aggregate?: InputMaybe<Cycle_Name_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "cycle" */
export enum Cycle_Constraint {
  /** unique or primary key constraint on columns "code" */
  CyclePkey = 'cycle_pkey'
}

/** input type for incrementing numeric columns in table "cycle" */
export type Cycle_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "cycle" */
export type Cycle_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  packs?: InputMaybe<Pack_Arr_Rel_Insert_Input>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Cycle_Name_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Cycle_Max_Fields = {
  __typename?: 'cycle_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Cycle_Min_Fields = {
  __typename?: 'cycle_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "cycle" */
export type Cycle_Mutation_Response = {
  __typename?: 'cycle_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Cycle>;
};

/** columns and relationships of "cycle_name" */
export type Cycle_Name = {
  __typename?: 'cycle_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "cycle_name" */
export type Cycle_Name_Aggregate = {
  __typename?: 'cycle_name_aggregate';
  aggregate?: Maybe<Cycle_Name_Aggregate_Fields>;
  nodes: Array<Cycle_Name>;
};

export type Cycle_Name_Aggregate_Bool_Exp = {
  count?: InputMaybe<Cycle_Name_Aggregate_Bool_Exp_Count>;
};

export type Cycle_Name_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Cycle_Name_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "cycle_name" */
export type Cycle_Name_Aggregate_Fields = {
  __typename?: 'cycle_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Cycle_Name_Max_Fields>;
  min?: Maybe<Cycle_Name_Min_Fields>;
};


/** aggregate fields of "cycle_name" */
export type Cycle_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "cycle_name" */
export type Cycle_Name_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Cycle_Name_Max_Order_By>;
  min?: InputMaybe<Cycle_Name_Min_Order_By>;
};

/** input type for inserting array relation for remote table "cycle_name" */
export type Cycle_Name_Arr_Rel_Insert_Input = {
  data: Array<Cycle_Name_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};

/** Boolean expression to filter rows from the table "cycle_name". All fields are combined with a logical 'AND'. */
export type Cycle_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Cycle_Name_Bool_Exp>>;
  _not?: InputMaybe<Cycle_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Cycle_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "cycle_name" */
export enum Cycle_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  CycleNamePkey = 'cycle_name_pkey'
}

/** input type for inserting data into table "cycle_name" */
export type Cycle_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Cycle_Name_Max_Fields = {
  __typename?: 'cycle_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "cycle_name" */
export type Cycle_Name_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Cycle_Name_Min_Fields = {
  __typename?: 'cycle_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "cycle_name" */
export type Cycle_Name_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "cycle_name" */
export type Cycle_Name_Mutation_Response = {
  __typename?: 'cycle_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Cycle_Name>;
};

/** on_conflict condition type for table "cycle_name" */
export type Cycle_Name_On_Conflict = {
  constraint: Cycle_Name_Constraint;
  update_columns?: Array<Cycle_Name_Update_Column>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "cycle_name". */
export type Cycle_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: cycle_name */
export type Cycle_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "cycle_name" */
export enum Cycle_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "cycle_name" */
export type Cycle_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "cycle_name" */
export type Cycle_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cycle_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cycle_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "cycle_name" */
export enum Cycle_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Cycle_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cycle_Name_Bool_Exp;
};

/** input type for inserting object relation for remote table "cycle" */
export type Cycle_Obj_Rel_Insert_Input = {
  data: Cycle_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};

/** on_conflict condition type for table "cycle" */
export type Cycle_On_Conflict = {
  constraint: Cycle_Constraint;
  update_columns?: Array<Cycle_Update_Column>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};

/** Ordering options when selecting data from "cycle". */
export type Cycle_Order_By = {
  code?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Pack_Aggregate_Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Cycle_Name_Aggregate_Order_By>;
};

/** primary key columns input for table: cycle */
export type Cycle_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "cycle" */
export enum Cycle_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

/** input type for updating data in table "cycle" */
export type Cycle_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Cycle_Stddev_Fields = {
  __typename?: 'cycle_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Cycle_Stddev_Pop_Fields = {
  __typename?: 'cycle_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Cycle_Stddev_Samp_Fields = {
  __typename?: 'cycle_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "cycle" */
export type Cycle_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cycle_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cycle_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Cycle_Sum_Fields = {
  __typename?: 'cycle_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "cycle" */
export enum Cycle_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

export type Cycle_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Cycle_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Cycle_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cycle_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Cycle_Var_Pop_Fields = {
  __typename?: 'cycle_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Cycle_Var_Samp_Fields = {
  __typename?: 'cycle_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Cycle_Variance_Fields = {
  __typename?: 'cycle_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "faction_name" */
export type Faction_Name = {
  __typename?: 'faction_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
};

/** aggregated selection of "faction_name" */
export type Faction_Name_Aggregate = {
  __typename?: 'faction_name_aggregate';
  aggregate?: Maybe<Faction_Name_Aggregate_Fields>;
  nodes: Array<Faction_Name>;
};

/** aggregate fields of "faction_name" */
export type Faction_Name_Aggregate_Fields = {
  __typename?: 'faction_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faction_Name_Max_Fields>;
  min?: Maybe<Faction_Name_Min_Fields>;
};


/** aggregate fields of "faction_name" */
export type Faction_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faction_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "faction_name". All fields are combined with a logical 'AND'. */
export type Faction_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Faction_Name_Bool_Exp>>;
  _not?: InputMaybe<Faction_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Faction_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faction_name" */
export enum Faction_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FactionNamePkey = 'faction_name_pkey'
}

/** input type for inserting data into table "faction_name" */
export type Faction_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faction_Name_Max_Fields = {
  __typename?: 'faction_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Faction_Name_Min_Fields = {
  __typename?: 'faction_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "faction_name" */
export type Faction_Name_Mutation_Response = {
  __typename?: 'faction_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faction_Name>;
};

/** on_conflict condition type for table "faction_name" */
export type Faction_Name_On_Conflict = {
  constraint: Faction_Name_Constraint;
  update_columns?: Array<Faction_Name_Update_Column>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "faction_name". */
export type Faction_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faction_name */
export type Faction_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "faction_name" */
export enum Faction_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "faction_name" */
export type Faction_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faction_name" */
export type Faction_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faction_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faction_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "faction_name" */
export enum Faction_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name'
}

export type Faction_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faction_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faction_Name_Bool_Exp;
};

/** columns and relationships of "faq" */
export type Faq = {
  __typename?: 'faq';
  code: Scalars['String']['output'];
  /** An array relationship */
  faq_texts: Array<Faq_Text>;
  /** An aggregate relationship */
  faq_texts_aggregate: Faq_Text_Aggregate;
  text: Scalars['String']['output'];
};


/** columns and relationships of "faq" */
export type FaqFaq_TextsArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


/** columns and relationships of "faq" */
export type FaqFaq_Texts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};

/** aggregated selection of "faq" */
export type Faq_Aggregate = {
  __typename?: 'faq_aggregate';
  aggregate?: Maybe<Faq_Aggregate_Fields>;
  nodes: Array<Faq>;
};

/** aggregate fields of "faq" */
export type Faq_Aggregate_Fields = {
  __typename?: 'faq_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faq_Max_Fields>;
  min?: Maybe<Faq_Min_Fields>;
};


/** aggregate fields of "faq" */
export type Faq_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faq_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "faq". All fields are combined with a logical 'AND'. */
export type Faq_Bool_Exp = {
  _and?: InputMaybe<Array<Faq_Bool_Exp>>;
  _not?: InputMaybe<Faq_Bool_Exp>;
  _or?: InputMaybe<Array<Faq_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  faq_texts?: InputMaybe<Faq_Text_Bool_Exp>;
  faq_texts_aggregate?: InputMaybe<Faq_Text_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faq" */
export enum Faq_Constraint {
  /** unique or primary key constraint on columns "code" */
  FaqPkey = 'faq_pkey'
}

/** input type for inserting data into table "faq" */
export type Faq_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  faq_texts?: InputMaybe<Faq_Text_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faq_Max_Fields = {
  __typename?: 'faq_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Faq_Min_Fields = {
  __typename?: 'faq_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "faq" */
export type Faq_Mutation_Response = {
  __typename?: 'faq_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faq>;
};

/** on_conflict condition type for table "faq" */
export type Faq_On_Conflict = {
  constraint: Faq_Constraint;
  update_columns?: Array<Faq_Update_Column>;
  where?: InputMaybe<Faq_Bool_Exp>;
};

/** Ordering options when selecting data from "faq". */
export type Faq_Order_By = {
  code?: InputMaybe<Order_By>;
  faq_texts_aggregate?: InputMaybe<Faq_Text_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faq */
export type Faq_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "faq" */
export enum Faq_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "faq" */
export type Faq_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faq" */
export type Faq_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faq_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faq_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "faq_text" */
export type Faq_Text = {
  __typename?: 'faq_text';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  text: Scalars['String']['output'];
};

/** aggregated selection of "faq_text" */
export type Faq_Text_Aggregate = {
  __typename?: 'faq_text_aggregate';
  aggregate?: Maybe<Faq_Text_Aggregate_Fields>;
  nodes: Array<Faq_Text>;
};

export type Faq_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Faq_Text_Aggregate_Bool_Exp_Count>;
};

export type Faq_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Faq_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Faq_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "faq_text" */
export type Faq_Text_Aggregate_Fields = {
  __typename?: 'faq_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Faq_Text_Max_Fields>;
  min?: Maybe<Faq_Text_Min_Fields>;
};


/** aggregate fields of "faq_text" */
export type Faq_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Faq_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "faq_text" */
export type Faq_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Faq_Text_Max_Order_By>;
  min?: InputMaybe<Faq_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "faq_text" */
export type Faq_Text_Arr_Rel_Insert_Input = {
  data: Array<Faq_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "faq_text". All fields are combined with a logical 'AND'. */
export type Faq_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Faq_Text_Bool_Exp>>;
  _not?: InputMaybe<Faq_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Faq_Text_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "faq_text" */
export enum Faq_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FaqTextPkey = 'faq_text_pkey'
}

/** input type for inserting data into table "faq_text" */
export type Faq_Text_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Faq_Text_Max_Fields = {
  __typename?: 'faq_text_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "faq_text" */
export type Faq_Text_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Faq_Text_Min_Fields = {
  __typename?: 'faq_text_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "faq_text" */
export type Faq_Text_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "faq_text" */
export type Faq_Text_Mutation_Response = {
  __typename?: 'faq_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Faq_Text>;
};

/** on_conflict condition type for table "faq_text" */
export type Faq_Text_On_Conflict = {
  constraint: Faq_Text_Constraint;
  update_columns?: Array<Faq_Text_Update_Column>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "faq_text". */
export type Faq_Text_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: faq_text */
export type Faq_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "faq_text" */
export enum Faq_Text_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "faq_text" */
export type Faq_Text_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "faq_text" */
export type Faq_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Faq_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Faq_Text_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "faq_text" */
export enum Faq_Text_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Text = 'text'
}

export type Faq_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faq_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faq_Text_Bool_Exp;
};

/** update columns of table "faq" */
export enum Faq_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Text = 'text'
}

export type Faq_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Faq_Set_Input>;
  /** filter the rows which have to be updated */
  where: Faq_Bool_Exp;
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['float8']['input']>;
  _gt?: InputMaybe<Scalars['float8']['input']>;
  _gte?: InputMaybe<Scalars['float8']['input']>;
  _in?: InputMaybe<Array<Scalars['float8']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['float8']['input']>;
  _lte?: InputMaybe<Scalars['float8']['input']>;
  _neq?: InputMaybe<Scalars['float8']['input']>;
  _nin?: InputMaybe<Array<Scalars['float8']['input']>>;
};

/** columns and relationships of "friend_status" */
export type Friend_Status = {
  __typename?: 'friend_status';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  status: Friend_Status_Type_Enum;
  user_id_a: Scalars['String']['output'];
  user_id_b: Scalars['String']['output'];
};

/** aggregated selection of "friend_status" */
export type Friend_Status_Aggregate = {
  __typename?: 'friend_status_aggregate';
  aggregate?: Maybe<Friend_Status_Aggregate_Fields>;
  nodes: Array<Friend_Status>;
};

/** aggregate fields of "friend_status" */
export type Friend_Status_Aggregate_Fields = {
  __typename?: 'friend_status_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Friend_Status_Max_Fields>;
  min?: Maybe<Friend_Status_Min_Fields>;
};


/** aggregate fields of "friend_status" */
export type Friend_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Friend_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "friend_status". All fields are combined with a logical 'AND'. */
export type Friend_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Friend_Status_Bool_Exp>>;
  _not?: InputMaybe<Friend_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Friend_Status_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  status?: InputMaybe<Friend_Status_Type_Enum_Comparison_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "friend_status" */
export enum Friend_Status_Constraint {
  /** unique or primary key constraint on columns "user_id_a", "user_id_b" */
  FriendStatusPkey = 'friend_status_pkey'
}

/** input type for inserting data into table "friend_status" */
export type Friend_Status_Insert_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Friend_Status_Max_Fields = {
  __typename?: 'friend_status_max_fields';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Friend_Status_Min_Fields = {
  __typename?: 'friend_status_min_fields';
  /** A computed field, executes function "friend_status_id" */
  id?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "friend_status" */
export type Friend_Status_Mutation_Response = {
  __typename?: 'friend_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Friend_Status>;
};

/** on_conflict condition type for table "friend_status" */
export type Friend_Status_On_Conflict = {
  constraint: Friend_Status_Constraint;
  update_columns?: Array<Friend_Status_Update_Column>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "friend_status". */
export type Friend_Status_Order_By = {
  id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** primary key columns input for table: friend_status */
export type Friend_Status_Pk_Columns_Input = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};

/** select columns of table "friend_status" */
export enum Friend_Status_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "friend_status" */
export type Friend_Status_Set_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "friend_status" */
export type Friend_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Friend_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Friend_Status_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "friend_status_type" */
export type Friend_Status_Type = {
  __typename?: 'friend_status_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "friend_status_type" */
export type Friend_Status_Type_Aggregate = {
  __typename?: 'friend_status_type_aggregate';
  aggregate?: Maybe<Friend_Status_Type_Aggregate_Fields>;
  nodes: Array<Friend_Status_Type>;
};

/** aggregate fields of "friend_status_type" */
export type Friend_Status_Type_Aggregate_Fields = {
  __typename?: 'friend_status_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Friend_Status_Type_Max_Fields>;
  min?: Maybe<Friend_Status_Type_Min_Fields>;
};


/** aggregate fields of "friend_status_type" */
export type Friend_Status_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "friend_status_type". All fields are combined with a logical 'AND'. */
export type Friend_Status_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Friend_Status_Type_Bool_Exp>>;
  _not?: InputMaybe<Friend_Status_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Friend_Status_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "friend_status_type" */
export enum Friend_Status_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  FriendStatusTypePkey = 'friend_status_type_pkey'
}

export enum Friend_Status_Type_Enum {
  Friend = 'friend',
  None = 'none',
  Received = 'received',
  Sent = 'sent'
}

/** Boolean expression to compare columns of type "friend_status_type_enum". All fields are combined with logical 'AND'. */
export type Friend_Status_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Friend_Status_Type_Enum>;
  _in?: InputMaybe<Array<Friend_Status_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Friend_Status_Type_Enum>;
  _nin?: InputMaybe<Array<Friend_Status_Type_Enum>>;
};

/** input type for inserting data into table "friend_status_type" */
export type Friend_Status_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Friend_Status_Type_Max_Fields = {
  __typename?: 'friend_status_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Friend_Status_Type_Min_Fields = {
  __typename?: 'friend_status_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "friend_status_type" */
export type Friend_Status_Type_Mutation_Response = {
  __typename?: 'friend_status_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Friend_Status_Type>;
};

/** on_conflict condition type for table "friend_status_type" */
export type Friend_Status_Type_On_Conflict = {
  constraint: Friend_Status_Type_Constraint;
  update_columns?: Array<Friend_Status_Type_Update_Column>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "friend_status_type". */
export type Friend_Status_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: friend_status_type */
export type Friend_Status_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "friend_status_type" */
export enum Friend_Status_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "friend_status_type" */
export type Friend_Status_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "friend_status_type" */
export type Friend_Status_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Friend_Status_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Friend_Status_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "friend_status_type" */
export enum Friend_Status_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type Friend_Status_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Friend_Status_Type_Bool_Exp;
};

/** update columns of table "friend_status" */
export enum Friend_Status_Update_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

export type Friend_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Friend_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Friend_Status_Bool_Exp;
};

/** columns and relationships of "full_card" */
export type Full_Card = {
  __typename?: 'full_card';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  clues_fixed?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  deck_options?: Maybe<Scalars['jsonb']['output']>;
  deck_requirements?: Maybe<Scalars['jsonb']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  double_sided?: Maybe<Scalars['Boolean']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  encounter_sets: Array<Card_Encounter_Set>;
  /** An aggregate relationship */
  encounter_sets_aggregate: Card_Encounter_Set_Aggregate;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  exceptional?: Maybe<Scalars['Boolean']['output']>;
  exile?: Maybe<Scalars['Boolean']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code: Scalars['String']['output'];
  health?: Maybe<Scalars['Int']['output']>;
  health_per_investigator?: Maybe<Scalars['Boolean']['output']>;
  hidden?: Maybe<Scalars['Boolean']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  is_unique?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  linked_card?: Maybe<Full_Card>;
  myriad?: Maybe<Scalars['Boolean']['output']>;
  pack_code: Scalars['String']['output'];
  pack_position: Scalars['Int']['output'];
  /** An array relationship */
  packs: Array<Card_Pack>;
  /** An aggregate relationship */
  packs_aggregate: Card_Pack_Aggregate;
  permanent?: Maybe<Scalars['Boolean']['output']>;
  position: Scalars['Int']['output'];
  quantity: Scalars['Int']['output'];
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name: Scalars['String']['output'];
  real_pack_name: Scalars['String']['output'];
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['jsonb']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Full_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Full_Card_Text_Aggregate;
  type_code: Card_Type_Code_Enum;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version: Scalars['Int']['output'];
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "full_card" */
export type Full_CardDeck_OptionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardDeck_RequirementsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardEncounter_SetsArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardEncounter_Sets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardPacksArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardPacks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardRestrictionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "full_card" */
export type Full_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


/** columns and relationships of "full_card" */
export type Full_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};

/** aggregated selection of "full_card" */
export type Full_Card_Aggregate = {
  __typename?: 'full_card_aggregate';
  aggregate?: Maybe<Full_Card_Aggregate_Fields>;
  nodes: Array<Full_Card>;
};

/** aggregate fields of "full_card" */
export type Full_Card_Aggregate_Fields = {
  __typename?: 'full_card_aggregate_fields';
  avg?: Maybe<Full_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Full_Card_Max_Fields>;
  min?: Maybe<Full_Card_Min_Fields>;
  stddev?: Maybe<Full_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Full_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Full_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Full_Card_Sum_Fields>;
  var_pop?: Maybe<Full_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Full_Card_Var_Samp_Fields>;
  variance?: Maybe<Full_Card_Variance_Fields>;
};


/** aggregate fields of "full_card" */
export type Full_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Full_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Full_Card_Append_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Full_Card_Avg_Fields = {
  __typename?: 'full_card_avg_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "full_card". All fields are combined with a logical 'AND'. */
export type Full_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Full_Card_Bool_Exp>>;
  _not?: InputMaybe<Full_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Full_Card_Bool_Exp>>;
  alternate_required_code?: InputMaybe<String_Comparison_Exp>;
  back_link?: InputMaybe<String_Comparison_Exp>;
  backimagesrc?: InputMaybe<String_Comparison_Exp>;
  clues?: InputMaybe<Int_Comparison_Exp>;
  clues_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  deck_options?: InputMaybe<Jsonb_Comparison_Exp>;
  deck_requirements?: InputMaybe<Jsonb_Comparison_Exp>;
  doom?: InputMaybe<Int_Comparison_Exp>;
  double_sided?: InputMaybe<Boolean_Comparison_Exp>;
  encounter_code?: InputMaybe<String_Comparison_Exp>;
  encounter_position?: InputMaybe<Int_Comparison_Exp>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Bool_Exp>;
  enemy_damage?: InputMaybe<Int_Comparison_Exp>;
  enemy_evade?: InputMaybe<Int_Comparison_Exp>;
  enemy_fight?: InputMaybe<Int_Comparison_Exp>;
  enemy_horror?: InputMaybe<Int_Comparison_Exp>;
  exceptional?: InputMaybe<Boolean_Comparison_Exp>;
  exile?: InputMaybe<Boolean_Comparison_Exp>;
  faction2_code?: InputMaybe<String_Comparison_Exp>;
  faction3_code?: InputMaybe<String_Comparison_Exp>;
  faction_code?: InputMaybe<String_Comparison_Exp>;
  health?: InputMaybe<Int_Comparison_Exp>;
  health_per_investigator?: InputMaybe<Boolean_Comparison_Exp>;
  hidden?: InputMaybe<Boolean_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  is_unique?: InputMaybe<Boolean_Comparison_Exp>;
  linked_card?: InputMaybe<Full_Card_Bool_Exp>;
  myriad?: InputMaybe<Boolean_Comparison_Exp>;
  pack_code?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  packs?: InputMaybe<Card_Pack_Bool_Exp>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Bool_Exp>;
  permanent?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_back_flavor?: InputMaybe<String_Comparison_Exp>;
  real_back_name?: InputMaybe<String_Comparison_Exp>;
  real_back_text?: InputMaybe<String_Comparison_Exp>;
  real_encounter_set_name?: InputMaybe<String_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_pack_name?: InputMaybe<String_Comparison_Exp>;
  real_slot?: InputMaybe<String_Comparison_Exp>;
  real_subname?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  restrictions?: InputMaybe<Jsonb_Comparison_Exp>;
  sanity?: InputMaybe<Int_Comparison_Exp>;
  shroud?: InputMaybe<Int_Comparison_Exp>;
  skill_agility?: InputMaybe<Int_Comparison_Exp>;
  skill_combat?: InputMaybe<Int_Comparison_Exp>;
  skill_intellect?: InputMaybe<Int_Comparison_Exp>;
  skill_wild?: InputMaybe<Int_Comparison_Exp>;
  skill_willpower?: InputMaybe<Int_Comparison_Exp>;
  stage?: InputMaybe<Int_Comparison_Exp>;
  subtype_code?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Full_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Full_Card_Text_Aggregate_Bool_Exp>;
  type_code?: InputMaybe<Card_Type_Code_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  vengeance?: InputMaybe<Int_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
  victory?: InputMaybe<Int_Comparison_Exp>;
  xp?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "full_card" */
export enum Full_Card_Constraint {
  /** unique or primary key constraint on columns "code" */
  FullCardPkey = 'full_card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Full_Card_Delete_At_Path_Input = {
  deck_options?: InputMaybe<Array<Scalars['String']['input']>>;
  deck_requirements?: InputMaybe<Array<Scalars['String']['input']>>;
  restrictions?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Full_Card_Delete_Elem_Input = {
  deck_options?: InputMaybe<Scalars['Int']['input']>;
  deck_requirements?: InputMaybe<Scalars['Int']['input']>;
  restrictions?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Full_Card_Delete_Key_Input = {
  deck_options?: InputMaybe<Scalars['String']['input']>;
  deck_requirements?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "full_card" */
export type Full_Card_Inc_Input = {
  clues?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "full_card" */
export type Full_Card_Insert_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  encounter_sets?: InputMaybe<Card_Encounter_Set_Arr_Rel_Insert_Input>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  linked_card?: InputMaybe<Full_Card_Obj_Rel_Insert_Input>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  packs?: InputMaybe<Card_Pack_Arr_Rel_Insert_Input>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Full_Card_Text_Arr_Rel_Insert_Input>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Full_Card_Max_Fields = {
  __typename?: 'full_card_max_fields';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Full_Card_Min_Fields = {
  __typename?: 'full_card_min_fields';
  alternate_required_code?: Maybe<Scalars['String']['output']>;
  back_link?: Maybe<Scalars['String']['output']>;
  backimagesrc?: Maybe<Scalars['String']['output']>;
  clues?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_code?: Maybe<Scalars['String']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  faction2_code?: Maybe<Scalars['String']['output']>;
  faction3_code?: Maybe<Scalars['String']['output']>;
  faction_code?: Maybe<Scalars['String']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  pack_code?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_back_flavor?: Maybe<Scalars['String']['output']>;
  real_back_name?: Maybe<Scalars['String']['output']>;
  real_back_text?: Maybe<Scalars['String']['output']>;
  real_encounter_set_name?: Maybe<Scalars['String']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_pack_name?: Maybe<Scalars['String']['output']>;
  real_slot?: Maybe<Scalars['String']['output']>;
  real_subname?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  subtype_code?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "full_card" */
export type Full_Card_Mutation_Response = {
  __typename?: 'full_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Full_Card>;
};

/** input type for inserting object relation for remote table "full_card" */
export type Full_Card_Obj_Rel_Insert_Input = {
  data: Full_Card_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};

/** on_conflict condition type for table "full_card" */
export type Full_Card_On_Conflict = {
  constraint: Full_Card_Constraint;
  update_columns?: Array<Full_Card_Update_Column>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "full_card". */
export type Full_Card_Order_By = {
  alternate_required_code?: InputMaybe<Order_By>;
  back_link?: InputMaybe<Order_By>;
  backimagesrc?: InputMaybe<Order_By>;
  clues?: InputMaybe<Order_By>;
  clues_fixed?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  deck_options?: InputMaybe<Order_By>;
  deck_requirements?: InputMaybe<Order_By>;
  doom?: InputMaybe<Order_By>;
  double_sided?: InputMaybe<Order_By>;
  encounter_code?: InputMaybe<Order_By>;
  encounter_position?: InputMaybe<Order_By>;
  encounter_sets_aggregate?: InputMaybe<Card_Encounter_Set_Aggregate_Order_By>;
  enemy_damage?: InputMaybe<Order_By>;
  enemy_evade?: InputMaybe<Order_By>;
  enemy_fight?: InputMaybe<Order_By>;
  enemy_horror?: InputMaybe<Order_By>;
  exceptional?: InputMaybe<Order_By>;
  exile?: InputMaybe<Order_By>;
  faction2_code?: InputMaybe<Order_By>;
  faction3_code?: InputMaybe<Order_By>;
  faction_code?: InputMaybe<Order_By>;
  health?: InputMaybe<Order_By>;
  health_per_investigator?: InputMaybe<Order_By>;
  hidden?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  is_unique?: InputMaybe<Order_By>;
  linked_card?: InputMaybe<Full_Card_Order_By>;
  myriad?: InputMaybe<Order_By>;
  pack_code?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  packs_aggregate?: InputMaybe<Card_Pack_Aggregate_Order_By>;
  permanent?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_back_flavor?: InputMaybe<Order_By>;
  real_back_name?: InputMaybe<Order_By>;
  real_back_text?: InputMaybe<Order_By>;
  real_encounter_set_name?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_pack_name?: InputMaybe<Order_By>;
  real_slot?: InputMaybe<Order_By>;
  real_subname?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  restrictions?: InputMaybe<Order_By>;
  sanity?: InputMaybe<Order_By>;
  shroud?: InputMaybe<Order_By>;
  skill_agility?: InputMaybe<Order_By>;
  skill_combat?: InputMaybe<Order_By>;
  skill_intellect?: InputMaybe<Order_By>;
  skill_wild?: InputMaybe<Order_By>;
  skill_willpower?: InputMaybe<Order_By>;
  stage?: InputMaybe<Order_By>;
  subtype_code?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Full_Card_Text_Aggregate_Order_By>;
  type_code?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  vengeance?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
  victory?: InputMaybe<Order_By>;
  xp?: InputMaybe<Order_By>;
};

/** primary key columns input for table: full_card */
export type Full_Card_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Full_Card_Prepend_Input = {
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "full_card" */
export enum Full_Card_Select_Column {
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

/** input type for updating data in table "full_card" */
export type Full_Card_Set_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Full_Card_Stddev_Fields = {
  __typename?: 'full_card_stddev_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Full_Card_Stddev_Pop_Fields = {
  __typename?: 'full_card_stddev_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Full_Card_Stddev_Samp_Fields = {
  __typename?: 'full_card_stddev_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "full_card" */
export type Full_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Full_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Full_Card_Stream_Cursor_Value_Input = {
  alternate_required_code?: InputMaybe<Scalars['String']['input']>;
  back_link?: InputMaybe<Scalars['String']['input']>;
  backimagesrc?: InputMaybe<Scalars['String']['input']>;
  clues?: InputMaybe<Scalars['Int']['input']>;
  clues_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  deck_options?: InputMaybe<Scalars['jsonb']['input']>;
  deck_requirements?: InputMaybe<Scalars['jsonb']['input']>;
  doom?: InputMaybe<Scalars['Int']['input']>;
  double_sided?: InputMaybe<Scalars['Boolean']['input']>;
  encounter_code?: InputMaybe<Scalars['String']['input']>;
  encounter_position?: InputMaybe<Scalars['Int']['input']>;
  enemy_damage?: InputMaybe<Scalars['Int']['input']>;
  enemy_evade?: InputMaybe<Scalars['Int']['input']>;
  enemy_fight?: InputMaybe<Scalars['Int']['input']>;
  enemy_horror?: InputMaybe<Scalars['Int']['input']>;
  exceptional?: InputMaybe<Scalars['Boolean']['input']>;
  exile?: InputMaybe<Scalars['Boolean']['input']>;
  faction2_code?: InputMaybe<Scalars['String']['input']>;
  faction3_code?: InputMaybe<Scalars['String']['input']>;
  faction_code?: InputMaybe<Scalars['String']['input']>;
  health?: InputMaybe<Scalars['Int']['input']>;
  health_per_investigator?: InputMaybe<Scalars['Boolean']['input']>;
  hidden?: InputMaybe<Scalars['Boolean']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  is_unique?: InputMaybe<Scalars['Boolean']['input']>;
  myriad?: InputMaybe<Scalars['Boolean']['input']>;
  pack_code?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  permanent?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_back_flavor?: InputMaybe<Scalars['String']['input']>;
  real_back_name?: InputMaybe<Scalars['String']['input']>;
  real_back_text?: InputMaybe<Scalars['String']['input']>;
  real_encounter_set_name?: InputMaybe<Scalars['String']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_pack_name?: InputMaybe<Scalars['String']['input']>;
  real_slot?: InputMaybe<Scalars['String']['input']>;
  real_subname?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  restrictions?: InputMaybe<Scalars['jsonb']['input']>;
  sanity?: InputMaybe<Scalars['Int']['input']>;
  shroud?: InputMaybe<Scalars['Int']['input']>;
  skill_agility?: InputMaybe<Scalars['Int']['input']>;
  skill_combat?: InputMaybe<Scalars['Int']['input']>;
  skill_intellect?: InputMaybe<Scalars['Int']['input']>;
  skill_wild?: InputMaybe<Scalars['Int']['input']>;
  skill_willpower?: InputMaybe<Scalars['Int']['input']>;
  stage?: InputMaybe<Scalars['Int']['input']>;
  subtype_code?: InputMaybe<Scalars['String']['input']>;
  type_code?: InputMaybe<Card_Type_Code_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  vengeance?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
  victory?: InputMaybe<Scalars['Int']['input']>;
  xp?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Full_Card_Sum_Fields = {
  __typename?: 'full_card_sum_fields';
  clues?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  doom?: Maybe<Scalars['Int']['output']>;
  encounter_position?: Maybe<Scalars['Int']['output']>;
  enemy_damage?: Maybe<Scalars['Int']['output']>;
  enemy_evade?: Maybe<Scalars['Int']['output']>;
  enemy_fight?: Maybe<Scalars['Int']['output']>;
  enemy_horror?: Maybe<Scalars['Int']['output']>;
  health?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  sanity?: Maybe<Scalars['Int']['output']>;
  shroud?: Maybe<Scalars['Int']['output']>;
  skill_agility?: Maybe<Scalars['Int']['output']>;
  skill_combat?: Maybe<Scalars['Int']['output']>;
  skill_intellect?: Maybe<Scalars['Int']['output']>;
  skill_wild?: Maybe<Scalars['Int']['output']>;
  skill_willpower?: Maybe<Scalars['Int']['output']>;
  stage?: Maybe<Scalars['Int']['output']>;
  vengeance?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
  victory?: Maybe<Scalars['Int']['output']>;
  xp?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "full_card_text" */
export type Full_Card_Text = {
  __typename?: 'full_card_text';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code: Scalars['String']['output'];
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "full_card_text" */
export type Full_Card_Text_Aggregate = {
  __typename?: 'full_card_text_aggregate';
  aggregate?: Maybe<Full_Card_Text_Aggregate_Fields>;
  nodes: Array<Full_Card_Text>;
};

export type Full_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Full_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Full_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Full_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "full_card_text" */
export type Full_Card_Text_Aggregate_Fields = {
  __typename?: 'full_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Full_Card_Text_Max_Fields>;
  min?: Maybe<Full_Card_Text_Min_Fields>;
};


/** aggregate fields of "full_card_text" */
export type Full_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "full_card_text" */
export type Full_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Full_Card_Text_Max_Order_By>;
  min?: InputMaybe<Full_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "full_card_text" */
export type Full_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Full_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "full_card_text". All fields are combined with a logical 'AND'. */
export type Full_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Full_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Full_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Full_Card_Text_Bool_Exp>>;
  back_flavor?: InputMaybe<String_Comparison_Exp>;
  back_name?: InputMaybe<String_Comparison_Exp>;
  back_text?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  encounter_name?: InputMaybe<String_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  slot?: InputMaybe<String_Comparison_Exp>;
  subname?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "full_card_text" */
export enum Full_Card_Text_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  FullCardTextPkey = 'full_card_text_pkey'
}

/** input type for inserting data into table "full_card_text" */
export type Full_Card_Text_Insert_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Full_Card_Text_Max_Fields = {
  __typename?: 'full_card_text_max_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "full_card_text" */
export type Full_Card_Text_Max_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Full_Card_Text_Min_Fields = {
  __typename?: 'full_card_text_min_fields';
  back_flavor?: Maybe<Scalars['String']['output']>;
  back_name?: Maybe<Scalars['String']['output']>;
  back_text?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  encounter_name?: Maybe<Scalars['String']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  slot?: Maybe<Scalars['String']['output']>;
  subname?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "full_card_text" */
export type Full_Card_Text_Min_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "full_card_text" */
export type Full_Card_Text_Mutation_Response = {
  __typename?: 'full_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Full_Card_Text>;
};

/** on_conflict condition type for table "full_card_text" */
export type Full_Card_Text_On_Conflict = {
  constraint: Full_Card_Text_Constraint;
  update_columns?: Array<Full_Card_Text_Update_Column>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "full_card_text". */
export type Full_Card_Text_Order_By = {
  back_flavor?: InputMaybe<Order_By>;
  back_name?: InputMaybe<Order_By>;
  back_text?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  encounter_name?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  slot?: InputMaybe<Order_By>;
  subname?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
};

/** primary key columns input for table: full_card_text */
export type Full_Card_Text_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "full_card_text" */
export enum Full_Card_Text_Select_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

/** input type for updating data in table "full_card_text" */
export type Full_Card_Text_Set_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "full_card_text" */
export type Full_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Full_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Full_Card_Text_Stream_Cursor_Value_Input = {
  back_flavor?: InputMaybe<Scalars['String']['input']>;
  back_name?: InputMaybe<Scalars['String']['input']>;
  back_text?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  encounter_name?: InputMaybe<Scalars['String']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  slot?: InputMaybe<Scalars['String']['input']>;
  subname?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "full_card_text" */
export enum Full_Card_Text_Update_Column {
  /** column name */
  BackFlavor = 'back_flavor',
  /** column name */
  BackName = 'back_name',
  /** column name */
  BackText = 'back_text',
  /** column name */
  Code = 'code',
  /** column name */
  EncounterName = 'encounter_name',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Slot = 'slot',
  /** column name */
  Subname = 'subname',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits'
}

export type Full_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Full_Card_Text_Bool_Exp;
};

/** update columns of table "full_card" */
export enum Full_Card_Update_Column {
  /** column name */
  AlternateRequiredCode = 'alternate_required_code',
  /** column name */
  BackLink = 'back_link',
  /** column name */
  Backimagesrc = 'backimagesrc',
  /** column name */
  Clues = 'clues',
  /** column name */
  CluesFixed = 'clues_fixed',
  /** column name */
  Code = 'code',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  DeckOptions = 'deck_options',
  /** column name */
  DeckRequirements = 'deck_requirements',
  /** column name */
  Doom = 'doom',
  /** column name */
  DoubleSided = 'double_sided',
  /** column name */
  EncounterCode = 'encounter_code',
  /** column name */
  EncounterPosition = 'encounter_position',
  /** column name */
  EnemyDamage = 'enemy_damage',
  /** column name */
  EnemyEvade = 'enemy_evade',
  /** column name */
  EnemyFight = 'enemy_fight',
  /** column name */
  EnemyHorror = 'enemy_horror',
  /** column name */
  Exceptional = 'exceptional',
  /** column name */
  Exile = 'exile',
  /** column name */
  Faction2Code = 'faction2_code',
  /** column name */
  Faction3Code = 'faction3_code',
  /** column name */
  FactionCode = 'faction_code',
  /** column name */
  Health = 'health',
  /** column name */
  HealthPerInvestigator = 'health_per_investigator',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  IsUnique = 'is_unique',
  /** column name */
  Myriad = 'myriad',
  /** column name */
  PackCode = 'pack_code',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Permanent = 'permanent',
  /** column name */
  Position = 'position',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealBackFlavor = 'real_back_flavor',
  /** column name */
  RealBackName = 'real_back_name',
  /** column name */
  RealBackText = 'real_back_text',
  /** column name */
  RealEncounterSetName = 'real_encounter_set_name',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealPackName = 'real_pack_name',
  /** column name */
  RealSlot = 'real_slot',
  /** column name */
  RealSubname = 'real_subname',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  Restrictions = 'restrictions',
  /** column name */
  Sanity = 'sanity',
  /** column name */
  Shroud = 'shroud',
  /** column name */
  SkillAgility = 'skill_agility',
  /** column name */
  SkillCombat = 'skill_combat',
  /** column name */
  SkillIntellect = 'skill_intellect',
  /** column name */
  SkillWild = 'skill_wild',
  /** column name */
  SkillWillpower = 'skill_willpower',
  /** column name */
  Stage = 'stage',
  /** column name */
  SubtypeCode = 'subtype_code',
  /** column name */
  TypeCode = 'type_code',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Vengeance = 'vengeance',
  /** column name */
  Version = 'version',
  /** column name */
  Victory = 'victory',
  /** column name */
  Xp = 'xp'
}

export type Full_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Full_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Full_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Full_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Full_Card_Var_Pop_Fields = {
  __typename?: 'full_card_var_pop_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Full_Card_Var_Samp_Fields = {
  __typename?: 'full_card_var_samp_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Full_Card_Variance_Fields = {
  __typename?: 'full_card_variance_fields';
  clues?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  doom?: Maybe<Scalars['Float']['output']>;
  encounter_position?: Maybe<Scalars['Float']['output']>;
  enemy_damage?: Maybe<Scalars['Float']['output']>;
  enemy_evade?: Maybe<Scalars['Float']['output']>;
  enemy_fight?: Maybe<Scalars['Float']['output']>;
  enemy_horror?: Maybe<Scalars['Float']['output']>;
  health?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  sanity?: Maybe<Scalars['Float']['output']>;
  shroud?: Maybe<Scalars['Float']['output']>;
  skill_agility?: Maybe<Scalars['Float']['output']>;
  skill_combat?: Maybe<Scalars['Float']['output']>;
  skill_intellect?: Maybe<Scalars['Float']['output']>;
  skill_wild?: Maybe<Scalars['Float']['output']>;
  skill_willpower?: Maybe<Scalars['Float']['output']>;
  stage?: Maybe<Scalars['Float']['output']>;
  vengeance?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
  victory?: Maybe<Scalars['Float']['output']>;
  xp?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "gender" */
export type Gender = {
  __typename?: 'gender';
  code: Scalars['String']['output'];
};

/** aggregated selection of "gender" */
export type Gender_Aggregate = {
  __typename?: 'gender_aggregate';
  aggregate?: Maybe<Gender_Aggregate_Fields>;
  nodes: Array<Gender>;
};

/** aggregate fields of "gender" */
export type Gender_Aggregate_Fields = {
  __typename?: 'gender_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Gender_Max_Fields>;
  min?: Maybe<Gender_Min_Fields>;
};


/** aggregate fields of "gender" */
export type Gender_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Gender_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "gender". All fields are combined with a logical 'AND'. */
export type Gender_Bool_Exp = {
  _and?: InputMaybe<Array<Gender_Bool_Exp>>;
  _not?: InputMaybe<Gender_Bool_Exp>;
  _or?: InputMaybe<Array<Gender_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "gender" */
export enum Gender_Constraint {
  /** unique or primary key constraint on columns "code" */
  GenderPkey = 'gender_pkey'
}

export enum Gender_Enum {
  F = 'f',
  M = 'm',
  Nb = 'nb'
}

/** Boolean expression to compare columns of type "gender_enum". All fields are combined with logical 'AND'. */
export type Gender_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Gender_Enum>;
  _in?: InputMaybe<Array<Gender_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Gender_Enum>;
  _nin?: InputMaybe<Array<Gender_Enum>>;
};

/** input type for inserting data into table "gender" */
export type Gender_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Gender_Max_Fields = {
  __typename?: 'gender_max_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Gender_Min_Fields = {
  __typename?: 'gender_min_fields';
  code?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "gender" */
export type Gender_Mutation_Response = {
  __typename?: 'gender_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Gender>;
};

/** on_conflict condition type for table "gender" */
export type Gender_On_Conflict = {
  constraint: Gender_Constraint;
  update_columns?: Array<Gender_Update_Column>;
  where?: InputMaybe<Gender_Bool_Exp>;
};

/** Ordering options when selecting data from "gender". */
export type Gender_Order_By = {
  code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: gender */
export type Gender_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "gender" */
export enum Gender_Select_Column {
  /** column name */
  Code = 'code'
}

/** input type for updating data in table "gender" */
export type Gender_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "gender" */
export type Gender_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gender_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gender_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "gender" */
export enum Gender_Update_Column {
  /** column name */
  Code = 'code'
}

export type Gender_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Gender_Set_Input>;
  /** filter the rows which have to be updated */
  where: Gender_Bool_Exp;
};

/** columns and relationships of "guide_achievement" */
export type Guide_Achievement = {
  __typename?: 'guide_achievement';
  bool_value?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  type: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
  value?: Maybe<Scalars['Int']['output']>;
};

/** aggregated selection of "guide_achievement" */
export type Guide_Achievement_Aggregate = {
  __typename?: 'guide_achievement_aggregate';
  aggregate?: Maybe<Guide_Achievement_Aggregate_Fields>;
  nodes: Array<Guide_Achievement>;
};

export type Guide_Achievement_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Guide_Achievement_Aggregate_Bool_Exp_Count>;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Bool_And = {
  arguments: Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Guide_Achievement_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Achievement_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "guide_achievement" */
export type Guide_Achievement_Aggregate_Fields = {
  __typename?: 'guide_achievement_aggregate_fields';
  avg?: Maybe<Guide_Achievement_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Guide_Achievement_Max_Fields>;
  min?: Maybe<Guide_Achievement_Min_Fields>;
  stddev?: Maybe<Guide_Achievement_Stddev_Fields>;
  stddev_pop?: Maybe<Guide_Achievement_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Guide_Achievement_Stddev_Samp_Fields>;
  sum?: Maybe<Guide_Achievement_Sum_Fields>;
  var_pop?: Maybe<Guide_Achievement_Var_Pop_Fields>;
  var_samp?: Maybe<Guide_Achievement_Var_Samp_Fields>;
  variance?: Maybe<Guide_Achievement_Variance_Fields>;
};


/** aggregate fields of "guide_achievement" */
export type Guide_Achievement_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "guide_achievement" */
export type Guide_Achievement_Aggregate_Order_By = {
  avg?: InputMaybe<Guide_Achievement_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Guide_Achievement_Max_Order_By>;
  min?: InputMaybe<Guide_Achievement_Min_Order_By>;
  stddev?: InputMaybe<Guide_Achievement_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Guide_Achievement_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Guide_Achievement_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Guide_Achievement_Sum_Order_By>;
  var_pop?: InputMaybe<Guide_Achievement_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Guide_Achievement_Var_Samp_Order_By>;
  variance?: InputMaybe<Guide_Achievement_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "guide_achievement" */
export type Guide_Achievement_Arr_Rel_Insert_Input = {
  data: Array<Guide_Achievement_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};

/** aggregate avg on columns */
export type Guide_Achievement_Avg_Fields = {
  __typename?: 'guide_achievement_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "guide_achievement" */
export type Guide_Achievement_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "guide_achievement". All fields are combined with a logical 'AND'. */
export type Guide_Achievement_Bool_Exp = {
  _and?: InputMaybe<Array<Guide_Achievement_Bool_Exp>>;
  _not?: InputMaybe<Guide_Achievement_Bool_Exp>;
  _or?: InputMaybe<Array<Guide_Achievement_Bool_Exp>>;
  bool_value?: InputMaybe<Boolean_Comparison_Exp>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  value?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "guide_achievement" */
export enum Guide_Achievement_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "id" */
  GuideAchievementPkey = 'guide_achievement_pkey'
}

/** input type for incrementing numeric columns in table "guide_achievement" */
export type Guide_Achievement_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "guide_achievement" */
export type Guide_Achievement_Insert_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Guide_Achievement_Max_Fields = {
  __typename?: 'guide_achievement_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by max() on columns of table "guide_achievement" */
export type Guide_Achievement_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Guide_Achievement_Min_Fields = {
  __typename?: 'guide_achievement_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by min() on columns of table "guide_achievement" */
export type Guide_Achievement_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "guide_achievement" */
export type Guide_Achievement_Mutation_Response = {
  __typename?: 'guide_achievement_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Guide_Achievement>;
};

/** on_conflict condition type for table "guide_achievement" */
export type Guide_Achievement_On_Conflict = {
  constraint: Guide_Achievement_Constraint;
  update_columns?: Array<Guide_Achievement_Update_Column>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};

/** Ordering options when selecting data from "guide_achievement". */
export type Guide_Achievement_Order_By = {
  bool_value?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: guide_achievement */
export type Guide_Achievement_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};

/** select columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column {
  /** column name */
  BoolValue = 'bool_value',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** select "guide_achievement_aggregate_bool_exp_bool_and_arguments_columns" columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  BoolValue = 'bool_value'
}

/** select "guide_achievement_aggregate_bool_exp_bool_or_arguments_columns" columns of table "guide_achievement" */
export enum Guide_Achievement_Select_Column_Guide_Achievement_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  BoolValue = 'bool_value'
}

/** input type for updating data in table "guide_achievement" */
export type Guide_Achievement_Set_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Guide_Achievement_Stddev_Fields = {
  __typename?: 'guide_achievement_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Guide_Achievement_Stddev_Pop_Fields = {
  __typename?: 'guide_achievement_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Guide_Achievement_Stddev_Samp_Fields = {
  __typename?: 'guide_achievement_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "guide_achievement" */
export type Guide_Achievement_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "guide_achievement" */
export type Guide_Achievement_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Guide_Achievement_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Guide_Achievement_Stream_Cursor_Value_Input = {
  bool_value?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Guide_Achievement_Sum_Fields = {
  __typename?: 'guide_achievement_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  value?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "guide_achievement" */
export type Guide_Achievement_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** update columns of table "guide_achievement" */
export enum Guide_Achievement_Update_Column {
  /** column name */
  BoolValue = 'bool_value',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

export type Guide_Achievement_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  /** filter the rows which have to be updated */
  where: Guide_Achievement_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Guide_Achievement_Var_Pop_Fields = {
  __typename?: 'guide_achievement_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "guide_achievement" */
export type Guide_Achievement_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Guide_Achievement_Var_Samp_Fields = {
  __typename?: 'guide_achievement_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "guide_achievement" */
export type Guide_Achievement_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Guide_Achievement_Variance_Fields = {
  __typename?: 'guide_achievement_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  value?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "guide_achievement" */
export type Guide_Achievement_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  value?: InputMaybe<Order_By>;
};

/** columns and relationships of "guide_input" */
export type Guide_Input = {
  __typename?: 'guide_input';
  /** An object relationship */
  campaign: Campaign;
  campaign_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  payload?: Maybe<Scalars['jsonb']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "guide_input" */
export type Guide_InputPayloadArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "guide_input" */
export type Guide_Input_Aggregate = {
  __typename?: 'guide_input_aggregate';
  aggregate?: Maybe<Guide_Input_Aggregate_Fields>;
  nodes: Array<Guide_Input>;
};

export type Guide_Input_Aggregate_Bool_Exp = {
  count?: InputMaybe<Guide_Input_Aggregate_Bool_Exp_Count>;
};

export type Guide_Input_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Guide_Input_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Guide_Input_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "guide_input" */
export type Guide_Input_Aggregate_Fields = {
  __typename?: 'guide_input_aggregate_fields';
  avg?: Maybe<Guide_Input_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Guide_Input_Max_Fields>;
  min?: Maybe<Guide_Input_Min_Fields>;
  stddev?: Maybe<Guide_Input_Stddev_Fields>;
  stddev_pop?: Maybe<Guide_Input_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Guide_Input_Stddev_Samp_Fields>;
  sum?: Maybe<Guide_Input_Sum_Fields>;
  var_pop?: Maybe<Guide_Input_Var_Pop_Fields>;
  var_samp?: Maybe<Guide_Input_Var_Samp_Fields>;
  variance?: Maybe<Guide_Input_Variance_Fields>;
};


/** aggregate fields of "guide_input" */
export type Guide_Input_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Guide_Input_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "guide_input" */
export type Guide_Input_Aggregate_Order_By = {
  avg?: InputMaybe<Guide_Input_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Guide_Input_Max_Order_By>;
  min?: InputMaybe<Guide_Input_Min_Order_By>;
  stddev?: InputMaybe<Guide_Input_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Guide_Input_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Guide_Input_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Guide_Input_Sum_Order_By>;
  var_pop?: InputMaybe<Guide_Input_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Guide_Input_Var_Samp_Order_By>;
  variance?: InputMaybe<Guide_Input_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Guide_Input_Append_Input = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "guide_input" */
export type Guide_Input_Arr_Rel_Insert_Input = {
  data: Array<Guide_Input_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};

/** aggregate avg on columns */
export type Guide_Input_Avg_Fields = {
  __typename?: 'guide_input_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "guide_input" */
export type Guide_Input_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "guide_input". All fields are combined with a logical 'AND'. */
export type Guide_Input_Bool_Exp = {
  _and?: InputMaybe<Array<Guide_Input_Bool_Exp>>;
  _not?: InputMaybe<Guide_Input_Bool_Exp>;
  _or?: InputMaybe<Array<Guide_Input_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  inserted_idx?: InputMaybe<Int_Comparison_Exp>;
  payload?: InputMaybe<Jsonb_Comparison_Exp>;
  scenario?: InputMaybe<String_Comparison_Exp>;
  step?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "guide_input" */
export enum Guide_Input_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "id" */
  GuideInputPkey = 'guide_input_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Guide_Input_Delete_At_Path_Input = {
  payload?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Guide_Input_Delete_Elem_Input = {
  payload?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Guide_Input_Delete_Key_Input = {
  payload?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "guide_input" */
export type Guide_Input_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "guide_input" */
export type Guide_Input_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Guide_Input_Max_Fields = {
  __typename?: 'guide_input_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "guide_input" */
export type Guide_Input_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Guide_Input_Min_Fields = {
  __typename?: 'guide_input_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
  scenario?: Maybe<Scalars['String']['output']>;
  step?: Maybe<Scalars['String']['output']>;
  type?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "guide_input" */
export type Guide_Input_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "guide_input" */
export type Guide_Input_Mutation_Response = {
  __typename?: 'guide_input_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Guide_Input>;
};

/** on_conflict condition type for table "guide_input" */
export type Guide_Input_On_Conflict = {
  constraint: Guide_Input_Constraint;
  update_columns?: Array<Guide_Input_Update_Column>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};

/** Ordering options when selecting data from "guide_input". */
export type Guide_Input_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
  payload?: InputMaybe<Order_By>;
  scenario?: InputMaybe<Order_By>;
  step?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: guide_input */
export type Guide_Input_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Guide_Input_Prepend_Input = {
  payload?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "guide_input" */
export enum Guide_Input_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InsertedIdx = 'inserted_idx',
  /** column name */
  Payload = 'payload',
  /** column name */
  Scenario = 'scenario',
  /** column name */
  Step = 'step',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "guide_input" */
export type Guide_Input_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Guide_Input_Stddev_Fields = {
  __typename?: 'guide_input_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "guide_input" */
export type Guide_Input_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Guide_Input_Stddev_Pop_Fields = {
  __typename?: 'guide_input_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "guide_input" */
export type Guide_Input_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Guide_Input_Stddev_Samp_Fields = {
  __typename?: 'guide_input_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "guide_input" */
export type Guide_Input_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "guide_input" */
export type Guide_Input_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Guide_Input_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Guide_Input_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  inserted_idx?: InputMaybe<Scalars['Int']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  type?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Guide_Input_Sum_Fields = {
  __typename?: 'guide_input_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  inserted_idx?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "guide_input" */
export type Guide_Input_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** update columns of table "guide_input" */
export enum Guide_Input_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InsertedIdx = 'inserted_idx',
  /** column name */
  Payload = 'payload',
  /** column name */
  Scenario = 'scenario',
  /** column name */
  Step = 'step',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Guide_Input_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Guide_Input_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Guide_Input_Set_Input>;
  /** filter the rows which have to be updated */
  where: Guide_Input_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Guide_Input_Var_Pop_Fields = {
  __typename?: 'guide_input_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "guide_input" */
export type Guide_Input_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Guide_Input_Var_Samp_Fields = {
  __typename?: 'guide_input_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "guide_input" */
export type Guide_Input_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Guide_Input_Variance_Fields = {
  __typename?: 'guide_input_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  inserted_idx?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "guide_input" */
export type Guide_Input_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  inserted_idx?: InputMaybe<Order_By>;
};

/** columns and relationships of "investigator_data" */
export type Investigator_Data = {
  __typename?: 'investigator_data';
  addedCards?: Maybe<Scalars['jsonb']['output']>;
  availableXp?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  campaign_data: Campaign;
  campaign_id: Scalars['Int']['output'];
  cardCounts?: Maybe<Scalars['jsonb']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  ignoreStoryAssets?: Maybe<Scalars['jsonb']['output']>;
  insane?: Maybe<Scalars['Boolean']['output']>;
  investigator: Scalars['String']['output'];
  killed?: Maybe<Scalars['Boolean']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  removedCards?: Maybe<Scalars['jsonb']['output']>;
  specialXp?: Maybe<Scalars['jsonb']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  storyAssets?: Maybe<Scalars['jsonb']['output']>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataAddedCardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataCardCountsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataIgnoreStoryAssetsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataRemovedCardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataSpecialXpArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "investigator_data" */
export type Investigator_DataStoryAssetsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "investigator_data" */
export type Investigator_Data_Aggregate = {
  __typename?: 'investigator_data_aggregate';
  aggregate?: Maybe<Investigator_Data_Aggregate_Fields>;
  nodes: Array<Investigator_Data>;
};

export type Investigator_Data_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Investigator_Data_Aggregate_Bool_Exp_Count>;
};

export type Investigator_Data_Aggregate_Bool_Exp_Bool_And = {
  arguments: Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investigator_Data_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Investigator_Data_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Investigator_Data_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "investigator_data" */
export type Investigator_Data_Aggregate_Fields = {
  __typename?: 'investigator_data_aggregate_fields';
  avg?: Maybe<Investigator_Data_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Investigator_Data_Max_Fields>;
  min?: Maybe<Investigator_Data_Min_Fields>;
  stddev?: Maybe<Investigator_Data_Stddev_Fields>;
  stddev_pop?: Maybe<Investigator_Data_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Investigator_Data_Stddev_Samp_Fields>;
  sum?: Maybe<Investigator_Data_Sum_Fields>;
  var_pop?: Maybe<Investigator_Data_Var_Pop_Fields>;
  var_samp?: Maybe<Investigator_Data_Var_Samp_Fields>;
  variance?: Maybe<Investigator_Data_Variance_Fields>;
};


/** aggregate fields of "investigator_data" */
export type Investigator_Data_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "investigator_data" */
export type Investigator_Data_Aggregate_Order_By = {
  avg?: InputMaybe<Investigator_Data_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Investigator_Data_Max_Order_By>;
  min?: InputMaybe<Investigator_Data_Min_Order_By>;
  stddev?: InputMaybe<Investigator_Data_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Investigator_Data_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Investigator_Data_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Investigator_Data_Sum_Order_By>;
  var_pop?: InputMaybe<Investigator_Data_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Investigator_Data_Var_Samp_Order_By>;
  variance?: InputMaybe<Investigator_Data_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Investigator_Data_Append_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** input type for inserting array relation for remote table "investigator_data" */
export type Investigator_Data_Arr_Rel_Insert_Input = {
  data: Array<Investigator_Data_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};

/** aggregate avg on columns */
export type Investigator_Data_Avg_Fields = {
  __typename?: 'investigator_data_avg_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "investigator_data" */
export type Investigator_Data_Avg_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "investigator_data". All fields are combined with a logical 'AND'. */
export type Investigator_Data_Bool_Exp = {
  _and?: InputMaybe<Array<Investigator_Data_Bool_Exp>>;
  _not?: InputMaybe<Investigator_Data_Bool_Exp>;
  _or?: InputMaybe<Array<Investigator_Data_Bool_Exp>>;
  addedCards?: InputMaybe<Jsonb_Comparison_Exp>;
  availableXp?: InputMaybe<Int_Comparison_Exp>;
  campaign_data?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  cardCounts?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  ignoreStoryAssets?: InputMaybe<Jsonb_Comparison_Exp>;
  insane?: InputMaybe<Boolean_Comparison_Exp>;
  investigator?: InputMaybe<String_Comparison_Exp>;
  killed?: InputMaybe<Boolean_Comparison_Exp>;
  mental?: InputMaybe<Int_Comparison_Exp>;
  physical?: InputMaybe<Int_Comparison_Exp>;
  removedCards?: InputMaybe<Jsonb_Comparison_Exp>;
  specialXp?: InputMaybe<Jsonb_Comparison_Exp>;
  spentXp?: InputMaybe<Int_Comparison_Exp>;
  storyAssets?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "investigator_data" */
export enum Investigator_Data_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "investigator" */
  InvestigatorDataPkey = 'investigator_data_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Investigator_Data_Delete_At_Path_Input = {
  addedCards?: InputMaybe<Array<Scalars['String']['input']>>;
  cardCounts?: InputMaybe<Array<Scalars['String']['input']>>;
  ignoreStoryAssets?: InputMaybe<Array<Scalars['String']['input']>>;
  removedCards?: InputMaybe<Array<Scalars['String']['input']>>;
  specialXp?: InputMaybe<Array<Scalars['String']['input']>>;
  storyAssets?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Investigator_Data_Delete_Elem_Input = {
  addedCards?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['Int']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['Int']['input']>;
  specialXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Investigator_Data_Delete_Key_Input = {
  addedCards?: InputMaybe<Scalars['String']['input']>;
  cardCounts?: InputMaybe<Scalars['String']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['String']['input']>;
  removedCards?: InputMaybe<Scalars['String']['input']>;
  specialXp?: InputMaybe<Scalars['String']['input']>;
  storyAssets?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "investigator_data" */
export type Investigator_Data_Inc_Input = {
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "investigator_data" */
export type Investigator_Data_Insert_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_data?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Investigator_Data_Max_Fields = {
  __typename?: 'investigator_data_max_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "investigator_data" */
export type Investigator_Data_Max_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Investigator_Data_Min_Fields = {
  __typename?: 'investigator_data_min_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  /** A computed field, executes function "investigator_data_id" */
  id?: Maybe<Scalars['String']['output']>;
  investigator?: Maybe<Scalars['String']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "investigator_data" */
export type Investigator_Data_Min_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "investigator_data" */
export type Investigator_Data_Mutation_Response = {
  __typename?: 'investigator_data_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Investigator_Data>;
};

/** input type for inserting object relation for remote table "investigator_data" */
export type Investigator_Data_Obj_Rel_Insert_Input = {
  data: Investigator_Data_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};

/** on_conflict condition type for table "investigator_data" */
export type Investigator_Data_On_Conflict = {
  constraint: Investigator_Data_Constraint;
  update_columns?: Array<Investigator_Data_Update_Column>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};

/** Ordering options when selecting data from "investigator_data". */
export type Investigator_Data_Order_By = {
  addedCards?: InputMaybe<Order_By>;
  availableXp?: InputMaybe<Order_By>;
  campaign_data?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  cardCounts?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  ignoreStoryAssets?: InputMaybe<Order_By>;
  insane?: InputMaybe<Order_By>;
  investigator?: InputMaybe<Order_By>;
  killed?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  removedCards?: InputMaybe<Order_By>;
  specialXp?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
  storyAssets?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: investigator_data */
export type Investigator_Data_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Investigator_Data_Prepend_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "investigator_data" */
export enum Investigator_Data_Select_Column {
  /** column name */
  AddedCards = 'addedCards',
  /** column name */
  AvailableXp = 'availableXp',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CardCounts = 'cardCounts',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IgnoreStoryAssets = 'ignoreStoryAssets',
  /** column name */
  Insane = 'insane',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Killed = 'killed',
  /** column name */
  Mental = 'mental',
  /** column name */
  Physical = 'physical',
  /** column name */
  RemovedCards = 'removedCards',
  /** column name */
  SpecialXp = 'specialXp',
  /** column name */
  SpentXp = 'spentXp',
  /** column name */
  StoryAssets = 'storyAssets',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select "investigator_data_aggregate_bool_exp_bool_and_arguments_columns" columns of table "investigator_data" */
export enum Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Insane = 'insane',
  /** column name */
  Killed = 'killed'
}

/** select "investigator_data_aggregate_bool_exp_bool_or_arguments_columns" columns of table "investigator_data" */
export enum Investigator_Data_Select_Column_Investigator_Data_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Insane = 'insane',
  /** column name */
  Killed = 'killed'
}

/** input type for updating data in table "investigator_data" */
export type Investigator_Data_Set_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Investigator_Data_Stddev_Fields = {
  __typename?: 'investigator_data_stddev_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Investigator_Data_Stddev_Pop_Fields = {
  __typename?: 'investigator_data_stddev_pop_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Pop_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Investigator_Data_Stddev_Samp_Fields = {
  __typename?: 'investigator_data_stddev_samp_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "investigator_data" */
export type Investigator_Data_Stddev_Samp_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "investigator_data" */
export type Investigator_Data_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Investigator_Data_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Investigator_Data_Stream_Cursor_Value_Input = {
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  investigator?: InputMaybe<Scalars['String']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  physical?: InputMaybe<Scalars['Int']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  spentXp?: InputMaybe<Scalars['Int']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Investigator_Data_Sum_Fields = {
  __typename?: 'investigator_data_sum_fields';
  availableXp?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  mental?: Maybe<Scalars['Int']['output']>;
  physical?: Maybe<Scalars['Int']['output']>;
  spentXp?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "investigator_data" */
export type Investigator_Data_Sum_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** update columns of table "investigator_data" */
export enum Investigator_Data_Update_Column {
  /** column name */
  AddedCards = 'addedCards',
  /** column name */
  AvailableXp = 'availableXp',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CardCounts = 'cardCounts',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  IgnoreStoryAssets = 'ignoreStoryAssets',
  /** column name */
  Insane = 'insane',
  /** column name */
  Investigator = 'investigator',
  /** column name */
  Killed = 'killed',
  /** column name */
  Mental = 'mental',
  /** column name */
  Physical = 'physical',
  /** column name */
  RemovedCards = 'removedCards',
  /** column name */
  SpecialXp = 'specialXp',
  /** column name */
  SpentXp = 'spentXp',
  /** column name */
  StoryAssets = 'storyAssets',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Investigator_Data_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  /** filter the rows which have to be updated */
  where: Investigator_Data_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Investigator_Data_Var_Pop_Fields = {
  __typename?: 'investigator_data_var_pop_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "investigator_data" */
export type Investigator_Data_Var_Pop_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Investigator_Data_Var_Samp_Fields = {
  __typename?: 'investigator_data_var_samp_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "investigator_data" */
export type Investigator_Data_Var_Samp_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Investigator_Data_Variance_Fields = {
  __typename?: 'investigator_data_variance_fields';
  availableXp?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  mental?: Maybe<Scalars['Float']['output']>;
  physical?: Maybe<Scalars['Float']['output']>;
  spentXp?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "investigator_data" */
export type Investigator_Data_Variance_Order_By = {
  availableXp?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  mental?: InputMaybe<Order_By>;
  physical?: InputMaybe<Order_By>;
  spentXp?: InputMaybe<Order_By>;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']['input']>;
  _eq?: InputMaybe<Scalars['jsonb']['input']>;
  _gt?: InputMaybe<Scalars['jsonb']['input']>;
  _gte?: InputMaybe<Scalars['jsonb']['input']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']['input']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']['input']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']['input']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['jsonb']['input']>;
  _lte?: InputMaybe<Scalars['jsonb']['input']>;
  _neq?: InputMaybe<Scalars['jsonb']['input']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']['input']>>;
};

/** columns and relationships of "latest_decks" */
export type Latest_Decks = {
  __typename?: 'latest_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "latest_decks" */
export type Latest_Decks_Aggregate = {
  __typename?: 'latest_decks_aggregate';
  aggregate?: Maybe<Latest_Decks_Aggregate_Fields>;
  nodes: Array<Latest_Decks>;
};

export type Latest_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp_Count>;
};

export type Latest_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Latest_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "latest_decks" */
export type Latest_Decks_Aggregate_Fields = {
  __typename?: 'latest_decks_aggregate_fields';
  avg?: Maybe<Latest_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Latest_Decks_Max_Fields>;
  min?: Maybe<Latest_Decks_Min_Fields>;
  stddev?: Maybe<Latest_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Latest_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Latest_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Latest_Decks_Sum_Fields>;
  var_pop?: Maybe<Latest_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Latest_Decks_Var_Samp_Fields>;
  variance?: Maybe<Latest_Decks_Variance_Fields>;
};


/** aggregate fields of "latest_decks" */
export type Latest_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "latest_decks" */
export type Latest_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Latest_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Latest_Decks_Max_Order_By>;
  min?: InputMaybe<Latest_Decks_Min_Order_By>;
  stddev?: InputMaybe<Latest_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Latest_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Latest_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Latest_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Latest_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Latest_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Latest_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "latest_decks" */
export type Latest_Decks_Arr_Rel_Insert_Input = {
  data: Array<Latest_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Latest_Decks_Avg_Fields = {
  __typename?: 'latest_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "latest_decks" */
export type Latest_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "latest_decks". All fields are combined with a logical 'AND'. */
export type Latest_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Latest_Decks_Bool_Exp>>;
  _not?: InputMaybe<Latest_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Latest_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "latest_decks" */
export type Latest_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "latest_decks" */
export type Latest_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Latest_Decks_Max_Fields = {
  __typename?: 'latest_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "latest_decks" */
export type Latest_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Latest_Decks_Min_Fields = {
  __typename?: 'latest_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "latest_decks" */
export type Latest_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "latest_decks" */
export type Latest_Decks_Mutation_Response = {
  __typename?: 'latest_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Latest_Decks>;
};

/** Ordering options when selecting data from "latest_decks". */
export type Latest_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** select columns of table "latest_decks" */
export enum Latest_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  OwnerId = 'owner_id'
}

/** input type for updating data in table "latest_decks" */
export type Latest_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Latest_Decks_Stddev_Fields = {
  __typename?: 'latest_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Latest_Decks_Stddev_Pop_Fields = {
  __typename?: 'latest_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Latest_Decks_Stddev_Samp_Fields = {
  __typename?: 'latest_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "latest_decks" */
export type Latest_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "latest_decks" */
export type Latest_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Latest_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Latest_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Latest_Decks_Sum_Fields = {
  __typename?: 'latest_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "latest_decks" */
export type Latest_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Latest_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Latest_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Latest_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Latest_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Latest_Decks_Var_Pop_Fields = {
  __typename?: 'latest_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "latest_decks" */
export type Latest_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Latest_Decks_Var_Samp_Fields = {
  __typename?: 'latest_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "latest_decks" */
export type Latest_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Latest_Decks_Variance_Fields = {
  __typename?: 'latest_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "latest_decks" */
export type Latest_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "local_decks" */
export type Local_Decks = {
  __typename?: 'local_decks';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Campaign_Deck>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "local_decks" */
export type Local_Decks_Aggregate = {
  __typename?: 'local_decks_aggregate';
  aggregate?: Maybe<Local_Decks_Aggregate_Fields>;
  nodes: Array<Local_Decks>;
};

export type Local_Decks_Aggregate_Bool_Exp = {
  count?: InputMaybe<Local_Decks_Aggregate_Bool_Exp_Count>;
};

export type Local_Decks_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Local_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Local_Decks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "local_decks" */
export type Local_Decks_Aggregate_Fields = {
  __typename?: 'local_decks_aggregate_fields';
  avg?: Maybe<Local_Decks_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Local_Decks_Max_Fields>;
  min?: Maybe<Local_Decks_Min_Fields>;
  stddev?: Maybe<Local_Decks_Stddev_Fields>;
  stddev_pop?: Maybe<Local_Decks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Local_Decks_Stddev_Samp_Fields>;
  sum?: Maybe<Local_Decks_Sum_Fields>;
  var_pop?: Maybe<Local_Decks_Var_Pop_Fields>;
  var_samp?: Maybe<Local_Decks_Var_Samp_Fields>;
  variance?: Maybe<Local_Decks_Variance_Fields>;
};


/** aggregate fields of "local_decks" */
export type Local_Decks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Local_Decks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "local_decks" */
export type Local_Decks_Aggregate_Order_By = {
  avg?: InputMaybe<Local_Decks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Local_Decks_Max_Order_By>;
  min?: InputMaybe<Local_Decks_Min_Order_By>;
  stddev?: InputMaybe<Local_Decks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Local_Decks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Local_Decks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Local_Decks_Sum_Order_By>;
  var_pop?: InputMaybe<Local_Decks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Local_Decks_Var_Samp_Order_By>;
  variance?: InputMaybe<Local_Decks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "local_decks" */
export type Local_Decks_Arr_Rel_Insert_Input = {
  data: Array<Local_Decks_Insert_Input>;
};

/** aggregate avg on columns */
export type Local_Decks_Avg_Fields = {
  __typename?: 'local_decks_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "local_decks" */
export type Local_Decks_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "local_decks". All fields are combined with a logical 'AND'. */
export type Local_Decks_Bool_Exp = {
  _and?: InputMaybe<Array<Local_Decks_Bool_Exp>>;
  _not?: InputMaybe<Local_Decks_Bool_Exp>;
  _or?: InputMaybe<Array<Local_Decks_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Campaign_Deck_Bool_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  owner_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "local_decks" */
export type Local_Decks_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "local_decks" */
export type Local_Decks_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Campaign_Deck_Obj_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Local_Decks_Max_Fields = {
  __typename?: 'local_decks_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "local_decks" */
export type Local_Decks_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Local_Decks_Min_Fields = {
  __typename?: 'local_decks_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  owner_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "local_decks" */
export type Local_Decks_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "local_decks" */
export type Local_Decks_Mutation_Response = {
  __typename?: 'local_decks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Local_Decks>;
};

/** Ordering options when selecting data from "local_decks". */
export type Local_Decks_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Campaign_Deck_Order_By>;
  id?: InputMaybe<Order_By>;
  owner_id?: InputMaybe<Order_By>;
};

/** select columns of table "local_decks" */
export enum Local_Decks_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  OwnerId = 'owner_id'
}

/** input type for updating data in table "local_decks" */
export type Local_Decks_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Local_Decks_Stddev_Fields = {
  __typename?: 'local_decks_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "local_decks" */
export type Local_Decks_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Local_Decks_Stddev_Pop_Fields = {
  __typename?: 'local_decks_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "local_decks" */
export type Local_Decks_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Local_Decks_Stddev_Samp_Fields = {
  __typename?: 'local_decks_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "local_decks" */
export type Local_Decks_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "local_decks" */
export type Local_Decks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Local_Decks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Local_Decks_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  owner_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Local_Decks_Sum_Fields = {
  __typename?: 'local_decks_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "local_decks" */
export type Local_Decks_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type Local_Decks_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Local_Decks_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Local_Decks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Local_Decks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Local_Decks_Var_Pop_Fields = {
  __typename?: 'local_decks_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "local_decks" */
export type Local_Decks_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Local_Decks_Var_Samp_Fields = {
  __typename?: 'local_decks_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "local_decks" */
export type Local_Decks_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Local_Decks_Variance_Fields = {
  __typename?: 'local_decks_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "local_decks" */
export type Local_Decks_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  apiDeleteArkhamDbDeck?: Maybe<DeleteDeckOutput>;
  /** execute VOLATILE function "conquest.publish_deck" which returns "conquest.deck" */
  conquest_publish_deck?: Maybe<Conquest_Deck>;
  createArkhamDbDeck?: Maybe<CreateDeckOutput>;
  createCampaign?: Maybe<CreateCampaignOutput>;
  deleteCampaign?: Maybe<DeleteCampaignOutput>;
  /** delete data from the table: "all_card" */
  delete_all_card?: Maybe<All_Card_Mutation_Response>;
  /** delete single row from the table: "all_card" */
  delete_all_card_by_pk?: Maybe<All_Card>;
  /** delete data from the table: "all_card_text" */
  delete_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** delete single row from the table: "all_card_text" */
  delete_all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** delete data from the table: "all_card_updated" */
  delete_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** delete single row from the table: "all_card_updated" */
  delete_all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** delete data from the table: "all_card_updated_by_version" */
  delete_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** delete single row from the table: "all_card_updated_by_version" */
  delete_all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** delete data from the table: "arkhamdb_auth" */
  delete_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** delete single row from the table: "arkhamdb_auth" */
  delete_arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** delete data from the table: "arkhamdb_deck" */
  delete_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** delete single row from the table: "arkhamdb_deck" */
  delete_arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** delete data from the table: "base_decks" */
  delete_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** delete data from the table: "campaign" */
  delete_campaign?: Maybe<Campaign_Mutation_Response>;
  /** delete data from the table: "campaign_access" */
  delete_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** delete single row from the table: "campaign_access" */
  delete_campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** delete single row from the table: "campaign" */
  delete_campaign_by_pk?: Maybe<Campaign>;
  /** delete data from the table: "campaign_deck" */
  delete_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** delete single row from the table: "campaign_deck" */
  delete_campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** delete data from the table: "campaign_difficulty" */
  delete_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** delete single row from the table: "campaign_difficulty" */
  delete_campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** delete data from the table: "campaign_guide" */
  delete_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** delete data from the table: "campaign_investigator" */
  delete_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** delete single row from the table: "campaign_investigator" */
  delete_campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** delete data from the table: "card" */
  delete_card?: Maybe<Card_Mutation_Response>;
  /** delete single row from the table: "card" */
  delete_card_by_pk?: Maybe<Card>;
  /** delete data from the table: "card_cycle" */
  delete_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** delete single row from the table: "card_cycle" */
  delete_card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** delete data from the table: "card_encounter_set" */
  delete_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** delete single row from the table: "card_encounter_set" */
  delete_card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** delete data from the table: "card_pack" */
  delete_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** delete single row from the table: "card_pack" */
  delete_card_pack_by_pk?: Maybe<Card_Pack>;
  /** delete data from the table: "card_subtype_name" */
  delete_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** delete single row from the table: "card_subtype_name" */
  delete_card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** delete data from the table: "card_text" */
  delete_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** delete single row from the table: "card_text" */
  delete_card_text_by_pk?: Maybe<Card_Text>;
  /** delete data from the table: "card_type_code" */
  delete_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** delete single row from the table: "card_type_code" */
  delete_card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** delete data from the table: "card_type_name" */
  delete_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** delete single row from the table: "card_type_name" */
  delete_card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** delete data from the table: "chaos_bag_result" */
  delete_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** delete single row from the table: "chaos_bag_result" */
  delete_chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** delete data from the table: "chaos_bag_tarot_mode" */
  delete_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** delete single row from the table: "chaos_bag_tarot_mode" */
  delete_chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** delete data from the table: "conquest.card" */
  delete_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** delete single row from the table: "conquest.card" */
  delete_conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** delete data from the table: "conquest.card_text" */
  delete_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.card_text" */
  delete_conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** delete data from the table: "conquest.comment" */
  delete_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** delete single row from the table: "conquest.comment" */
  delete_conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** delete data from the table: "conquest.cycle" */
  delete_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** delete single row from the table: "conquest.cycle" */
  delete_conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** delete data from the table: "conquest.cycle_text" */
  delete_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.cycle_text" */
  delete_conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** delete data from the table: "conquest.deck" */
  delete_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** delete single row from the table: "conquest.deck" */
  delete_conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** delete data from the table: "conquest.deck_copy" */
  delete_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** delete single row from the table: "conquest.deck_copy" */
  delete_conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** delete data from the table: "conquest.deck_like" */
  delete_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** delete single row from the table: "conquest.deck_like" */
  delete_conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** delete data from the table: "conquest.faction" */
  delete_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** delete single row from the table: "conquest.faction" */
  delete_conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** delete data from the table: "conquest.faction_text" */
  delete_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.faction_text" */
  delete_conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** delete data from the table: "conquest.loyalty" */
  delete_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** delete single row from the table: "conquest.loyalty" */
  delete_conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** delete data from the table: "conquest.loyalty_text" */
  delete_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.loyalty_text" */
  delete_conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** delete data from the table: "conquest.pack" */
  delete_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** delete single row from the table: "conquest.pack" */
  delete_conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** delete data from the table: "conquest.pack_text" */
  delete_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.pack_text" */
  delete_conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** delete data from the table: "conquest.type" */
  delete_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** delete single row from the table: "conquest.type" */
  delete_conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** delete data from the table: "conquest.type_text" */
  delete_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** delete single row from the table: "conquest.type_text" */
  delete_conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** delete data from the table: "conquest.user_role" */
  delete_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** delete single row from the table: "conquest.user_role" */
  delete_conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** delete data from the table: "conquest.user_settings" */
  delete_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** delete single row from the table: "conquest.user_settings" */
  delete_conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** delete data from the table: "conquest.users" */
  delete_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** delete single row from the table: "conquest.users" */
  delete_conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** delete data from the table: "cycle" */
  delete_cycle?: Maybe<Cycle_Mutation_Response>;
  /** delete single row from the table: "cycle" */
  delete_cycle_by_pk?: Maybe<Cycle>;
  /** delete data from the table: "cycle_name" */
  delete_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** delete single row from the table: "cycle_name" */
  delete_cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** delete data from the table: "faction_name" */
  delete_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** delete single row from the table: "faction_name" */
  delete_faction_name_by_pk?: Maybe<Faction_Name>;
  /** delete data from the table: "faq" */
  delete_faq?: Maybe<Faq_Mutation_Response>;
  /** delete single row from the table: "faq" */
  delete_faq_by_pk?: Maybe<Faq>;
  /** delete data from the table: "faq_text" */
  delete_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** delete single row from the table: "faq_text" */
  delete_faq_text_by_pk?: Maybe<Faq_Text>;
  /** delete data from the table: "friend_status" */
  delete_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** delete single row from the table: "friend_status" */
  delete_friend_status_by_pk?: Maybe<Friend_Status>;
  /** delete data from the table: "friend_status_type" */
  delete_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** delete single row from the table: "friend_status_type" */
  delete_friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** delete data from the table: "full_card" */
  delete_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** delete single row from the table: "full_card" */
  delete_full_card_by_pk?: Maybe<Full_Card>;
  /** delete data from the table: "full_card_text" */
  delete_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** delete single row from the table: "full_card_text" */
  delete_full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** delete data from the table: "gender" */
  delete_gender?: Maybe<Gender_Mutation_Response>;
  /** delete single row from the table: "gender" */
  delete_gender_by_pk?: Maybe<Gender>;
  /** delete data from the table: "guide_achievement" */
  delete_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** delete single row from the table: "guide_achievement" */
  delete_guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** delete data from the table: "guide_input" */
  delete_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** delete single row from the table: "guide_input" */
  delete_guide_input_by_pk?: Maybe<Guide_Input>;
  /** delete data from the table: "investigator_data" */
  delete_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** delete single row from the table: "investigator_data" */
  delete_investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** delete data from the table: "latest_decks" */
  delete_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** delete data from the table: "local_decks" */
  delete_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** delete data from the table: "pack" */
  delete_pack?: Maybe<Pack_Mutation_Response>;
  /** delete single row from the table: "pack" */
  delete_pack_by_pk?: Maybe<Pack>;
  /** delete data from the table: "pack_name" */
  delete_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** delete single row from the table: "pack_name" */
  delete_pack_name_by_pk?: Maybe<Pack_Name>;
  /** delete data from the table: "rangers.area" */
  delete_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** delete single row from the table: "rangers.area" */
  delete_rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** delete data from the table: "rangers.area_text" */
  delete_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.area_text" */
  delete_rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** delete data from the table: "rangers.aspect" */
  delete_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** delete single row from the table: "rangers.aspect" */
  delete_rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** delete data from the table: "rangers.aspect_text" */
  delete_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.aspect_text" */
  delete_rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** delete data from the table: "rangers.campaign" */
  delete_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** delete data from the table: "rangers.campaign_access" */
  delete_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** delete single row from the table: "rangers.campaign_access" */
  delete_rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** delete single row from the table: "rangers.campaign" */
  delete_rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** delete data from the table: "rangers.card" */
  delete_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** delete single row from the table: "rangers.card" */
  delete_rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** delete data from the table: "rangers.card_text" */
  delete_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.card_text" */
  delete_rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** delete data from the table: "rangers.comment" */
  delete_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** delete single row from the table: "rangers.comment" */
  delete_rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** delete data from the table: "rangers.deck" */
  delete_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** delete single row from the table: "rangers.deck" */
  delete_rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** delete data from the table: "rangers.deck_copy" */
  delete_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_copy" */
  delete_rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** delete data from the table: "rangers.deck_like" */
  delete_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_like" */
  delete_rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** delete data from the table: "rangers.deck_like_count" */
  delete_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** delete single row from the table: "rangers.deck_like_count" */
  delete_rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** delete data from the table: "rangers.faq_entry" */
  delete_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** delete single row from the table: "rangers.faq_entry" */
  delete_rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** delete data from the table: "rangers.friend_status" */
  delete_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** delete single row from the table: "rangers.friend_status" */
  delete_rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** delete data from the table: "rangers.friend_status_type" */
  delete_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.friend_status_type" */
  delete_rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** delete data from the table: "rangers.latest_deck" */
  delete_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** delete data from the table: "rangers.locale" */
  delete_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** delete single row from the table: "rangers.locale" */
  delete_rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** delete data from the table: "rangers.pack" */
  delete_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** delete single row from the table: "rangers.pack" */
  delete_rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** delete data from the table: "rangers.pack_text" */
  delete_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.pack_text" */
  delete_rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** delete data from the table: "rangers.search_deck" */
  delete_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** delete data from the table: "rangers.set" */
  delete_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** delete single row from the table: "rangers.set" */
  delete_rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** delete data from the table: "rangers.set_text" */
  delete_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.set_text" */
  delete_rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** delete data from the table: "rangers.set_type" */
  delete_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.set_type" */
  delete_rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** delete data from the table: "rangers.set_type_text" */
  delete_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.set_type_text" */
  delete_rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** delete data from the table: "rangers.token" */
  delete_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** delete single row from the table: "rangers.token" */
  delete_rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** delete data from the table: "rangers.token_text" */
  delete_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.token_text" */
  delete_rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** delete data from the table: "rangers.type" */
  delete_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** delete single row from the table: "rangers.type" */
  delete_rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** delete data from the table: "rangers.type_text" */
  delete_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** delete single row from the table: "rangers.type_text" */
  delete_rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** delete data from the table: "rangers.user_friends" */
  delete_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** delete data from the table: "rangers.user_received_friend_requests" */
  delete_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "rangers.user_role" */
  delete_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** delete single row from the table: "rangers.user_role" */
  delete_rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** delete data from the table: "rangers.user_sent_friend_requests" */
  delete_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "rangers.user_settings" */
  delete_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** delete single row from the table: "rangers.user_settings" */
  delete_rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** delete data from the table: "rangers.users" */
  delete_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** delete single row from the table: "rangers.users" */
  delete_rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** delete data from the table: "taboo_set" */
  delete_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** delete single row from the table: "taboo_set" */
  delete_taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** delete data from the table: "user_campaigns" */
  delete_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** delete data from the table: "user_flag" */
  delete_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** delete single row from the table: "user_flag" */
  delete_user_flag_by_pk?: Maybe<User_Flag>;
  /** delete data from the table: "user_flag_type" */
  delete_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** delete single row from the table: "user_flag_type" */
  delete_user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** delete data from the table: "user_friends" */
  delete_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** delete data from the table: "user_received_friend_requests" */
  delete_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "user_sent_friend_requests" */
  delete_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** delete data from the table: "user_settings" */
  delete_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** delete single row from the table: "user_settings" */
  delete_user_settings_by_pk?: Maybe<User_Settings>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  editCampaignAccess?: Maybe<EditCampaignAccessOutput>;
  /** insert data into the table: "all_card" */
  insert_all_card?: Maybe<All_Card_Mutation_Response>;
  /** insert a single row into the table: "all_card" */
  insert_all_card_one?: Maybe<All_Card>;
  /** insert data into the table: "all_card_text" */
  insert_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "all_card_text" */
  insert_all_card_text_one?: Maybe<All_Card_Text>;
  /** insert data into the table: "all_card_updated" */
  insert_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** insert data into the table: "all_card_updated_by_version" */
  insert_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** insert a single row into the table: "all_card_updated_by_version" */
  insert_all_card_updated_by_version_one?: Maybe<All_Card_Updated_By_Version>;
  /** insert a single row into the table: "all_card_updated" */
  insert_all_card_updated_one?: Maybe<All_Card_Updated>;
  /** insert data into the table: "arkhamdb_auth" */
  insert_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** insert a single row into the table: "arkhamdb_auth" */
  insert_arkhamdb_auth_one?: Maybe<Arkhamdb_Auth>;
  /** insert data into the table: "arkhamdb_deck" */
  insert_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** insert a single row into the table: "arkhamdb_deck" */
  insert_arkhamdb_deck_one?: Maybe<Arkhamdb_Deck>;
  /** insert data into the table: "base_decks" */
  insert_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** insert a single row into the table: "base_decks" */
  insert_base_decks_one?: Maybe<Base_Decks>;
  /** insert data into the table: "campaign" */
  insert_campaign?: Maybe<Campaign_Mutation_Response>;
  /** insert data into the table: "campaign_access" */
  insert_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** insert a single row into the table: "campaign_access" */
  insert_campaign_access_one?: Maybe<Campaign_Access>;
  /** insert data into the table: "campaign_deck" */
  insert_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** insert a single row into the table: "campaign_deck" */
  insert_campaign_deck_one?: Maybe<Campaign_Deck>;
  /** insert data into the table: "campaign_difficulty" */
  insert_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** insert a single row into the table: "campaign_difficulty" */
  insert_campaign_difficulty_one?: Maybe<Campaign_Difficulty>;
  /** insert data into the table: "campaign_guide" */
  insert_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** insert a single row into the table: "campaign_guide" */
  insert_campaign_guide_one?: Maybe<Campaign_Guide>;
  /** insert data into the table: "campaign_investigator" */
  insert_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** insert a single row into the table: "campaign_investigator" */
  insert_campaign_investigator_one?: Maybe<Campaign_Investigator>;
  /** insert a single row into the table: "campaign" */
  insert_campaign_one?: Maybe<Campaign>;
  /** insert data into the table: "card" */
  insert_card?: Maybe<Card_Mutation_Response>;
  /** insert data into the table: "card_cycle" */
  insert_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** insert a single row into the table: "card_cycle" */
  insert_card_cycle_one?: Maybe<Card_Cycle>;
  /** insert data into the table: "card_encounter_set" */
  insert_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** insert a single row into the table: "card_encounter_set" */
  insert_card_encounter_set_one?: Maybe<Card_Encounter_Set>;
  /** insert a single row into the table: "card" */
  insert_card_one?: Maybe<Card>;
  /** insert data into the table: "card_pack" */
  insert_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** insert a single row into the table: "card_pack" */
  insert_card_pack_one?: Maybe<Card_Pack>;
  /** insert data into the table: "card_subtype_name" */
  insert_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** insert a single row into the table: "card_subtype_name" */
  insert_card_subtype_name_one?: Maybe<Card_Subtype_Name>;
  /** insert data into the table: "card_text" */
  insert_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** insert a single row into the table: "card_text" */
  insert_card_text_one?: Maybe<Card_Text>;
  /** insert data into the table: "card_type_code" */
  insert_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** insert a single row into the table: "card_type_code" */
  insert_card_type_code_one?: Maybe<Card_Type_Code>;
  /** insert data into the table: "card_type_name" */
  insert_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** insert a single row into the table: "card_type_name" */
  insert_card_type_name_one?: Maybe<Card_Type_Name>;
  /** insert data into the table: "chaos_bag_result" */
  insert_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** insert a single row into the table: "chaos_bag_result" */
  insert_chaos_bag_result_one?: Maybe<Chaos_Bag_Result>;
  /** insert data into the table: "chaos_bag_tarot_mode" */
  insert_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** insert a single row into the table: "chaos_bag_tarot_mode" */
  insert_chaos_bag_tarot_mode_one?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** insert data into the table: "conquest.card" */
  insert_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** insert a single row into the table: "conquest.card" */
  insert_conquest_card_one?: Maybe<Conquest_Card>;
  /** insert data into the table: "conquest.card_text" */
  insert_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.card_text" */
  insert_conquest_card_text_one?: Maybe<Conquest_Card_Text>;
  /** insert data into the table: "conquest.comment" */
  insert_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** insert a single row into the table: "conquest.comment" */
  insert_conquest_comment_one?: Maybe<Conquest_Comment>;
  /** insert data into the table: "conquest.cycle" */
  insert_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** insert a single row into the table: "conquest.cycle" */
  insert_conquest_cycle_one?: Maybe<Conquest_Cycle>;
  /** insert data into the table: "conquest.cycle_text" */
  insert_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.cycle_text" */
  insert_conquest_cycle_text_one?: Maybe<Conquest_Cycle_Text>;
  /** insert data into the table: "conquest.deck" */
  insert_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** insert data into the table: "conquest.deck_copy" */
  insert_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** insert a single row into the table: "conquest.deck_copy" */
  insert_conquest_deck_copy_one?: Maybe<Conquest_Deck_Copy>;
  /** insert data into the table: "conquest.deck_like" */
  insert_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** insert a single row into the table: "conquest.deck_like" */
  insert_conquest_deck_like_one?: Maybe<Conquest_Deck_Like>;
  /** insert a single row into the table: "conquest.deck" */
  insert_conquest_deck_one?: Maybe<Conquest_Deck>;
  /** insert data into the table: "conquest.faction" */
  insert_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** insert a single row into the table: "conquest.faction" */
  insert_conquest_faction_one?: Maybe<Conquest_Faction>;
  /** insert data into the table: "conquest.faction_text" */
  insert_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.faction_text" */
  insert_conquest_faction_text_one?: Maybe<Conquest_Faction_Text>;
  /** insert data into the table: "conquest.loyalty" */
  insert_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** insert a single row into the table: "conquest.loyalty" */
  insert_conquest_loyalty_one?: Maybe<Conquest_Loyalty>;
  /** insert data into the table: "conquest.loyalty_text" */
  insert_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.loyalty_text" */
  insert_conquest_loyalty_text_one?: Maybe<Conquest_Loyalty_Text>;
  /** insert data into the table: "conquest.pack" */
  insert_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** insert a single row into the table: "conquest.pack" */
  insert_conquest_pack_one?: Maybe<Conquest_Pack>;
  /** insert data into the table: "conquest.pack_text" */
  insert_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.pack_text" */
  insert_conquest_pack_text_one?: Maybe<Conquest_Pack_Text>;
  /** insert data into the table: "conquest.type" */
  insert_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** insert a single row into the table: "conquest.type" */
  insert_conquest_type_one?: Maybe<Conquest_Type>;
  /** insert data into the table: "conquest.type_text" */
  insert_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "conquest.type_text" */
  insert_conquest_type_text_one?: Maybe<Conquest_Type_Text>;
  /** insert data into the table: "conquest.user_role" */
  insert_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** insert a single row into the table: "conquest.user_role" */
  insert_conquest_user_role_one?: Maybe<Conquest_User_Role>;
  /** insert data into the table: "conquest.user_settings" */
  insert_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** insert a single row into the table: "conquest.user_settings" */
  insert_conquest_user_settings_one?: Maybe<Conquest_User_Settings>;
  /** insert data into the table: "conquest.users" */
  insert_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** insert a single row into the table: "conquest.users" */
  insert_conquest_users_one?: Maybe<Conquest_Users>;
  /** insert data into the table: "cycle" */
  insert_cycle?: Maybe<Cycle_Mutation_Response>;
  /** insert data into the table: "cycle_name" */
  insert_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** insert a single row into the table: "cycle_name" */
  insert_cycle_name_one?: Maybe<Cycle_Name>;
  /** insert a single row into the table: "cycle" */
  insert_cycle_one?: Maybe<Cycle>;
  /** insert data into the table: "faction_name" */
  insert_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** insert a single row into the table: "faction_name" */
  insert_faction_name_one?: Maybe<Faction_Name>;
  /** insert data into the table: "faq" */
  insert_faq?: Maybe<Faq_Mutation_Response>;
  /** insert a single row into the table: "faq" */
  insert_faq_one?: Maybe<Faq>;
  /** insert data into the table: "faq_text" */
  insert_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** insert a single row into the table: "faq_text" */
  insert_faq_text_one?: Maybe<Faq_Text>;
  /** insert data into the table: "friend_status" */
  insert_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** insert a single row into the table: "friend_status" */
  insert_friend_status_one?: Maybe<Friend_Status>;
  /** insert data into the table: "friend_status_type" */
  insert_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** insert a single row into the table: "friend_status_type" */
  insert_friend_status_type_one?: Maybe<Friend_Status_Type>;
  /** insert data into the table: "full_card" */
  insert_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** insert a single row into the table: "full_card" */
  insert_full_card_one?: Maybe<Full_Card>;
  /** insert data into the table: "full_card_text" */
  insert_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "full_card_text" */
  insert_full_card_text_one?: Maybe<Full_Card_Text>;
  /** insert data into the table: "gender" */
  insert_gender?: Maybe<Gender_Mutation_Response>;
  /** insert a single row into the table: "gender" */
  insert_gender_one?: Maybe<Gender>;
  /** insert data into the table: "guide_achievement" */
  insert_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** insert a single row into the table: "guide_achievement" */
  insert_guide_achievement_one?: Maybe<Guide_Achievement>;
  /** insert data into the table: "guide_input" */
  insert_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** insert a single row into the table: "guide_input" */
  insert_guide_input_one?: Maybe<Guide_Input>;
  /** insert data into the table: "investigator_data" */
  insert_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** insert a single row into the table: "investigator_data" */
  insert_investigator_data_one?: Maybe<Investigator_Data>;
  /** insert data into the table: "latest_decks" */
  insert_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** insert a single row into the table: "latest_decks" */
  insert_latest_decks_one?: Maybe<Latest_Decks>;
  /** insert data into the table: "local_decks" */
  insert_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** insert a single row into the table: "local_decks" */
  insert_local_decks_one?: Maybe<Local_Decks>;
  /** insert data into the table: "pack" */
  insert_pack?: Maybe<Pack_Mutation_Response>;
  /** insert data into the table: "pack_name" */
  insert_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** insert a single row into the table: "pack_name" */
  insert_pack_name_one?: Maybe<Pack_Name>;
  /** insert a single row into the table: "pack" */
  insert_pack_one?: Maybe<Pack>;
  /** insert data into the table: "rangers.area" */
  insert_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** insert a single row into the table: "rangers.area" */
  insert_rangers_area_one?: Maybe<Rangers_Area>;
  /** insert data into the table: "rangers.area_text" */
  insert_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.area_text" */
  insert_rangers_area_text_one?: Maybe<Rangers_Area_Text>;
  /** insert data into the table: "rangers.aspect" */
  insert_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** insert a single row into the table: "rangers.aspect" */
  insert_rangers_aspect_one?: Maybe<Rangers_Aspect>;
  /** insert data into the table: "rangers.aspect_text" */
  insert_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.aspect_text" */
  insert_rangers_aspect_text_one?: Maybe<Rangers_Aspect_Text>;
  /** insert data into the table: "rangers.campaign" */
  insert_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** insert data into the table: "rangers.campaign_access" */
  insert_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** insert a single row into the table: "rangers.campaign_access" */
  insert_rangers_campaign_access_one?: Maybe<Rangers_Campaign_Access>;
  /** insert a single row into the table: "rangers.campaign" */
  insert_rangers_campaign_one?: Maybe<Rangers_Campaign>;
  /** insert data into the table: "rangers.card" */
  insert_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** insert a single row into the table: "rangers.card" */
  insert_rangers_card_one?: Maybe<Rangers_Card>;
  /** insert data into the table: "rangers.card_text" */
  insert_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.card_text" */
  insert_rangers_card_text_one?: Maybe<Rangers_Card_Text>;
  /** insert data into the table: "rangers.comment" */
  insert_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** insert a single row into the table: "rangers.comment" */
  insert_rangers_comment_one?: Maybe<Rangers_Comment>;
  /** insert data into the table: "rangers.deck" */
  insert_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** insert data into the table: "rangers.deck_copy" */
  insert_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** insert a single row into the table: "rangers.deck_copy" */
  insert_rangers_deck_copy_one?: Maybe<Rangers_Deck_Copy>;
  /** insert data into the table: "rangers.deck_like" */
  insert_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** insert data into the table: "rangers.deck_like_count" */
  insert_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** insert a single row into the table: "rangers.deck_like_count" */
  insert_rangers_deck_like_count_one?: Maybe<Rangers_Deck_Like_Count>;
  /** insert a single row into the table: "rangers.deck_like" */
  insert_rangers_deck_like_one?: Maybe<Rangers_Deck_Like>;
  /** insert a single row into the table: "rangers.deck" */
  insert_rangers_deck_one?: Maybe<Rangers_Deck>;
  /** insert data into the table: "rangers.faq_entry" */
  insert_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** insert a single row into the table: "rangers.faq_entry" */
  insert_rangers_faq_entry_one?: Maybe<Rangers_Faq_Entry>;
  /** insert data into the table: "rangers.friend_status" */
  insert_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** insert a single row into the table: "rangers.friend_status" */
  insert_rangers_friend_status_one?: Maybe<Rangers_Friend_Status>;
  /** insert data into the table: "rangers.friend_status_type" */
  insert_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.friend_status_type" */
  insert_rangers_friend_status_type_one?: Maybe<Rangers_Friend_Status_Type>;
  /** insert data into the table: "rangers.latest_deck" */
  insert_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** insert a single row into the table: "rangers.latest_deck" */
  insert_rangers_latest_deck_one?: Maybe<Rangers_Latest_Deck>;
  /** insert data into the table: "rangers.locale" */
  insert_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** insert a single row into the table: "rangers.locale" */
  insert_rangers_locale_one?: Maybe<Rangers_Locale>;
  /** insert data into the table: "rangers.pack" */
  insert_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** insert a single row into the table: "rangers.pack" */
  insert_rangers_pack_one?: Maybe<Rangers_Pack>;
  /** insert data into the table: "rangers.pack_text" */
  insert_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.pack_text" */
  insert_rangers_pack_text_one?: Maybe<Rangers_Pack_Text>;
  /** insert data into the table: "rangers.search_deck" */
  insert_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** insert a single row into the table: "rangers.search_deck" */
  insert_rangers_search_deck_one?: Maybe<Rangers_Search_Deck>;
  /** insert data into the table: "rangers.set" */
  insert_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** insert a single row into the table: "rangers.set" */
  insert_rangers_set_one?: Maybe<Rangers_Set>;
  /** insert data into the table: "rangers.set_text" */
  insert_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_text" */
  insert_rangers_set_text_one?: Maybe<Rangers_Set_Text>;
  /** insert data into the table: "rangers.set_type" */
  insert_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_type" */
  insert_rangers_set_type_one?: Maybe<Rangers_Set_Type>;
  /** insert data into the table: "rangers.set_type_text" */
  insert_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.set_type_text" */
  insert_rangers_set_type_text_one?: Maybe<Rangers_Set_Type_Text>;
  /** insert data into the table: "rangers.token" */
  insert_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** insert a single row into the table: "rangers.token" */
  insert_rangers_token_one?: Maybe<Rangers_Token>;
  /** insert data into the table: "rangers.token_text" */
  insert_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.token_text" */
  insert_rangers_token_text_one?: Maybe<Rangers_Token_Text>;
  /** insert data into the table: "rangers.type" */
  insert_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** insert a single row into the table: "rangers.type" */
  insert_rangers_type_one?: Maybe<Rangers_Type>;
  /** insert data into the table: "rangers.type_text" */
  insert_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** insert a single row into the table: "rangers.type_text" */
  insert_rangers_type_text_one?: Maybe<Rangers_Type_Text>;
  /** insert data into the table: "rangers.user_friends" */
  insert_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_friends" */
  insert_rangers_user_friends_one?: Maybe<Rangers_User_Friends>;
  /** insert data into the table: "rangers.user_received_friend_requests" */
  insert_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_received_friend_requests" */
  insert_rangers_user_received_friend_requests_one?: Maybe<Rangers_User_Received_Friend_Requests>;
  /** insert data into the table: "rangers.user_role" */
  insert_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_role" */
  insert_rangers_user_role_one?: Maybe<Rangers_User_Role>;
  /** insert data into the table: "rangers.user_sent_friend_requests" */
  insert_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_sent_friend_requests" */
  insert_rangers_user_sent_friend_requests_one?: Maybe<Rangers_User_Sent_Friend_Requests>;
  /** insert data into the table: "rangers.user_settings" */
  insert_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** insert a single row into the table: "rangers.user_settings" */
  insert_rangers_user_settings_one?: Maybe<Rangers_User_Settings>;
  /** insert data into the table: "rangers.users" */
  insert_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** insert a single row into the table: "rangers.users" */
  insert_rangers_users_one?: Maybe<Rangers_Users>;
  /** insert data into the table: "taboo_set" */
  insert_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** insert a single row into the table: "taboo_set" */
  insert_taboo_set_one?: Maybe<Taboo_Set>;
  /** insert data into the table: "user_campaigns" */
  insert_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** insert a single row into the table: "user_campaigns" */
  insert_user_campaigns_one?: Maybe<User_Campaigns>;
  /** insert data into the table: "user_flag" */
  insert_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** insert a single row into the table: "user_flag" */
  insert_user_flag_one?: Maybe<User_Flag>;
  /** insert data into the table: "user_flag_type" */
  insert_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** insert a single row into the table: "user_flag_type" */
  insert_user_flag_type_one?: Maybe<User_Flag_Type>;
  /** insert data into the table: "user_friends" */
  insert_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** insert a single row into the table: "user_friends" */
  insert_user_friends_one?: Maybe<User_Friends>;
  /** insert data into the table: "user_received_friend_requests" */
  insert_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "user_received_friend_requests" */
  insert_user_received_friend_requests_one?: Maybe<User_Received_Friend_Requests>;
  /** insert data into the table: "user_sent_friend_requests" */
  insert_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** insert a single row into the table: "user_sent_friend_requests" */
  insert_user_sent_friend_requests_one?: Maybe<User_Sent_Friend_Requests>;
  /** insert data into the table: "user_settings" */
  insert_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** insert a single row into the table: "user_settings" */
  insert_user_settings_one?: Maybe<User_Settings>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  loginToArkhamDb?: Maybe<LoginOutput>;
  logoutFromArkhamDb?: Maybe<LogoutOutput>;
  migrateLoginToArkhamDb?: Maybe<MigrateLoginOutput>;
  /** execute VOLATILE function "rangers.publish_deck" which returns "rangers.deck" */
  rangers_publish_deck?: Maybe<Rangers_Deck>;
  /** execute VOLATILE function "rangers.remove_campaign_deck" which returns "rangers.campaign" */
  rangers_remove_campaign_deck: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.set_campaign_deck" which returns "rangers.campaign" */
  rangers_set_campaign_deck: Array<Rangers_Campaign>;
  /** execute VOLATILE function "rangers.upgrade_deck" which returns "rangers.deck" */
  rangers_upgrade_deck?: Maybe<Rangers_Deck>;
  refreshArkhamDbDecks?: Maybe<RefreshDecksOutput>;
  updateFriendRequest?: Maybe<FriendRequestOutput>;
  updateHandle?: Maybe<UpdateHandleOutput>;
  /** update data of the table: "all_card" */
  update_all_card?: Maybe<All_Card_Mutation_Response>;
  /** update single row of the table: "all_card" */
  update_all_card_by_pk?: Maybe<All_Card>;
  /** update multiples rows of table: "all_card" */
  update_all_card_many?: Maybe<Array<Maybe<All_Card_Mutation_Response>>>;
  /** update data of the table: "all_card_text" */
  update_all_card_text?: Maybe<All_Card_Text_Mutation_Response>;
  /** update single row of the table: "all_card_text" */
  update_all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** update multiples rows of table: "all_card_text" */
  update_all_card_text_many?: Maybe<Array<Maybe<All_Card_Text_Mutation_Response>>>;
  /** update data of the table: "all_card_updated" */
  update_all_card_updated?: Maybe<All_Card_Updated_Mutation_Response>;
  /** update single row of the table: "all_card_updated" */
  update_all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** update data of the table: "all_card_updated_by_version" */
  update_all_card_updated_by_version?: Maybe<All_Card_Updated_By_Version_Mutation_Response>;
  /** update single row of the table: "all_card_updated_by_version" */
  update_all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** update multiples rows of table: "all_card_updated_by_version" */
  update_all_card_updated_by_version_many?: Maybe<Array<Maybe<All_Card_Updated_By_Version_Mutation_Response>>>;
  /** update multiples rows of table: "all_card_updated" */
  update_all_card_updated_many?: Maybe<Array<Maybe<All_Card_Updated_Mutation_Response>>>;
  /** update data of the table: "arkhamdb_auth" */
  update_arkhamdb_auth?: Maybe<Arkhamdb_Auth_Mutation_Response>;
  /** update single row of the table: "arkhamdb_auth" */
  update_arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** update multiples rows of table: "arkhamdb_auth" */
  update_arkhamdb_auth_many?: Maybe<Array<Maybe<Arkhamdb_Auth_Mutation_Response>>>;
  /** update data of the table: "arkhamdb_deck" */
  update_arkhamdb_deck?: Maybe<Arkhamdb_Deck_Mutation_Response>;
  /** update single row of the table: "arkhamdb_deck" */
  update_arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** update multiples rows of table: "arkhamdb_deck" */
  update_arkhamdb_deck_many?: Maybe<Array<Maybe<Arkhamdb_Deck_Mutation_Response>>>;
  /** update data of the table: "base_decks" */
  update_base_decks?: Maybe<Base_Decks_Mutation_Response>;
  /** update multiples rows of table: "base_decks" */
  update_base_decks_many?: Maybe<Array<Maybe<Base_Decks_Mutation_Response>>>;
  /** update data of the table: "campaign" */
  update_campaign?: Maybe<Campaign_Mutation_Response>;
  /** update data of the table: "campaign_access" */
  update_campaign_access?: Maybe<Campaign_Access_Mutation_Response>;
  /** update single row of the table: "campaign_access" */
  update_campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** update multiples rows of table: "campaign_access" */
  update_campaign_access_many?: Maybe<Array<Maybe<Campaign_Access_Mutation_Response>>>;
  /** update single row of the table: "campaign" */
  update_campaign_by_pk?: Maybe<Campaign>;
  /** update data of the table: "campaign_deck" */
  update_campaign_deck?: Maybe<Campaign_Deck_Mutation_Response>;
  /** update single row of the table: "campaign_deck" */
  update_campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** update multiples rows of table: "campaign_deck" */
  update_campaign_deck_many?: Maybe<Array<Maybe<Campaign_Deck_Mutation_Response>>>;
  /** update data of the table: "campaign_difficulty" */
  update_campaign_difficulty?: Maybe<Campaign_Difficulty_Mutation_Response>;
  /** update single row of the table: "campaign_difficulty" */
  update_campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** update multiples rows of table: "campaign_difficulty" */
  update_campaign_difficulty_many?: Maybe<Array<Maybe<Campaign_Difficulty_Mutation_Response>>>;
  /** update data of the table: "campaign_guide" */
  update_campaign_guide?: Maybe<Campaign_Guide_Mutation_Response>;
  /** update multiples rows of table: "campaign_guide" */
  update_campaign_guide_many?: Maybe<Array<Maybe<Campaign_Guide_Mutation_Response>>>;
  /** update data of the table: "campaign_investigator" */
  update_campaign_investigator?: Maybe<Campaign_Investigator_Mutation_Response>;
  /** update single row of the table: "campaign_investigator" */
  update_campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** update multiples rows of table: "campaign_investigator" */
  update_campaign_investigator_many?: Maybe<Array<Maybe<Campaign_Investigator_Mutation_Response>>>;
  /** update multiples rows of table: "campaign" */
  update_campaign_many?: Maybe<Array<Maybe<Campaign_Mutation_Response>>>;
  /** update data of the table: "card" */
  update_card?: Maybe<Card_Mutation_Response>;
  /** update single row of the table: "card" */
  update_card_by_pk?: Maybe<Card>;
  /** update data of the table: "card_cycle" */
  update_card_cycle?: Maybe<Card_Cycle_Mutation_Response>;
  /** update single row of the table: "card_cycle" */
  update_card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** update multiples rows of table: "card_cycle" */
  update_card_cycle_many?: Maybe<Array<Maybe<Card_Cycle_Mutation_Response>>>;
  /** update data of the table: "card_encounter_set" */
  update_card_encounter_set?: Maybe<Card_Encounter_Set_Mutation_Response>;
  /** update single row of the table: "card_encounter_set" */
  update_card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** update multiples rows of table: "card_encounter_set" */
  update_card_encounter_set_many?: Maybe<Array<Maybe<Card_Encounter_Set_Mutation_Response>>>;
  /** update multiples rows of table: "card" */
  update_card_many?: Maybe<Array<Maybe<Card_Mutation_Response>>>;
  /** update data of the table: "card_pack" */
  update_card_pack?: Maybe<Card_Pack_Mutation_Response>;
  /** update single row of the table: "card_pack" */
  update_card_pack_by_pk?: Maybe<Card_Pack>;
  /** update multiples rows of table: "card_pack" */
  update_card_pack_many?: Maybe<Array<Maybe<Card_Pack_Mutation_Response>>>;
  /** update data of the table: "card_subtype_name" */
  update_card_subtype_name?: Maybe<Card_Subtype_Name_Mutation_Response>;
  /** update single row of the table: "card_subtype_name" */
  update_card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** update multiples rows of table: "card_subtype_name" */
  update_card_subtype_name_many?: Maybe<Array<Maybe<Card_Subtype_Name_Mutation_Response>>>;
  /** update data of the table: "card_text" */
  update_card_text?: Maybe<Card_Text_Mutation_Response>;
  /** update single row of the table: "card_text" */
  update_card_text_by_pk?: Maybe<Card_Text>;
  /** update multiples rows of table: "card_text" */
  update_card_text_many?: Maybe<Array<Maybe<Card_Text_Mutation_Response>>>;
  /** update data of the table: "card_type_code" */
  update_card_type_code?: Maybe<Card_Type_Code_Mutation_Response>;
  /** update single row of the table: "card_type_code" */
  update_card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** update multiples rows of table: "card_type_code" */
  update_card_type_code_many?: Maybe<Array<Maybe<Card_Type_Code_Mutation_Response>>>;
  /** update data of the table: "card_type_name" */
  update_card_type_name?: Maybe<Card_Type_Name_Mutation_Response>;
  /** update single row of the table: "card_type_name" */
  update_card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** update multiples rows of table: "card_type_name" */
  update_card_type_name_many?: Maybe<Array<Maybe<Card_Type_Name_Mutation_Response>>>;
  /** update data of the table: "chaos_bag_result" */
  update_chaos_bag_result?: Maybe<Chaos_Bag_Result_Mutation_Response>;
  /** update single row of the table: "chaos_bag_result" */
  update_chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** update multiples rows of table: "chaos_bag_result" */
  update_chaos_bag_result_many?: Maybe<Array<Maybe<Chaos_Bag_Result_Mutation_Response>>>;
  /** update data of the table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode?: Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>;
  /** update single row of the table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** update multiples rows of table: "chaos_bag_tarot_mode" */
  update_chaos_bag_tarot_mode_many?: Maybe<Array<Maybe<Chaos_Bag_Tarot_Mode_Mutation_Response>>>;
  /** update data of the table: "conquest.card" */
  update_conquest_card?: Maybe<Conquest_Card_Mutation_Response>;
  /** update single row of the table: "conquest.card" */
  update_conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** update multiples rows of table: "conquest.card" */
  update_conquest_card_many?: Maybe<Array<Maybe<Conquest_Card_Mutation_Response>>>;
  /** update data of the table: "conquest.card_text" */
  update_conquest_card_text?: Maybe<Conquest_Card_Text_Mutation_Response>;
  /** update single row of the table: "conquest.card_text" */
  update_conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** update multiples rows of table: "conquest.card_text" */
  update_conquest_card_text_many?: Maybe<Array<Maybe<Conquest_Card_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.comment" */
  update_conquest_comment?: Maybe<Conquest_Comment_Mutation_Response>;
  /** update single row of the table: "conquest.comment" */
  update_conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** update multiples rows of table: "conquest.comment" */
  update_conquest_comment_many?: Maybe<Array<Maybe<Conquest_Comment_Mutation_Response>>>;
  /** update data of the table: "conquest.cycle" */
  update_conquest_cycle?: Maybe<Conquest_Cycle_Mutation_Response>;
  /** update single row of the table: "conquest.cycle" */
  update_conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** update multiples rows of table: "conquest.cycle" */
  update_conquest_cycle_many?: Maybe<Array<Maybe<Conquest_Cycle_Mutation_Response>>>;
  /** update data of the table: "conquest.cycle_text" */
  update_conquest_cycle_text?: Maybe<Conquest_Cycle_Text_Mutation_Response>;
  /** update single row of the table: "conquest.cycle_text" */
  update_conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** update multiples rows of table: "conquest.cycle_text" */
  update_conquest_cycle_text_many?: Maybe<Array<Maybe<Conquest_Cycle_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.deck" */
  update_conquest_deck?: Maybe<Conquest_Deck_Mutation_Response>;
  /** update single row of the table: "conquest.deck" */
  update_conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** update data of the table: "conquest.deck_copy" */
  update_conquest_deck_copy?: Maybe<Conquest_Deck_Copy_Mutation_Response>;
  /** update single row of the table: "conquest.deck_copy" */
  update_conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** update multiples rows of table: "conquest.deck_copy" */
  update_conquest_deck_copy_many?: Maybe<Array<Maybe<Conquest_Deck_Copy_Mutation_Response>>>;
  /** update data of the table: "conquest.deck_like" */
  update_conquest_deck_like?: Maybe<Conquest_Deck_Like_Mutation_Response>;
  /** update single row of the table: "conquest.deck_like" */
  update_conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** update multiples rows of table: "conquest.deck_like" */
  update_conquest_deck_like_many?: Maybe<Array<Maybe<Conquest_Deck_Like_Mutation_Response>>>;
  /** update multiples rows of table: "conquest.deck" */
  update_conquest_deck_many?: Maybe<Array<Maybe<Conquest_Deck_Mutation_Response>>>;
  /** update data of the table: "conquest.faction" */
  update_conquest_faction?: Maybe<Conquest_Faction_Mutation_Response>;
  /** update single row of the table: "conquest.faction" */
  update_conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** update multiples rows of table: "conquest.faction" */
  update_conquest_faction_many?: Maybe<Array<Maybe<Conquest_Faction_Mutation_Response>>>;
  /** update data of the table: "conquest.faction_text" */
  update_conquest_faction_text?: Maybe<Conquest_Faction_Text_Mutation_Response>;
  /** update single row of the table: "conquest.faction_text" */
  update_conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** update multiples rows of table: "conquest.faction_text" */
  update_conquest_faction_text_many?: Maybe<Array<Maybe<Conquest_Faction_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.loyalty" */
  update_conquest_loyalty?: Maybe<Conquest_Loyalty_Mutation_Response>;
  /** update single row of the table: "conquest.loyalty" */
  update_conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** update multiples rows of table: "conquest.loyalty" */
  update_conquest_loyalty_many?: Maybe<Array<Maybe<Conquest_Loyalty_Mutation_Response>>>;
  /** update data of the table: "conquest.loyalty_text" */
  update_conquest_loyalty_text?: Maybe<Conquest_Loyalty_Text_Mutation_Response>;
  /** update single row of the table: "conquest.loyalty_text" */
  update_conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** update multiples rows of table: "conquest.loyalty_text" */
  update_conquest_loyalty_text_many?: Maybe<Array<Maybe<Conquest_Loyalty_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.pack" */
  update_conquest_pack?: Maybe<Conquest_Pack_Mutation_Response>;
  /** update single row of the table: "conquest.pack" */
  update_conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** update multiples rows of table: "conquest.pack" */
  update_conquest_pack_many?: Maybe<Array<Maybe<Conquest_Pack_Mutation_Response>>>;
  /** update data of the table: "conquest.pack_text" */
  update_conquest_pack_text?: Maybe<Conquest_Pack_Text_Mutation_Response>;
  /** update single row of the table: "conquest.pack_text" */
  update_conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** update multiples rows of table: "conquest.pack_text" */
  update_conquest_pack_text_many?: Maybe<Array<Maybe<Conquest_Pack_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.type" */
  update_conquest_type?: Maybe<Conquest_Type_Mutation_Response>;
  /** update single row of the table: "conquest.type" */
  update_conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** update multiples rows of table: "conquest.type" */
  update_conquest_type_many?: Maybe<Array<Maybe<Conquest_Type_Mutation_Response>>>;
  /** update data of the table: "conquest.type_text" */
  update_conquest_type_text?: Maybe<Conquest_Type_Text_Mutation_Response>;
  /** update single row of the table: "conquest.type_text" */
  update_conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** update multiples rows of table: "conquest.type_text" */
  update_conquest_type_text_many?: Maybe<Array<Maybe<Conquest_Type_Text_Mutation_Response>>>;
  /** update data of the table: "conquest.user_role" */
  update_conquest_user_role?: Maybe<Conquest_User_Role_Mutation_Response>;
  /** update single row of the table: "conquest.user_role" */
  update_conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** update multiples rows of table: "conquest.user_role" */
  update_conquest_user_role_many?: Maybe<Array<Maybe<Conquest_User_Role_Mutation_Response>>>;
  /** update data of the table: "conquest.user_settings" */
  update_conquest_user_settings?: Maybe<Conquest_User_Settings_Mutation_Response>;
  /** update single row of the table: "conquest.user_settings" */
  update_conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** update multiples rows of table: "conquest.user_settings" */
  update_conquest_user_settings_many?: Maybe<Array<Maybe<Conquest_User_Settings_Mutation_Response>>>;
  /** update data of the table: "conquest.users" */
  update_conquest_users?: Maybe<Conquest_Users_Mutation_Response>;
  /** update single row of the table: "conquest.users" */
  update_conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** update multiples rows of table: "conquest.users" */
  update_conquest_users_many?: Maybe<Array<Maybe<Conquest_Users_Mutation_Response>>>;
  /** update data of the table: "cycle" */
  update_cycle?: Maybe<Cycle_Mutation_Response>;
  /** update single row of the table: "cycle" */
  update_cycle_by_pk?: Maybe<Cycle>;
  /** update multiples rows of table: "cycle" */
  update_cycle_many?: Maybe<Array<Maybe<Cycle_Mutation_Response>>>;
  /** update data of the table: "cycle_name" */
  update_cycle_name?: Maybe<Cycle_Name_Mutation_Response>;
  /** update single row of the table: "cycle_name" */
  update_cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** update multiples rows of table: "cycle_name" */
  update_cycle_name_many?: Maybe<Array<Maybe<Cycle_Name_Mutation_Response>>>;
  /** update data of the table: "faction_name" */
  update_faction_name?: Maybe<Faction_Name_Mutation_Response>;
  /** update single row of the table: "faction_name" */
  update_faction_name_by_pk?: Maybe<Faction_Name>;
  /** update multiples rows of table: "faction_name" */
  update_faction_name_many?: Maybe<Array<Maybe<Faction_Name_Mutation_Response>>>;
  /** update data of the table: "faq" */
  update_faq?: Maybe<Faq_Mutation_Response>;
  /** update single row of the table: "faq" */
  update_faq_by_pk?: Maybe<Faq>;
  /** update multiples rows of table: "faq" */
  update_faq_many?: Maybe<Array<Maybe<Faq_Mutation_Response>>>;
  /** update data of the table: "faq_text" */
  update_faq_text?: Maybe<Faq_Text_Mutation_Response>;
  /** update single row of the table: "faq_text" */
  update_faq_text_by_pk?: Maybe<Faq_Text>;
  /** update multiples rows of table: "faq_text" */
  update_faq_text_many?: Maybe<Array<Maybe<Faq_Text_Mutation_Response>>>;
  /** update data of the table: "friend_status" */
  update_friend_status?: Maybe<Friend_Status_Mutation_Response>;
  /** update single row of the table: "friend_status" */
  update_friend_status_by_pk?: Maybe<Friend_Status>;
  /** update multiples rows of table: "friend_status" */
  update_friend_status_many?: Maybe<Array<Maybe<Friend_Status_Mutation_Response>>>;
  /** update data of the table: "friend_status_type" */
  update_friend_status_type?: Maybe<Friend_Status_Type_Mutation_Response>;
  /** update single row of the table: "friend_status_type" */
  update_friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** update multiples rows of table: "friend_status_type" */
  update_friend_status_type_many?: Maybe<Array<Maybe<Friend_Status_Type_Mutation_Response>>>;
  /** update data of the table: "full_card" */
  update_full_card?: Maybe<Full_Card_Mutation_Response>;
  /** update single row of the table: "full_card" */
  update_full_card_by_pk?: Maybe<Full_Card>;
  /** update multiples rows of table: "full_card" */
  update_full_card_many?: Maybe<Array<Maybe<Full_Card_Mutation_Response>>>;
  /** update data of the table: "full_card_text" */
  update_full_card_text?: Maybe<Full_Card_Text_Mutation_Response>;
  /** update single row of the table: "full_card_text" */
  update_full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** update multiples rows of table: "full_card_text" */
  update_full_card_text_many?: Maybe<Array<Maybe<Full_Card_Text_Mutation_Response>>>;
  /** update data of the table: "gender" */
  update_gender?: Maybe<Gender_Mutation_Response>;
  /** update single row of the table: "gender" */
  update_gender_by_pk?: Maybe<Gender>;
  /** update multiples rows of table: "gender" */
  update_gender_many?: Maybe<Array<Maybe<Gender_Mutation_Response>>>;
  /** update data of the table: "guide_achievement" */
  update_guide_achievement?: Maybe<Guide_Achievement_Mutation_Response>;
  /** update single row of the table: "guide_achievement" */
  update_guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** update multiples rows of table: "guide_achievement" */
  update_guide_achievement_many?: Maybe<Array<Maybe<Guide_Achievement_Mutation_Response>>>;
  /** update data of the table: "guide_input" */
  update_guide_input?: Maybe<Guide_Input_Mutation_Response>;
  /** update single row of the table: "guide_input" */
  update_guide_input_by_pk?: Maybe<Guide_Input>;
  /** update multiples rows of table: "guide_input" */
  update_guide_input_many?: Maybe<Array<Maybe<Guide_Input_Mutation_Response>>>;
  /** update data of the table: "investigator_data" */
  update_investigator_data?: Maybe<Investigator_Data_Mutation_Response>;
  /** update single row of the table: "investigator_data" */
  update_investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** update multiples rows of table: "investigator_data" */
  update_investigator_data_many?: Maybe<Array<Maybe<Investigator_Data_Mutation_Response>>>;
  /** update data of the table: "latest_decks" */
  update_latest_decks?: Maybe<Latest_Decks_Mutation_Response>;
  /** update multiples rows of table: "latest_decks" */
  update_latest_decks_many?: Maybe<Array<Maybe<Latest_Decks_Mutation_Response>>>;
  /** update data of the table: "local_decks" */
  update_local_decks?: Maybe<Local_Decks_Mutation_Response>;
  /** update multiples rows of table: "local_decks" */
  update_local_decks_many?: Maybe<Array<Maybe<Local_Decks_Mutation_Response>>>;
  /** update data of the table: "pack" */
  update_pack?: Maybe<Pack_Mutation_Response>;
  /** update single row of the table: "pack" */
  update_pack_by_pk?: Maybe<Pack>;
  /** update multiples rows of table: "pack" */
  update_pack_many?: Maybe<Array<Maybe<Pack_Mutation_Response>>>;
  /** update data of the table: "pack_name" */
  update_pack_name?: Maybe<Pack_Name_Mutation_Response>;
  /** update single row of the table: "pack_name" */
  update_pack_name_by_pk?: Maybe<Pack_Name>;
  /** update multiples rows of table: "pack_name" */
  update_pack_name_many?: Maybe<Array<Maybe<Pack_Name_Mutation_Response>>>;
  /** update data of the table: "rangers.area" */
  update_rangers_area?: Maybe<Rangers_Area_Mutation_Response>;
  /** update single row of the table: "rangers.area" */
  update_rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** update multiples rows of table: "rangers.area" */
  update_rangers_area_many?: Maybe<Array<Maybe<Rangers_Area_Mutation_Response>>>;
  /** update data of the table: "rangers.area_text" */
  update_rangers_area_text?: Maybe<Rangers_Area_Text_Mutation_Response>;
  /** update single row of the table: "rangers.area_text" */
  update_rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** update multiples rows of table: "rangers.area_text" */
  update_rangers_area_text_many?: Maybe<Array<Maybe<Rangers_Area_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.aspect" */
  update_rangers_aspect?: Maybe<Rangers_Aspect_Mutation_Response>;
  /** update single row of the table: "rangers.aspect" */
  update_rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** update multiples rows of table: "rangers.aspect" */
  update_rangers_aspect_many?: Maybe<Array<Maybe<Rangers_Aspect_Mutation_Response>>>;
  /** update data of the table: "rangers.aspect_text" */
  update_rangers_aspect_text?: Maybe<Rangers_Aspect_Text_Mutation_Response>;
  /** update single row of the table: "rangers.aspect_text" */
  update_rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** update multiples rows of table: "rangers.aspect_text" */
  update_rangers_aspect_text_many?: Maybe<Array<Maybe<Rangers_Aspect_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.campaign" */
  update_rangers_campaign?: Maybe<Rangers_Campaign_Mutation_Response>;
  /** update data of the table: "rangers.campaign_access" */
  update_rangers_campaign_access?: Maybe<Rangers_Campaign_Access_Mutation_Response>;
  /** update single row of the table: "rangers.campaign_access" */
  update_rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** update multiples rows of table: "rangers.campaign_access" */
  update_rangers_campaign_access_many?: Maybe<Array<Maybe<Rangers_Campaign_Access_Mutation_Response>>>;
  /** update single row of the table: "rangers.campaign" */
  update_rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** update multiples rows of table: "rangers.campaign" */
  update_rangers_campaign_many?: Maybe<Array<Maybe<Rangers_Campaign_Mutation_Response>>>;
  /** update data of the table: "rangers.card" */
  update_rangers_card?: Maybe<Rangers_Card_Mutation_Response>;
  /** update single row of the table: "rangers.card" */
  update_rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** update multiples rows of table: "rangers.card" */
  update_rangers_card_many?: Maybe<Array<Maybe<Rangers_Card_Mutation_Response>>>;
  /** update data of the table: "rangers.card_text" */
  update_rangers_card_text?: Maybe<Rangers_Card_Text_Mutation_Response>;
  /** update single row of the table: "rangers.card_text" */
  update_rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** update multiples rows of table: "rangers.card_text" */
  update_rangers_card_text_many?: Maybe<Array<Maybe<Rangers_Card_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.comment" */
  update_rangers_comment?: Maybe<Rangers_Comment_Mutation_Response>;
  /** update single row of the table: "rangers.comment" */
  update_rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** update multiples rows of table: "rangers.comment" */
  update_rangers_comment_many?: Maybe<Array<Maybe<Rangers_Comment_Mutation_Response>>>;
  /** update data of the table: "rangers.deck" */
  update_rangers_deck?: Maybe<Rangers_Deck_Mutation_Response>;
  /** update single row of the table: "rangers.deck" */
  update_rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** update data of the table: "rangers.deck_copy" */
  update_rangers_deck_copy?: Maybe<Rangers_Deck_Copy_Mutation_Response>;
  /** update single row of the table: "rangers.deck_copy" */
  update_rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** update multiples rows of table: "rangers.deck_copy" */
  update_rangers_deck_copy_many?: Maybe<Array<Maybe<Rangers_Deck_Copy_Mutation_Response>>>;
  /** update data of the table: "rangers.deck_like" */
  update_rangers_deck_like?: Maybe<Rangers_Deck_Like_Mutation_Response>;
  /** update single row of the table: "rangers.deck_like" */
  update_rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** update data of the table: "rangers.deck_like_count" */
  update_rangers_deck_like_count?: Maybe<Rangers_Deck_Like_Count_Mutation_Response>;
  /** update single row of the table: "rangers.deck_like_count" */
  update_rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** update multiples rows of table: "rangers.deck_like_count" */
  update_rangers_deck_like_count_many?: Maybe<Array<Maybe<Rangers_Deck_Like_Count_Mutation_Response>>>;
  /** update multiples rows of table: "rangers.deck_like" */
  update_rangers_deck_like_many?: Maybe<Array<Maybe<Rangers_Deck_Like_Mutation_Response>>>;
  /** update multiples rows of table: "rangers.deck" */
  update_rangers_deck_many?: Maybe<Array<Maybe<Rangers_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.faq_entry" */
  update_rangers_faq_entry?: Maybe<Rangers_Faq_Entry_Mutation_Response>;
  /** update single row of the table: "rangers.faq_entry" */
  update_rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** update multiples rows of table: "rangers.faq_entry" */
  update_rangers_faq_entry_many?: Maybe<Array<Maybe<Rangers_Faq_Entry_Mutation_Response>>>;
  /** update data of the table: "rangers.friend_status" */
  update_rangers_friend_status?: Maybe<Rangers_Friend_Status_Mutation_Response>;
  /** update single row of the table: "rangers.friend_status" */
  update_rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** update multiples rows of table: "rangers.friend_status" */
  update_rangers_friend_status_many?: Maybe<Array<Maybe<Rangers_Friend_Status_Mutation_Response>>>;
  /** update data of the table: "rangers.friend_status_type" */
  update_rangers_friend_status_type?: Maybe<Rangers_Friend_Status_Type_Mutation_Response>;
  /** update single row of the table: "rangers.friend_status_type" */
  update_rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** update multiples rows of table: "rangers.friend_status_type" */
  update_rangers_friend_status_type_many?: Maybe<Array<Maybe<Rangers_Friend_Status_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.latest_deck" */
  update_rangers_latest_deck?: Maybe<Rangers_Latest_Deck_Mutation_Response>;
  /** update multiples rows of table: "rangers.latest_deck" */
  update_rangers_latest_deck_many?: Maybe<Array<Maybe<Rangers_Latest_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.locale" */
  update_rangers_locale?: Maybe<Rangers_Locale_Mutation_Response>;
  /** update single row of the table: "rangers.locale" */
  update_rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** update multiples rows of table: "rangers.locale" */
  update_rangers_locale_many?: Maybe<Array<Maybe<Rangers_Locale_Mutation_Response>>>;
  /** update data of the table: "rangers.pack" */
  update_rangers_pack?: Maybe<Rangers_Pack_Mutation_Response>;
  /** update single row of the table: "rangers.pack" */
  update_rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** update multiples rows of table: "rangers.pack" */
  update_rangers_pack_many?: Maybe<Array<Maybe<Rangers_Pack_Mutation_Response>>>;
  /** update data of the table: "rangers.pack_text" */
  update_rangers_pack_text?: Maybe<Rangers_Pack_Text_Mutation_Response>;
  /** update single row of the table: "rangers.pack_text" */
  update_rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** update multiples rows of table: "rangers.pack_text" */
  update_rangers_pack_text_many?: Maybe<Array<Maybe<Rangers_Pack_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.search_deck" */
  update_rangers_search_deck?: Maybe<Rangers_Search_Deck_Mutation_Response>;
  /** update multiples rows of table: "rangers.search_deck" */
  update_rangers_search_deck_many?: Maybe<Array<Maybe<Rangers_Search_Deck_Mutation_Response>>>;
  /** update data of the table: "rangers.set" */
  update_rangers_set?: Maybe<Rangers_Set_Mutation_Response>;
  /** update single row of the table: "rangers.set" */
  update_rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** update multiples rows of table: "rangers.set" */
  update_rangers_set_many?: Maybe<Array<Maybe<Rangers_Set_Mutation_Response>>>;
  /** update data of the table: "rangers.set_text" */
  update_rangers_set_text?: Maybe<Rangers_Set_Text_Mutation_Response>;
  /** update single row of the table: "rangers.set_text" */
  update_rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** update multiples rows of table: "rangers.set_text" */
  update_rangers_set_text_many?: Maybe<Array<Maybe<Rangers_Set_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.set_type" */
  update_rangers_set_type?: Maybe<Rangers_Set_Type_Mutation_Response>;
  /** update single row of the table: "rangers.set_type" */
  update_rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** update multiples rows of table: "rangers.set_type" */
  update_rangers_set_type_many?: Maybe<Array<Maybe<Rangers_Set_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.set_type_text" */
  update_rangers_set_type_text?: Maybe<Rangers_Set_Type_Text_Mutation_Response>;
  /** update single row of the table: "rangers.set_type_text" */
  update_rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** update multiples rows of table: "rangers.set_type_text" */
  update_rangers_set_type_text_many?: Maybe<Array<Maybe<Rangers_Set_Type_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.token" */
  update_rangers_token?: Maybe<Rangers_Token_Mutation_Response>;
  /** update single row of the table: "rangers.token" */
  update_rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** update multiples rows of table: "rangers.token" */
  update_rangers_token_many?: Maybe<Array<Maybe<Rangers_Token_Mutation_Response>>>;
  /** update data of the table: "rangers.token_text" */
  update_rangers_token_text?: Maybe<Rangers_Token_Text_Mutation_Response>;
  /** update single row of the table: "rangers.token_text" */
  update_rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** update multiples rows of table: "rangers.token_text" */
  update_rangers_token_text_many?: Maybe<Array<Maybe<Rangers_Token_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.type" */
  update_rangers_type?: Maybe<Rangers_Type_Mutation_Response>;
  /** update single row of the table: "rangers.type" */
  update_rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** update multiples rows of table: "rangers.type" */
  update_rangers_type_many?: Maybe<Array<Maybe<Rangers_Type_Mutation_Response>>>;
  /** update data of the table: "rangers.type_text" */
  update_rangers_type_text?: Maybe<Rangers_Type_Text_Mutation_Response>;
  /** update single row of the table: "rangers.type_text" */
  update_rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** update multiples rows of table: "rangers.type_text" */
  update_rangers_type_text_many?: Maybe<Array<Maybe<Rangers_Type_Text_Mutation_Response>>>;
  /** update data of the table: "rangers.user_friends" */
  update_rangers_user_friends?: Maybe<Rangers_User_Friends_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_friends" */
  update_rangers_user_friends_many?: Maybe<Array<Maybe<Rangers_User_Friends_Mutation_Response>>>;
  /** update data of the table: "rangers.user_received_friend_requests" */
  update_rangers_user_received_friend_requests?: Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_received_friend_requests" */
  update_rangers_user_received_friend_requests_many?: Maybe<Array<Maybe<Rangers_User_Received_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "rangers.user_role" */
  update_rangers_user_role?: Maybe<Rangers_User_Role_Mutation_Response>;
  /** update single row of the table: "rangers.user_role" */
  update_rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** update multiples rows of table: "rangers.user_role" */
  update_rangers_user_role_many?: Maybe<Array<Maybe<Rangers_User_Role_Mutation_Response>>>;
  /** update data of the table: "rangers.user_sent_friend_requests" */
  update_rangers_user_sent_friend_requests?: Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "rangers.user_sent_friend_requests" */
  update_rangers_user_sent_friend_requests_many?: Maybe<Array<Maybe<Rangers_User_Sent_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "rangers.user_settings" */
  update_rangers_user_settings?: Maybe<Rangers_User_Settings_Mutation_Response>;
  /** update single row of the table: "rangers.user_settings" */
  update_rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** update multiples rows of table: "rangers.user_settings" */
  update_rangers_user_settings_many?: Maybe<Array<Maybe<Rangers_User_Settings_Mutation_Response>>>;
  /** update data of the table: "rangers.users" */
  update_rangers_users?: Maybe<Rangers_Users_Mutation_Response>;
  /** update single row of the table: "rangers.users" */
  update_rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** update multiples rows of table: "rangers.users" */
  update_rangers_users_many?: Maybe<Array<Maybe<Rangers_Users_Mutation_Response>>>;
  /** update data of the table: "taboo_set" */
  update_taboo_set?: Maybe<Taboo_Set_Mutation_Response>;
  /** update single row of the table: "taboo_set" */
  update_taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** update multiples rows of table: "taboo_set" */
  update_taboo_set_many?: Maybe<Array<Maybe<Taboo_Set_Mutation_Response>>>;
  /** update data of the table: "user_campaigns" */
  update_user_campaigns?: Maybe<User_Campaigns_Mutation_Response>;
  /** update multiples rows of table: "user_campaigns" */
  update_user_campaigns_many?: Maybe<Array<Maybe<User_Campaigns_Mutation_Response>>>;
  /** update data of the table: "user_flag" */
  update_user_flag?: Maybe<User_Flag_Mutation_Response>;
  /** update single row of the table: "user_flag" */
  update_user_flag_by_pk?: Maybe<User_Flag>;
  /** update multiples rows of table: "user_flag" */
  update_user_flag_many?: Maybe<Array<Maybe<User_Flag_Mutation_Response>>>;
  /** update data of the table: "user_flag_type" */
  update_user_flag_type?: Maybe<User_Flag_Type_Mutation_Response>;
  /** update single row of the table: "user_flag_type" */
  update_user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** update multiples rows of table: "user_flag_type" */
  update_user_flag_type_many?: Maybe<Array<Maybe<User_Flag_Type_Mutation_Response>>>;
  /** update data of the table: "user_friends" */
  update_user_friends?: Maybe<User_Friends_Mutation_Response>;
  /** update multiples rows of table: "user_friends" */
  update_user_friends_many?: Maybe<Array<Maybe<User_Friends_Mutation_Response>>>;
  /** update data of the table: "user_received_friend_requests" */
  update_user_received_friend_requests?: Maybe<User_Received_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "user_received_friend_requests" */
  update_user_received_friend_requests_many?: Maybe<Array<Maybe<User_Received_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "user_sent_friend_requests" */
  update_user_sent_friend_requests?: Maybe<User_Sent_Friend_Requests_Mutation_Response>;
  /** update multiples rows of table: "user_sent_friend_requests" */
  update_user_sent_friend_requests_many?: Maybe<Array<Maybe<User_Sent_Friend_Requests_Mutation_Response>>>;
  /** update data of the table: "user_settings" */
  update_user_settings?: Maybe<User_Settings_Mutation_Response>;
  /** update single row of the table: "user_settings" */
  update_user_settings_by_pk?: Maybe<User_Settings>;
  /** update multiples rows of table: "user_settings" */
  update_user_settings_many?: Maybe<Array<Maybe<User_Settings_Mutation_Response>>>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  upgradeArkhamDbDeck?: Maybe<UpgradeDeckOutput>;
  uploadLocalCampaignDeck?: Maybe<UploadLocalCampaignDeckOutput>;
};


/** mutation root */
export type Mutation_RootApiDeleteArkhamDbDeckArgs = {
  args: DeleteDeckInput;
};


/** mutation root */
export type Mutation_RootConquest_Publish_DeckArgs = {
  args: Conquest_Publish_Deck_Args;
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootCreateArkhamDbDeckArgs = {
  args: CreateDeckInput;
};


/** mutation root */
export type Mutation_RootCreateCampaignArgs = {
  args: CreateCampaignInput;
};


/** mutation root */
export type Mutation_RootDeleteCampaignArgs = {
  args: DeleteCampaignInput;
};


/** mutation root */
export type Mutation_RootDelete_All_CardArgs = {
  where: All_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_TextArgs = {
  where: All_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_UpdatedArgs = {
  where: All_Card_Updated_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_VersionArgs = {
  where: All_Card_Updated_By_Version_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_All_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_AuthArgs = {
  where: Arkhamdb_Auth_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_DeckArgs = {
  where: Arkhamdb_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Arkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Base_DecksArgs = {
  where: Base_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_CampaignArgs = {
  where: Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_AccessArgs = {
  where: Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_DeckArgs = {
  where: Campaign_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_DifficultyArgs = {
  where: Campaign_Difficulty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Campaign_GuideArgs = {
  where: Campaign_Guide_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_InvestigatorArgs = {
  where: Campaign_Investigator_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Campaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CardArgs = {
  where: Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_CycleArgs = {
  where: Card_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Encounter_SetArgs = {
  where: Card_Encounter_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_PackArgs = {
  where: Card_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Subtype_NameArgs = {
  where: Card_Subtype_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_TextArgs = {
  where: Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_CodeArgs = {
  where: Card_Type_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_NameArgs = {
  where: Card_Type_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Card_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_ResultArgs = {
  where: Chaos_Bag_Result_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Tarot_ModeArgs = {
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CardArgs = {
  where: Conquest_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_TextArgs = {
  where: Conquest_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CommentArgs = {
  where: Conquest_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_CycleArgs = {
  where: Conquest_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_TextArgs = {
  where: Conquest_Cycle_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_DeckArgs = {
  where: Conquest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_CopyArgs = {
  where: Conquest_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_LikeArgs = {
  where: Conquest_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_FactionArgs = {
  where: Conquest_Faction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_TextArgs = {
  where: Conquest_Faction_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_LoyaltyArgs = {
  where: Conquest_Loyalty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_TextArgs = {
  where: Conquest_Loyalty_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_PackArgs = {
  where: Conquest_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_TextArgs = {
  where: Conquest_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_TypeArgs = {
  where: Conquest_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_TextArgs = {
  where: Conquest_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_RoleArgs = {
  where: Conquest_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_SettingsArgs = {
  where: Conquest_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Conquest_UsersArgs = {
  where: Conquest_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_CycleArgs = {
  where: Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Cycle_NameArgs = {
  where: Cycle_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Faction_NameArgs = {
  where: Faction_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_FaqArgs = {
  where: Faq_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faq_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Faq_TextArgs = {
  where: Faq_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Faq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Friend_StatusArgs = {
  where: Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_TypeArgs = {
  where: Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Full_CardArgs = {
  where: Full_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_TextArgs = {
  where: Full_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Full_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_GenderArgs = {
  where: Gender_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Gender_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Guide_AchievementArgs = {
  where: Guide_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Guide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Guide_InputArgs = {
  where: Guide_Input_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Guide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Investigator_DataArgs = {
  where: Investigator_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Investigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Latest_DecksArgs = {
  where: Latest_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Local_DecksArgs = {
  where: Local_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PackArgs = {
  where: Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Pack_NameArgs = {
  where: Pack_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Pack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_AreaArgs = {
  where: Rangers_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_TextArgs = {
  where: Rangers_Area_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_AspectArgs = {
  where: Rangers_Aspect_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_TextArgs = {
  where: Rangers_Aspect_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CampaignArgs = {
  where: Rangers_Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_AccessArgs = {
  where: Rangers_Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CardArgs = {
  where: Rangers_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_TextArgs = {
  where: Rangers_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_CommentArgs = {
  where: Rangers_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_DeckArgs = {
  where: Rangers_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_CopyArgs = {
  where: Rangers_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_LikeArgs = {
  where: Rangers_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_CountArgs = {
  where: Rangers_Deck_Like_Count_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Faq_EntryArgs = {
  where: Rangers_Faq_Entry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_StatusArgs = {
  where: Rangers_Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_TypeArgs = {
  where: Rangers_Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Latest_DeckArgs = {
  where: Rangers_Latest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_LocaleArgs = {
  where: Rangers_Locale_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_PackArgs = {
  where: Rangers_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_TextArgs = {
  where: Rangers_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Search_DeckArgs = {
  where: Rangers_Search_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_SetArgs = {
  where: Rangers_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_TextArgs = {
  where: Rangers_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_TypeArgs = {
  where: Rangers_Set_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_TextArgs = {
  where: Rangers_Set_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_TokenArgs = {
  where: Rangers_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_TextArgs = {
  where: Rangers_Token_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_TypeArgs = {
  where: Rangers_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_TextArgs = {
  where: Rangers_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_FriendsArgs = {
  where: Rangers_User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Received_Friend_RequestsArgs = {
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_RoleArgs = {
  where: Rangers_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Sent_Friend_RequestsArgs = {
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_SettingsArgs = {
  where: Rangers_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Rangers_UsersArgs = {
  where: Rangers_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Rangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_Taboo_SetArgs = {
  where: Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Taboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_CampaignsArgs = {
  where: User_Campaigns_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_FlagArgs = {
  where: User_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_TypeArgs = {
  where: User_Flag_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_FriendsArgs = {
  where: User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Received_Friend_RequestsArgs = {
  where: User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Sent_Friend_RequestsArgs = {
  where: User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_SettingsArgs = {
  where: User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


/** mutation root */
export type Mutation_RootEditCampaignAccessArgs = {
  args: EditCampaignAccessInput;
};


/** mutation root */
export type Mutation_RootInsert_All_CardArgs = {
  objects: Array<All_Card_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_OneArgs = {
  object: All_Card_Insert_Input;
  on_conflict?: InputMaybe<All_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_TextArgs = {
  objects: Array<All_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Text_OneArgs = {
  object: All_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_UpdatedArgs = {
  objects: Array<All_Card_Updated_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Updated_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_By_VersionArgs = {
  objects: Array<All_Card_Updated_By_Version_Insert_Input>;
  on_conflict?: InputMaybe<All_Card_Updated_By_Version_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_By_Version_OneArgs = {
  object: All_Card_Updated_By_Version_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Updated_By_Version_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_All_Card_Updated_OneArgs = {
  object: All_Card_Updated_Insert_Input;
  on_conflict?: InputMaybe<All_Card_Updated_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_AuthArgs = {
  objects: Array<Arkhamdb_Auth_Insert_Input>;
  on_conflict?: InputMaybe<Arkhamdb_Auth_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_Auth_OneArgs = {
  object: Arkhamdb_Auth_Insert_Input;
  on_conflict?: InputMaybe<Arkhamdb_Auth_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_DeckArgs = {
  objects: Array<Arkhamdb_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Arkhamdb_Deck_OneArgs = {
  object: Arkhamdb_Deck_Insert_Input;
  on_conflict?: InputMaybe<Arkhamdb_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Base_DecksArgs = {
  objects: Array<Base_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Base_Decks_OneArgs = {
  object: Base_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_CampaignArgs = {
  objects: Array<Campaign_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_AccessArgs = {
  objects: Array<Campaign_Access_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Access_OneArgs = {
  object: Campaign_Access_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_DeckArgs = {
  objects: Array<Campaign_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Deck_OneArgs = {
  object: Campaign_Deck_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_DifficultyArgs = {
  objects: Array<Campaign_Difficulty_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Difficulty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Difficulty_OneArgs = {
  object: Campaign_Difficulty_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Difficulty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_GuideArgs = {
  objects: Array<Campaign_Guide_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Guide_OneArgs = {
  object: Campaign_Guide_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_InvestigatorArgs = {
  objects: Array<Campaign_Investigator_Insert_Input>;
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_Investigator_OneArgs = {
  object: Campaign_Investigator_Insert_Input;
  on_conflict?: InputMaybe<Campaign_Investigator_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Campaign_OneArgs = {
  object: Campaign_Insert_Input;
  on_conflict?: InputMaybe<Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CardArgs = {
  objects: Array<Card_Insert_Input>;
  on_conflict?: InputMaybe<Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_CycleArgs = {
  objects: Array<Card_Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Cycle_OneArgs = {
  object: Card_Cycle_Insert_Input;
  on_conflict?: InputMaybe<Card_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Encounter_SetArgs = {
  objects: Array<Card_Encounter_Set_Insert_Input>;
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Encounter_Set_OneArgs = {
  object: Card_Encounter_Set_Insert_Input;
  on_conflict?: InputMaybe<Card_Encounter_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_OneArgs = {
  object: Card_Insert_Input;
  on_conflict?: InputMaybe<Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_PackArgs = {
  objects: Array<Card_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Pack_OneArgs = {
  object: Card_Pack_Insert_Input;
  on_conflict?: InputMaybe<Card_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Subtype_NameArgs = {
  objects: Array<Card_Subtype_Name_Insert_Input>;
  on_conflict?: InputMaybe<Card_Subtype_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Subtype_Name_OneArgs = {
  object: Card_Subtype_Name_Insert_Input;
  on_conflict?: InputMaybe<Card_Subtype_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_TextArgs = {
  objects: Array<Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Text_OneArgs = {
  object: Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_CodeArgs = {
  objects: Array<Card_Type_Code_Insert_Input>;
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_Code_OneArgs = {
  object: Card_Type_Code_Insert_Input;
  on_conflict?: InputMaybe<Card_Type_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_NameArgs = {
  objects: Array<Card_Type_Name_Insert_Input>;
  on_conflict?: InputMaybe<Card_Type_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Card_Type_Name_OneArgs = {
  object: Card_Type_Name_Insert_Input;
  on_conflict?: InputMaybe<Card_Type_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_ResultArgs = {
  objects: Array<Chaos_Bag_Result_Insert_Input>;
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Result_OneArgs = {
  object: Chaos_Bag_Result_Insert_Input;
  on_conflict?: InputMaybe<Chaos_Bag_Result_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Tarot_ModeArgs = {
  objects: Array<Chaos_Bag_Tarot_Mode_Insert_Input>;
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chaos_Bag_Tarot_Mode_OneArgs = {
  object: Chaos_Bag_Tarot_Mode_Insert_Input;
  on_conflict?: InputMaybe<Chaos_Bag_Tarot_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CardArgs = {
  objects: Array<Conquest_Card_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_OneArgs = {
  object: Conquest_Card_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_TextArgs = {
  objects: Array<Conquest_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Card_Text_OneArgs = {
  object: Conquest_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CommentArgs = {
  objects: Array<Conquest_Comment_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Comment_OneArgs = {
  object: Conquest_Comment_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_CycleArgs = {
  objects: Array<Conquest_Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_OneArgs = {
  object: Conquest_Cycle_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_TextArgs = {
  objects: Array<Conquest_Cycle_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Cycle_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Cycle_Text_OneArgs = {
  object: Conquest_Cycle_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Cycle_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_DeckArgs = {
  objects: Array<Conquest_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_CopyArgs = {
  objects: Array<Conquest_Deck_Copy_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_Copy_OneArgs = {
  object: Conquest_Deck_Copy_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_LikeArgs = {
  objects: Array<Conquest_Deck_Like_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_Like_OneArgs = {
  object: Conquest_Deck_Like_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Deck_OneArgs = {
  object: Conquest_Deck_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_FactionArgs = {
  objects: Array<Conquest_Faction_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Faction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_OneArgs = {
  object: Conquest_Faction_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Faction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_TextArgs = {
  objects: Array<Conquest_Faction_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Faction_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Faction_Text_OneArgs = {
  object: Conquest_Faction_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Faction_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_LoyaltyArgs = {
  objects: Array<Conquest_Loyalty_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Loyalty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_OneArgs = {
  object: Conquest_Loyalty_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Loyalty_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_TextArgs = {
  objects: Array<Conquest_Loyalty_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Loyalty_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Loyalty_Text_OneArgs = {
  object: Conquest_Loyalty_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Loyalty_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_PackArgs = {
  objects: Array<Conquest_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_OneArgs = {
  object: Conquest_Pack_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_TextArgs = {
  objects: Array<Conquest_Pack_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Pack_Text_OneArgs = {
  object: Conquest_Pack_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_TypeArgs = {
  objects: Array<Conquest_Type_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_OneArgs = {
  object: Conquest_Type_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_TextArgs = {
  objects: Array<Conquest_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Type_Text_OneArgs = {
  object: Conquest_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_RoleArgs = {
  objects: Array<Conquest_User_Role_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_Role_OneArgs = {
  object: Conquest_User_Role_Insert_Input;
  on_conflict?: InputMaybe<Conquest_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_SettingsArgs = {
  objects: Array<Conquest_User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_User_Settings_OneArgs = {
  object: Conquest_User_Settings_Insert_Input;
  on_conflict?: InputMaybe<Conquest_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_UsersArgs = {
  objects: Array<Conquest_Users_Insert_Input>;
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conquest_Users_OneArgs = {
  object: Conquest_Users_Insert_Input;
  on_conflict?: InputMaybe<Conquest_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CycleArgs = {
  objects: Array<Cycle_Insert_Input>;
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_NameArgs = {
  objects: Array<Cycle_Name_Insert_Input>;
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_Name_OneArgs = {
  object: Cycle_Name_Insert_Input;
  on_conflict?: InputMaybe<Cycle_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cycle_OneArgs = {
  object: Cycle_Insert_Input;
  on_conflict?: InputMaybe<Cycle_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faction_NameArgs = {
  objects: Array<Faction_Name_Insert_Input>;
  on_conflict?: InputMaybe<Faction_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faction_Name_OneArgs = {
  object: Faction_Name_Insert_Input;
  on_conflict?: InputMaybe<Faction_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_FaqArgs = {
  objects: Array<Faq_Insert_Input>;
  on_conflict?: InputMaybe<Faq_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_OneArgs = {
  object: Faq_Insert_Input;
  on_conflict?: InputMaybe<Faq_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_TextArgs = {
  objects: Array<Faq_Text_Insert_Input>;
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Faq_Text_OneArgs = {
  object: Faq_Text_Insert_Input;
  on_conflict?: InputMaybe<Faq_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_StatusArgs = {
  objects: Array<Friend_Status_Insert_Input>;
  on_conflict?: InputMaybe<Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_OneArgs = {
  object: Friend_Status_Insert_Input;
  on_conflict?: InputMaybe<Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_TypeArgs = {
  objects: Array<Friend_Status_Type_Insert_Input>;
  on_conflict?: InputMaybe<Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Friend_Status_Type_OneArgs = {
  object: Friend_Status_Type_Insert_Input;
  on_conflict?: InputMaybe<Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_CardArgs = {
  objects: Array<Full_Card_Insert_Input>;
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_OneArgs = {
  object: Full_Card_Insert_Input;
  on_conflict?: InputMaybe<Full_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_TextArgs = {
  objects: Array<Full_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Full_Card_Text_OneArgs = {
  object: Full_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Full_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GenderArgs = {
  objects: Array<Gender_Insert_Input>;
  on_conflict?: InputMaybe<Gender_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Gender_OneArgs = {
  object: Gender_Insert_Input;
  on_conflict?: InputMaybe<Gender_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_AchievementArgs = {
  objects: Array<Guide_Achievement_Insert_Input>;
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_Achievement_OneArgs = {
  object: Guide_Achievement_Insert_Input;
  on_conflict?: InputMaybe<Guide_Achievement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_InputArgs = {
  objects: Array<Guide_Input_Insert_Input>;
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Guide_Input_OneArgs = {
  object: Guide_Input_Insert_Input;
  on_conflict?: InputMaybe<Guide_Input_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investigator_DataArgs = {
  objects: Array<Investigator_Data_Insert_Input>;
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Investigator_Data_OneArgs = {
  object: Investigator_Data_Insert_Input;
  on_conflict?: InputMaybe<Investigator_Data_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Latest_DecksArgs = {
  objects: Array<Latest_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Latest_Decks_OneArgs = {
  object: Latest_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Local_DecksArgs = {
  objects: Array<Local_Decks_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Local_Decks_OneArgs = {
  object: Local_Decks_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_PackArgs = {
  objects: Array<Pack_Insert_Input>;
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_NameArgs = {
  objects: Array<Pack_Name_Insert_Input>;
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_Name_OneArgs = {
  object: Pack_Name_Insert_Input;
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Pack_OneArgs = {
  object: Pack_Insert_Input;
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_AreaArgs = {
  objects: Array<Rangers_Area_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_OneArgs = {
  object: Rangers_Area_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Area_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_TextArgs = {
  objects: Array<Rangers_Area_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Area_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Area_Text_OneArgs = {
  object: Rangers_Area_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Area_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_AspectArgs = {
  objects: Array<Rangers_Aspect_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Aspect_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_OneArgs = {
  object: Rangers_Aspect_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Aspect_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_TextArgs = {
  objects: Array<Rangers_Aspect_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Aspect_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Aspect_Text_OneArgs = {
  object: Rangers_Aspect_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Aspect_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CampaignArgs = {
  objects: Array<Rangers_Campaign_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_AccessArgs = {
  objects: Array<Rangers_Campaign_Access_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_Access_OneArgs = {
  object: Rangers_Campaign_Access_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Campaign_Access_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Campaign_OneArgs = {
  object: Rangers_Campaign_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CardArgs = {
  objects: Array<Rangers_Card_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_OneArgs = {
  object: Rangers_Card_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Card_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_TextArgs = {
  objects: Array<Rangers_Card_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Card_Text_OneArgs = {
  object: Rangers_Card_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_CommentArgs = {
  objects: Array<Rangers_Comment_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Comment_OneArgs = {
  object: Rangers_Comment_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_DeckArgs = {
  objects: Array<Rangers_Deck_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_CopyArgs = {
  objects: Array<Rangers_Deck_Copy_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Copy_OneArgs = {
  object: Rangers_Deck_Copy_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_LikeArgs = {
  objects: Array<Rangers_Deck_Like_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_CountArgs = {
  objects: Array<Rangers_Deck_Like_Count_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_Count_OneArgs = {
  object: Rangers_Deck_Like_Count_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_Like_OneArgs = {
  object: Rangers_Deck_Like_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_Like_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Deck_OneArgs = {
  object: Rangers_Deck_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Faq_EntryArgs = {
  objects: Array<Rangers_Faq_Entry_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Faq_Entry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Faq_Entry_OneArgs = {
  object: Rangers_Faq_Entry_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Faq_Entry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_StatusArgs = {
  objects: Array<Rangers_Friend_Status_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_OneArgs = {
  object: Rangers_Friend_Status_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Friend_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_TypeArgs = {
  objects: Array<Rangers_Friend_Status_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Friend_Status_Type_OneArgs = {
  object: Rangers_Friend_Status_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Friend_Status_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Latest_DeckArgs = {
  objects: Array<Rangers_Latest_Deck_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Latest_Deck_OneArgs = {
  object: Rangers_Latest_Deck_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_LocaleArgs = {
  objects: Array<Rangers_Locale_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Locale_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Locale_OneArgs = {
  object: Rangers_Locale_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Locale_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_PackArgs = {
  objects: Array<Rangers_Pack_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_OneArgs = {
  object: Rangers_Pack_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Pack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_TextArgs = {
  objects: Array<Rangers_Pack_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Pack_Text_OneArgs = {
  object: Rangers_Pack_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Search_DeckArgs = {
  objects: Array<Rangers_Search_Deck_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Search_Deck_OneArgs = {
  object: Rangers_Search_Deck_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_SetArgs = {
  objects: Array<Rangers_Set_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_OneArgs = {
  object: Rangers_Set_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_TextArgs = {
  objects: Array<Rangers_Set_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Text_OneArgs = {
  object: Rangers_Set_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_TypeArgs = {
  objects: Array<Rangers_Set_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_OneArgs = {
  object: Rangers_Set_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_TextArgs = {
  objects: Array<Rangers_Set_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Set_Type_Text_OneArgs = {
  object: Rangers_Set_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_TokenArgs = {
  objects: Array<Rangers_Token_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_OneArgs = {
  object: Rangers_Token_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Token_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_TextArgs = {
  objects: Array<Rangers_Token_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Token_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Token_Text_OneArgs = {
  object: Rangers_Token_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Token_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_TypeArgs = {
  objects: Array<Rangers_Type_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_OneArgs = {
  object: Rangers_Type_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_TextArgs = {
  objects: Array<Rangers_Type_Text_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Type_Text_OneArgs = {
  object: Rangers_Type_Text_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Type_Text_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_FriendsArgs = {
  objects: Array<Rangers_User_Friends_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Friends_OneArgs = {
  object: Rangers_User_Friends_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Received_Friend_RequestsArgs = {
  objects: Array<Rangers_User_Received_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Received_Friend_Requests_OneArgs = {
  object: Rangers_User_Received_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_RoleArgs = {
  objects: Array<Rangers_User_Role_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Role_OneArgs = {
  object: Rangers_User_Role_Insert_Input;
  on_conflict?: InputMaybe<Rangers_User_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Sent_Friend_RequestsArgs = {
  objects: Array<Rangers_User_Sent_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Sent_Friend_Requests_OneArgs = {
  object: Rangers_User_Sent_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_SettingsArgs = {
  objects: Array<Rangers_User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_User_Settings_OneArgs = {
  object: Rangers_User_Settings_Insert_Input;
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_UsersArgs = {
  objects: Array<Rangers_Users_Insert_Input>;
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Rangers_Users_OneArgs = {
  object: Rangers_Users_Insert_Input;
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Taboo_SetArgs = {
  objects: Array<Taboo_Set_Insert_Input>;
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Taboo_Set_OneArgs = {
  object: Taboo_Set_Insert_Input;
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_CampaignsArgs = {
  objects: Array<User_Campaigns_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Campaigns_OneArgs = {
  object: User_Campaigns_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_FlagArgs = {
  objects: Array<User_Flag_Insert_Input>;
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_OneArgs = {
  object: User_Flag_Insert_Input;
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_TypeArgs = {
  objects: Array<User_Flag_Type_Insert_Input>;
  on_conflict?: InputMaybe<User_Flag_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Flag_Type_OneArgs = {
  object: User_Flag_Type_Insert_Input;
  on_conflict?: InputMaybe<User_Flag_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_FriendsArgs = {
  objects: Array<User_Friends_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Friends_OneArgs = {
  object: User_Friends_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_Received_Friend_RequestsArgs = {
  objects: Array<User_Received_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Received_Friend_Requests_OneArgs = {
  object: User_Received_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_Sent_Friend_RequestsArgs = {
  objects: Array<User_Sent_Friend_Requests_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_User_Sent_Friend_Requests_OneArgs = {
  object: User_Sent_Friend_Requests_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_User_SettingsArgs = {
  objects: Array<User_Settings_Insert_Input>;
  on_conflict?: InputMaybe<User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Settings_OneArgs = {
  object: User_Settings_Insert_Input;
  on_conflict?: InputMaybe<User_Settings_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootLoginToArkhamDbArgs = {
  args: LoginInput;
};


/** mutation root */
export type Mutation_RootMigrateLoginToArkhamDbArgs = {
  args: MigrateLoginInput;
};


/** mutation root */
export type Mutation_RootRangers_Publish_DeckArgs = {
  args: Rangers_Publish_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Remove_Campaign_DeckArgs = {
  args: Rangers_Remove_Campaign_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Set_Campaign_DeckArgs = {
  args: Rangers_Set_Campaign_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRangers_Upgrade_DeckArgs = {
  args: Rangers_Upgrade_Deck_Args;
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


/** mutation root */
export type Mutation_RootRefreshArkhamDbDecksArgs = {
  args: RefreshDecksInput;
};


/** mutation root */
export type Mutation_RootUpdateFriendRequestArgs = {
  args: FriendRequestInput;
};


/** mutation root */
export type Mutation_RootUpdateHandleArgs = {
  args: UpdateHandleInput;
};


/** mutation root */
export type Mutation_RootUpdate_All_CardArgs = {
  _append?: InputMaybe<All_Card_Append_Input>;
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  _inc?: InputMaybe<All_Card_Inc_Input>;
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  _set?: InputMaybe<All_Card_Set_Input>;
  where: All_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_By_PkArgs = {
  _append?: InputMaybe<All_Card_Append_Input>;
  _delete_at_path?: InputMaybe<All_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<All_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<All_Card_Delete_Key_Input>;
  _inc?: InputMaybe<All_Card_Inc_Input>;
  _prepend?: InputMaybe<All_Card_Prepend_Input>;
  _set?: InputMaybe<All_Card_Set_Input>;
  pk_columns: All_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_ManyArgs = {
  updates: Array<All_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_TextArgs = {
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  where: All_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Text_By_PkArgs = {
  _set?: InputMaybe<All_Card_Text_Set_Input>;
  pk_columns: All_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Text_ManyArgs = {
  updates: Array<All_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_UpdatedArgs = {
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  where: All_Card_Updated_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_PkArgs = {
  _inc?: InputMaybe<All_Card_Updated_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_Set_Input>;
  pk_columns: All_Card_Updated_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_VersionArgs = {
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  where: All_Card_Updated_By_Version_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_Version_By_PkArgs = {
  _inc?: InputMaybe<All_Card_Updated_By_Version_Inc_Input>;
  _set?: InputMaybe<All_Card_Updated_By_Version_Set_Input>;
  pk_columns: All_Card_Updated_By_Version_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_By_Version_ManyArgs = {
  updates: Array<All_Card_Updated_By_Version_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_All_Card_Updated_ManyArgs = {
  updates: Array<All_Card_Updated_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_AuthArgs = {
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  where: Arkhamdb_Auth_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Auth_By_PkArgs = {
  _inc?: InputMaybe<Arkhamdb_Auth_Inc_Input>;
  _set?: InputMaybe<Arkhamdb_Auth_Set_Input>;
  pk_columns: Arkhamdb_Auth_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Auth_ManyArgs = {
  updates: Array<Arkhamdb_Auth_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_DeckArgs = {
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  where: Arkhamdb_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Deck_By_PkArgs = {
  _append?: InputMaybe<Arkhamdb_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Arkhamdb_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Arkhamdb_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Arkhamdb_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Arkhamdb_Deck_Inc_Input>;
  _prepend?: InputMaybe<Arkhamdb_Deck_Prepend_Input>;
  _set?: InputMaybe<Arkhamdb_Deck_Set_Input>;
  pk_columns: Arkhamdb_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Arkhamdb_Deck_ManyArgs = {
  updates: Array<Arkhamdb_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Base_DecksArgs = {
  _inc?: InputMaybe<Base_Decks_Inc_Input>;
  _set?: InputMaybe<Base_Decks_Set_Input>;
  where: Base_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Base_Decks_ManyArgs = {
  updates: Array<Base_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CampaignArgs = {
  _append?: InputMaybe<Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  _set?: InputMaybe<Campaign_Set_Input>;
  where: Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_AccessArgs = {
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  where: Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Access_By_PkArgs = {
  _inc?: InputMaybe<Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Campaign_Access_Set_Input>;
  pk_columns: Campaign_Access_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Access_ManyArgs = {
  updates: Array<Campaign_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_By_PkArgs = {
  _append?: InputMaybe<Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Prepend_Input>;
  _set?: InputMaybe<Campaign_Set_Input>;
  pk_columns: Campaign_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_DeckArgs = {
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  where: Campaign_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Deck_By_PkArgs = {
  _append?: InputMaybe<Campaign_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Campaign_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Campaign_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Campaign_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Campaign_Deck_Inc_Input>;
  _prepend?: InputMaybe<Campaign_Deck_Prepend_Input>;
  _set?: InputMaybe<Campaign_Deck_Set_Input>;
  pk_columns: Campaign_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Deck_ManyArgs = {
  updates: Array<Campaign_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_DifficultyArgs = {
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  where: Campaign_Difficulty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Difficulty_By_PkArgs = {
  _set?: InputMaybe<Campaign_Difficulty_Set_Input>;
  pk_columns: Campaign_Difficulty_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Difficulty_ManyArgs = {
  updates: Array<Campaign_Difficulty_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_GuideArgs = {
  _inc?: InputMaybe<Campaign_Guide_Inc_Input>;
  _set?: InputMaybe<Campaign_Guide_Set_Input>;
  where: Campaign_Guide_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Guide_ManyArgs = {
  updates: Array<Campaign_Guide_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_InvestigatorArgs = {
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  where: Campaign_Investigator_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Investigator_By_PkArgs = {
  _inc?: InputMaybe<Campaign_Investigator_Inc_Input>;
  _set?: InputMaybe<Campaign_Investigator_Set_Input>;
  pk_columns: Campaign_Investigator_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_Investigator_ManyArgs = {
  updates: Array<Campaign_Investigator_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Campaign_ManyArgs = {
  updates: Array<Campaign_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CardArgs = {
  _append?: InputMaybe<Card_Append_Input>;
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  _inc?: InputMaybe<Card_Inc_Input>;
  _prepend?: InputMaybe<Card_Prepend_Input>;
  _set?: InputMaybe<Card_Set_Input>;
  where: Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_By_PkArgs = {
  _append?: InputMaybe<Card_Append_Input>;
  _delete_at_path?: InputMaybe<Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Card_Delete_Key_Input>;
  _inc?: InputMaybe<Card_Inc_Input>;
  _prepend?: InputMaybe<Card_Prepend_Input>;
  _set?: InputMaybe<Card_Set_Input>;
  pk_columns: Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_CycleArgs = {
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  where: Card_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Card_Cycle_Inc_Input>;
  _set?: InputMaybe<Card_Cycle_Set_Input>;
  pk_columns: Card_Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Cycle_ManyArgs = {
  updates: Array<Card_Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_SetArgs = {
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  where: Card_Encounter_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_Set_By_PkArgs = {
  _set?: InputMaybe<Card_Encounter_Set_Set_Input>;
  pk_columns: Card_Encounter_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Encounter_Set_ManyArgs = {
  updates: Array<Card_Encounter_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_ManyArgs = {
  updates: Array<Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_PackArgs = {
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  _set?: InputMaybe<Card_Pack_Set_Input>;
  where: Card_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Pack_By_PkArgs = {
  _inc?: InputMaybe<Card_Pack_Inc_Input>;
  _set?: InputMaybe<Card_Pack_Set_Input>;
  pk_columns: Card_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Pack_ManyArgs = {
  updates: Array<Card_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_NameArgs = {
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  where: Card_Subtype_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_Name_By_PkArgs = {
  _set?: InputMaybe<Card_Subtype_Name_Set_Input>;
  pk_columns: Card_Subtype_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Subtype_Name_ManyArgs = {
  updates: Array<Card_Subtype_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_TextArgs = {
  _set?: InputMaybe<Card_Text_Set_Input>;
  where: Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Card_Text_Set_Input>;
  pk_columns: Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Text_ManyArgs = {
  updates: Array<Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_CodeArgs = {
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  where: Card_Type_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Code_By_PkArgs = {
  _set?: InputMaybe<Card_Type_Code_Set_Input>;
  pk_columns: Card_Type_Code_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Code_ManyArgs = {
  updates: Array<Card_Type_Code_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_NameArgs = {
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  where: Card_Type_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Name_By_PkArgs = {
  _set?: InputMaybe<Card_Type_Name_Set_Input>;
  pk_columns: Card_Type_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Card_Type_Name_ManyArgs = {
  updates: Array<Card_Type_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_ResultArgs = {
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  where: Chaos_Bag_Result_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Result_By_PkArgs = {
  _append?: InputMaybe<Chaos_Bag_Result_Append_Input>;
  _delete_at_path?: InputMaybe<Chaos_Bag_Result_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Chaos_Bag_Result_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Chaos_Bag_Result_Delete_Key_Input>;
  _inc?: InputMaybe<Chaos_Bag_Result_Inc_Input>;
  _prepend?: InputMaybe<Chaos_Bag_Result_Prepend_Input>;
  _set?: InputMaybe<Chaos_Bag_Result_Set_Input>;
  pk_columns: Chaos_Bag_Result_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Result_ManyArgs = {
  updates: Array<Chaos_Bag_Result_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_ModeArgs = {
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  where: Chaos_Bag_Tarot_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_Mode_By_PkArgs = {
  _set?: InputMaybe<Chaos_Bag_Tarot_Mode_Set_Input>;
  pk_columns: Chaos_Bag_Tarot_Mode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chaos_Bag_Tarot_Mode_ManyArgs = {
  updates: Array<Chaos_Bag_Tarot_Mode_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CardArgs = {
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  where: Conquest_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_By_PkArgs = {
  _append?: InputMaybe<Conquest_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Card_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Card_Prepend_Input>;
  _set?: InputMaybe<Conquest_Card_Set_Input>;
  pk_columns: Conquest_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_ManyArgs = {
  updates: Array<Conquest_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_TextArgs = {
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  where: Conquest_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Card_Text_Set_Input>;
  pk_columns: Conquest_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Card_Text_ManyArgs = {
  updates: Array<Conquest_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CommentArgs = {
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  where: Conquest_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Comment_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Comment_Inc_Input>;
  _set?: InputMaybe<Conquest_Comment_Set_Input>;
  pk_columns: Conquest_Comment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Comment_ManyArgs = {
  updates: Array<Conquest_Comment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_CycleArgs = {
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  where: Conquest_Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Cycle_Inc_Input>;
  _set?: InputMaybe<Conquest_Cycle_Set_Input>;
  pk_columns: Conquest_Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_ManyArgs = {
  updates: Array<Conquest_Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_TextArgs = {
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  where: Conquest_Cycle_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Cycle_Text_Set_Input>;
  pk_columns: Conquest_Cycle_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Cycle_Text_ManyArgs = {
  updates: Array<Conquest_Cycle_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_DeckArgs = {
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  where: Conquest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_By_PkArgs = {
  _append?: InputMaybe<Conquest_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Conquest_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Conquest_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Conquest_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Conquest_Deck_Inc_Input>;
  _prepend?: InputMaybe<Conquest_Deck_Prepend_Input>;
  _set?: InputMaybe<Conquest_Deck_Set_Input>;
  pk_columns: Conquest_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_CopyArgs = {
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  where: Conquest_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Copy_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Copy_Set_Input>;
  pk_columns: Conquest_Deck_Copy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Copy_ManyArgs = {
  updates: Array<Conquest_Deck_Copy_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_LikeArgs = {
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  where: Conquest_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Like_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Conquest_Deck_Like_Set_Input>;
  pk_columns: Conquest_Deck_Like_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_Like_ManyArgs = {
  updates: Array<Conquest_Deck_Like_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Deck_ManyArgs = {
  updates: Array<Conquest_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_FactionArgs = {
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  where: Conquest_Faction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_By_PkArgs = {
  _set?: InputMaybe<Conquest_Faction_Set_Input>;
  pk_columns: Conquest_Faction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_ManyArgs = {
  updates: Array<Conquest_Faction_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_TextArgs = {
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  where: Conquest_Faction_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Faction_Text_Set_Input>;
  pk_columns: Conquest_Faction_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Faction_Text_ManyArgs = {
  updates: Array<Conquest_Faction_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_LoyaltyArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  where: Conquest_Loyalty_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_By_PkArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Set_Input>;
  pk_columns: Conquest_Loyalty_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_ManyArgs = {
  updates: Array<Conquest_Loyalty_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_TextArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  where: Conquest_Loyalty_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Loyalty_Text_Set_Input>;
  pk_columns: Conquest_Loyalty_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Loyalty_Text_ManyArgs = {
  updates: Array<Conquest_Loyalty_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_PackArgs = {
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  where: Conquest_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_By_PkArgs = {
  _inc?: InputMaybe<Conquest_Pack_Inc_Input>;
  _set?: InputMaybe<Conquest_Pack_Set_Input>;
  pk_columns: Conquest_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_ManyArgs = {
  updates: Array<Conquest_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_TextArgs = {
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  where: Conquest_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Pack_Text_Set_Input>;
  pk_columns: Conquest_Pack_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Pack_Text_ManyArgs = {
  updates: Array<Conquest_Pack_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_TypeArgs = {
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  where: Conquest_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_By_PkArgs = {
  _set?: InputMaybe<Conquest_Type_Set_Input>;
  pk_columns: Conquest_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_ManyArgs = {
  updates: Array<Conquest_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_TextArgs = {
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  where: Conquest_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Conquest_Type_Text_Set_Input>;
  pk_columns: Conquest_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Type_Text_ManyArgs = {
  updates: Array<Conquest_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_RoleArgs = {
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  where: Conquest_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Role_By_PkArgs = {
  _set?: InputMaybe<Conquest_User_Role_Set_Input>;
  pk_columns: Conquest_User_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Role_ManyArgs = {
  updates: Array<Conquest_User_Role_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_SettingsArgs = {
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  where: Conquest_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Settings_By_PkArgs = {
  _set?: InputMaybe<Conquest_User_Settings_Set_Input>;
  pk_columns: Conquest_User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_User_Settings_ManyArgs = {
  updates: Array<Conquest_User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_UsersArgs = {
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  where: Conquest_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Users_By_PkArgs = {
  _set?: InputMaybe<Conquest_Users_Set_Input>;
  pk_columns: Conquest_Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conquest_Users_ManyArgs = {
  updates: Array<Conquest_Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CycleArgs = {
  _inc?: InputMaybe<Cycle_Inc_Input>;
  _set?: InputMaybe<Cycle_Set_Input>;
  where: Cycle_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_By_PkArgs = {
  _inc?: InputMaybe<Cycle_Inc_Input>;
  _set?: InputMaybe<Cycle_Set_Input>;
  pk_columns: Cycle_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_ManyArgs = {
  updates: Array<Cycle_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_NameArgs = {
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  where: Cycle_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_Name_By_PkArgs = {
  _set?: InputMaybe<Cycle_Name_Set_Input>;
  pk_columns: Cycle_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cycle_Name_ManyArgs = {
  updates: Array<Cycle_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_NameArgs = {
  _set?: InputMaybe<Faction_Name_Set_Input>;
  where: Faction_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_Name_By_PkArgs = {
  _set?: InputMaybe<Faction_Name_Set_Input>;
  pk_columns: Faction_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faction_Name_ManyArgs = {
  updates: Array<Faction_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FaqArgs = {
  _set?: InputMaybe<Faq_Set_Input>;
  where: Faq_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_By_PkArgs = {
  _set?: InputMaybe<Faq_Set_Input>;
  pk_columns: Faq_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_ManyArgs = {
  updates: Array<Faq_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_TextArgs = {
  _set?: InputMaybe<Faq_Text_Set_Input>;
  where: Faq_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_Text_By_PkArgs = {
  _set?: InputMaybe<Faq_Text_Set_Input>;
  pk_columns: Faq_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Faq_Text_ManyArgs = {
  updates: Array<Faq_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_StatusArgs = {
  _set?: InputMaybe<Friend_Status_Set_Input>;
  where: Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_By_PkArgs = {
  _set?: InputMaybe<Friend_Status_Set_Input>;
  pk_columns: Friend_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_ManyArgs = {
  updates: Array<Friend_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_TypeArgs = {
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  where: Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_Type_By_PkArgs = {
  _set?: InputMaybe<Friend_Status_Type_Set_Input>;
  pk_columns: Friend_Status_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Friend_Status_Type_ManyArgs = {
  updates: Array<Friend_Status_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Full_CardArgs = {
  _append?: InputMaybe<Full_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  _set?: InputMaybe<Full_Card_Set_Input>;
  where: Full_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_By_PkArgs = {
  _append?: InputMaybe<Full_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Full_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Full_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Full_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Full_Card_Inc_Input>;
  _prepend?: InputMaybe<Full_Card_Prepend_Input>;
  _set?: InputMaybe<Full_Card_Set_Input>;
  pk_columns: Full_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_ManyArgs = {
  updates: Array<Full_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_TextArgs = {
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  where: Full_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Full_Card_Text_Set_Input>;
  pk_columns: Full_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Full_Card_Text_ManyArgs = {
  updates: Array<Full_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_GenderArgs = {
  _set?: InputMaybe<Gender_Set_Input>;
  where: Gender_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Gender_By_PkArgs = {
  _set?: InputMaybe<Gender_Set_Input>;
  pk_columns: Gender_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Gender_ManyArgs = {
  updates: Array<Gender_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_AchievementArgs = {
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  where: Guide_Achievement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Achievement_By_PkArgs = {
  _inc?: InputMaybe<Guide_Achievement_Inc_Input>;
  _set?: InputMaybe<Guide_Achievement_Set_Input>;
  pk_columns: Guide_Achievement_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Achievement_ManyArgs = {
  updates: Array<Guide_Achievement_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_InputArgs = {
  _append?: InputMaybe<Guide_Input_Append_Input>;
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  _set?: InputMaybe<Guide_Input_Set_Input>;
  where: Guide_Input_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Input_By_PkArgs = {
  _append?: InputMaybe<Guide_Input_Append_Input>;
  _delete_at_path?: InputMaybe<Guide_Input_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Guide_Input_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Guide_Input_Delete_Key_Input>;
  _inc?: InputMaybe<Guide_Input_Inc_Input>;
  _prepend?: InputMaybe<Guide_Input_Prepend_Input>;
  _set?: InputMaybe<Guide_Input_Set_Input>;
  pk_columns: Guide_Input_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Guide_Input_ManyArgs = {
  updates: Array<Guide_Input_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_DataArgs = {
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  where: Investigator_Data_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_Data_By_PkArgs = {
  _append?: InputMaybe<Investigator_Data_Append_Input>;
  _delete_at_path?: InputMaybe<Investigator_Data_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Investigator_Data_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Investigator_Data_Delete_Key_Input>;
  _inc?: InputMaybe<Investigator_Data_Inc_Input>;
  _prepend?: InputMaybe<Investigator_Data_Prepend_Input>;
  _set?: InputMaybe<Investigator_Data_Set_Input>;
  pk_columns: Investigator_Data_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Investigator_Data_ManyArgs = {
  updates: Array<Investigator_Data_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Latest_DecksArgs = {
  _inc?: InputMaybe<Latest_Decks_Inc_Input>;
  _set?: InputMaybe<Latest_Decks_Set_Input>;
  where: Latest_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Latest_Decks_ManyArgs = {
  updates: Array<Latest_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Local_DecksArgs = {
  _inc?: InputMaybe<Local_Decks_Inc_Input>;
  _set?: InputMaybe<Local_Decks_Set_Input>;
  where: Local_Decks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Local_Decks_ManyArgs = {
  updates: Array<Local_Decks_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PackArgs = {
  _inc?: InputMaybe<Pack_Inc_Input>;
  _set?: InputMaybe<Pack_Set_Input>;
  where: Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_By_PkArgs = {
  _inc?: InputMaybe<Pack_Inc_Input>;
  _set?: InputMaybe<Pack_Set_Input>;
  pk_columns: Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_ManyArgs = {
  updates: Array<Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_NameArgs = {
  _set?: InputMaybe<Pack_Name_Set_Input>;
  where: Pack_Name_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_Name_By_PkArgs = {
  _set?: InputMaybe<Pack_Name_Set_Input>;
  pk_columns: Pack_Name_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Pack_Name_ManyArgs = {
  updates: Array<Pack_Name_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_AreaArgs = {
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  where: Rangers_Area_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_By_PkArgs = {
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  pk_columns: Rangers_Area_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_ManyArgs = {
  updates: Array<Rangers_Area_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_TextArgs = {
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  where: Rangers_Area_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  pk_columns: Rangers_Area_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Area_Text_ManyArgs = {
  updates: Array<Rangers_Area_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_AspectArgs = {
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  where: Rangers_Aspect_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_By_PkArgs = {
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  pk_columns: Rangers_Aspect_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_ManyArgs = {
  updates: Array<Rangers_Aspect_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_TextArgs = {
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  where: Rangers_Aspect_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  pk_columns: Rangers_Aspect_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Aspect_Text_ManyArgs = {
  updates: Array<Rangers_Aspect_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CampaignArgs = {
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  where: Rangers_Campaign_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_AccessArgs = {
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  where: Rangers_Campaign_Access_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_Access_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  pk_columns: Rangers_Campaign_Access_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_Access_ManyArgs = {
  updates: Array<Rangers_Campaign_Access_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_By_PkArgs = {
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  pk_columns: Rangers_Campaign_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Campaign_ManyArgs = {
  updates: Array<Rangers_Campaign_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CardArgs = {
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  where: Rangers_Card_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_By_PkArgs = {
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  pk_columns: Rangers_Card_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_ManyArgs = {
  updates: Array<Rangers_Card_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_TextArgs = {
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  where: Rangers_Card_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  pk_columns: Rangers_Card_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Card_Text_ManyArgs = {
  updates: Array<Rangers_Card_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_CommentArgs = {
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  where: Rangers_Comment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Comment_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  pk_columns: Rangers_Comment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Comment_ManyArgs = {
  updates: Array<Rangers_Comment_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_DeckArgs = {
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  where: Rangers_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_By_PkArgs = {
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  pk_columns: Rangers_Deck_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_CopyArgs = {
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  where: Rangers_Deck_Copy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Copy_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  pk_columns: Rangers_Deck_Copy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Copy_ManyArgs = {
  updates: Array<Rangers_Deck_Copy_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_LikeArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  where: Rangers_Deck_Like_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  pk_columns: Rangers_Deck_Like_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_CountArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  where: Rangers_Deck_Like_Count_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_Count_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  pk_columns: Rangers_Deck_Like_Count_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_Count_ManyArgs = {
  updates: Array<Rangers_Deck_Like_Count_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_Like_ManyArgs = {
  updates: Array<Rangers_Deck_Like_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Deck_ManyArgs = {
  updates: Array<Rangers_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_EntryArgs = {
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  where: Rangers_Faq_Entry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_Entry_By_PkArgs = {
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  pk_columns: Rangers_Faq_Entry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Faq_Entry_ManyArgs = {
  updates: Array<Rangers_Faq_Entry_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_StatusArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  where: Rangers_Friend_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_By_PkArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  pk_columns: Rangers_Friend_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_ManyArgs = {
  updates: Array<Rangers_Friend_Status_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_TypeArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  where: Rangers_Friend_Status_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  pk_columns: Rangers_Friend_Status_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Friend_Status_Type_ManyArgs = {
  updates: Array<Rangers_Friend_Status_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Latest_DeckArgs = {
  _inc?: InputMaybe<Rangers_Latest_Deck_Inc_Input>;
  _set?: InputMaybe<Rangers_Latest_Deck_Set_Input>;
  where: Rangers_Latest_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Latest_Deck_ManyArgs = {
  updates: Array<Rangers_Latest_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_LocaleArgs = {
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  where: Rangers_Locale_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Locale_By_PkArgs = {
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  pk_columns: Rangers_Locale_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Locale_ManyArgs = {
  updates: Array<Rangers_Locale_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_PackArgs = {
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  where: Rangers_Pack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  pk_columns: Rangers_Pack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_ManyArgs = {
  updates: Array<Rangers_Pack_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_TextArgs = {
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  where: Rangers_Pack_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  pk_columns: Rangers_Pack_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Pack_Text_ManyArgs = {
  updates: Array<Rangers_Pack_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Search_DeckArgs = {
  _append?: InputMaybe<Rangers_Search_Deck_Append_Input>;
  _delete_at_path?: InputMaybe<Rangers_Search_Deck_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Rangers_Search_Deck_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Rangers_Search_Deck_Delete_Key_Input>;
  _inc?: InputMaybe<Rangers_Search_Deck_Inc_Input>;
  _prepend?: InputMaybe<Rangers_Search_Deck_Prepend_Input>;
  _set?: InputMaybe<Rangers_Search_Deck_Set_Input>;
  where: Rangers_Search_Deck_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Search_Deck_ManyArgs = {
  updates: Array<Rangers_Search_Deck_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_SetArgs = {
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  where: Rangers_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_By_PkArgs = {
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  pk_columns: Rangers_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_ManyArgs = {
  updates: Array<Rangers_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_TextArgs = {
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  where: Rangers_Set_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  pk_columns: Rangers_Set_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Text_ManyArgs = {
  updates: Array<Rangers_Set_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_TypeArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  where: Rangers_Set_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  pk_columns: Rangers_Set_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_ManyArgs = {
  updates: Array<Rangers_Set_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_TextArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  where: Rangers_Set_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  pk_columns: Rangers_Set_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Set_Type_Text_ManyArgs = {
  updates: Array<Rangers_Set_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_TokenArgs = {
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  where: Rangers_Token_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_By_PkArgs = {
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  pk_columns: Rangers_Token_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_ManyArgs = {
  updates: Array<Rangers_Token_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_TextArgs = {
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  where: Rangers_Token_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  pk_columns: Rangers_Token_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Token_Text_ManyArgs = {
  updates: Array<Rangers_Token_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_TypeArgs = {
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  where: Rangers_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_By_PkArgs = {
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  pk_columns: Rangers_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_ManyArgs = {
  updates: Array<Rangers_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_TextArgs = {
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  where: Rangers_Type_Text_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_Text_By_PkArgs = {
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  pk_columns: Rangers_Type_Text_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Type_Text_ManyArgs = {
  updates: Array<Rangers_Type_Text_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_FriendsArgs = {
  _set?: InputMaybe<Rangers_User_Friends_Set_Input>;
  where: Rangers_User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Friends_ManyArgs = {
  updates: Array<Rangers_User_Friends_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Received_Friend_RequestsArgs = {
  _set?: InputMaybe<Rangers_User_Received_Friend_Requests_Set_Input>;
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Received_Friend_Requests_ManyArgs = {
  updates: Array<Rangers_User_Received_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_RoleArgs = {
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  where: Rangers_User_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Role_By_PkArgs = {
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  pk_columns: Rangers_User_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Role_ManyArgs = {
  updates: Array<Rangers_User_Role_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Sent_Friend_RequestsArgs = {
  _set?: InputMaybe<Rangers_User_Sent_Friend_Requests_Set_Input>;
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Sent_Friend_Requests_ManyArgs = {
  updates: Array<Rangers_User_Sent_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_SettingsArgs = {
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  where: Rangers_User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Settings_By_PkArgs = {
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  pk_columns: Rangers_User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_User_Settings_ManyArgs = {
  updates: Array<Rangers_User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_UsersArgs = {
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  where: Rangers_Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Users_By_PkArgs = {
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  pk_columns: Rangers_Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Rangers_Users_ManyArgs = {
  updates: Array<Rangers_Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_SetArgs = {
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  where: Taboo_Set_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_Set_By_PkArgs = {
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  pk_columns: Taboo_Set_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Taboo_Set_ManyArgs = {
  updates: Array<Taboo_Set_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_CampaignsArgs = {
  _inc?: InputMaybe<User_Campaigns_Inc_Input>;
  _set?: InputMaybe<User_Campaigns_Set_Input>;
  where: User_Campaigns_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Campaigns_ManyArgs = {
  updates: Array<User_Campaigns_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_FlagArgs = {
  _set?: InputMaybe<User_Flag_Set_Input>;
  where: User_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_By_PkArgs = {
  _set?: InputMaybe<User_Flag_Set_Input>;
  pk_columns: User_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_ManyArgs = {
  updates: Array<User_Flag_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_TypeArgs = {
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  where: User_Flag_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_Type_By_PkArgs = {
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  pk_columns: User_Flag_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Flag_Type_ManyArgs = {
  updates: Array<User_Flag_Type_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_FriendsArgs = {
  _set?: InputMaybe<User_Friends_Set_Input>;
  where: User_Friends_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Friends_ManyArgs = {
  updates: Array<User_Friends_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Received_Friend_RequestsArgs = {
  _set?: InputMaybe<User_Received_Friend_Requests_Set_Input>;
  where: User_Received_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Received_Friend_Requests_ManyArgs = {
  updates: Array<User_Received_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_Sent_Friend_RequestsArgs = {
  _set?: InputMaybe<User_Sent_Friend_Requests_Set_Input>;
  where: User_Sent_Friend_Requests_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Sent_Friend_Requests_ManyArgs = {
  updates: Array<User_Sent_Friend_Requests_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_SettingsArgs = {
  _append?: InputMaybe<User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  _set?: InputMaybe<User_Settings_Set_Input>;
  where: User_Settings_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Settings_By_PkArgs = {
  _append?: InputMaybe<User_Settings_Append_Input>;
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  _set?: InputMaybe<User_Settings_Set_Input>;
  pk_columns: User_Settings_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Settings_ManyArgs = {
  updates: Array<User_Settings_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _set?: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _set?: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};


/** mutation root */
export type Mutation_RootUpgradeArkhamDbDeckArgs = {
  args: UpgradeDeckInput;
};


/** mutation root */
export type Mutation_RootUploadLocalCampaignDeckArgs = {
  args: UploadLocalCampaignDeckInput;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "pack" */
export type Pack = {
  __typename?: 'pack';
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  /** An object relationship */
  cycle: Cycle;
  cycle_code: Scalars['String']['output'];
  official: Scalars['Boolean']['output'];
  position: Scalars['Int']['output'];
  real_name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Pack_Name>;
  /** An aggregate relationship */
  translations_aggregate: Pack_Name_Aggregate;
};


/** columns and relationships of "pack" */
export type PackCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


/** columns and relationships of "pack" */
export type PackTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};

/** aggregated selection of "pack" */
export type Pack_Aggregate = {
  __typename?: 'pack_aggregate';
  aggregate?: Maybe<Pack_Aggregate_Fields>;
  nodes: Array<Pack>;
};

export type Pack_Aggregate_Bool_Exp = {
  bool_and?: InputMaybe<Pack_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: InputMaybe<Pack_Aggregate_Bool_Exp_Bool_Or>;
  count?: InputMaybe<Pack_Aggregate_Bool_Exp_Count>;
};

export type Pack_Aggregate_Bool_Exp_Bool_And = {
  arguments: Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Pack_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Pack_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pack" */
export type Pack_Aggregate_Fields = {
  __typename?: 'pack_aggregate_fields';
  avg?: Maybe<Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Pack_Max_Fields>;
  min?: Maybe<Pack_Min_Fields>;
  stddev?: Maybe<Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Pack_Sum_Fields>;
  var_pop?: Maybe<Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Pack_Var_Samp_Fields>;
  variance?: Maybe<Pack_Variance_Fields>;
};


/** aggregate fields of "pack" */
export type Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "pack" */
export type Pack_Aggregate_Order_By = {
  avg?: InputMaybe<Pack_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Pack_Max_Order_By>;
  min?: InputMaybe<Pack_Min_Order_By>;
  stddev?: InputMaybe<Pack_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Pack_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Pack_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Pack_Sum_Order_By>;
  var_pop?: InputMaybe<Pack_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Pack_Var_Samp_Order_By>;
  variance?: InputMaybe<Pack_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "pack" */
export type Pack_Arr_Rel_Insert_Input = {
  data: Array<Pack_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};

/** aggregate avg on columns */
export type Pack_Avg_Fields = {
  __typename?: 'pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "pack" */
export type Pack_Avg_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "pack". All fields are combined with a logical 'AND'. */
export type Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Pack_Bool_Exp>>;
  _not?: InputMaybe<Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Pack_Bool_Exp>>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  cycle?: InputMaybe<Cycle_Bool_Exp>;
  cycle_code?: InputMaybe<String_Comparison_Exp>;
  official?: InputMaybe<Boolean_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Pack_Name_Bool_Exp>;
  translations_aggregate?: InputMaybe<Pack_Name_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "pack" */
export enum Pack_Constraint {
  /** unique or primary key constraint on columns "code" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "pack" */
export type Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "pack" */
export type Pack_Insert_Input = {
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  cycle?: InputMaybe<Cycle_Obj_Rel_Insert_Input>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Pack_Name_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Pack_Max_Fields = {
  __typename?: 'pack_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "pack" */
export type Pack_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Pack_Min_Fields = {
  __typename?: 'pack_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  cycle_code?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "pack" */
export type Pack_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "pack" */
export type Pack_Mutation_Response = {
  __typename?: 'pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Pack>;
};

/** columns and relationships of "pack_name" */
export type Pack_Name = {
  __typename?: 'pack_name';
  code: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "pack_name" */
export type Pack_Name_Aggregate = {
  __typename?: 'pack_name_aggregate';
  aggregate?: Maybe<Pack_Name_Aggregate_Fields>;
  nodes: Array<Pack_Name>;
};

export type Pack_Name_Aggregate_Bool_Exp = {
  count?: InputMaybe<Pack_Name_Aggregate_Bool_Exp_Count>;
};

export type Pack_Name_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Pack_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Pack_Name_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "pack_name" */
export type Pack_Name_Aggregate_Fields = {
  __typename?: 'pack_name_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Pack_Name_Max_Fields>;
  min?: Maybe<Pack_Name_Min_Fields>;
};


/** aggregate fields of "pack_name" */
export type Pack_Name_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Pack_Name_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "pack_name" */
export type Pack_Name_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Pack_Name_Max_Order_By>;
  min?: InputMaybe<Pack_Name_Min_Order_By>;
};

/** input type for inserting array relation for remote table "pack_name" */
export type Pack_Name_Arr_Rel_Insert_Input = {
  data: Array<Pack_Name_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_Name_On_Conflict>;
};

/** Boolean expression to filter rows from the table "pack_name". All fields are combined with a logical 'AND'. */
export type Pack_Name_Bool_Exp = {
  _and?: InputMaybe<Array<Pack_Name_Bool_Exp>>;
  _not?: InputMaybe<Pack_Name_Bool_Exp>;
  _or?: InputMaybe<Array<Pack_Name_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "pack_name" */
export enum Pack_Name_Constraint {
  /** unique or primary key constraint on columns "locale", "code" */
  PackNamePkey = 'pack_name_pkey'
}

/** input type for inserting data into table "pack_name" */
export type Pack_Name_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Pack_Name_Max_Fields = {
  __typename?: 'pack_name_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "pack_name" */
export type Pack_Name_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Pack_Name_Min_Fields = {
  __typename?: 'pack_name_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "pack_name" */
export type Pack_Name_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "pack_name" */
export type Pack_Name_Mutation_Response = {
  __typename?: 'pack_name_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Pack_Name>;
};

/** on_conflict condition type for table "pack_name" */
export type Pack_Name_On_Conflict = {
  constraint: Pack_Name_Constraint;
  update_columns?: Array<Pack_Name_Update_Column>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};

/** Ordering options when selecting data from "pack_name". */
export type Pack_Name_Order_By = {
  code?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: pack_name */
export type Pack_Name_Pk_Columns_Input = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "pack_name" */
export enum Pack_Name_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "pack_name" */
export type Pack_Name_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "pack_name" */
export type Pack_Name_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pack_Name_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pack_Name_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "pack_name" */
export enum Pack_Name_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Pack_Name_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Pack_Name_Set_Input>;
  /** filter the rows which have to be updated */
  where: Pack_Name_Bool_Exp;
};

/** input type for inserting object relation for remote table "pack" */
export type Pack_Obj_Rel_Insert_Input = {
  data: Pack_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Pack_On_Conflict>;
};

/** on_conflict condition type for table "pack" */
export type Pack_On_Conflict = {
  constraint: Pack_Constraint;
  update_columns?: Array<Pack_Update_Column>;
  where?: InputMaybe<Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "pack". */
export type Pack_Order_By = {
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  cycle?: InputMaybe<Cycle_Order_By>;
  cycle_code?: InputMaybe<Order_By>;
  official?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Pack_Name_Aggregate_Order_By>;
};

/** primary key columns input for table: pack */
export type Pack_Pk_Columns_Input = {
  code: Scalars['String']['input'];
};

/** select columns of table "pack" */
export enum Pack_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

/** select "pack_aggregate_bool_exp_bool_and_arguments_columns" columns of table "pack" */
export enum Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** select "pack_aggregate_bool_exp_bool_or_arguments_columns" columns of table "pack" */
export enum Pack_Select_Column_Pack_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Official = 'official'
}

/** input type for updating data in table "pack" */
export type Pack_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Pack_Stddev_Fields = {
  __typename?: 'pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "pack" */
export type Pack_Stddev_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Pack_Stddev_Pop_Fields = {
  __typename?: 'pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "pack" */
export type Pack_Stddev_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Pack_Stddev_Samp_Fields = {
  __typename?: 'pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "pack" */
export type Pack_Stddev_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "pack" */
export type Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pack_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  cycle_code?: InputMaybe<Scalars['String']['input']>;
  official?: InputMaybe<Scalars['Boolean']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Pack_Sum_Fields = {
  __typename?: 'pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "pack" */
export type Pack_Sum_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** update columns of table "pack" */
export enum Pack_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CycleCode = 'cycle_code',
  /** column name */
  Official = 'official',
  /** column name */
  Position = 'position',
  /** column name */
  RealName = 'real_name'
}

export type Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pack_Var_Pop_Fields = {
  __typename?: 'pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "pack" */
export type Pack_Var_Pop_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Pack_Var_Samp_Fields = {
  __typename?: 'pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "pack" */
export type Pack_Var_Samp_Order_By = {
  position?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Pack_Variance_Fields = {
  __typename?: 'pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "pack" */
export type Pack_Variance_Order_By = {
  position?: InputMaybe<Order_By>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "all_card" */
  all_card: Array<All_Card>;
  /** fetch aggregated fields from the table: "all_card" */
  all_card_aggregate: All_Card_Aggregate;
  /** fetch data from the table: "all_card" using primary key columns */
  all_card_by_pk?: Maybe<All_Card>;
  /** fetch data from the table: "all_card_text" */
  all_card_text: Array<All_Card_Text>;
  /** fetch aggregated fields from the table: "all_card_text" */
  all_card_text_aggregate: All_Card_Text_Aggregate;
  /** fetch data from the table: "all_card_text" using primary key columns */
  all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** fetch data from the table: "all_card_updated" */
  all_card_updated: Array<All_Card_Updated>;
  /** fetch aggregated fields from the table: "all_card_updated" */
  all_card_updated_aggregate: All_Card_Updated_Aggregate;
  /** fetch data from the table: "all_card_updated" using primary key columns */
  all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** fetch data from the table: "all_card_updated_by_version" */
  all_card_updated_by_version: Array<All_Card_Updated_By_Version>;
  /** fetch aggregated fields from the table: "all_card_updated_by_version" */
  all_card_updated_by_version_aggregate: All_Card_Updated_By_Version_Aggregate;
  /** fetch data from the table: "all_card_updated_by_version" using primary key columns */
  all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** fetch data from the table: "arkhamdb_auth" */
  arkhamdb_auth: Array<Arkhamdb_Auth>;
  /** fetch aggregated fields from the table: "arkhamdb_auth" */
  arkhamdb_auth_aggregate: Arkhamdb_Auth_Aggregate;
  /** fetch data from the table: "arkhamdb_auth" using primary key columns */
  arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** fetch data from the table: "arkhamdb_deck" */
  arkhamdb_deck: Array<Arkhamdb_Deck>;
  /** fetch aggregated fields from the table: "arkhamdb_deck" */
  arkhamdb_deck_aggregate: Arkhamdb_Deck_Aggregate;
  /** fetch data from the table: "arkhamdb_deck" using primary key columns */
  arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  /** fetch data from the table: "campaign" */
  campaign: Array<Campaign>;
  /** fetch data from the table: "campaign_access" */
  campaign_access: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign_access" */
  campaign_access_aggregate: Campaign_Access_Aggregate;
  /** fetch data from the table: "campaign_access" using primary key columns */
  campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign" */
  campaign_aggregate: Campaign_Aggregate;
  /** fetch data from the table: "campaign" using primary key columns */
  campaign_by_pk?: Maybe<Campaign>;
  /** fetch data from the table: "campaign_deck" */
  campaign_deck: Array<Campaign_Deck>;
  /** fetch aggregated fields from the table: "campaign_deck" */
  campaign_deck_aggregate: Campaign_Deck_Aggregate;
  /** fetch data from the table: "campaign_deck" using primary key columns */
  campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** fetch data from the table: "campaign_difficulty" */
  campaign_difficulty: Array<Campaign_Difficulty>;
  /** fetch aggregated fields from the table: "campaign_difficulty" */
  campaign_difficulty_aggregate: Campaign_Difficulty_Aggregate;
  /** fetch data from the table: "campaign_difficulty" using primary key columns */
  campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** fetch data from the table: "campaign_guide" */
  campaign_guide: Array<Campaign_Guide>;
  /** fetch aggregated fields from the table: "campaign_guide" */
  campaign_guide_aggregate: Campaign_Guide_Aggregate;
  /** fetch data from the table: "campaign_investigator" */
  campaign_investigator: Array<Campaign_Investigator>;
  /** fetch aggregated fields from the table: "campaign_investigator" */
  campaign_investigator_aggregate: Campaign_Investigator_Aggregate;
  /** fetch data from the table: "campaign_investigator" using primary key columns */
  campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** fetch data from the table: "campaigns_by_cycle" */
  campaigns_by_cycle: Array<Campaigns_By_Cycle>;
  /** fetch aggregated fields from the table: "campaigns_by_cycle" */
  campaigns_by_cycle_aggregate: Campaigns_By_Cycle_Aggregate;
  /** fetch data from the table: "card" */
  card: Array<Card>;
  /** fetch aggregated fields from the table: "card" */
  card_aggregate: Card_Aggregate;
  /** fetch data from the table: "card" using primary key columns */
  card_by_pk?: Maybe<Card>;
  /** fetch data from the table: "card_cycle" */
  card_cycle: Array<Card_Cycle>;
  /** fetch aggregated fields from the table: "card_cycle" */
  card_cycle_aggregate: Card_Cycle_Aggregate;
  /** fetch data from the table: "card_cycle" using primary key columns */
  card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** fetch data from the table: "card_encounter_set" */
  card_encounter_set: Array<Card_Encounter_Set>;
  /** fetch aggregated fields from the table: "card_encounter_set" */
  card_encounter_set_aggregate: Card_Encounter_Set_Aggregate;
  /** fetch data from the table: "card_encounter_set" using primary key columns */
  card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** fetch data from the table: "card_pack" */
  card_pack: Array<Card_Pack>;
  /** fetch aggregated fields from the table: "card_pack" */
  card_pack_aggregate: Card_Pack_Aggregate;
  /** fetch data from the table: "card_pack" using primary key columns */
  card_pack_by_pk?: Maybe<Card_Pack>;
  /** fetch data from the table: "card_subtype_name" */
  card_subtype_name: Array<Card_Subtype_Name>;
  /** fetch aggregated fields from the table: "card_subtype_name" */
  card_subtype_name_aggregate: Card_Subtype_Name_Aggregate;
  /** fetch data from the table: "card_subtype_name" using primary key columns */
  card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** fetch data from the table: "card_text" */
  card_text: Array<Card_Text>;
  /** fetch aggregated fields from the table: "card_text" */
  card_text_aggregate: Card_Text_Aggregate;
  /** fetch data from the table: "card_text" using primary key columns */
  card_text_by_pk?: Maybe<Card_Text>;
  /** fetch data from the table: "card_type_code" */
  card_type_code: Array<Card_Type_Code>;
  /** fetch aggregated fields from the table: "card_type_code" */
  card_type_code_aggregate: Card_Type_Code_Aggregate;
  /** fetch data from the table: "card_type_code" using primary key columns */
  card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** fetch data from the table: "card_type_name" */
  card_type_name: Array<Card_Type_Name>;
  /** fetch aggregated fields from the table: "card_type_name" */
  card_type_name_aggregate: Card_Type_Name_Aggregate;
  /** fetch data from the table: "card_type_name" using primary key columns */
  card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  /** fetch data from the table: "chaos_bag_result" using primary key columns */
  chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** fetch data from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch aggregated fields from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_aggregate: Chaos_Bag_Tarot_Mode_Aggregate;
  /** fetch data from the table: "chaos_bag_tarot_mode" using primary key columns */
  chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table: "conquest.card" */
  conquest_card: Array<Conquest_Card>;
  /** fetch aggregated fields from the table: "conquest.card" */
  conquest_card_aggregate: Conquest_Card_Aggregate;
  /** fetch data from the table: "conquest.card" using primary key columns */
  conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** fetch data from the table: "conquest.card_localized" */
  conquest_card_localized: Array<Conquest_Card_Localized>;
  /** fetch aggregated fields from the table: "conquest.card_localized" */
  conquest_card_localized_aggregate: Conquest_Card_Localized_Aggregate;
  /** fetch data from the table: "conquest.card_text" */
  conquest_card_text: Array<Conquest_Card_Text>;
  /** fetch aggregated fields from the table: "conquest.card_text" */
  conquest_card_text_aggregate: Conquest_Card_Text_Aggregate;
  /** fetch data from the table: "conquest.card_text" using primary key columns */
  conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** fetch data from the table: "conquest.card_updated" */
  conquest_card_updated: Array<Conquest_Card_Updated>;
  /** fetch aggregated fields from the table: "conquest.card_updated" */
  conquest_card_updated_aggregate: Conquest_Card_Updated_Aggregate;
  /** fetch data from the table: "conquest.comment" */
  conquest_comment: Array<Conquest_Comment>;
  /** fetch aggregated fields from the table: "conquest.comment" */
  conquest_comment_aggregate: Conquest_Comment_Aggregate;
  /** fetch data from the table: "conquest.comment" using primary key columns */
  conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** fetch data from the table: "conquest.cycle" */
  conquest_cycle: Array<Conquest_Cycle>;
  /** fetch aggregated fields from the table: "conquest.cycle" */
  conquest_cycle_aggregate: Conquest_Cycle_Aggregate;
  /** fetch data from the table: "conquest.cycle" using primary key columns */
  conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** fetch data from the table: "conquest.cycle_text" */
  conquest_cycle_text: Array<Conquest_Cycle_Text>;
  /** fetch aggregated fields from the table: "conquest.cycle_text" */
  conquest_cycle_text_aggregate: Conquest_Cycle_Text_Aggregate;
  /** fetch data from the table: "conquest.cycle_text" using primary key columns */
  conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** fetch data from the table: "conquest.deck" */
  conquest_deck: Array<Conquest_Deck>;
  /** fetch aggregated fields from the table: "conquest.deck" */
  conquest_deck_aggregate: Conquest_Deck_Aggregate;
  /** fetch data from the table: "conquest.deck" using primary key columns */
  conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** fetch data from the table: "conquest.deck_copy" */
  conquest_deck_copy: Array<Conquest_Deck_Copy>;
  /** fetch aggregated fields from the table: "conquest.deck_copy" */
  conquest_deck_copy_aggregate: Conquest_Deck_Copy_Aggregate;
  /** fetch data from the table: "conquest.deck_copy" using primary key columns */
  conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** fetch data from the table: "conquest.deck_like" */
  conquest_deck_like: Array<Conquest_Deck_Like>;
  /** fetch aggregated fields from the table: "conquest.deck_like" */
  conquest_deck_like_aggregate: Conquest_Deck_Like_Aggregate;
  /** fetch data from the table: "conquest.deck_like" using primary key columns */
  conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** fetch data from the table: "conquest.faction" */
  conquest_faction: Array<Conquest_Faction>;
  /** fetch aggregated fields from the table: "conquest.faction" */
  conquest_faction_aggregate: Conquest_Faction_Aggregate;
  /** fetch data from the table: "conquest.faction" using primary key columns */
  conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** fetch data from the table: "conquest.faction_text" */
  conquest_faction_text: Array<Conquest_Faction_Text>;
  /** fetch aggregated fields from the table: "conquest.faction_text" */
  conquest_faction_text_aggregate: Conquest_Faction_Text_Aggregate;
  /** fetch data from the table: "conquest.faction_text" using primary key columns */
  conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** fetch data from the table: "conquest.loyalty" */
  conquest_loyalty: Array<Conquest_Loyalty>;
  /** fetch aggregated fields from the table: "conquest.loyalty" */
  conquest_loyalty_aggregate: Conquest_Loyalty_Aggregate;
  /** fetch data from the table: "conquest.loyalty" using primary key columns */
  conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** fetch data from the table: "conquest.loyalty_text" */
  conquest_loyalty_text: Array<Conquest_Loyalty_Text>;
  /** fetch aggregated fields from the table: "conquest.loyalty_text" */
  conquest_loyalty_text_aggregate: Conquest_Loyalty_Text_Aggregate;
  /** fetch data from the table: "conquest.loyalty_text" using primary key columns */
  conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** fetch data from the table: "conquest.pack" */
  conquest_pack: Array<Conquest_Pack>;
  /** fetch aggregated fields from the table: "conquest.pack" */
  conquest_pack_aggregate: Conquest_Pack_Aggregate;
  /** fetch data from the table: "conquest.pack" using primary key columns */
  conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** fetch data from the table: "conquest.pack_text" */
  conquest_pack_text: Array<Conquest_Pack_Text>;
  /** fetch aggregated fields from the table: "conquest.pack_text" */
  conquest_pack_text_aggregate: Conquest_Pack_Text_Aggregate;
  /** fetch data from the table: "conquest.pack_text" using primary key columns */
  conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** fetch data from the table: "conquest.type" */
  conquest_type: Array<Conquest_Type>;
  /** fetch aggregated fields from the table: "conquest.type" */
  conquest_type_aggregate: Conquest_Type_Aggregate;
  /** fetch data from the table: "conquest.type" using primary key columns */
  conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** fetch data from the table: "conquest.type_text" */
  conquest_type_text: Array<Conquest_Type_Text>;
  /** fetch aggregated fields from the table: "conquest.type_text" */
  conquest_type_text_aggregate: Conquest_Type_Text_Aggregate;
  /** fetch data from the table: "conquest.type_text" using primary key columns */
  conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** fetch data from the table: "conquest.user_role" */
  conquest_user_role: Array<Conquest_User_Role>;
  /** fetch aggregated fields from the table: "conquest.user_role" */
  conquest_user_role_aggregate: Conquest_User_Role_Aggregate;
  /** fetch data from the table: "conquest.user_role" using primary key columns */
  conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** fetch data from the table: "conquest.user_settings" */
  conquest_user_settings: Array<Conquest_User_Settings>;
  /** fetch aggregated fields from the table: "conquest.user_settings" */
  conquest_user_settings_aggregate: Conquest_User_Settings_Aggregate;
  /** fetch data from the table: "conquest.user_settings" using primary key columns */
  conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** fetch data from the table: "conquest.users" */
  conquest_users: Array<Conquest_Users>;
  /** fetch aggregated fields from the table: "conquest.users" */
  conquest_users_aggregate: Conquest_Users_Aggregate;
  /** fetch data from the table: "conquest.users" using primary key columns */
  conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** fetch data from the table: "cycle" */
  cycle: Array<Cycle>;
  /** fetch aggregated fields from the table: "cycle" */
  cycle_aggregate: Cycle_Aggregate;
  /** fetch data from the table: "cycle" using primary key columns */
  cycle_by_pk?: Maybe<Cycle>;
  /** fetch data from the table: "cycle_name" */
  cycle_name: Array<Cycle_Name>;
  /** fetch aggregated fields from the table: "cycle_name" */
  cycle_name_aggregate: Cycle_Name_Aggregate;
  /** fetch data from the table: "cycle_name" using primary key columns */
  cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** fetch data from the table: "faction_name" */
  faction_name: Array<Faction_Name>;
  /** fetch aggregated fields from the table: "faction_name" */
  faction_name_aggregate: Faction_Name_Aggregate;
  /** fetch data from the table: "faction_name" using primary key columns */
  faction_name_by_pk?: Maybe<Faction_Name>;
  /** fetch data from the table: "faq" */
  faq: Array<Faq>;
  /** fetch aggregated fields from the table: "faq" */
  faq_aggregate: Faq_Aggregate;
  /** fetch data from the table: "faq" using primary key columns */
  faq_by_pk?: Maybe<Faq>;
  /** fetch data from the table: "faq_text" */
  faq_text: Array<Faq_Text>;
  /** fetch aggregated fields from the table: "faq_text" */
  faq_text_aggregate: Faq_Text_Aggregate;
  /** fetch data from the table: "faq_text" using primary key columns */
  faq_text_by_pk?: Maybe<Faq_Text>;
  /** fetch data from the table: "friend_status" */
  friend_status: Array<Friend_Status>;
  /** fetch aggregated fields from the table: "friend_status" */
  friend_status_aggregate: Friend_Status_Aggregate;
  /** fetch data from the table: "friend_status" using primary key columns */
  friend_status_by_pk?: Maybe<Friend_Status>;
  /** fetch data from the table: "friend_status_type" */
  friend_status_type: Array<Friend_Status_Type>;
  /** fetch aggregated fields from the table: "friend_status_type" */
  friend_status_type_aggregate: Friend_Status_Type_Aggregate;
  /** fetch data from the table: "friend_status_type" using primary key columns */
  friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** fetch data from the table: "full_card" */
  full_card: Array<Full_Card>;
  /** fetch aggregated fields from the table: "full_card" */
  full_card_aggregate: Full_Card_Aggregate;
  /** fetch data from the table: "full_card" using primary key columns */
  full_card_by_pk?: Maybe<Full_Card>;
  /** fetch data from the table: "full_card_text" */
  full_card_text: Array<Full_Card_Text>;
  /** fetch aggregated fields from the table: "full_card_text" */
  full_card_text_aggregate: Full_Card_Text_Aggregate;
  /** fetch data from the table: "full_card_text" using primary key columns */
  full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  gender_aggregate: Gender_Aggregate;
  /** fetch data from the table: "gender" using primary key columns */
  gender_by_pk?: Maybe<Gender>;
  /** fetch data from the table: "guide_achievement" */
  guide_achievement: Array<Guide_Achievement>;
  /** fetch aggregated fields from the table: "guide_achievement" */
  guide_achievement_aggregate: Guide_Achievement_Aggregate;
  /** fetch data from the table: "guide_achievement" using primary key columns */
  guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** fetch data from the table: "guide_input" */
  guide_input: Array<Guide_Input>;
  /** fetch aggregated fields from the table: "guide_input" */
  guide_input_aggregate: Guide_Input_Aggregate;
  /** fetch data from the table: "guide_input" using primary key columns */
  guide_input_by_pk?: Maybe<Guide_Input>;
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** fetch data from the table: "investigator_data" using primary key columns */
  investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  /** fetch data from the table: "pack" */
  pack: Array<Pack>;
  /** fetch aggregated fields from the table: "pack" */
  pack_aggregate: Pack_Aggregate;
  /** fetch data from the table: "pack" using primary key columns */
  pack_by_pk?: Maybe<Pack>;
  /** fetch data from the table: "pack_name" */
  pack_name: Array<Pack_Name>;
  /** fetch aggregated fields from the table: "pack_name" */
  pack_name_aggregate: Pack_Name_Aggregate;
  /** fetch data from the table: "pack_name" using primary key columns */
  pack_name_by_pk?: Maybe<Pack_Name>;
  /** fetch data from the table: "rangers.area" */
  rangers_area: Array<Rangers_Area>;
  /** fetch aggregated fields from the table: "rangers.area" */
  rangers_area_aggregate: Rangers_Area_Aggregate;
  /** fetch data from the table: "rangers.area" using primary key columns */
  rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** fetch data from the table: "rangers.area_text" */
  rangers_area_text: Array<Rangers_Area_Text>;
  /** fetch aggregated fields from the table: "rangers.area_text" */
  rangers_area_text_aggregate: Rangers_Area_Text_Aggregate;
  /** fetch data from the table: "rangers.area_text" using primary key columns */
  rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** fetch data from the table: "rangers.aspect" */
  rangers_aspect: Array<Rangers_Aspect>;
  /** fetch aggregated fields from the table: "rangers.aspect" */
  rangers_aspect_aggregate: Rangers_Aspect_Aggregate;
  /** fetch data from the table: "rangers.aspect" using primary key columns */
  rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_localized" */
  rangers_aspect_localized: Array<Rangers_Aspect_Localized>;
  /** fetch aggregated fields from the table: "rangers.aspect_localized" */
  rangers_aspect_localized_aggregate: Rangers_Aspect_Localized_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" */
  rangers_aspect_text: Array<Rangers_Aspect_Text>;
  /** fetch aggregated fields from the table: "rangers.aspect_text" */
  rangers_aspect_text_aggregate: Rangers_Aspect_Text_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" using primary key columns */
  rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** fetch data from the table: "rangers.campaign" */
  rangers_campaign: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.campaign_access" */
  rangers_campaign_access: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign_access" */
  rangers_campaign_access_aggregate: Rangers_Campaign_Access_Aggregate;
  /** fetch data from the table: "rangers.campaign_access" using primary key columns */
  rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign" */
  rangers_campaign_aggregate: Rangers_Campaign_Aggregate;
  /** fetch data from the table: "rangers.campaign" using primary key columns */
  rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** fetch data from the table: "rangers.card" */
  rangers_card: Array<Rangers_Card>;
  /** fetch aggregated fields from the table: "rangers.card" */
  rangers_card_aggregate: Rangers_Card_Aggregate;
  /** fetch data from the table: "rangers.card" using primary key columns */
  rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** fetch data from the table: "rangers.card_localized" */
  rangers_card_localized: Array<Rangers_Card_Localized>;
  /** fetch aggregated fields from the table: "rangers.card_localized" */
  rangers_card_localized_aggregate: Rangers_Card_Localized_Aggregate;
  /** execute function "rangers.card_search" which returns "rangers.card_localized" */
  rangers_card_search: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized" */
  rangers_card_search_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table: "rangers.card_text" */
  rangers_card_text: Array<Rangers_Card_Text>;
  /** fetch aggregated fields from the table: "rangers.card_text" */
  rangers_card_text_aggregate: Rangers_Card_Text_Aggregate;
  /** fetch data from the table: "rangers.card_text" using primary key columns */
  rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** fetch data from the table: "rangers.card_updated" */
  rangers_card_updated: Array<Rangers_Card_Updated>;
  /** fetch aggregated fields from the table: "rangers.card_updated" */
  rangers_card_updated_aggregate: Rangers_Card_Updated_Aggregate;
  /** fetch data from the table: "rangers.comment" */
  rangers_comment: Array<Rangers_Comment>;
  /** fetch aggregated fields from the table: "rangers.comment" */
  rangers_comment_aggregate: Rangers_Comment_Aggregate;
  /** fetch data from the table: "rangers.comment" using primary key columns */
  rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** fetch data from the table: "rangers.deck" */
  rangers_deck: Array<Rangers_Deck>;
  /** fetch aggregated fields from the table: "rangers.deck" */
  rangers_deck_aggregate: Rangers_Deck_Aggregate;
  /** fetch data from the table: "rangers.deck" using primary key columns */
  rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** fetch data from the table: "rangers.deck_copy" */
  rangers_deck_copy: Array<Rangers_Deck_Copy>;
  /** fetch aggregated fields from the table: "rangers.deck_copy" */
  rangers_deck_copy_aggregate: Rangers_Deck_Copy_Aggregate;
  /** fetch data from the table: "rangers.deck_copy" using primary key columns */
  rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** fetch data from the table: "rangers.deck_like" */
  rangers_deck_like: Array<Rangers_Deck_Like>;
  /** fetch aggregated fields from the table: "rangers.deck_like" */
  rangers_deck_like_aggregate: Rangers_Deck_Like_Aggregate;
  /** fetch data from the table: "rangers.deck_like" using primary key columns */
  rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_like_count" */
  rangers_deck_like_count: Array<Rangers_Deck_Like_Count>;
  /** fetch aggregated fields from the table: "rangers.deck_like_count" */
  rangers_deck_like_count_aggregate: Rangers_Deck_Like_Count_Aggregate;
  /** fetch data from the table: "rangers.deck_like_count" using primary key columns */
  rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** fetch data from the table: "rangers.deck_rank" */
  rangers_deck_rank: Array<Rangers_Deck_Rank>;
  /** fetch aggregated fields from the table: "rangers.deck_rank" */
  rangers_deck_rank_aggregate: Rangers_Deck_Rank_Aggregate;
  /** execute function "rangers.deck_search" which returns "rangers.search_deck" */
  rangers_deck_search: Array<Rangers_Search_Deck>;
  /** execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck" */
  rangers_deck_search_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" */
  rangers_faq_entry: Array<Rangers_Faq_Entry>;
  /** fetch aggregated fields from the table: "rangers.faq_entry" */
  rangers_faq_entry_aggregate: Rangers_Faq_Entry_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" using primary key columns */
  rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** fetch data from the table: "rangers.friend_status" */
  rangers_friend_status: Array<Rangers_Friend_Status>;
  /** fetch aggregated fields from the table: "rangers.friend_status" */
  rangers_friend_status_aggregate: Rangers_Friend_Status_Aggregate;
  /** fetch data from the table: "rangers.friend_status" using primary key columns */
  rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** fetch data from the table: "rangers.friend_status_type" */
  rangers_friend_status_type: Array<Rangers_Friend_Status_Type>;
  /** fetch aggregated fields from the table: "rangers.friend_status_type" */
  rangers_friend_status_type_aggregate: Rangers_Friend_Status_Type_Aggregate;
  /** fetch data from the table: "rangers.friend_status_type" using primary key columns */
  rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** fetch data from the table: "rangers.latest_deck" */
  rangers_latest_deck: Array<Rangers_Latest_Deck>;
  /** fetch aggregated fields from the table: "rangers.latest_deck" */
  rangers_latest_deck_aggregate: Rangers_Latest_Deck_Aggregate;
  /** fetch data from the table: "rangers.locale" */
  rangers_locale: Array<Rangers_Locale>;
  /** fetch aggregated fields from the table: "rangers.locale" */
  rangers_locale_aggregate: Rangers_Locale_Aggregate;
  /** fetch data from the table: "rangers.locale" using primary key columns */
  rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** fetch data from the table: "rangers.pack" */
  rangers_pack: Array<Rangers_Pack>;
  /** fetch aggregated fields from the table: "rangers.pack" */
  rangers_pack_aggregate: Rangers_Pack_Aggregate;
  /** fetch data from the table: "rangers.pack" using primary key columns */
  rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** fetch data from the table: "rangers.pack_text" */
  rangers_pack_text: Array<Rangers_Pack_Text>;
  /** fetch aggregated fields from the table: "rangers.pack_text" */
  rangers_pack_text_aggregate: Rangers_Pack_Text_Aggregate;
  /** fetch data from the table: "rangers.pack_text" using primary key columns */
  rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** fetch data from the table: "rangers.search_deck" */
  rangers_search_deck: Array<Rangers_Search_Deck>;
  /** fetch aggregated fields from the table: "rangers.search_deck" */
  rangers_search_deck_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table: "rangers.set" */
  rangers_set: Array<Rangers_Set>;
  /** fetch aggregated fields from the table: "rangers.set" */
  rangers_set_aggregate: Rangers_Set_Aggregate;
  /** fetch data from the table: "rangers.set" using primary key columns */
  rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** fetch data from the table: "rangers.set_localized" */
  rangers_set_localized: Array<Rangers_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_localized" */
  rangers_set_localized_aggregate: Rangers_Set_Localized_Aggregate;
  /** fetch data from the table: "rangers.set_text" */
  rangers_set_text: Array<Rangers_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.set_text" */
  rangers_set_text_aggregate: Rangers_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.set_text" using primary key columns */
  rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** fetch data from the table: "rangers.set_type" */
  rangers_set_type: Array<Rangers_Set_Type>;
  /** fetch aggregated fields from the table: "rangers.set_type" */
  rangers_set_type_aggregate: Rangers_Set_Type_Aggregate;
  /** fetch data from the table: "rangers.set_type" using primary key columns */
  rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_localized" */
  rangers_set_type_localized: Array<Rangers_Set_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_type_localized" */
  rangers_set_type_localized_aggregate: Rangers_Set_Type_Localized_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" */
  rangers_set_type_text: Array<Rangers_Set_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.set_type_text" */
  rangers_set_type_text_aggregate: Rangers_Set_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" using primary key columns */
  rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** fetch data from the table: "rangers.token" */
  rangers_token: Array<Rangers_Token>;
  /** fetch aggregated fields from the table: "rangers.token" */
  rangers_token_aggregate: Rangers_Token_Aggregate;
  /** fetch data from the table: "rangers.token" using primary key columns */
  rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** fetch data from the table: "rangers.token_text" */
  rangers_token_text: Array<Rangers_Token_Text>;
  /** fetch aggregated fields from the table: "rangers.token_text" */
  rangers_token_text_aggregate: Rangers_Token_Text_Aggregate;
  /** fetch data from the table: "rangers.token_text" using primary key columns */
  rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** fetch data from the table: "rangers.type" */
  rangers_type: Array<Rangers_Type>;
  /** fetch aggregated fields from the table: "rangers.type" */
  rangers_type_aggregate: Rangers_Type_Aggregate;
  /** fetch data from the table: "rangers.type" using primary key columns */
  rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** fetch data from the table: "rangers.type_localized" */
  rangers_type_localized: Array<Rangers_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.type_localized" */
  rangers_type_localized_aggregate: Rangers_Type_Localized_Aggregate;
  /** fetch data from the table: "rangers.type_text" */
  rangers_type_text: Array<Rangers_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.type_text" */
  rangers_type_text_aggregate: Rangers_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.type_text" using primary key columns */
  rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** fetch data from the table: "rangers.user_campaign" */
  rangers_user_campaign: Array<Rangers_User_Campaign>;
  /** fetch aggregated fields from the table: "rangers.user_campaign" */
  rangers_user_campaign_aggregate: Rangers_User_Campaign_Aggregate;
  /** fetch data from the table: "rangers.user_friends" */
  rangers_user_friends: Array<Rangers_User_Friends>;
  /** fetch aggregated fields from the table: "rangers.user_friends" */
  rangers_user_friends_aggregate: Rangers_User_Friends_Aggregate;
  /** fetch data from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table: "rangers.user_role" */
  rangers_user_role: Array<Rangers_User_Role>;
  /** fetch aggregated fields from the table: "rangers.user_role" */
  rangers_user_role_aggregate: Rangers_User_Role_Aggregate;
  /** fetch data from the table: "rangers.user_role" using primary key columns */
  rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** fetch data from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table: "rangers.user_settings" */
  rangers_user_settings: Array<Rangers_User_Settings>;
  /** fetch aggregated fields from the table: "rangers.user_settings" */
  rangers_user_settings_aggregate: Rangers_User_Settings_Aggregate;
  /** fetch data from the table: "rangers.user_settings" using primary key columns */
  rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** fetch data from the table: "rangers.users" */
  rangers_users: Array<Rangers_Users>;
  /** fetch aggregated fields from the table: "rangers.users" */
  rangers_users_aggregate: Rangers_Users_Aggregate;
  /** fetch data from the table: "rangers.users" using primary key columns */
  rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** fetch data from the table: "taboo_set" */
  taboo_set: Array<Taboo_Set>;
  /** fetch aggregated fields from the table: "taboo_set" */
  taboo_set_aggregate: Taboo_Set_Aggregate;
  /** fetch data from the table: "taboo_set" using primary key columns */
  taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** fetch data from the table: "user_campaigns" */
  user_campaigns: Array<User_Campaigns>;
  /** fetch aggregated fields from the table: "user_campaigns" */
  user_campaigns_aggregate: User_Campaigns_Aggregate;
  /** fetch data from the table: "user_flag" */
  user_flag: Array<User_Flag>;
  /** fetch aggregated fields from the table: "user_flag" */
  user_flag_aggregate: User_Flag_Aggregate;
  /** fetch data from the table: "user_flag" using primary key columns */
  user_flag_by_pk?: Maybe<User_Flag>;
  /** fetch data from the table: "user_flag_type" */
  user_flag_type: Array<User_Flag_Type>;
  /** fetch aggregated fields from the table: "user_flag_type" */
  user_flag_type_aggregate: User_Flag_Type_Aggregate;
  /** fetch data from the table: "user_flag_type" using primary key columns */
  user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** fetch data from the table: "user_friends" */
  user_friends: Array<User_Friends>;
  /** fetch aggregated fields from the table: "user_friends" */
  user_friends_aggregate: User_Friends_Aggregate;
  /** fetch data from the table: "user_received_friend_requests" */
  user_received_friend_requests: Array<User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_received_friend_requests" */
  user_received_friend_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table: "user_sent_friend_requests" */
  user_sent_friend_requests: Array<User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_sent_friend_requests" */
  user_sent_friend_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table: "user_settings" */
  user_settings: Array<User_Settings>;
  /** fetch aggregated fields from the table: "user_settings" */
  user_settings_aggregate: User_Settings_Aggregate;
  /** fetch data from the table: "user_settings" using primary key columns */
  user_settings_by_pk?: Maybe<User_Settings>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  usersSearch?: Maybe<UsersSearchOutput>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
};


export type Query_RootAll_CardArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Query_RootAll_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Query_RootAll_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootAll_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Query_RootAll_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Query_RootAll_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootAll_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Query_RootAll_Card_Updated_By_VersionArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_Version_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Query_RootAll_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


export type Query_RootArkhamdb_AuthArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Query_RootArkhamdb_Auth_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Query_RootArkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootArkhamdb_DeckArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Query_RootArkhamdb_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Query_RootArkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Query_RootBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Query_RootCampaignArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Query_RootCampaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Query_RootCampaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Query_RootCampaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Query_RootCampaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_DeckArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Query_RootCampaign_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Query_RootCampaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootCampaign_DifficultyArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Query_RootCampaign_Difficulty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Query_RootCampaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootCampaign_GuideArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Query_RootCampaign_Guide_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Query_RootCampaign_InvestigatorArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Query_RootCampaign_Investigator_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Query_RootCampaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Query_RootCampaigns_By_CycleArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Query_RootCampaigns_By_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Query_RootCardArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Query_RootCard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Query_RootCard_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCard_CycleArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Query_RootCard_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Query_RootCard_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Encounter_SetArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Query_RootCard_Encounter_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Query_RootCard_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_PackArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Query_RootCard_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Query_RootCard_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Subtype_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Query_RootCard_Subtype_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Query_RootCard_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_TextArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Query_RootCard_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Query_RootCard_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootCard_Type_CodeArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Query_RootCard_Type_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Query_RootCard_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCard_Type_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Query_RootCard_Type_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Query_RootCard_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


export type Query_RootChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Query_RootChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Query_RootChaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootChaos_Bag_Tarot_ModeArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Query_RootChaos_Bag_Tarot_Mode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Query_RootChaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootConquest_CardArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Query_RootConquest_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Query_RootConquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Query_RootConquest_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Query_RootConquest_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Query_RootConquest_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Query_RootConquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Query_RootConquest_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Query_RootConquest_CommentArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Query_RootConquest_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Query_RootConquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootConquest_CycleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Query_RootConquest_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Query_RootConquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Cycle_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Query_RootConquest_Cycle_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Query_RootConquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Query_RootConquest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Query_RootConquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootConquest_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Query_RootConquest_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Query_RootConquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Query_RootConquest_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Query_RootConquest_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Query_RootConquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootConquest_FactionArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Query_RootConquest_Faction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Query_RootConquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Faction_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Query_RootConquest_Faction_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Query_RootConquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_LoyaltyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Loyalty_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Query_RootConquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_PackArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Query_RootConquest_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Query_RootConquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Query_RootConquest_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Query_RootConquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_TypeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Query_RootConquest_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Query_RootConquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Query_RootConquest_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Query_RootConquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootConquest_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Query_RootConquest_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Query_RootConquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootConquest_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Query_RootConquest_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Query_RootConquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootConquest_UsersArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Query_RootConquest_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Query_RootConquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootCycleArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Query_RootCycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Query_RootCycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootCycle_NameArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Query_RootCycle_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Query_RootCycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFaction_NameArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Query_RootFaction_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Query_RootFaction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFaqArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Query_RootFaq_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Query_RootFaq_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootFaq_TextArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Query_RootFaq_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Query_RootFaq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootFriend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Query_RootFriend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Query_RootFriend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Query_RootFriend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Query_RootFriend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Query_RootFriend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootFull_CardArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Query_RootFull_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Query_RootFull_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootFull_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Query_RootFull_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Query_RootFull_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootGenderArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Query_RootGender_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Query_RootGender_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootGuide_AchievementArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Query_RootGuide_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Query_RootGuide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Query_RootGuide_InputArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Query_RootGuide_Input_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Query_RootGuide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Query_RootInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Query_RootInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Query_RootInvestigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Query_RootLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Query_RootLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Query_RootLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Query_RootLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Query_RootPackArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Query_RootPack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Query_RootPack_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Query_RootPack_NameArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Query_RootPack_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Query_RootPack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_AreaArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Query_RootRangers_Area_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Query_RootRangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Area_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Query_RootRangers_Area_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Query_RootRangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_AspectArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Query_RootRangers_Aspect_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Query_RootRangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Aspect_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Query_RootRangers_Aspect_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Query_RootRangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Query_RootRangers_Campaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Query_RootRangers_Campaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Query_RootRangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Query_RootRangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootRangers_CardArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Query_RootRangers_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Query_RootRangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_SearchArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Query_RootRangers_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Query_RootRangers_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Query_RootRangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Query_RootRangers_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Query_RootRangers_CommentArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Query_RootRangers_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Query_RootRangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootRangers_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Query_RootRangers_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Query_RootRangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_Deck_Like_CountArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_Count_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Query_RootRangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


export type Query_RootRangers_Deck_RankArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Query_RootRangers_Deck_Rank_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Query_RootRangers_Deck_SearchArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Deck_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Faq_EntryArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Query_RootRangers_Faq_Entry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Query_RootRangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Friend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Query_RootRangers_Friend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Query_RootRangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootRangers_Latest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Query_RootRangers_Latest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Query_RootRangers_LocaleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Query_RootRangers_Locale_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Query_RootRangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_PackArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Query_RootRangers_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Query_RootRangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Query_RootRangers_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Query_RootRangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Search_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_Search_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Query_RootRangers_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Query_RootRangers_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Query_RootRangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_Set_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Set_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_TokenArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Query_RootRangers_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Query_RootRangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Token_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Query_RootRangers_Token_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Query_RootRangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Query_RootRangers_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Query_RootRangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Query_RootRangers_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Query_RootRangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Query_RootRangers_User_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Query_RootRangers_User_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Query_RootRangers_User_FriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Query_RootRangers_User_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Query_RootRangers_User_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Query_RootRangers_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Query_RootRangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootRangers_User_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootRangers_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Query_RootRangers_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Query_RootRangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootRangers_UsersArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Query_RootRangers_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Query_RootRangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Query_RootTaboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Query_RootTaboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Query_RootTaboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Query_RootUser_CampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Query_RootUser_Campaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Query_RootUser_FlagArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Query_RootUser_Flag_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Query_RootUser_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


export type Query_RootUser_Flag_TypeArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Query_RootUser_Flag_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Query_RootUser_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Query_RootUser_FriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Query_RootUser_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Query_RootUser_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Query_RootUser_SettingsArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Query_RootUser_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Query_RootUser_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Query_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsersSearchArgs = {
  args: UsersSearchInput;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['String']['input'];
};

/** columns and relationships of "rangers.area" */
export type Rangers_Area = {
  __typename?: 'rangers_area';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.area" */
export type Rangers_Area_Aggregate = {
  __typename?: 'rangers_area_aggregate';
  aggregate?: Maybe<Rangers_Area_Aggregate_Fields>;
  nodes: Array<Rangers_Area>;
};

/** aggregate fields of "rangers.area" */
export type Rangers_Area_Aggregate_Fields = {
  __typename?: 'rangers_area_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Area_Max_Fields>;
  min?: Maybe<Rangers_Area_Min_Fields>;
};


/** aggregate fields of "rangers.area" */
export type Rangers_Area_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.area". All fields are combined with a logical 'AND'. */
export type Rangers_Area_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Area_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Area_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Area_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.area" */
export enum Rangers_Area_Constraint {
  /** unique or primary key constraint on columns "id" */
  AreaPkey = 'area_pkey'
}

/** input type for inserting data into table "rangers.area" */
export type Rangers_Area_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Area_Max_Fields = {
  __typename?: 'rangers_area_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Area_Min_Fields = {
  __typename?: 'rangers_area_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.area" */
export type Rangers_Area_Mutation_Response = {
  __typename?: 'rangers_area_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Area>;
};

/** on_conflict condition type for table "rangers.area" */
export type Rangers_Area_On_Conflict = {
  constraint: Rangers_Area_Constraint;
  update_columns?: Array<Rangers_Area_Update_Column>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.area". */
export type Rangers_Area_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.area */
export type Rangers_Area_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.area" */
export enum Rangers_Area_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.area" */
export type Rangers_Area_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_area" */
export type Rangers_Area_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Area_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Area_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.area_text" */
export type Rangers_Area_Text = {
  __typename?: 'rangers_area_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate = {
  __typename?: 'rangers_area_text_aggregate';
  aggregate?: Maybe<Rangers_Area_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Area_Text>;
};

/** aggregate fields of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate_Fields = {
  __typename?: 'rangers_area_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Area_Text_Max_Fields>;
  min?: Maybe<Rangers_Area_Text_Min_Fields>;
};


/** aggregate fields of "rangers.area_text" */
export type Rangers_Area_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.area_text". All fields are combined with a logical 'AND'. */
export type Rangers_Area_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Area_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Area_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.area_text" */
export enum Rangers_Area_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AreaTextPkey = 'area_text_pkey'
}

/** input type for inserting data into table "rangers.area_text" */
export type Rangers_Area_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Area_Text_Max_Fields = {
  __typename?: 'rangers_area_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Area_Text_Min_Fields = {
  __typename?: 'rangers_area_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.area_text" */
export type Rangers_Area_Text_Mutation_Response = {
  __typename?: 'rangers_area_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Area_Text>;
};

/** on_conflict condition type for table "rangers.area_text" */
export type Rangers_Area_Text_On_Conflict = {
  constraint: Rangers_Area_Text_Constraint;
  update_columns?: Array<Rangers_Area_Text_Update_Column>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.area_text". */
export type Rangers_Area_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.area_text */
export type Rangers_Area_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.area_text" */
export enum Rangers_Area_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.area_text" */
export type Rangers_Area_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_area_text" */
export type Rangers_Area_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Area_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Area_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.area_text" */
export enum Rangers_Area_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Area_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Area_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Area_Text_Bool_Exp;
};

/** update columns of table "rangers.area" */
export enum Rangers_Area_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Area_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Area_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Area_Bool_Exp;
};

/** columns and relationships of "rangers.aspect" */
export type Rangers_Aspect = {
  __typename?: 'rangers_aspect';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect" */
export type Rangers_Aspect_Aggregate = {
  __typename?: 'rangers_aspect_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect>;
};

/** aggregate fields of "rangers.aspect" */
export type Rangers_Aspect_Aggregate_Fields = {
  __typename?: 'rangers_aspect_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Min_Fields>;
};


/** aggregate fields of "rangers.aspect" */
export type Rangers_Aspect_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.aspect" */
export enum Rangers_Aspect_Constraint {
  /** unique or primary key constraint on columns "id" */
  AspectPkey = 'aspect_pkey'
}

/** input type for inserting data into table "rangers.aspect" */
export type Rangers_Aspect_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized = {
  __typename?: 'rangers_aspect_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate = {
  __typename?: 'rangers_aspect_localized_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect_Localized>;
};

/** aggregate fields of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate_Fields = {
  __typename?: 'rangers_aspect_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Localized_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.aspect_localized" */
export type Rangers_Aspect_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_short_name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Localized_Max_Fields = {
  __typename?: 'rangers_aspect_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Localized_Min_Fields = {
  __typename?: 'rangers_aspect_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_short_name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.aspect_localized". */
export type Rangers_Aspect_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_short_name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.aspect_localized" */
export enum Rangers_Aspect_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealShortName = 'real_short_name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_aspect_localized" */
export type Rangers_Aspect_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_short_name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Max_Fields = {
  __typename?: 'rangers_aspect_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Min_Fields = {
  __typename?: 'rangers_aspect_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.aspect" */
export type Rangers_Aspect_Mutation_Response = {
  __typename?: 'rangers_aspect_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Aspect>;
};

/** on_conflict condition type for table "rangers.aspect" */
export type Rangers_Aspect_On_Conflict = {
  constraint: Rangers_Aspect_Constraint;
  update_columns?: Array<Rangers_Aspect_Update_Column>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.aspect". */
export type Rangers_Aspect_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.aspect */
export type Rangers_Aspect_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.aspect" */
export enum Rangers_Aspect_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.aspect" */
export type Rangers_Aspect_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_aspect" */
export type Rangers_Aspect_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.aspect_text" */
export type Rangers_Aspect_Text = {
  __typename?: 'rangers_aspect_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  short_name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate = {
  __typename?: 'rangers_aspect_text_aggregate';
  aggregate?: Maybe<Rangers_Aspect_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Aspect_Text>;
};

/** aggregate fields of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate_Fields = {
  __typename?: 'rangers_aspect_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Aspect_Text_Max_Fields>;
  min?: Maybe<Rangers_Aspect_Text_Min_Fields>;
};


/** aggregate fields of "rangers.aspect_text" */
export type Rangers_Aspect_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.aspect_text". All fields are combined with a logical 'AND'. */
export type Rangers_Aspect_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Aspect_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Aspect_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  short_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  AspectTextPkey = 'aspect_text_pkey'
}

/** input type for inserting data into table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Aspect_Text_Max_Fields = {
  __typename?: 'rangers_aspect_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Aspect_Text_Min_Fields = {
  __typename?: 'rangers_aspect_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  short_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Mutation_Response = {
  __typename?: 'rangers_aspect_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Aspect_Text>;
};

/** on_conflict condition type for table "rangers.aspect_text" */
export type Rangers_Aspect_Text_On_Conflict = {
  constraint: Rangers_Aspect_Text_Constraint;
  update_columns?: Array<Rangers_Aspect_Text_Update_Column>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.aspect_text". */
export type Rangers_Aspect_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  short_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.aspect_text */
export type Rangers_Aspect_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.aspect_text" */
export type Rangers_Aspect_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_aspect_text" */
export type Rangers_Aspect_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Aspect_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Aspect_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  short_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.aspect_text" */
export enum Rangers_Aspect_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Aspect_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Aspect_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Aspect_Text_Bool_Exp;
};

/** update columns of table "rangers.aspect" */
export enum Rangers_Aspect_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'short_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Aspect_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Aspect_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Aspect_Bool_Exp;
};

/** columns and relationships of "rangers.campaign" */
export type Rangers_Campaign = {
  __typename?: 'rangers_campaign';
  /** An array relationship */
  access: Array<Rangers_User_Campaign>;
  /** An aggregate relationship */
  access_aggregate: Rangers_User_Campaign_Aggregate;
  calendar: Scalars['jsonb']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  creator: Rangers_Users;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id: Scalars['String']['output'];
  day: Scalars['Int']['output'];
  events: Scalars['jsonb']['output'];
  extended_calendar?: Maybe<Scalars['Boolean']['output']>;
  history: Scalars['jsonb']['output'];
  id: Scalars['Int']['output'];
  /** An array relationship */
  latest_decks: Array<Rangers_Latest_Deck>;
  /** An aggregate relationship */
  latest_decks_aggregate: Rangers_Latest_Deck_Aggregate;
  missions: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  notes: Scalars['jsonb']['output'];
  removed: Scalars['jsonb']['output'];
  rewards: Scalars['jsonb']['output'];
  updated_at: Scalars['timestamptz']['output'];
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignAccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignAccess_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignCalendarArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignEventsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignHistoryArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignMissionsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignNotesArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignRemovedArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.campaign" */
export type Rangers_CampaignRewardsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "rangers.campaign_access" */
export type Rangers_Campaign_Access = {
  __typename?: 'rangers_campaign_access';
  /** An object relationship */
  campaign: Rangers_Campaign;
  campaign_id: Scalars['Int']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate = {
  __typename?: 'rangers_campaign_access_aggregate';
  aggregate?: Maybe<Rangers_Campaign_Access_Aggregate_Fields>;
  nodes: Array<Rangers_Campaign_Access>;
};

/** aggregate fields of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate_Fields = {
  __typename?: 'rangers_campaign_access_aggregate_fields';
  avg?: Maybe<Rangers_Campaign_Access_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Campaign_Access_Max_Fields>;
  min?: Maybe<Rangers_Campaign_Access_Min_Fields>;
  stddev?: Maybe<Rangers_Campaign_Access_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Campaign_Access_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Campaign_Access_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Campaign_Access_Sum_Fields>;
  var_pop?: Maybe<Rangers_Campaign_Access_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Campaign_Access_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Campaign_Access_Variance_Fields>;
};


/** aggregate fields of "rangers.campaign_access" */
export type Rangers_Campaign_Access_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Campaign_Access_Avg_Fields = {
  __typename?: 'rangers_campaign_access_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.campaign_access". All fields are combined with a logical 'AND'. */
export type Rangers_Campaign_Access_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Campaign_Access_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Campaign_Access_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Constraint {
  /** unique or primary key constraint on columns "campaign_id", "user_id" */
  CampaignAccessPkey = 'campaign_access_pkey'
}

/** input type for incrementing numeric columns in table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Campaign_Access_Max_Fields = {
  __typename?: 'rangers_campaign_access_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Campaign_Access_Min_Fields = {
  __typename?: 'rangers_campaign_access_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Mutation_Response = {
  __typename?: 'rangers_campaign_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Campaign_Access>;
};

/** on_conflict condition type for table "rangers.campaign_access" */
export type Rangers_Campaign_Access_On_Conflict = {
  constraint: Rangers_Campaign_Access_Constraint;
  update_columns?: Array<Rangers_Campaign_Access_Update_Column>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.campaign_access". */
export type Rangers_Campaign_Access_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.campaign_access */
export type Rangers_Campaign_Access_Pk_Columns_Input = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.campaign_access" */
export type Rangers_Campaign_Access_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Campaign_Access_Stddev_Fields = {
  __typename?: 'rangers_campaign_access_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Campaign_Access_Stddev_Pop_Fields = {
  __typename?: 'rangers_campaign_access_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Campaign_Access_Stddev_Samp_Fields = {
  __typename?: 'rangers_campaign_access_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_campaign_access" */
export type Rangers_Campaign_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Campaign_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Campaign_Access_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Campaign_Access_Sum_Fields = {
  __typename?: 'rangers_campaign_access_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.campaign_access" */
export enum Rangers_Campaign_Access_Update_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Campaign_Access_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Campaign_Access_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Campaign_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Campaign_Access_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Campaign_Access_Var_Pop_Fields = {
  __typename?: 'rangers_campaign_access_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Campaign_Access_Var_Samp_Fields = {
  __typename?: 'rangers_campaign_access_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Campaign_Access_Variance_Fields = {
  __typename?: 'rangers_campaign_access_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregated selection of "rangers.campaign" */
export type Rangers_Campaign_Aggregate = {
  __typename?: 'rangers_campaign_aggregate';
  aggregate?: Maybe<Rangers_Campaign_Aggregate_Fields>;
  nodes: Array<Rangers_Campaign>;
};

/** aggregate fields of "rangers.campaign" */
export type Rangers_Campaign_Aggregate_Fields = {
  __typename?: 'rangers_campaign_aggregate_fields';
  avg?: Maybe<Rangers_Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Campaign_Max_Fields>;
  min?: Maybe<Rangers_Campaign_Min_Fields>;
  stddev?: Maybe<Rangers_Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Campaign_Sum_Fields>;
  var_pop?: Maybe<Rangers_Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Campaign_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Campaign_Variance_Fields>;
};


/** aggregate fields of "rangers.campaign" */
export type Rangers_Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Campaign_Append_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Campaign_Avg_Fields = {
  __typename?: 'rangers_campaign_avg_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.campaign". All fields are combined with a logical 'AND'. */
export type Rangers_Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Campaign_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Campaign_Bool_Exp>>;
  access?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  access_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp>;
  calendar?: InputMaybe<Jsonb_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  creator?: InputMaybe<Rangers_Users_Bool_Exp>;
  current_location?: InputMaybe<String_Comparison_Exp>;
  current_path_terrain?: InputMaybe<String_Comparison_Exp>;
  cycle_id?: InputMaybe<String_Comparison_Exp>;
  day?: InputMaybe<Int_Comparison_Exp>;
  events?: InputMaybe<Jsonb_Comparison_Exp>;
  extended_calendar?: InputMaybe<Boolean_Comparison_Exp>;
  history?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  latest_decks?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  latest_decks_aggregate?: InputMaybe<Rangers_Latest_Deck_Aggregate_Bool_Exp>;
  missions?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<Jsonb_Comparison_Exp>;
  removed?: InputMaybe<Jsonb_Comparison_Exp>;
  rewards?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.campaign" */
export enum Rangers_Campaign_Constraint {
  /** unique or primary key constraint on columns "id" */
  CampaignPkey = 'campaign_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Campaign_Delete_At_Path_Input = {
  calendar?: InputMaybe<Array<Scalars['String']['input']>>;
  events?: InputMaybe<Array<Scalars['String']['input']>>;
  history?: InputMaybe<Array<Scalars['String']['input']>>;
  missions?: InputMaybe<Array<Scalars['String']['input']>>;
  notes?: InputMaybe<Array<Scalars['String']['input']>>;
  removed?: InputMaybe<Array<Scalars['String']['input']>>;
  rewards?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Campaign_Delete_Elem_Input = {
  calendar?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['Int']['input']>;
  history?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['Int']['input']>;
  notes?: InputMaybe<Scalars['Int']['input']>;
  removed?: InputMaybe<Scalars['Int']['input']>;
  rewards?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Campaign_Delete_Key_Input = {
  calendar?: InputMaybe<Scalars['String']['input']>;
  events?: InputMaybe<Scalars['String']['input']>;
  history?: InputMaybe<Scalars['String']['input']>;
  missions?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['String']['input']>;
  removed?: InputMaybe<Scalars['String']['input']>;
  rewards?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.campaign" */
export type Rangers_Campaign_Inc_Input = {
  day?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.campaign" */
export type Rangers_Campaign_Insert_Input = {
  access?: InputMaybe<Rangers_User_Campaign_Arr_Rel_Insert_Input>;
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  creator?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  latest_decks?: InputMaybe<Rangers_Latest_Deck_Arr_Rel_Insert_Input>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Campaign_Max_Fields = {
  __typename?: 'rangers_campaign_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id?: Maybe<Scalars['String']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Campaign_Min_Fields = {
  __typename?: 'rangers_campaign_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  current_location?: Maybe<Scalars['String']['output']>;
  current_path_terrain?: Maybe<Scalars['String']['output']>;
  cycle_id?: Maybe<Scalars['String']['output']>;
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.campaign" */
export type Rangers_Campaign_Mutation_Response = {
  __typename?: 'rangers_campaign_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Campaign>;
};

/** input type for inserting object relation for remote table "rangers.campaign" */
export type Rangers_Campaign_Obj_Rel_Insert_Input = {
  data: Rangers_Campaign_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Campaign_On_Conflict>;
};

/** on_conflict condition type for table "rangers.campaign" */
export type Rangers_Campaign_On_Conflict = {
  constraint: Rangers_Campaign_Constraint;
  update_columns?: Array<Rangers_Campaign_Update_Column>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.campaign". */
export type Rangers_Campaign_Order_By = {
  access_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Order_By>;
  calendar?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  creator?: InputMaybe<Rangers_Users_Order_By>;
  current_location?: InputMaybe<Order_By>;
  current_path_terrain?: InputMaybe<Order_By>;
  cycle_id?: InputMaybe<Order_By>;
  day?: InputMaybe<Order_By>;
  events?: InputMaybe<Order_By>;
  extended_calendar?: InputMaybe<Order_By>;
  history?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  latest_decks_aggregate?: InputMaybe<Rangers_Latest_Deck_Aggregate_Order_By>;
  missions?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  removed?: InputMaybe<Order_By>;
  rewards?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.campaign */
export type Rangers_Campaign_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Campaign_Prepend_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "rangers.campaign" */
export enum Rangers_Campaign_Select_Column {
  /** column name */
  Calendar = 'calendar',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentLocation = 'current_location',
  /** column name */
  CurrentPathTerrain = 'current_path_terrain',
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Day = 'day',
  /** column name */
  Events = 'events',
  /** column name */
  ExtendedCalendar = 'extended_calendar',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Missions = 'missions',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  Removed = 'removed',
  /** column name */
  Rewards = 'rewards',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.campaign" */
export type Rangers_Campaign_Set_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Campaign_Stddev_Fields = {
  __typename?: 'rangers_campaign_stddev_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Campaign_Stddev_Pop_Fields = {
  __typename?: 'rangers_campaign_stddev_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Campaign_Stddev_Samp_Fields = {
  __typename?: 'rangers_campaign_stddev_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_campaign" */
export type Rangers_Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Campaign_Stream_Cursor_Value_Input = {
  calendar?: InputMaybe<Scalars['jsonb']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  current_location?: InputMaybe<Scalars['String']['input']>;
  current_path_terrain?: InputMaybe<Scalars['String']['input']>;
  cycle_id?: InputMaybe<Scalars['String']['input']>;
  day?: InputMaybe<Scalars['Int']['input']>;
  events?: InputMaybe<Scalars['jsonb']['input']>;
  extended_calendar?: InputMaybe<Scalars['Boolean']['input']>;
  history?: InputMaybe<Scalars['jsonb']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  missions?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notes?: InputMaybe<Scalars['jsonb']['input']>;
  removed?: InputMaybe<Scalars['jsonb']['input']>;
  rewards?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Campaign_Sum_Fields = {
  __typename?: 'rangers_campaign_sum_fields';
  day?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.campaign" */
export enum Rangers_Campaign_Update_Column {
  /** column name */
  Calendar = 'calendar',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentLocation = 'current_location',
  /** column name */
  CurrentPathTerrain = 'current_path_terrain',
  /** column name */
  CycleId = 'cycle_id',
  /** column name */
  Day = 'day',
  /** column name */
  Events = 'events',
  /** column name */
  ExtendedCalendar = 'extended_calendar',
  /** column name */
  History = 'history',
  /** column name */
  Id = 'id',
  /** column name */
  Missions = 'missions',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  Removed = 'removed',
  /** column name */
  Rewards = 'rewards',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Campaign_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Campaign_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Campaign_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Campaign_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Campaign_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Campaign_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Campaign_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Campaign_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Campaign_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Campaign_Var_Pop_Fields = {
  __typename?: 'rangers_campaign_var_pop_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Campaign_Var_Samp_Fields = {
  __typename?: 'rangers_campaign_var_samp_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Campaign_Variance_Fields = {
  __typename?: 'rangers_campaign_variance_fields';
  day?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.card" */
export type Rangers_Card = {
  __typename?: 'rangers_card';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id: Scalars['String']['output'];
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locations?: Maybe<Scalars['jsonb']['output']>;
  name: Scalars['String']['output'];
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  progress_fixed?: Maybe<Scalars['Boolean']['output']>;
  quantity: Scalars['Int']['output'];
  set_id: Scalars['String']['output'];
  set_position: Scalars['Int']['output'];
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Card_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Card_Text_Aggregate;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardLocationsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.card" */
export type Rangers_CardTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.card" */
export type Rangers_Card_Aggregate = {
  __typename?: 'rangers_card_aggregate';
  aggregate?: Maybe<Rangers_Card_Aggregate_Fields>;
  nodes: Array<Rangers_Card>;
};

/** aggregate fields of "rangers.card" */
export type Rangers_Card_Aggregate_Fields = {
  __typename?: 'rangers_card_aggregate_fields';
  avg?: Maybe<Rangers_Card_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Max_Fields>;
  min?: Maybe<Rangers_Card_Min_Fields>;
  stddev?: Maybe<Rangers_Card_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Card_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Card_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Card_Sum_Fields>;
  var_pop?: Maybe<Rangers_Card_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Card_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Card_Variance_Fields>;
};


/** aggregate fields of "rangers.card" */
export type Rangers_Card_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Card_Append_Input = {
  locations?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Card_Avg_Fields = {
  __typename?: 'rangers_card_avg_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.card". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Bool_Exp>>;
  approach_conflict?: InputMaybe<Int_Comparison_Exp>;
  approach_connection?: InputMaybe<Int_Comparison_Exp>;
  approach_exploration?: InputMaybe<Int_Comparison_Exp>;
  approach_reason?: InputMaybe<Int_Comparison_Exp>;
  area_id?: InputMaybe<String_Comparison_Exp>;
  aspect_id?: InputMaybe<String_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  equip?: InputMaybe<Int_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  guide_entry?: InputMaybe<String_Comparison_Exp>;
  harm?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  level?: InputMaybe<Int_Comparison_Exp>;
  locations?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  presence?: InputMaybe<Int_Comparison_Exp>;
  progress?: InputMaybe<Int_Comparison_Exp>;
  progress_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  set_position?: InputMaybe<Int_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  token_count?: InputMaybe<Int_Comparison_Exp>;
  token_id?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Card_Text_Aggregate_Bool_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.card" */
export enum Rangers_Card_Constraint {
  /** unique or primary key constraint on columns "id" */
  CardPkey = 'card_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Card_Delete_At_Path_Input = {
  locations?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Card_Delete_Elem_Input = {
  locations?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Card_Delete_Key_Input = {
  locations?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.card" */
export type Rangers_Card_Inc_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.card" */
export type Rangers_Card_Insert_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Rangers_Card_Text_Arr_Rel_Insert_Input>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.card_localized" */
export type Rangers_Card_Localized = {
  __typename?: 'rangers_card_localized';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  locations?: Maybe<Scalars['jsonb']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  progress_fixed?: Maybe<Scalars['Boolean']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  spoiler?: Maybe<Scalars['Boolean']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.card_localized" */
export type Rangers_Card_LocalizedLocationsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate = {
  __typename?: 'rangers_card_localized_aggregate';
  aggregate?: Maybe<Rangers_Card_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Localized>;
};

/** aggregate fields of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate_Fields = {
  __typename?: 'rangers_card_localized_aggregate_fields';
  avg?: Maybe<Rangers_Card_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Localized_Max_Fields>;
  min?: Maybe<Rangers_Card_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Card_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Card_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Card_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Card_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Card_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Card_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Card_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.card_localized" */
export type Rangers_Card_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Card_Localized_Avg_Fields = {
  __typename?: 'rangers_card_localized_avg_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.card_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Localized_Bool_Exp>>;
  approach_conflict?: InputMaybe<Int_Comparison_Exp>;
  approach_connection?: InputMaybe<Int_Comparison_Exp>;
  approach_exploration?: InputMaybe<Int_Comparison_Exp>;
  approach_reason?: InputMaybe<Int_Comparison_Exp>;
  area_id?: InputMaybe<String_Comparison_Exp>;
  area_name?: InputMaybe<String_Comparison_Exp>;
  aspect_id?: InputMaybe<String_Comparison_Exp>;
  aspect_name?: InputMaybe<String_Comparison_Exp>;
  aspect_short_name?: InputMaybe<String_Comparison_Exp>;
  back_card_id?: InputMaybe<String_Comparison_Exp>;
  cost?: InputMaybe<Int_Comparison_Exp>;
  deck_limit?: InputMaybe<Int_Comparison_Exp>;
  equip?: InputMaybe<Int_Comparison_Exp>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  guide_entry?: InputMaybe<String_Comparison_Exp>;
  harm?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  illustrator?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  level?: InputMaybe<Int_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  locations?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  pack_id?: InputMaybe<String_Comparison_Exp>;
  pack_name?: InputMaybe<String_Comparison_Exp>;
  pack_position?: InputMaybe<Int_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  presence?: InputMaybe<Int_Comparison_Exp>;
  progress?: InputMaybe<Int_Comparison_Exp>;
  progress_fixed?: InputMaybe<Boolean_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  real_flavor?: InputMaybe<String_Comparison_Exp>;
  real_imagesrc?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  real_objective?: InputMaybe<String_Comparison_Exp>;
  real_text?: InputMaybe<String_Comparison_Exp>;
  real_traits?: InputMaybe<String_Comparison_Exp>;
  set_id?: InputMaybe<String_Comparison_Exp>;
  set_name?: InputMaybe<String_Comparison_Exp>;
  set_position?: InputMaybe<Int_Comparison_Exp>;
  set_size?: InputMaybe<Int_Comparison_Exp>;
  set_type_id?: InputMaybe<String_Comparison_Exp>;
  set_type_name?: InputMaybe<String_Comparison_Exp>;
  spoiler?: InputMaybe<Boolean_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  token_count?: InputMaybe<Int_Comparison_Exp>;
  token_id?: InputMaybe<String_Comparison_Exp>;
  token_name?: InputMaybe<String_Comparison_Exp>;
  token_plurals?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Card_Localized_Max_Fields = {
  __typename?: 'rangers_card_localized_max_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Localized_Min_Fields = {
  __typename?: 'rangers_card_localized_min_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  area_name?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  aspect_name?: Maybe<Scalars['String']['output']>;
  aspect_short_name?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  pack_name?: Maybe<Scalars['String']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  real_flavor?: Maybe<Scalars['String']['output']>;
  real_imagesrc?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  real_objective?: Maybe<Scalars['String']['output']>;
  real_text?: Maybe<Scalars['String']['output']>;
  real_traits?: Maybe<Scalars['String']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_name?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  set_type_id?: Maybe<Scalars['String']['output']>;
  set_type_name?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  token_name?: Maybe<Scalars['String']['output']>;
  token_plurals?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.card_localized". */
export type Rangers_Card_Localized_Order_By = {
  approach_conflict?: InputMaybe<Order_By>;
  approach_connection?: InputMaybe<Order_By>;
  approach_exploration?: InputMaybe<Order_By>;
  approach_reason?: InputMaybe<Order_By>;
  area_id?: InputMaybe<Order_By>;
  area_name?: InputMaybe<Order_By>;
  aspect_id?: InputMaybe<Order_By>;
  aspect_name?: InputMaybe<Order_By>;
  aspect_short_name?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  equip?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  guide_entry?: InputMaybe<Order_By>;
  harm?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  locations?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  pack_name?: InputMaybe<Order_By>;
  pack_position?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  presence?: InputMaybe<Order_By>;
  progress?: InputMaybe<Order_By>;
  progress_fixed?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  real_flavor?: InputMaybe<Order_By>;
  real_imagesrc?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  real_objective?: InputMaybe<Order_By>;
  real_text?: InputMaybe<Order_By>;
  real_traits?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  set_name?: InputMaybe<Order_By>;
  set_position?: InputMaybe<Order_By>;
  set_size?: InputMaybe<Order_By>;
  set_type_id?: InputMaybe<Order_By>;
  set_type_name?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  token_count?: InputMaybe<Order_By>;
  token_id?: InputMaybe<Order_By>;
  token_name?: InputMaybe<Order_By>;
  token_plurals?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.card_localized" */
export enum Rangers_Card_Localized_Select_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AreaName = 'area_name',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  AspectName = 'aspect_name',
  /** column name */
  AspectShortName = 'aspect_short_name',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locale = 'locale',
  /** column name */
  Locations = 'locations',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  PackName = 'pack_name',
  /** column name */
  PackPosition = 'pack_position',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RealFlavor = 'real_flavor',
  /** column name */
  RealImagesrc = 'real_imagesrc',
  /** column name */
  RealName = 'real_name',
  /** column name */
  RealObjective = 'real_objective',
  /** column name */
  RealText = 'real_text',
  /** column name */
  RealTraits = 'real_traits',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetName = 'set_name',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  SetSize = 'set_size',
  /** column name */
  SetTypeId = 'set_type_id',
  /** column name */
  SetTypeName = 'set_type_name',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  TokenName = 'token_name',
  /** column name */
  TokenPlurals = 'token_plurals',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Card_Localized_Stddev_Fields = {
  __typename?: 'rangers_card_localized_stddev_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Card_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_card_localized_stddev_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Card_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_card_localized_stddev_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_card_localized" */
export type Rangers_Card_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Localized_Stream_Cursor_Value_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  area_name?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  aspect_name?: InputMaybe<Scalars['String']['input']>;
  aspect_short_name?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  pack_name?: InputMaybe<Scalars['String']['input']>;
  pack_position?: InputMaybe<Scalars['Int']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  real_flavor?: InputMaybe<Scalars['String']['input']>;
  real_imagesrc?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  real_objective?: InputMaybe<Scalars['String']['input']>;
  real_text?: InputMaybe<Scalars['String']['input']>;
  real_traits?: InputMaybe<Scalars['String']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_name?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  set_size?: InputMaybe<Scalars['Int']['input']>;
  set_type_id?: InputMaybe<Scalars['String']['input']>;
  set_type_name?: InputMaybe<Scalars['String']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  token_name?: InputMaybe<Scalars['String']['input']>;
  token_plurals?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Card_Localized_Sum_Fields = {
  __typename?: 'rangers_card_localized_sum_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  pack_position?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  set_size?: Maybe<Scalars['Int']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Card_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_card_localized_var_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Card_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_card_localized_var_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Card_Localized_Variance_Fields = {
  __typename?: 'rangers_card_localized_variance_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  pack_position?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  set_size?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Card_Max_Fields = {
  __typename?: 'rangers_card_max_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Min_Fields = {
  __typename?: 'rangers_card_min_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  area_id?: Maybe<Scalars['String']['output']>;
  aspect_id?: Maybe<Scalars['String']['output']>;
  back_card_id?: Maybe<Scalars['String']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  flavor?: Maybe<Scalars['String']['output']>;
  guide_entry?: Maybe<Scalars['String']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  illustrator?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  pack_id?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_id?: Maybe<Scalars['String']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
  token_id?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.card" */
export type Rangers_Card_Mutation_Response = {
  __typename?: 'rangers_card_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Card>;
};

/** on_conflict condition type for table "rangers.card" */
export type Rangers_Card_On_Conflict = {
  constraint: Rangers_Card_Constraint;
  update_columns?: Array<Rangers_Card_Update_Column>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.card". */
export type Rangers_Card_Order_By = {
  approach_conflict?: InputMaybe<Order_By>;
  approach_connection?: InputMaybe<Order_By>;
  approach_exploration?: InputMaybe<Order_By>;
  approach_reason?: InputMaybe<Order_By>;
  area_id?: InputMaybe<Order_By>;
  aspect_id?: InputMaybe<Order_By>;
  back_card_id?: InputMaybe<Order_By>;
  cost?: InputMaybe<Order_By>;
  deck_limit?: InputMaybe<Order_By>;
  equip?: InputMaybe<Order_By>;
  flavor?: InputMaybe<Order_By>;
  guide_entry?: InputMaybe<Order_By>;
  harm?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  illustrator?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locations?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  pack_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  presence?: InputMaybe<Order_By>;
  progress?: InputMaybe<Order_By>;
  progress_fixed?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  set_id?: InputMaybe<Order_By>;
  set_position?: InputMaybe<Order_By>;
  spoiler?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  token_count?: InputMaybe<Order_By>;
  token_id?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Card_Text_Aggregate_Order_By>;
  type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.card */
export type Rangers_Card_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Card_Prepend_Input = {
  locations?: InputMaybe<Scalars['jsonb']['input']>;
};

export type Rangers_Card_Search_Args = {
  _limit?: InputMaybe<Scalars['Int']['input']>;
  _offset?: InputMaybe<Scalars['Int']['input']>;
  aspect_in?: InputMaybe<Scalars['_text']['input']>;
  level_eq?: InputMaybe<Scalars['Int']['input']>;
  level_gt?: InputMaybe<Scalars['Int']['input']>;
  level_lt?: InputMaybe<Scalars['Int']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  pack_in?: InputMaybe<Scalars['_text']['input']>;
  search?: InputMaybe<Scalars['String']['input']>;
  search_flavor?: InputMaybe<Scalars['Boolean']['input']>;
  search_text?: InputMaybe<Scalars['Boolean']['input']>;
  search_traits?: InputMaybe<Scalars['Boolean']['input']>;
  set_in?: InputMaybe<Scalars['_text']['input']>;
  type_in?: InputMaybe<Scalars['_text']['input']>;
};

/** select columns of table "rangers.card" */
export enum Rangers_Card_Select_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locations = 'locations',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.card" */
export type Rangers_Card_Set_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Card_Stddev_Fields = {
  __typename?: 'rangers_card_stddev_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Card_Stddev_Pop_Fields = {
  __typename?: 'rangers_card_stddev_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Card_Stddev_Samp_Fields = {
  __typename?: 'rangers_card_stddev_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_card" */
export type Rangers_Card_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Stream_Cursor_Value_Input = {
  approach_conflict?: InputMaybe<Scalars['Int']['input']>;
  approach_connection?: InputMaybe<Scalars['Int']['input']>;
  approach_exploration?: InputMaybe<Scalars['Int']['input']>;
  approach_reason?: InputMaybe<Scalars['Int']['input']>;
  area_id?: InputMaybe<Scalars['String']['input']>;
  aspect_id?: InputMaybe<Scalars['String']['input']>;
  back_card_id?: InputMaybe<Scalars['String']['input']>;
  cost?: InputMaybe<Scalars['Int']['input']>;
  deck_limit?: InputMaybe<Scalars['Int']['input']>;
  equip?: InputMaybe<Scalars['Int']['input']>;
  flavor?: InputMaybe<Scalars['String']['input']>;
  guide_entry?: InputMaybe<Scalars['String']['input']>;
  harm?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  illustrator?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  level?: InputMaybe<Scalars['Int']['input']>;
  locations?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  pack_id?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  presence?: InputMaybe<Scalars['Int']['input']>;
  progress?: InputMaybe<Scalars['Int']['input']>;
  progress_fixed?: InputMaybe<Scalars['Boolean']['input']>;
  quantity?: InputMaybe<Scalars['Int']['input']>;
  set_id?: InputMaybe<Scalars['String']['input']>;
  set_position?: InputMaybe<Scalars['Int']['input']>;
  spoiler?: InputMaybe<Scalars['Boolean']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  token_count?: InputMaybe<Scalars['Int']['input']>;
  token_id?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Card_Sum_Fields = {
  __typename?: 'rangers_card_sum_fields';
  approach_conflict?: Maybe<Scalars['Int']['output']>;
  approach_connection?: Maybe<Scalars['Int']['output']>;
  approach_exploration?: Maybe<Scalars['Int']['output']>;
  approach_reason?: Maybe<Scalars['Int']['output']>;
  cost?: Maybe<Scalars['Int']['output']>;
  deck_limit?: Maybe<Scalars['Int']['output']>;
  equip?: Maybe<Scalars['Int']['output']>;
  harm?: Maybe<Scalars['Int']['output']>;
  level?: Maybe<Scalars['Int']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  presence?: Maybe<Scalars['Int']['output']>;
  progress?: Maybe<Scalars['Int']['output']>;
  quantity?: Maybe<Scalars['Int']['output']>;
  set_position?: Maybe<Scalars['Int']['output']>;
  token_count?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.card_text" */
export type Rangers_Card_Text = {
  __typename?: 'rangers_card_text';
  flavor?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale: Scalars['String']['output'];
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate = {
  __typename?: 'rangers_card_text_aggregate';
  aggregate?: Maybe<Rangers_Card_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Text>;
};

export type Rangers_Card_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Card_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Card_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_Fields = {
  __typename?: 'rangers_card_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Text_Max_Fields>;
  min?: Maybe<Rangers_Card_Text_Min_Fields>;
};


/** aggregate fields of "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.card_text" */
export type Rangers_Card_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Card_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Card_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.card_text" */
export type Rangers_Card_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Card_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Card_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.card_text". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Text_Bool_Exp>>;
  flavor?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  imagesrc?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  objective?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  traits?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.card_text" */
export enum Rangers_Card_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  CardTextPkey = 'card_text_pkey'
}

/** input type for inserting data into table "rangers.card_text" */
export type Rangers_Card_Text_Insert_Input = {
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Card_Text_Max_Fields = {
  __typename?: 'rangers_card_text_max_fields';
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.card_text" */
export type Rangers_Card_Text_Max_Order_By = {
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Card_Text_Min_Fields = {
  __typename?: 'rangers_card_text_min_fields';
  flavor?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  imagesrc?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  objective?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  traits?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.card_text" */
export type Rangers_Card_Text_Min_Order_By = {
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.card_text" */
export type Rangers_Card_Text_Mutation_Response = {
  __typename?: 'rangers_card_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Card_Text>;
};

/** on_conflict condition type for table "rangers.card_text" */
export type Rangers_Card_Text_On_Conflict = {
  constraint: Rangers_Card_Text_Constraint;
  update_columns?: Array<Rangers_Card_Text_Update_Column>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.card_text". */
export type Rangers_Card_Text_Order_By = {
  flavor?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  imagesrc?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  objective?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  traits?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.card_text */
export type Rangers_Card_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.card_text" */
export enum Rangers_Card_Text_Select_Column {
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.card_text" */
export type Rangers_Card_Text_Set_Input = {
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_card_text" */
export type Rangers_Card_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Text_Stream_Cursor_Value_Input = {
  flavor?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  imagesrc?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  objective?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  traits?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.card_text" */
export enum Rangers_Card_Text_Update_Column {
  /** column name */
  Flavor = 'flavor',
  /** column name */
  Id = 'id',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  Text = 'text',
  /** column name */
  Traits = 'traits',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Card_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Card_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Card_Text_Bool_Exp;
};

/** update columns of table "rangers.card" */
export enum Rangers_Card_Update_Column {
  /** column name */
  ApproachConflict = 'approach_conflict',
  /** column name */
  ApproachConnection = 'approach_connection',
  /** column name */
  ApproachExploration = 'approach_exploration',
  /** column name */
  ApproachReason = 'approach_reason',
  /** column name */
  AreaId = 'area_id',
  /** column name */
  AspectId = 'aspect_id',
  /** column name */
  BackCardId = 'back_card_id',
  /** column name */
  Cost = 'cost',
  /** column name */
  DeckLimit = 'deck_limit',
  /** column name */
  Equip = 'equip',
  /** column name */
  Flavor = 'flavor',
  /** column name */
  GuideEntry = 'guide_entry',
  /** column name */
  Harm = 'harm',
  /** column name */
  Id = 'id',
  /** column name */
  Illustrator = 'illustrator',
  /** column name */
  Imagesrc = 'imagesrc',
  /** column name */
  Level = 'level',
  /** column name */
  Locations = 'locations',
  /** column name */
  Name = 'name',
  /** column name */
  Objective = 'objective',
  /** column name */
  PackId = 'pack_id',
  /** column name */
  Position = 'position',
  /** column name */
  Presence = 'presence',
  /** column name */
  Progress = 'progress',
  /** column name */
  ProgressFixed = 'progress_fixed',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  SetId = 'set_id',
  /** column name */
  SetPosition = 'set_position',
  /** column name */
  Spoiler = 'spoiler',
  /** column name */
  Text = 'text',
  /** column name */
  TokenCount = 'token_count',
  /** column name */
  TokenId = 'token_id',
  /** column name */
  Traits = 'traits',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "rangers.card_updated" */
export type Rangers_Card_Updated = {
  __typename?: 'rangers_card_updated';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate = {
  __typename?: 'rangers_card_updated_aggregate';
  aggregate?: Maybe<Rangers_Card_Updated_Aggregate_Fields>;
  nodes: Array<Rangers_Card_Updated>;
};

/** aggregate fields of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate_Fields = {
  __typename?: 'rangers_card_updated_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Card_Updated_Max_Fields>;
  min?: Maybe<Rangers_Card_Updated_Min_Fields>;
};


/** aggregate fields of "rangers.card_updated" */
export type Rangers_Card_Updated_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.card_updated". All fields are combined with a logical 'AND'. */
export type Rangers_Card_Updated_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Card_Updated_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Card_Updated_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Card_Updated_Max_Fields = {
  __typename?: 'rangers_card_updated_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Card_Updated_Min_Fields = {
  __typename?: 'rangers_card_updated_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.card_updated". */
export type Rangers_Card_Updated_Order_By = {
  locale?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.card_updated" */
export enum Rangers_Card_Updated_Select_Column {
  /** column name */
  Locale = 'locale',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_card_updated" */
export type Rangers_Card_Updated_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Card_Updated_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Card_Updated_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

export type Rangers_Card_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Card_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Card_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Card_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Card_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Card_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Card_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Card_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Card_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Card_Var_Pop_Fields = {
  __typename?: 'rangers_card_var_pop_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Card_Var_Samp_Fields = {
  __typename?: 'rangers_card_var_samp_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Card_Variance_Fields = {
  __typename?: 'rangers_card_variance_fields';
  approach_conflict?: Maybe<Scalars['Float']['output']>;
  approach_connection?: Maybe<Scalars['Float']['output']>;
  approach_exploration?: Maybe<Scalars['Float']['output']>;
  approach_reason?: Maybe<Scalars['Float']['output']>;
  cost?: Maybe<Scalars['Float']['output']>;
  deck_limit?: Maybe<Scalars['Float']['output']>;
  equip?: Maybe<Scalars['Float']['output']>;
  harm?: Maybe<Scalars['Float']['output']>;
  level?: Maybe<Scalars['Float']['output']>;
  position?: Maybe<Scalars['Float']['output']>;
  presence?: Maybe<Scalars['Float']['output']>;
  progress?: Maybe<Scalars['Float']['output']>;
  quantity?: Maybe<Scalars['Float']['output']>;
  set_position?: Maybe<Scalars['Float']['output']>;
  token_count?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.comment" */
export type Rangers_Comment = {
  __typename?: 'rangers_comment';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck?: Maybe<Rangers_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id: Scalars['uuid']['output'];
  /** An object relationship */
  parent?: Maybe<Rangers_Comment>;
  response_count: Scalars['Int']['output'];
  /** An array relationship */
  responses: Array<Rangers_Comment>;
  /** An aggregate relationship */
  responses_aggregate: Rangers_Comment_Aggregate;
  text?: Maybe<Scalars['String']['output']>;
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "rangers.comment" */
export type Rangers_CommentResponsesArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.comment" */
export type Rangers_CommentResponses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};

/** aggregated selection of "rangers.comment" */
export type Rangers_Comment_Aggregate = {
  __typename?: 'rangers_comment_aggregate';
  aggregate?: Maybe<Rangers_Comment_Aggregate_Fields>;
  nodes: Array<Rangers_Comment>;
};

export type Rangers_Comment_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Comment_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Comment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.comment" */
export type Rangers_Comment_Aggregate_Fields = {
  __typename?: 'rangers_comment_aggregate_fields';
  avg?: Maybe<Rangers_Comment_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Comment_Max_Fields>;
  min?: Maybe<Rangers_Comment_Min_Fields>;
  stddev?: Maybe<Rangers_Comment_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Comment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Comment_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Comment_Sum_Fields>;
  var_pop?: Maybe<Rangers_Comment_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Comment_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Comment_Variance_Fields>;
};


/** aggregate fields of "rangers.comment" */
export type Rangers_Comment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.comment" */
export type Rangers_Comment_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Comment_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Comment_Max_Order_By>;
  min?: InputMaybe<Rangers_Comment_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Comment_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Comment_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Comment_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Comment_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Comment_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Comment_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Comment_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.comment" */
export type Rangers_Comment_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Comment_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};

/** aggregate avg on columns */
export type Rangers_Comment_Avg_Fields = {
  __typename?: 'rangers_comment_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.comment" */
export type Rangers_Comment_Avg_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.comment". All fields are combined with a logical 'AND'. */
export type Rangers_Comment_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Comment_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Comment_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Comment_Bool_Exp>>;
  comment_id?: InputMaybe<Uuid_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  parent?: InputMaybe<Rangers_Comment_Bool_Exp>;
  response_count?: InputMaybe<Int_Comparison_Exp>;
  responses?: InputMaybe<Rangers_Comment_Bool_Exp>;
  responses_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.comment" */
export enum Rangers_Comment_Constraint {
  /** unique or primary key constraint on columns "deck_id", "id" */
  CommentIdDeckIdKey = 'comment_id_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  CommentPkey = 'comment_pkey'
}

/** input type for incrementing numeric columns in table "rangers.comment" */
export type Rangers_Comment_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.comment" */
export type Rangers_Comment_Insert_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  parent?: InputMaybe<Rangers_Comment_Obj_Rel_Insert_Input>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  responses?: InputMaybe<Rangers_Comment_Arr_Rel_Insert_Input>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Comment_Max_Fields = {
  __typename?: 'rangers_comment_max_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.comment" */
export type Rangers_Comment_Max_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Comment_Min_Fields = {
  __typename?: 'rangers_comment_min_fields';
  comment_id?: Maybe<Scalars['uuid']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
  text?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.comment" */
export type Rangers_Comment_Min_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.comment" */
export type Rangers_Comment_Mutation_Response = {
  __typename?: 'rangers_comment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Comment>;
};

/** input type for inserting object relation for remote table "rangers.comment" */
export type Rangers_Comment_Obj_Rel_Insert_Input = {
  data: Rangers_Comment_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Comment_On_Conflict>;
};

/** on_conflict condition type for table "rangers.comment" */
export type Rangers_Comment_On_Conflict = {
  constraint: Rangers_Comment_Constraint;
  update_columns?: Array<Rangers_Comment_Update_Column>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.comment". */
export type Rangers_Comment_Order_By = {
  comment_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  parent?: InputMaybe<Rangers_Comment_Order_By>;
  response_count?: InputMaybe<Order_By>;
  responses_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Order_By>;
  text?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.comment */
export type Rangers_Comment_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "rangers.comment" */
export enum Rangers_Comment_Select_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.comment" */
export type Rangers_Comment_Set_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Comment_Stddev_Fields = {
  __typename?: 'rangers_comment_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Comment_Stddev_Pop_Fields = {
  __typename?: 'rangers_comment_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Comment_Stddev_Samp_Fields = {
  __typename?: 'rangers_comment_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.comment" */
export type Rangers_Comment_Stddev_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_comment" */
export type Rangers_Comment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Comment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Comment_Stream_Cursor_Value_Input = {
  comment_id?: InputMaybe<Scalars['uuid']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  response_count?: InputMaybe<Scalars['Int']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Comment_Sum_Fields = {
  __typename?: 'rangers_comment_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
  response_count?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.comment" */
export type Rangers_Comment_Sum_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** update columns of table "rangers.comment" */
export enum Rangers_Comment_Update_Column {
  /** column name */
  CommentId = 'comment_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Id = 'id',
  /** column name */
  ResponseCount = 'response_count',
  /** column name */
  Text = 'text',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Comment_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Comment_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Comment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Comment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Comment_Var_Pop_Fields = {
  __typename?: 'rangers_comment_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.comment" */
export type Rangers_Comment_Var_Pop_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Comment_Var_Samp_Fields = {
  __typename?: 'rangers_comment_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.comment" */
export type Rangers_Comment_Var_Samp_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Comment_Variance_Fields = {
  __typename?: 'rangers_comment_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
  response_count?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.comment" */
export type Rangers_Comment_Variance_Order_By = {
  deck_id?: InputMaybe<Order_By>;
  response_count?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.deck" */
export type Rangers_Deck = {
  __typename?: 'rangers_deck';
  awa: Scalars['Int']['output'];
  /** An object relationship */
  base_deck?: Maybe<Rangers_Deck>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count: Scalars['Int']['output'];
  /** An array relationship */
  comments: Array<Rangers_Comment>;
  /** An aggregate relationship */
  comments_aggregate: Rangers_Comment_Aggregate;
  copy_count: Scalars['Int']['output'];
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  extra_slots: Scalars['jsonb']['output'];
  fit: Scalars['Int']['output'];
  foc: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  like_count?: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "rangers.deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  likes?: Maybe<Rangers_Deck_Like_Count>;
  meta: Scalars['jsonb']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  next_deck?: Maybe<Rangers_Deck>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  original_deck?: Maybe<Rangers_Deck_Copy>;
  /** An object relationship */
  previous_deck?: Maybe<Rangers_Deck>;
  published?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  rank?: Maybe<Rangers_Deck_Rank>;
  side_slots: Scalars['jsonb']['output'];
  slots: Scalars['jsonb']['output'];
  spi: Scalars['Int']['output'];
  tags: Scalars['jsonb']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  upgrade?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
  version: Scalars['Int']['output'];
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckCommentsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckComments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckExtra_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.deck" */
export type Rangers_DeckUpgradeArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "rangers.deck" */
export type Rangers_Deck_Aggregate = {
  __typename?: 'rangers_deck_aggregate';
  aggregate?: Maybe<Rangers_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Deck>;
};

/** aggregate fields of "rangers.deck" */
export type Rangers_Deck_Aggregate_Fields = {
  __typename?: 'rangers_deck_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Max_Fields>;
  min?: Maybe<Rangers_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.deck" */
export type Rangers_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Deck_Append_Input = {
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Avg_Fields = {
  __typename?: 'rangers_deck_avg_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Bool_Exp>>;
  awa?: InputMaybe<Int_Comparison_Exp>;
  base_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  base_deck_id?: InputMaybe<Int_Comparison_Exp>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  comments?: InputMaybe<Rangers_Comment_Bool_Exp>;
  comments_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Bool_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  extra_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  fit?: InputMaybe<Int_Comparison_Exp>;
  foc?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
  previous_deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  rank?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  spi?: InputMaybe<Int_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  upgrade?: InputMaybe<Jsonb_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck" */
export enum Rangers_Deck_Constraint {
  /** unique or primary key constraint on columns "next_deck_id" */
  DeckNextDeckIdKey = 'deck_next_deck_id_key',
  /** unique or primary key constraint on columns "id" */
  DeckPkey = 'deck_pkey'
}

/** columns and relationships of "rangers.deck_copy" */
export type Rangers_Deck_Copy = {
  __typename?: 'rangers_deck_copy';
  copy_deck_id: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Rangers_Deck;
  /** An object relationship */
  deck_copy: Rangers_Deck;
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  user: Rangers_Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate = {
  __typename?: 'rangers_deck_copy_aggregate';
  aggregate?: Maybe<Rangers_Deck_Copy_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Copy>;
};

/** aggregate fields of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate_Fields = {
  __typename?: 'rangers_deck_copy_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Copy_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Copy_Max_Fields>;
  min?: Maybe<Rangers_Deck_Copy_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Copy_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Copy_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Copy_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Copy_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Copy_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Copy_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Copy_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_copy" */
export type Rangers_Deck_Copy_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Copy_Avg_Fields = {
  __typename?: 'rangers_deck_copy_avg_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_copy". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Copy_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Copy_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Copy_Bool_Exp>>;
  copy_deck_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_copy?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Constraint {
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyCopyDeckIdKey = 'deck_copy_copy_deck_id_key',
  /** unique or primary key constraint on columns "copy_deck_id" */
  DeckCopyPkey = 'deck_copy_pkey'
}

/** input type for incrementing numeric columns in table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Inc_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Insert_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_copy?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Copy_Max_Fields = {
  __typename?: 'rangers_deck_copy_max_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Copy_Min_Fields = {
  __typename?: 'rangers_deck_copy_min_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Mutation_Response = {
  __typename?: 'rangers_deck_copy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Copy>;
};

/** input type for inserting object relation for remote table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Copy_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_Copy_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck_copy" */
export type Rangers_Deck_Copy_On_Conflict = {
  constraint: Rangers_Deck_Copy_Constraint;
  update_columns?: Array<Rangers_Deck_Copy_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_copy". */
export type Rangers_Deck_Copy_Order_By = {
  copy_deck_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_copy?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_copy */
export type Rangers_Deck_Copy_Pk_Columns_Input = {
  copy_deck_id: Scalars['Int']['input'];
};

/** select columns of table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Select_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.deck_copy" */
export type Rangers_Deck_Copy_Set_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Copy_Stddev_Fields = {
  __typename?: 'rangers_deck_copy_stddev_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Copy_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_copy_stddev_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Copy_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_copy_stddev_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_copy" */
export type Rangers_Deck_Copy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Copy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Copy_Stream_Cursor_Value_Input = {
  copy_deck_id?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Copy_Sum_Fields = {
  __typename?: 'rangers_deck_copy_sum_fields';
  copy_deck_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_copy" */
export enum Rangers_Deck_Copy_Update_Column {
  /** column name */
  CopyDeckId = 'copy_deck_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Deck_Copy_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Copy_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Copy_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Copy_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Copy_Var_Pop_Fields = {
  __typename?: 'rangers_deck_copy_var_pop_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Copy_Var_Samp_Fields = {
  __typename?: 'rangers_deck_copy_var_samp_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Copy_Variance_Fields = {
  __typename?: 'rangers_deck_copy_variance_fields';
  copy_deck_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Deck_Delete_At_Path_Input = {
  extra_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  upgrade?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Deck_Delete_Elem_Input = {
  extra_slots?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
  upgrade?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Deck_Delete_Key_Input = {
  extra_slots?: InputMaybe<Scalars['String']['input']>;
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  upgrade?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.deck" */
export type Rangers_Deck_Inc_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck" */
export type Rangers_Deck_Insert_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  comments?: InputMaybe<Rangers_Comment_Arr_Rel_Insert_Input>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Obj_Rel_Insert_Input>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Obj_Rel_Insert_Input>;
  previous_deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  rank?: InputMaybe<Rangers_Deck_Rank_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "rangers.deck_like" */
export type Rangers_Deck_Like = {
  __typename?: 'rangers_deck_like';
  created_at: Scalars['timestamptz']['output'];
  /** An object relationship */
  deck: Rangers_Deck;
  deck_id: Scalars['Int']['output'];
  liked: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate = {
  __typename?: 'rangers_deck_like_aggregate';
  aggregate?: Maybe<Rangers_Deck_Like_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Like>;
};

/** aggregate fields of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate_Fields = {
  __typename?: 'rangers_deck_like_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Like_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Like_Max_Fields>;
  min?: Maybe<Rangers_Deck_Like_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Like_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Like_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Like_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Like_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Like_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Like_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Like_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_like" */
export type Rangers_Deck_Like_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Like_Avg_Fields = {
  __typename?: 'rangers_deck_like_avg_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_like". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Like_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Like_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Like_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  liked?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_like" */
export enum Rangers_Deck_Like_Constraint {
  /** unique or primary key constraint on columns "user_id", "deck_id" */
  DeckLikesPkey = 'deck_likes_pkey'
}

/** columns and relationships of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count = {
  __typename?: 'rangers_deck_like_count';
  count: Scalars['Int']['output'];
  created_at: Scalars['timestamptz']['output'];
  deck_id: Scalars['Int']['output'];
  updated_at: Scalars['timestamptz']['output'];
};

/** aggregated selection of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate = {
  __typename?: 'rangers_deck_like_count_aggregate';
  aggregate?: Maybe<Rangers_Deck_Like_Count_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Like_Count>;
};

/** aggregate fields of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate_Fields = {
  __typename?: 'rangers_deck_like_count_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Like_Count_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Like_Count_Max_Fields>;
  min?: Maybe<Rangers_Deck_Like_Count_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Like_Count_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Like_Count_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Like_Count_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Like_Count_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Like_Count_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Like_Count_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Like_Count_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Like_Count_Avg_Fields = {
  __typename?: 'rangers_deck_like_count_avg_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_like_count". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Like_Count_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Like_Count_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Like_Count_Bool_Exp>>;
  count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Constraint {
  /** unique or primary key constraint on columns "deck_id" */
  DeckLikeCountPkey = 'deck_like_count_pkey'
}

/** input type for incrementing numeric columns in table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Inc_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Insert_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Like_Count_Max_Fields = {
  __typename?: 'rangers_deck_like_count_max_fields';
  count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Like_Count_Min_Fields = {
  __typename?: 'rangers_deck_like_count_min_fields';
  count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Mutation_Response = {
  __typename?: 'rangers_deck_like_count_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Like_Count>;
};

/** input type for inserting object relation for remote table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Like_Count_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_Like_Count_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_On_Conflict = {
  constraint: Rangers_Deck_Like_Count_Constraint;
  update_columns?: Array<Rangers_Deck_Like_Count_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_like_count". */
export type Rangers_Deck_Like_Count_Order_By = {
  count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_like_count */
export type Rangers_Deck_Like_Count_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
};

/** select columns of table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.deck_like_count" */
export type Rangers_Deck_Like_Count_Set_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Like_Count_Stddev_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Like_Count_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Like_Count_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_like_count_stddev_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_like_count" */
export type Rangers_Deck_Like_Count_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Like_Count_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Like_Count_Stream_Cursor_Value_Input = {
  count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Like_Count_Sum_Fields = {
  __typename?: 'rangers_deck_like_count_sum_fields';
  count?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_like_count" */
export enum Rangers_Deck_Like_Count_Update_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Deck_Like_Count_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Like_Count_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Like_Count_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Like_Count_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Like_Count_Var_Pop_Fields = {
  __typename?: 'rangers_deck_like_count_var_pop_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Like_Count_Var_Samp_Fields = {
  __typename?: 'rangers_deck_like_count_var_samp_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Like_Count_Variance_Fields = {
  __typename?: 'rangers_deck_like_count_variance_fields';
  count?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** input type for incrementing numeric columns in table "rangers.deck_like" */
export type Rangers_Deck_Like_Inc_Input = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.deck_like" */
export type Rangers_Deck_Like_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Like_Max_Fields = {
  __typename?: 'rangers_deck_like_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Like_Min_Fields = {
  __typename?: 'rangers_deck_like_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.deck_like" */
export type Rangers_Deck_Like_Mutation_Response = {
  __typename?: 'rangers_deck_like_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck_Like>;
};

/** on_conflict condition type for table "rangers.deck_like" */
export type Rangers_Deck_Like_On_Conflict = {
  constraint: Rangers_Deck_Like_Constraint;
  update_columns?: Array<Rangers_Deck_Like_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck_like". */
export type Rangers_Deck_Like_Order_By = {
  created_at?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  liked?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck_like */
export type Rangers_Deck_Like_Pk_Columns_Input = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};

/** select columns of table "rangers.deck_like" */
export enum Rangers_Deck_Like_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.deck_like" */
export type Rangers_Deck_Like_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Like_Stddev_Fields = {
  __typename?: 'rangers_deck_like_stddev_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Like_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_like_stddev_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Like_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_like_stddev_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_like" */
export type Rangers_Deck_Like_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Like_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Like_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  liked?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Like_Sum_Fields = {
  __typename?: 'rangers_deck_like_sum_fields';
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck_like" */
export enum Rangers_Deck_Like_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  Liked = 'liked',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_Deck_Like_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Like_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Like_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Like_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Like_Var_Pop_Fields = {
  __typename?: 'rangers_deck_like_var_pop_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Like_Var_Samp_Fields = {
  __typename?: 'rangers_deck_like_var_samp_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Like_Variance_Fields = {
  __typename?: 'rangers_deck_like_variance_fields';
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Max_Fields = {
  __typename?: 'rangers_deck_max_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Min_Fields = {
  __typename?: 'rangers_deck_min_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "rangers.deck" */
export type Rangers_Deck_Mutation_Response = {
  __typename?: 'rangers_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Deck>;
};

/** input type for inserting object relation for remote table "rangers.deck" */
export type Rangers_Deck_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Deck_On_Conflict>;
};

/** on_conflict condition type for table "rangers.deck" */
export type Rangers_Deck_On_Conflict = {
  constraint: Rangers_Deck_Constraint;
  update_columns?: Array<Rangers_Deck_Update_Column>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.deck". */
export type Rangers_Deck_Order_By = {
  awa?: InputMaybe<Order_By>;
  base_deck?: InputMaybe<Rangers_Deck_Order_By>;
  base_deck_id?: InputMaybe<Order_By>;
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  comment_count?: InputMaybe<Order_By>;
  comments_aggregate?: InputMaybe<Rangers_Comment_Aggregate_Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  extra_slots?: InputMaybe<Order_By>;
  fit?: InputMaybe<Order_By>;
  foc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck?: InputMaybe<Rangers_Deck_Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  original_deck?: InputMaybe<Rangers_Deck_Copy_Order_By>;
  previous_deck?: InputMaybe<Rangers_Deck_Order_By>;
  published?: InputMaybe<Order_By>;
  rank?: InputMaybe<Rangers_Deck_Rank_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  spi?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  upgrade?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.deck */
export type Rangers_Deck_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Deck_Prepend_Input = {
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** columns and relationships of "rangers.deck_rank" */
export type Rangers_Deck_Rank = {
  __typename?: 'rangers_deck_rank';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregated selection of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate = {
  __typename?: 'rangers_deck_rank_aggregate';
  aggregate?: Maybe<Rangers_Deck_Rank_Aggregate_Fields>;
  nodes: Array<Rangers_Deck_Rank>;
};

/** aggregate fields of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate_Fields = {
  __typename?: 'rangers_deck_rank_aggregate_fields';
  avg?: Maybe<Rangers_Deck_Rank_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Deck_Rank_Max_Fields>;
  min?: Maybe<Rangers_Deck_Rank_Min_Fields>;
  stddev?: Maybe<Rangers_Deck_Rank_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Deck_Rank_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Deck_Rank_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Deck_Rank_Sum_Fields>;
  var_pop?: Maybe<Rangers_Deck_Rank_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Deck_Rank_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Deck_Rank_Variance_Fields>;
};


/** aggregate fields of "rangers.deck_rank" */
export type Rangers_Deck_Rank_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Deck_Rank_Avg_Fields = {
  __typename?: 'rangers_deck_rank_avg_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.deck_rank". All fields are combined with a logical 'AND'. */
export type Rangers_Deck_Rank_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Deck_Rank_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Deck_Rank_Bool_Exp>>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Bigint_Comparison_Exp>;
  score?: InputMaybe<Float8_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.deck_rank" */
export type Rangers_Deck_Rank_Insert_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['bigint']['input']>;
  score?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate max on columns */
export type Rangers_Deck_Rank_Max_Fields = {
  __typename?: 'rangers_deck_rank_max_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregate min on columns */
export type Rangers_Deck_Rank_Min_Fields = {
  __typename?: 'rangers_deck_rank_min_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** input type for inserting object relation for remote table "rangers.deck_rank" */
export type Rangers_Deck_Rank_Obj_Rel_Insert_Input = {
  data: Rangers_Deck_Rank_Insert_Input;
};

/** Ordering options when selecting data from "rangers.deck_rank". */
export type Rangers_Deck_Rank_Order_By = {
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  score?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.deck_rank" */
export enum Rangers_Deck_Rank_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Score = 'score'
}

/** aggregate stddev on columns */
export type Rangers_Deck_Rank_Stddev_Fields = {
  __typename?: 'rangers_deck_rank_stddev_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Rank_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_rank_stddev_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Rank_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_rank_stddev_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck_rank" */
export type Rangers_Deck_Rank_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Rank_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Rank_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['bigint']['input']>;
  score?: InputMaybe<Scalars['float8']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Rank_Sum_Fields = {
  __typename?: 'rangers_deck_rank_sum_fields';
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['bigint']['output']>;
  score?: Maybe<Scalars['float8']['output']>;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Rank_Var_Pop_Fields = {
  __typename?: 'rangers_deck_rank_var_pop_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Rank_Var_Samp_Fields = {
  __typename?: 'rangers_deck_rank_var_samp_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Rank_Variance_Fields = {
  __typename?: 'rangers_deck_rank_variance_fields';
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  score?: Maybe<Scalars['Float']['output']>;
};

export type Rangers_Deck_Search_Args = {
  _limit?: InputMaybe<Scalars['Int']['input']>;
  _offset?: InputMaybe<Scalars['Int']['input']>;
  awa_eq?: InputMaybe<Scalars['Int']['input']>;
  background?: InputMaybe<Scalars['_text']['input']>;
  fit_eq?: InputMaybe<Scalars['Int']['input']>;
  foc_eq?: InputMaybe<Scalars['Int']['input']>;
  role?: InputMaybe<Scalars['_text']['input']>;
  specialty?: InputMaybe<Scalars['_text']['input']>;
  spi_eq?: InputMaybe<Scalars['Int']['input']>;
  user_id_eq?: InputMaybe<Scalars['String']['input']>;
};

/** select columns of table "rangers.deck" */
export enum Rangers_Deck_Select_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ExtraSlots = 'extra_slots',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "rangers.deck" */
export type Rangers_Deck_Set_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Deck_Stddev_Fields = {
  __typename?: 'rangers_deck_stddev_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_deck_stddev_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_deck_stddev_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_deck" */
export type Rangers_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Deck_Stream_Cursor_Value_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  extra_slots?: InputMaybe<Scalars['jsonb']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Deck_Sum_Fields = {
  __typename?: 'rangers_deck_sum_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "rangers.deck" */
export enum Rangers_Deck_Update_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  ExtraSlots = 'extra_slots',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

export type Rangers_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_deck_var_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_deck_var_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Deck_Variance_Fields = {
  __typename?: 'rangers_deck_variance_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.faq_entry" */
export type Rangers_Faq_Entry = {
  __typename?: 'rangers_faq_entry';
  card_id: Scalars['String']['output'];
  created_at: Scalars['timestamptz']['output'];
  id: Scalars['String']['output'];
  lang: Scalars['String']['output'];
  text: Scalars['String']['output'];
};

/** aggregated selection of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate = {
  __typename?: 'rangers_faq_entry_aggregate';
  aggregate?: Maybe<Rangers_Faq_Entry_Aggregate_Fields>;
  nodes: Array<Rangers_Faq_Entry>;
};

/** aggregate fields of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate_Fields = {
  __typename?: 'rangers_faq_entry_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Faq_Entry_Max_Fields>;
  min?: Maybe<Rangers_Faq_Entry_Min_Fields>;
};


/** aggregate fields of "rangers.faq_entry" */
export type Rangers_Faq_Entry_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.faq_entry". All fields are combined with a logical 'AND'. */
export type Rangers_Faq_Entry_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Faq_Entry_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Faq_Entry_Bool_Exp>>;
  card_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  lang?: InputMaybe<String_Comparison_Exp>;
  text?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Constraint {
  /** unique or primary key constraint on columns "id" */
  FaqEntryPkey = 'faq_entry_pkey'
}

/** input type for inserting data into table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Insert_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Faq_Entry_Max_Fields = {
  __typename?: 'rangers_faq_entry_max_fields';
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  lang?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Faq_Entry_Min_Fields = {
  __typename?: 'rangers_faq_entry_min_fields';
  card_id?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  lang?: Maybe<Scalars['String']['output']>;
  text?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Mutation_Response = {
  __typename?: 'rangers_faq_entry_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Faq_Entry>;
};

/** on_conflict condition type for table "rangers.faq_entry" */
export type Rangers_Faq_Entry_On_Conflict = {
  constraint: Rangers_Faq_Entry_Constraint;
  update_columns?: Array<Rangers_Faq_Entry_Update_Column>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.faq_entry". */
export type Rangers_Faq_Entry_Order_By = {
  card_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lang?: InputMaybe<Order_By>;
  text?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.faq_entry */
export type Rangers_Faq_Entry_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Select_Column {
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Text = 'text'
}

/** input type for updating data in table "rangers.faq_entry" */
export type Rangers_Faq_Entry_Set_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_faq_entry" */
export type Rangers_Faq_Entry_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Faq_Entry_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Faq_Entry_Stream_Cursor_Value_Input = {
  card_id?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  lang?: InputMaybe<Scalars['String']['input']>;
  text?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.faq_entry" */
export enum Rangers_Faq_Entry_Update_Column {
  /** column name */
  CardId = 'card_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Lang = 'lang',
  /** column name */
  Text = 'text'
}

export type Rangers_Faq_Entry_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Faq_Entry_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Faq_Entry_Bool_Exp;
};

/** columns and relationships of "rangers.friend_status" */
export type Rangers_Friend_Status = {
  __typename?: 'rangers_friend_status';
  status: Rangers_Friend_Status_Type_Enum;
  user_id_a: Scalars['String']['output'];
  user_id_b: Scalars['String']['output'];
};

/** aggregated selection of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate = {
  __typename?: 'rangers_friend_status_aggregate';
  aggregate?: Maybe<Rangers_Friend_Status_Aggregate_Fields>;
  nodes: Array<Rangers_Friend_Status>;
};

/** aggregate fields of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate_Fields = {
  __typename?: 'rangers_friend_status_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Friend_Status_Max_Fields>;
  min?: Maybe<Rangers_Friend_Status_Min_Fields>;
};


/** aggregate fields of "rangers.friend_status" */
export type Rangers_Friend_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.friend_status". All fields are combined with a logical 'AND'. */
export type Rangers_Friend_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Friend_Status_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Friend_Status_Bool_Exp>>;
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum_Comparison_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.friend_status" */
export enum Rangers_Friend_Status_Constraint {
  /** unique or primary key constraint on columns "user_id_a", "user_id_b" */
  FriendStatusPkey = 'friend_status_pkey'
}

/** input type for inserting data into table "rangers.friend_status" */
export type Rangers_Friend_Status_Insert_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Friend_Status_Max_Fields = {
  __typename?: 'rangers_friend_status_max_fields';
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Friend_Status_Min_Fields = {
  __typename?: 'rangers_friend_status_min_fields';
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.friend_status" */
export type Rangers_Friend_Status_Mutation_Response = {
  __typename?: 'rangers_friend_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Friend_Status>;
};

/** on_conflict condition type for table "rangers.friend_status" */
export type Rangers_Friend_Status_On_Conflict = {
  constraint: Rangers_Friend_Status_Constraint;
  update_columns?: Array<Rangers_Friend_Status_Update_Column>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.friend_status". */
export type Rangers_Friend_Status_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.friend_status */
export type Rangers_Friend_Status_Pk_Columns_Input = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};

/** select columns of table "rangers.friend_status" */
export enum Rangers_Friend_Status_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.friend_status" */
export type Rangers_Friend_Status_Set_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_friend_status" */
export type Rangers_Friend_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Friend_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Friend_Status_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type = {
  __typename?: 'rangers_friend_status_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate = {
  __typename?: 'rangers_friend_status_type_aggregate';
  aggregate?: Maybe<Rangers_Friend_Status_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Friend_Status_Type>;
};

/** aggregate fields of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate_Fields = {
  __typename?: 'rangers_friend_status_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Friend_Status_Type_Max_Fields>;
  min?: Maybe<Rangers_Friend_Status_Type_Min_Fields>;
};


/** aggregate fields of "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.friend_status_type". All fields are combined with a logical 'AND'. */
export type Rangers_Friend_Status_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Friend_Status_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Friend_Status_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  FriendStatusTypePkey = 'friend_status_type_pkey'
}

export enum Rangers_Friend_Status_Type_Enum {
  Friend = 'friend',
  None = 'none',
  Received = 'received',
  Sent = 'sent'
}

/** Boolean expression to compare columns of type "rangers_friend_status_type_enum". All fields are combined with logical 'AND'. */
export type Rangers_Friend_Status_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  _in?: InputMaybe<Array<Rangers_Friend_Status_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Rangers_Friend_Status_Type_Enum>;
  _nin?: InputMaybe<Array<Rangers_Friend_Status_Type_Enum>>;
};

/** input type for inserting data into table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Friend_Status_Type_Max_Fields = {
  __typename?: 'rangers_friend_status_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Friend_Status_Type_Min_Fields = {
  __typename?: 'rangers_friend_status_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Mutation_Response = {
  __typename?: 'rangers_friend_status_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Friend_Status_Type>;
};

/** on_conflict condition type for table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_On_Conflict = {
  constraint: Rangers_Friend_Status_Type_Constraint;
  update_columns?: Array<Rangers_Friend_Status_Type_Update_Column>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.friend_status_type". */
export type Rangers_Friend_Status_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.friend_status_type */
export type Rangers_Friend_Status_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "rangers.friend_status_type" */
export type Rangers_Friend_Status_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_friend_status_type" */
export type Rangers_Friend_Status_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Friend_Status_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Friend_Status_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.friend_status_type" */
export enum Rangers_Friend_Status_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type Rangers_Friend_Status_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Friend_Status_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Friend_Status_Type_Bool_Exp;
};

/** update columns of table "rangers.friend_status" */
export enum Rangers_Friend_Status_Update_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

export type Rangers_Friend_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Friend_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Friend_Status_Bool_Exp;
};

/** columns and relationships of "rangers.latest_deck" */
export type Rangers_Latest_Deck = {
  __typename?: 'rangers_latest_deck';
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  deck?: Maybe<Rangers_Deck>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate = {
  __typename?: 'rangers_latest_deck_aggregate';
  aggregate?: Maybe<Rangers_Latest_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Latest_Deck>;
};

export type Rangers_Latest_Deck_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Latest_Deck_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Latest_Deck_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_Fields = {
  __typename?: 'rangers_latest_deck_aggregate_fields';
  avg?: Maybe<Rangers_Latest_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Latest_Deck_Max_Fields>;
  min?: Maybe<Rangers_Latest_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Latest_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Latest_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Latest_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Latest_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Latest_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Latest_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Latest_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Latest_Deck_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Latest_Deck_Max_Order_By>;
  min?: InputMaybe<Rangers_Latest_Deck_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Latest_Deck_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Latest_Deck_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Latest_Deck_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Latest_Deck_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Latest_Deck_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Latest_Deck_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Latest_Deck_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Latest_Deck_Insert_Input>;
};

/** aggregate avg on columns */
export type Rangers_Latest_Deck_Avg_Fields = {
  __typename?: 'rangers_latest_deck_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.latest_deck". All fields are combined with a logical 'AND'. */
export type Rangers_Latest_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Latest_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Latest_Deck_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  deck?: InputMaybe<Rangers_Deck_Bool_Exp>;
  deck_id?: InputMaybe<Int_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck?: InputMaybe<Rangers_Deck_Obj_Rel_Insert_Input>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Latest_Deck_Max_Fields = {
  __typename?: 'rangers_latest_deck_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Latest_Deck_Min_Fields = {
  __typename?: 'rangers_latest_deck_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Mutation_Response = {
  __typename?: 'rangers_latest_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Latest_Deck>;
};

/** Ordering options when selecting data from "rangers.latest_deck". */
export type Rangers_Latest_Deck_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  deck?: InputMaybe<Rangers_Deck_Order_By>;
  deck_id?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.latest_deck" */
export enum Rangers_Latest_Deck_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  DeckId = 'deck_id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Latest_Deck_Stddev_Fields = {
  __typename?: 'rangers_latest_deck_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Latest_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_latest_deck_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Latest_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_latest_deck_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_latest_deck" */
export type Rangers_Latest_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Latest_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Latest_Deck_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Latest_Deck_Sum_Fields = {
  __typename?: 'rangers_latest_deck_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  deck_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

export type Rangers_Latest_Deck_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Latest_Deck_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Latest_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Latest_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Latest_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_latest_deck_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Latest_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_latest_deck_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Latest_Deck_Variance_Fields = {
  __typename?: 'rangers_latest_deck_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  deck_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.latest_deck" */
export type Rangers_Latest_Deck_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  deck_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.locale" */
export type Rangers_Locale = {
  __typename?: 'rangers_locale';
  locale: Scalars['String']['output'];
};

/** aggregated selection of "rangers.locale" */
export type Rangers_Locale_Aggregate = {
  __typename?: 'rangers_locale_aggregate';
  aggregate?: Maybe<Rangers_Locale_Aggregate_Fields>;
  nodes: Array<Rangers_Locale>;
};

/** aggregate fields of "rangers.locale" */
export type Rangers_Locale_Aggregate_Fields = {
  __typename?: 'rangers_locale_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Locale_Max_Fields>;
  min?: Maybe<Rangers_Locale_Min_Fields>;
};


/** aggregate fields of "rangers.locale" */
export type Rangers_Locale_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.locale". All fields are combined with a logical 'AND'. */
export type Rangers_Locale_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Locale_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Locale_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Locale_Bool_Exp>>;
  locale?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.locale" */
export enum Rangers_Locale_Constraint {
  /** unique or primary key constraint on columns "locale" */
  LocalePkey = 'locale_pkey'
}

/** input type for inserting data into table "rangers.locale" */
export type Rangers_Locale_Insert_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_Locale_Max_Fields = {
  __typename?: 'rangers_locale_max_fields';
  locale?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_Locale_Min_Fields = {
  __typename?: 'rangers_locale_min_fields';
  locale?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.locale" */
export type Rangers_Locale_Mutation_Response = {
  __typename?: 'rangers_locale_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Locale>;
};

/** on_conflict condition type for table "rangers.locale" */
export type Rangers_Locale_On_Conflict = {
  constraint: Rangers_Locale_Constraint;
  update_columns?: Array<Rangers_Locale_Update_Column>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.locale". */
export type Rangers_Locale_Order_By = {
  locale?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.locale */
export type Rangers_Locale_Pk_Columns_Input = {
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.locale" */
export enum Rangers_Locale_Select_Column {
  /** column name */
  Locale = 'locale'
}

/** input type for updating data in table "rangers.locale" */
export type Rangers_Locale_Set_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_locale" */
export type Rangers_Locale_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Locale_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Locale_Stream_Cursor_Value_Input = {
  locale?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.locale" */
export enum Rangers_Locale_Update_Column {
  /** column name */
  Locale = 'locale'
}

export type Rangers_Locale_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Locale_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Locale_Bool_Exp;
};

/** columns and relationships of "rangers.pack" */
export type Rangers_Pack = {
  __typename?: 'rangers_pack';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  position?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Pack_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Pack_Text_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.pack" */
export type Rangers_PackTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.pack" */
export type Rangers_PackTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.pack" */
export type Rangers_Pack_Aggregate = {
  __typename?: 'rangers_pack_aggregate';
  aggregate?: Maybe<Rangers_Pack_Aggregate_Fields>;
  nodes: Array<Rangers_Pack>;
};

/** aggregate fields of "rangers.pack" */
export type Rangers_Pack_Aggregate_Fields = {
  __typename?: 'rangers_pack_aggregate_fields';
  avg?: Maybe<Rangers_Pack_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Pack_Max_Fields>;
  min?: Maybe<Rangers_Pack_Min_Fields>;
  stddev?: Maybe<Rangers_Pack_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Pack_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Pack_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Pack_Sum_Fields>;
  var_pop?: Maybe<Rangers_Pack_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Pack_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Pack_Variance_Fields>;
};


/** aggregate fields of "rangers.pack" */
export type Rangers_Pack_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Pack_Avg_Fields = {
  __typename?: 'rangers_pack_avg_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.pack". All fields are combined with a logical 'AND'. */
export type Rangers_Pack_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Pack_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Pack_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Pack_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<Int_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Pack_Text_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.pack" */
export enum Rangers_Pack_Constraint {
  /** unique or primary key constraint on columns "id" */
  PackPkey = 'pack_pkey'
}

/** input type for incrementing numeric columns in table "rangers.pack" */
export type Rangers_Pack_Inc_Input = {
  position?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.pack" */
export type Rangers_Pack_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<Rangers_Pack_Text_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Pack_Max_Fields = {
  __typename?: 'rangers_pack_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Pack_Min_Fields = {
  __typename?: 'rangers_pack_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.pack" */
export type Rangers_Pack_Mutation_Response = {
  __typename?: 'rangers_pack_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Pack>;
};

/** on_conflict condition type for table "rangers.pack" */
export type Rangers_Pack_On_Conflict = {
  constraint: Rangers_Pack_Constraint;
  update_columns?: Array<Rangers_Pack_Update_Column>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.pack". */
export type Rangers_Pack_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Pack_Text_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.pack */
export type Rangers_Pack_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.pack" */
export enum Rangers_Pack_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.pack" */
export type Rangers_Pack_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Pack_Stddev_Fields = {
  __typename?: 'rangers_pack_stddev_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Pack_Stddev_Pop_Fields = {
  __typename?: 'rangers_pack_stddev_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Pack_Stddev_Samp_Fields = {
  __typename?: 'rangers_pack_stddev_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_pack" */
export type Rangers_Pack_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Pack_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Pack_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Pack_Sum_Fields = {
  __typename?: 'rangers_pack_sum_fields';
  position?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.pack_text" */
export type Rangers_Pack_Text = {
  __typename?: 'rangers_pack_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate = {
  __typename?: 'rangers_pack_text_aggregate';
  aggregate?: Maybe<Rangers_Pack_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Pack_Text>;
};

export type Rangers_Pack_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Pack_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Pack_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_Fields = {
  __typename?: 'rangers_pack_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Pack_Text_Max_Fields>;
  min?: Maybe<Rangers_Pack_Text_Min_Fields>;
};


/** aggregate fields of "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.pack_text" */
export type Rangers_Pack_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Pack_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Pack_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.pack_text" */
export type Rangers_Pack_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Pack_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Pack_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.pack_text". All fields are combined with a logical 'AND'. */
export type Rangers_Pack_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Pack_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Pack_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.pack_text" */
export enum Rangers_Pack_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  PackTextPkey = 'pack_text_pkey'
}

/** input type for inserting data into table "rangers.pack_text" */
export type Rangers_Pack_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Pack_Text_Max_Fields = {
  __typename?: 'rangers_pack_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.pack_text" */
export type Rangers_Pack_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Pack_Text_Min_Fields = {
  __typename?: 'rangers_pack_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.pack_text" */
export type Rangers_Pack_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.pack_text" */
export type Rangers_Pack_Text_Mutation_Response = {
  __typename?: 'rangers_pack_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Pack_Text>;
};

/** on_conflict condition type for table "rangers.pack_text" */
export type Rangers_Pack_Text_On_Conflict = {
  constraint: Rangers_Pack_Text_Constraint;
  update_columns?: Array<Rangers_Pack_Text_Update_Column>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.pack_text". */
export type Rangers_Pack_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.pack_text */
export type Rangers_Pack_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.pack_text" */
export enum Rangers_Pack_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.pack_text" */
export type Rangers_Pack_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_pack_text" */
export type Rangers_Pack_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Pack_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Pack_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.pack_text" */
export enum Rangers_Pack_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Pack_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Pack_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Pack_Text_Bool_Exp;
};

/** update columns of table "rangers.pack" */
export enum Rangers_Pack_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Pack_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Pack_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Pack_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Pack_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Pack_Var_Pop_Fields = {
  __typename?: 'rangers_pack_var_pop_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Pack_Var_Samp_Fields = {
  __typename?: 'rangers_pack_var_samp_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Pack_Variance_Fields = {
  __typename?: 'rangers_pack_variance_fields';
  position?: Maybe<Scalars['Float']['output']>;
};

export type Rangers_Publish_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
};

export type Rangers_Remove_Campaign_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  old_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_Deck = {
  __typename?: 'rangers_search_deck';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  /** A computed field, executes function "rangers.search_deck_liked_by_user" */
  liked_by_user?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  likes?: Maybe<Rangers_Deck_Like_Count>;
  meta?: Maybe<Scalars['jsonb']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  published?: Maybe<Scalars['Boolean']['output']>;
  /** An object relationship */
  rank?: Maybe<Rangers_Deck_Rank>;
  side_slots?: Maybe<Scalars['jsonb']['output']>;
  slots?: Maybe<Scalars['jsonb']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  tags?: Maybe<Scalars['jsonb']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  upgrade?: Maybe<Scalars['jsonb']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckMetaArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckSide_SlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckSlotsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckTagsArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "rangers.search_deck" */
export type Rangers_Search_DeckUpgradeArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_Search_Deck_Aggregate = {
  __typename?: 'rangers_search_deck_aggregate';
  aggregate?: Maybe<Rangers_Search_Deck_Aggregate_Fields>;
  nodes: Array<Rangers_Search_Deck>;
};

/** aggregate fields of "rangers.search_deck" */
export type Rangers_Search_Deck_Aggregate_Fields = {
  __typename?: 'rangers_search_deck_aggregate_fields';
  avg?: Maybe<Rangers_Search_Deck_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Search_Deck_Max_Fields>;
  min?: Maybe<Rangers_Search_Deck_Min_Fields>;
  stddev?: Maybe<Rangers_Search_Deck_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Search_Deck_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Search_Deck_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Search_Deck_Sum_Fields>;
  var_pop?: Maybe<Rangers_Search_Deck_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Search_Deck_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Search_Deck_Variance_Fields>;
};


/** aggregate fields of "rangers.search_deck" */
export type Rangers_Search_Deck_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Search_Deck_Append_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Search_Deck_Avg_Fields = {
  __typename?: 'rangers_search_deck_avg_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.search_deck". All fields are combined with a logical 'AND'. */
export type Rangers_Search_Deck_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Search_Deck_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Search_Deck_Bool_Exp>>;
  awa?: InputMaybe<Int_Comparison_Exp>;
  base_deck_id?: InputMaybe<Int_Comparison_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  comment_count?: InputMaybe<Int_Comparison_Exp>;
  copy_count?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  fit?: InputMaybe<Int_Comparison_Exp>;
  foc?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  like_count?: InputMaybe<Int_Comparison_Exp>;
  liked_by_user?: InputMaybe<Boolean_Comparison_Exp>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
  meta?: InputMaybe<Jsonb_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  next_deck_id?: InputMaybe<Int_Comparison_Exp>;
  published?: InputMaybe<Boolean_Comparison_Exp>;
  rank?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
  side_slots?: InputMaybe<Jsonb_Comparison_Exp>;
  slots?: InputMaybe<Jsonb_Comparison_Exp>;
  spi?: InputMaybe<Int_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  upgrade?: InputMaybe<Jsonb_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
  version?: InputMaybe<Int_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Rangers_Search_Deck_Delete_At_Path_Input = {
  meta?: InputMaybe<Array<Scalars['String']['input']>>;
  side_slots?: InputMaybe<Array<Scalars['String']['input']>>;
  slots?: InputMaybe<Array<Scalars['String']['input']>>;
  tags?: InputMaybe<Array<Scalars['String']['input']>>;
  upgrade?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Rangers_Search_Deck_Delete_Elem_Input = {
  meta?: InputMaybe<Scalars['Int']['input']>;
  side_slots?: InputMaybe<Scalars['Int']['input']>;
  slots?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['Int']['input']>;
  upgrade?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Rangers_Search_Deck_Delete_Key_Input = {
  meta?: InputMaybe<Scalars['String']['input']>;
  side_slots?: InputMaybe<Scalars['String']['input']>;
  slots?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
  upgrade?: InputMaybe<Scalars['String']['input']>;
};

/** input type for incrementing numeric columns in table "rangers.search_deck" */
export type Rangers_Search_Deck_Inc_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.search_deck" */
export type Rangers_Search_Deck_Insert_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Obj_Rel_Insert_Input>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  rank?: InputMaybe<Rangers_Deck_Rank_Obj_Rel_Insert_Input>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate max on columns */
export type Rangers_Search_Deck_Max_Fields = {
  __typename?: 'rangers_search_deck_max_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** aggregate min on columns */
export type Rangers_Search_Deck_Min_Fields = {
  __typename?: 'rangers_search_deck_min_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

/** response of any mutation on the table "rangers.search_deck" */
export type Rangers_Search_Deck_Mutation_Response = {
  __typename?: 'rangers_search_deck_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Search_Deck>;
};

/** Ordering options when selecting data from "rangers.search_deck". */
export type Rangers_Search_Deck_Order_By = {
  awa?: InputMaybe<Order_By>;
  base_deck_id?: InputMaybe<Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  comment_count?: InputMaybe<Order_By>;
  copy_count?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  fit?: InputMaybe<Order_By>;
  foc?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  like_count?: InputMaybe<Order_By>;
  liked_by_user?: InputMaybe<Order_By>;
  likes?: InputMaybe<Rangers_Deck_Like_Count_Order_By>;
  meta?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  next_deck_id?: InputMaybe<Order_By>;
  published?: InputMaybe<Order_By>;
  rank?: InputMaybe<Rangers_Deck_Rank_Order_By>;
  side_slots?: InputMaybe<Order_By>;
  slots?: InputMaybe<Order_By>;
  spi?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  upgrade?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Rangers_Search_Deck_Prepend_Input = {
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "rangers.search_deck" */
export enum Rangers_Search_Deck_Select_Column {
  /** column name */
  Awa = 'awa',
  /** column name */
  BaseDeckId = 'base_deck_id',
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  CommentCount = 'comment_count',
  /** column name */
  CopyCount = 'copy_count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Fit = 'fit',
  /** column name */
  Foc = 'foc',
  /** column name */
  Id = 'id',
  /** column name */
  LikeCount = 'like_count',
  /** column name */
  Meta = 'meta',
  /** column name */
  Name = 'name',
  /** column name */
  NextDeckId = 'next_deck_id',
  /** column name */
  Published = 'published',
  /** column name */
  SideSlots = 'side_slots',
  /** column name */
  Slots = 'slots',
  /** column name */
  Spi = 'spi',
  /** column name */
  Tags = 'tags',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Upgrade = 'upgrade',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "rangers.search_deck" */
export type Rangers_Search_Deck_Set_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Search_Deck_Stddev_Fields = {
  __typename?: 'rangers_search_deck_stddev_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Search_Deck_Stddev_Pop_Fields = {
  __typename?: 'rangers_search_deck_stddev_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Search_Deck_Stddev_Samp_Fields = {
  __typename?: 'rangers_search_deck_stddev_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_search_deck" */
export type Rangers_Search_Deck_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Search_Deck_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Search_Deck_Stream_Cursor_Value_Input = {
  awa?: InputMaybe<Scalars['Int']['input']>;
  base_deck_id?: InputMaybe<Scalars['Int']['input']>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  comment_count?: InputMaybe<Scalars['Int']['input']>;
  copy_count?: InputMaybe<Scalars['Int']['input']>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  fit?: InputMaybe<Scalars['Int']['input']>;
  foc?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  like_count?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  next_deck_id?: InputMaybe<Scalars['Int']['input']>;
  published?: InputMaybe<Scalars['Boolean']['input']>;
  side_slots?: InputMaybe<Scalars['jsonb']['input']>;
  slots?: InputMaybe<Scalars['jsonb']['input']>;
  spi?: InputMaybe<Scalars['Int']['input']>;
  tags?: InputMaybe<Scalars['jsonb']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  upgrade?: InputMaybe<Scalars['jsonb']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
  version?: InputMaybe<Scalars['Int']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Search_Deck_Sum_Fields = {
  __typename?: 'rangers_search_deck_sum_fields';
  awa?: Maybe<Scalars['Int']['output']>;
  base_deck_id?: Maybe<Scalars['Int']['output']>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  comment_count?: Maybe<Scalars['Int']['output']>;
  copy_count?: Maybe<Scalars['Int']['output']>;
  fit?: Maybe<Scalars['Int']['output']>;
  foc?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  like_count?: Maybe<Scalars['Int']['output']>;
  next_deck_id?: Maybe<Scalars['Int']['output']>;
  spi?: Maybe<Scalars['Int']['output']>;
  version?: Maybe<Scalars['Int']['output']>;
};

export type Rangers_Search_Deck_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<Rangers_Search_Deck_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<Rangers_Search_Deck_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<Rangers_Search_Deck_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<Rangers_Search_Deck_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Search_Deck_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<Rangers_Search_Deck_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Search_Deck_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Search_Deck_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Search_Deck_Var_Pop_Fields = {
  __typename?: 'rangers_search_deck_var_pop_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Search_Deck_Var_Samp_Fields = {
  __typename?: 'rangers_search_deck_var_samp_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Search_Deck_Variance_Fields = {
  __typename?: 'rangers_search_deck_variance_fields';
  awa?: Maybe<Scalars['Float']['output']>;
  base_deck_id?: Maybe<Scalars['Float']['output']>;
  campaign_id?: Maybe<Scalars['Float']['output']>;
  comment_count?: Maybe<Scalars['Float']['output']>;
  copy_count?: Maybe<Scalars['Float']['output']>;
  fit?: Maybe<Scalars['Float']['output']>;
  foc?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
  like_count?: Maybe<Scalars['Float']['output']>;
  next_deck_id?: Maybe<Scalars['Float']['output']>;
  spi?: Maybe<Scalars['Float']['output']>;
  version?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.set" */
export type Rangers_Set = {
  __typename?: 'rangers_set';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  size?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  translations: Array<Rangers_Set_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Set_Text_Aggregate;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set" */
export type Rangers_SetTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.set" */
export type Rangers_SetTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.set" */
export type Rangers_Set_Aggregate = {
  __typename?: 'rangers_set_aggregate';
  aggregate?: Maybe<Rangers_Set_Aggregate_Fields>;
  nodes: Array<Rangers_Set>;
};

/** aggregate fields of "rangers.set" */
export type Rangers_Set_Aggregate_Fields = {
  __typename?: 'rangers_set_aggregate_fields';
  avg?: Maybe<Rangers_Set_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Max_Fields>;
  min?: Maybe<Rangers_Set_Min_Fields>;
  stddev?: Maybe<Rangers_Set_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Set_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Set_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Set_Sum_Fields>;
  var_pop?: Maybe<Rangers_Set_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Set_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Set_Variance_Fields>;
};


/** aggregate fields of "rangers.set" */
export type Rangers_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Rangers_Set_Avg_Fields = {
  __typename?: 'rangers_set_avg_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "rangers.set". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Set_Text_Aggregate_Bool_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

export type Rangers_Set_Campaign_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  new_campaign_id?: InputMaybe<Scalars['Int']['input']>;
};

/** unique or primary key constraints on table "rangers.set" */
export enum Rangers_Set_Constraint {
  /** unique or primary key constraint on columns "id" */
  SetPkey = 'set_pkey'
}

/** input type for incrementing numeric columns in table "rangers.set" */
export type Rangers_Set_Inc_Input = {
  size?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "rangers.set" */
export type Rangers_Set_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  translations?: InputMaybe<Rangers_Set_Text_Arr_Rel_Insert_Input>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_localized" */
export type Rangers_Set_Localized = {
  __typename?: 'rangers_set_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate = {
  __typename?: 'rangers_set_localized_aggregate';
  aggregate?: Maybe<Rangers_Set_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Localized>;
};

export type Rangers_Set_Localized_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Localized_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Localized_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_Fields = {
  __typename?: 'rangers_set_localized_aggregate_fields';
  avg?: Maybe<Rangers_Set_Localized_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Localized_Max_Fields>;
  min?: Maybe<Rangers_Set_Localized_Min_Fields>;
  stddev?: Maybe<Rangers_Set_Localized_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_Set_Localized_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_Set_Localized_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_Set_Localized_Sum_Fields>;
  var_pop?: Maybe<Rangers_Set_Localized_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_Set_Localized_Var_Samp_Fields>;
  variance?: Maybe<Rangers_Set_Localized_Variance_Fields>;
};


/** aggregate fields of "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_localized" */
export type Rangers_Set_Localized_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_Set_Localized_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Localized_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Localized_Min_Order_By>;
  stddev?: InputMaybe<Rangers_Set_Localized_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_Set_Localized_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_Set_Localized_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_Set_Localized_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_Set_Localized_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_Set_Localized_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_Set_Localized_Variance_Order_By>;
};

/** aggregate avg on columns */
export type Rangers_Set_Localized_Avg_Fields = {
  __typename?: 'rangers_set_localized_avg_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Avg_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.set_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  size?: InputMaybe<Int_Comparison_Exp>;
  type_id?: InputMaybe<String_Comparison_Exp>;
  type_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Set_Localized_Max_Fields = {
  __typename?: 'rangers_set_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Localized_Min_Fields = {
  __typename?: 'rangers_set_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  type_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "rangers.set_localized". */
export type Rangers_Set_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  type_id?: InputMaybe<Order_By>;
  type_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.set_localized" */
export enum Rangers_Set_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  TypeName = 'type_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate stddev on columns */
export type Rangers_Set_Localized_Stddev_Fields = {
  __typename?: 'rangers_set_localized_stddev_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Set_Localized_Stddev_Pop_Fields = {
  __typename?: 'rangers_set_localized_stddev_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Set_Localized_Stddev_Samp_Fields = {
  __typename?: 'rangers_set_localized_stddev_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Stddev_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_set_localized" */
export type Rangers_Set_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  type_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Set_Localized_Sum_Fields = {
  __typename?: 'rangers_set_localized_sum_fields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Sum_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Rangers_Set_Localized_Var_Pop_Fields = {
  __typename?: 'rangers_set_localized_var_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Var_Pop_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_Set_Localized_Var_Samp_Fields = {
  __typename?: 'rangers_set_localized_var_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Var_Samp_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_Set_Localized_Variance_Fields = {
  __typename?: 'rangers_set_localized_variance_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.set_localized" */
export type Rangers_Set_Localized_Variance_Order_By = {
  size?: InputMaybe<Order_By>;
};

/** aggregate max on columns */
export type Rangers_Set_Max_Fields = {
  __typename?: 'rangers_set_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Min_Fields = {
  __typename?: 'rangers_set_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  size?: Maybe<Scalars['Int']['output']>;
  type_id?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.set" */
export type Rangers_Set_Mutation_Response = {
  __typename?: 'rangers_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set>;
};

/** on_conflict condition type for table "rangers.set" */
export type Rangers_Set_On_Conflict = {
  constraint: Rangers_Set_Constraint;
  update_columns?: Array<Rangers_Set_Update_Column>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set". */
export type Rangers_Set_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  size?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Set_Text_Aggregate_Order_By>;
  type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set */
export type Rangers_Set_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.set" */
export enum Rangers_Set_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set" */
export type Rangers_Set_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate stddev on columns */
export type Rangers_Set_Stddev_Fields = {
  __typename?: 'rangers_set_stddev_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Rangers_Set_Stddev_Pop_Fields = {
  __typename?: 'rangers_set_stddev_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Rangers_Set_Stddev_Samp_Fields = {
  __typename?: 'rangers_set_stddev_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "rangers_set" */
export type Rangers_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  size?: InputMaybe<Scalars['Int']['input']>;
  type_id?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate sum on columns */
export type Rangers_Set_Sum_Fields = {
  __typename?: 'rangers_set_sum_fields';
  size?: Maybe<Scalars['Int']['output']>;
};

/** columns and relationships of "rangers.set_text" */
export type Rangers_Set_Text = {
  __typename?: 'rangers_set_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate = {
  __typename?: 'rangers_set_text_aggregate';
  aggregate?: Maybe<Rangers_Set_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Text>;
};

export type Rangers_Set_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_Fields = {
  __typename?: 'rangers_set_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Text_Max_Fields>;
  min?: Maybe<Rangers_Set_Text_Min_Fields>;
};


/** aggregate fields of "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_text" */
export type Rangers_Set_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.set_text" */
export type Rangers_Set_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Set_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Set_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.set_text". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_text" */
export enum Rangers_Set_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  SetTextPkey = 'set_text_pkey'
}

/** input type for inserting data into table "rangers.set_text" */
export type Rangers_Set_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Text_Max_Fields = {
  __typename?: 'rangers_set_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_text" */
export type Rangers_Set_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Text_Min_Fields = {
  __typename?: 'rangers_set_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_text" */
export type Rangers_Set_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.set_text" */
export type Rangers_Set_Text_Mutation_Response = {
  __typename?: 'rangers_set_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Text>;
};

/** on_conflict condition type for table "rangers.set_text" */
export type Rangers_Set_Text_On_Conflict = {
  constraint: Rangers_Set_Text_Constraint;
  update_columns?: Array<Rangers_Set_Text_Update_Column>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_text". */
export type Rangers_Set_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_text */
export type Rangers_Set_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.set_text" */
export enum Rangers_Set_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_text" */
export type Rangers_Set_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_text" */
export type Rangers_Set_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.set_text" */
export enum Rangers_Set_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Text_Bool_Exp;
};

/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_Type = {
  __typename?: 'rangers_set_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  translations: Array<Rangers_Set_Type_Text>;
  /** An aggregate relationship */
  translations_aggregate: Rangers_Set_Type_Text_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_TypeTranslationsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


/** columns and relationships of "rangers.set_type" */
export type Rangers_Set_TypeTranslations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};

/** aggregated selection of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate = {
  __typename?: 'rangers_set_type_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type>;
};

/** aggregate fields of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate_Fields = {
  __typename?: 'rangers_set_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Min_Fields>;
};


/** aggregate fields of "rangers.set_type" */
export type Rangers_Set_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.set_type". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  translations?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  translations_aggregate?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_type" */
export enum Rangers_Set_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  SetTypePkey = 'set_type_pkey'
}

/** input type for inserting data into table "rangers.set_type" */
export type Rangers_Set_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  translations?: InputMaybe<Rangers_Set_Type_Text_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized = {
  __typename?: 'rangers_set_type_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  sets: Array<Rangers_Set_Localized>;
  /** An aggregate relationship */
  sets_aggregate: Rangers_Set_Localized_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};


/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_LocalizedSetsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


/** columns and relationships of "rangers.set_type_localized" */
export type Rangers_Set_Type_LocalizedSets_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};

/** aggregated selection of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate = {
  __typename?: 'rangers_set_type_localized_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type_Localized>;
};

/** aggregate fields of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate_Fields = {
  __typename?: 'rangers_set_type_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Localized_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.set_type_localized" */
export type Rangers_Set_Type_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.set_type_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  sets?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
  sets_aggregate?: InputMaybe<Rangers_Set_Localized_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Localized_Max_Fields = {
  __typename?: 'rangers_set_type_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Localized_Min_Fields = {
  __typename?: 'rangers_set_type_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.set_type_localized". */
export type Rangers_Set_Type_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  sets_aggregate?: InputMaybe<Rangers_Set_Localized_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.set_type_localized" */
export enum Rangers_Set_Type_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_set_type_localized" */
export type Rangers_Set_Type_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Max_Fields = {
  __typename?: 'rangers_set_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Min_Fields = {
  __typename?: 'rangers_set_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.set_type" */
export type Rangers_Set_Type_Mutation_Response = {
  __typename?: 'rangers_set_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Type>;
};

/** on_conflict condition type for table "rangers.set_type" */
export type Rangers_Set_Type_On_Conflict = {
  constraint: Rangers_Set_Type_Constraint;
  update_columns?: Array<Rangers_Set_Type_Update_Column>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_type". */
export type Rangers_Set_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  translations_aggregate?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_type */
export type Rangers_Set_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.set_type" */
export enum Rangers_Set_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_type" */
export type Rangers_Set_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_type" */
export type Rangers_Set_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.set_type_text" */
export type Rangers_Set_Type_Text = {
  __typename?: 'rangers_set_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate = {
  __typename?: 'rangers_set_type_text_aggregate';
  aggregate?: Maybe<Rangers_Set_Type_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Set_Type_Text>;
};

export type Rangers_Set_Type_Text_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_Set_Type_Text_Aggregate_Bool_Exp_Count>;
};

export type Rangers_Set_Type_Text_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_Fields = {
  __typename?: 'rangers_set_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Set_Type_Text_Max_Fields>;
  min?: Maybe<Rangers_Set_Type_Text_Min_Fields>;
};


/** aggregate fields of "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_Set_Type_Text_Max_Order_By>;
  min?: InputMaybe<Rangers_Set_Type_Text_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Arr_Rel_Insert_Input = {
  data: Array<Rangers_Set_Type_Text_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Set_Type_Text_On_Conflict>;
};

/** Boolean expression to filter rows from the table "rangers.set_type_text". All fields are combined with a logical 'AND'. */
export type Rangers_Set_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Set_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Set_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  SetTypeTextPkey = 'set_type_text_pkey'
}

/** input type for inserting data into table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Set_Type_Text_Max_Fields = {
  __typename?: 'rangers_set_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by max() on columns of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_Set_Type_Text_Min_Fields = {
  __typename?: 'rangers_set_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** order by min() on columns of table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Mutation_Response = {
  __typename?: 'rangers_set_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Set_Type_Text>;
};

/** on_conflict condition type for table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_On_Conflict = {
  constraint: Rangers_Set_Type_Text_Constraint;
  update_columns?: Array<Rangers_Set_Type_Text_Update_Column>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.set_type_text". */
export type Rangers_Set_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.set_type_text */
export type Rangers_Set_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.set_type_text" */
export type Rangers_Set_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_set_type_text" */
export type Rangers_Set_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Set_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Set_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.set_type_text" */
export enum Rangers_Set_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Type_Text_Bool_Exp;
};

/** update columns of table "rangers.set_type" */
export enum Rangers_Set_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Type_Bool_Exp;
};

/** update columns of table "rangers.set" */
export enum Rangers_Set_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Size = 'size',
  /** column name */
  TypeId = 'type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Set_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Rangers_Set_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Set_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Rangers_Set_Var_Pop_Fields = {
  __typename?: 'rangers_set_var_pop_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Rangers_Set_Var_Samp_Fields = {
  __typename?: 'rangers_set_var_samp_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Rangers_Set_Variance_Fields = {
  __typename?: 'rangers_set_variance_fields';
  size?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "rangers.token" */
export type Rangers_Token = {
  __typename?: 'rangers_token';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.token" */
export type Rangers_Token_Aggregate = {
  __typename?: 'rangers_token_aggregate';
  aggregate?: Maybe<Rangers_Token_Aggregate_Fields>;
  nodes: Array<Rangers_Token>;
};

/** aggregate fields of "rangers.token" */
export type Rangers_Token_Aggregate_Fields = {
  __typename?: 'rangers_token_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Token_Max_Fields>;
  min?: Maybe<Rangers_Token_Min_Fields>;
};


/** aggregate fields of "rangers.token" */
export type Rangers_Token_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.token". All fields are combined with a logical 'AND'. */
export type Rangers_Token_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Token_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Token_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Token_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plurals?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.token" */
export enum Rangers_Token_Constraint {
  /** unique or primary key constraint on columns "id" */
  TokenPkey = 'token_pkey'
}

/** input type for inserting data into table "rangers.token" */
export type Rangers_Token_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Token_Max_Fields = {
  __typename?: 'rangers_token_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Token_Min_Fields = {
  __typename?: 'rangers_token_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.token" */
export type Rangers_Token_Mutation_Response = {
  __typename?: 'rangers_token_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Token>;
};

/** on_conflict condition type for table "rangers.token" */
export type Rangers_Token_On_Conflict = {
  constraint: Rangers_Token_Constraint;
  update_columns?: Array<Rangers_Token_Update_Column>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.token". */
export type Rangers_Token_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  plurals?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.token */
export type Rangers_Token_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.token" */
export enum Rangers_Token_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.token" */
export type Rangers_Token_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_token" */
export type Rangers_Token_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Token_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Token_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.token_text" */
export type Rangers_Token_Text = {
  __typename?: 'rangers_token_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  plurals: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate = {
  __typename?: 'rangers_token_text_aggregate';
  aggregate?: Maybe<Rangers_Token_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Token_Text>;
};

/** aggregate fields of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate_Fields = {
  __typename?: 'rangers_token_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Token_Text_Max_Fields>;
  min?: Maybe<Rangers_Token_Text_Min_Fields>;
};


/** aggregate fields of "rangers.token_text" */
export type Rangers_Token_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.token_text". All fields are combined with a logical 'AND'. */
export type Rangers_Token_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Token_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Token_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  plurals?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.token_text" */
export enum Rangers_Token_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TokenTextPkey = 'token_text_pkey'
}

/** input type for inserting data into table "rangers.token_text" */
export type Rangers_Token_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Token_Text_Max_Fields = {
  __typename?: 'rangers_token_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Token_Text_Min_Fields = {
  __typename?: 'rangers_token_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  plurals?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.token_text" */
export type Rangers_Token_Text_Mutation_Response = {
  __typename?: 'rangers_token_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Token_Text>;
};

/** on_conflict condition type for table "rangers.token_text" */
export type Rangers_Token_Text_On_Conflict = {
  constraint: Rangers_Token_Text_Constraint;
  update_columns?: Array<Rangers_Token_Text_Update_Column>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.token_text". */
export type Rangers_Token_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  plurals?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.token_text */
export type Rangers_Token_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.token_text" */
export enum Rangers_Token_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.token_text" */
export type Rangers_Token_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_token_text" */
export type Rangers_Token_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Token_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Token_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  plurals?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.token_text" */
export enum Rangers_Token_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Token_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Token_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Token_Text_Bool_Exp;
};

/** update columns of table "rangers.token" */
export enum Rangers_Token_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Plurals = 'plurals',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Token_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Token_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Token_Bool_Exp;
};

/** columns and relationships of "rangers.type" */
export type Rangers_Type = {
  __typename?: 'rangers_type';
  id: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type" */
export type Rangers_Type_Aggregate = {
  __typename?: 'rangers_type_aggregate';
  aggregate?: Maybe<Rangers_Type_Aggregate_Fields>;
  nodes: Array<Rangers_Type>;
};

/** aggregate fields of "rangers.type" */
export type Rangers_Type_Aggregate_Fields = {
  __typename?: 'rangers_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Max_Fields>;
  min?: Maybe<Rangers_Type_Min_Fields>;
};


/** aggregate fields of "rangers.type" */
export type Rangers_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.type" */
export enum Rangers_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  TypePkey = 'type_pkey'
}

/** input type for inserting data into table "rangers.type" */
export type Rangers_Type_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.type_localized" */
export type Rangers_Type_Localized = {
  __typename?: 'rangers_type_localized';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate = {
  __typename?: 'rangers_type_localized_aggregate';
  aggregate?: Maybe<Rangers_Type_Localized_Aggregate_Fields>;
  nodes: Array<Rangers_Type_Localized>;
};

/** aggregate fields of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate_Fields = {
  __typename?: 'rangers_type_localized_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Localized_Max_Fields>;
  min?: Maybe<Rangers_Type_Localized_Min_Fields>;
};


/** aggregate fields of "rangers.type_localized" */
export type Rangers_Type_Localized_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type_localized". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Localized_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Localized_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Localized_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  real_name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** aggregate max on columns */
export type Rangers_Type_Localized_Max_Fields = {
  __typename?: 'rangers_type_localized_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Localized_Min_Fields = {
  __typename?: 'rangers_type_localized_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  real_name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** Ordering options when selecting data from "rangers.type_localized". */
export type Rangers_Type_Localized_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  real_name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.type_localized" */
export enum Rangers_Type_Localized_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  RealName = 'real_name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Streaming cursor of the table "rangers_type_localized" */
export type Rangers_Type_Localized_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Localized_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Localized_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  real_name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Type_Max_Fields = {
  __typename?: 'rangers_type_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Min_Fields = {
  __typename?: 'rangers_type_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.type" */
export type Rangers_Type_Mutation_Response = {
  __typename?: 'rangers_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Type>;
};

/** on_conflict condition type for table "rangers.type" */
export type Rangers_Type_On_Conflict = {
  constraint: Rangers_Type_Constraint;
  update_columns?: Array<Rangers_Type_Update_Column>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.type". */
export type Rangers_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.type */
export type Rangers_Type_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.type" */
export enum Rangers_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.type" */
export type Rangers_Type_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_type" */
export type Rangers_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** columns and relationships of "rangers.type_text" */
export type Rangers_Type_Text = {
  __typename?: 'rangers_type_text';
  id: Scalars['String']['output'];
  locale: Scalars['String']['output'];
  name: Scalars['String']['output'];
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregated selection of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate = {
  __typename?: 'rangers_type_text_aggregate';
  aggregate?: Maybe<Rangers_Type_Text_Aggregate_Fields>;
  nodes: Array<Rangers_Type_Text>;
};

/** aggregate fields of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate_Fields = {
  __typename?: 'rangers_type_text_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Type_Text_Max_Fields>;
  min?: Maybe<Rangers_Type_Text_Min_Fields>;
};


/** aggregate fields of "rangers.type_text" */
export type Rangers_Type_Text_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.type_text". All fields are combined with a logical 'AND'. */
export type Rangers_Type_Text_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Type_Text_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Type_Text_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
  locale?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.type_text" */
export enum Rangers_Type_Text_Constraint {
  /** unique or primary key constraint on columns "id", "locale" */
  TypeTextPkey = 'type_text_pkey'
}

/** input type for inserting data into table "rangers.type_text" */
export type Rangers_Type_Text_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Type_Text_Max_Fields = {
  __typename?: 'rangers_type_text_max_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Type_Text_Min_Fields = {
  __typename?: 'rangers_type_text_min_fields';
  id?: Maybe<Scalars['String']['output']>;
  locale?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.type_text" */
export type Rangers_Type_Text_Mutation_Response = {
  __typename?: 'rangers_type_text_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Type_Text>;
};

/** on_conflict condition type for table "rangers.type_text" */
export type Rangers_Type_Text_On_Conflict = {
  constraint: Rangers_Type_Text_Constraint;
  update_columns?: Array<Rangers_Type_Text_Update_Column>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.type_text". */
export type Rangers_Type_Text_Order_By = {
  id?: InputMaybe<Order_By>;
  locale?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.type_text */
export type Rangers_Type_Text_Pk_Columns_Input = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};

/** select columns of table "rangers.type_text" */
export enum Rangers_Type_Text_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.type_text" */
export type Rangers_Type_Text_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_type_text" */
export type Rangers_Type_Text_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Type_Text_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Type_Text_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
  locale?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.type_text" */
export enum Rangers_Type_Text_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Locale = 'locale',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Type_Text_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Type_Text_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Type_Text_Bool_Exp;
};

/** update columns of table "rangers.type" */
export enum Rangers_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Type_Bool_Exp;
};

export type Rangers_Upgrade_Deck_Args = {
  deck_id?: InputMaybe<Scalars['Int']['input']>;
  upgrade_data?: InputMaybe<Scalars['json']['input']>;
};

/** columns and relationships of "rangers.user_campaign" */
export type Rangers_User_Campaign = {
  __typename?: 'rangers_user_campaign';
  /** An object relationship */
  campaign?: Maybe<Rangers_Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate = {
  __typename?: 'rangers_user_campaign_aggregate';
  aggregate?: Maybe<Rangers_User_Campaign_Aggregate_Fields>;
  nodes: Array<Rangers_User_Campaign>;
};

export type Rangers_User_Campaign_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Campaign_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_Fields = {
  __typename?: 'rangers_user_campaign_aggregate_fields';
  avg?: Maybe<Rangers_User_Campaign_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Campaign_Max_Fields>;
  min?: Maybe<Rangers_User_Campaign_Min_Fields>;
  stddev?: Maybe<Rangers_User_Campaign_Stddev_Fields>;
  stddev_pop?: Maybe<Rangers_User_Campaign_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Rangers_User_Campaign_Stddev_Samp_Fields>;
  sum?: Maybe<Rangers_User_Campaign_Sum_Fields>;
  var_pop?: Maybe<Rangers_User_Campaign_Var_Pop_Fields>;
  var_samp?: Maybe<Rangers_User_Campaign_Var_Samp_Fields>;
  variance?: Maybe<Rangers_User_Campaign_Variance_Fields>;
};


/** aggregate fields of "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Aggregate_Order_By = {
  avg?: InputMaybe<Rangers_User_Campaign_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Campaign_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Campaign_Min_Order_By>;
  stddev?: InputMaybe<Rangers_User_Campaign_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Rangers_User_Campaign_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Rangers_User_Campaign_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Rangers_User_Campaign_Sum_Order_By>;
  var_pop?: InputMaybe<Rangers_User_Campaign_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Rangers_User_Campaign_Var_Samp_Order_By>;
  variance?: InputMaybe<Rangers_User_Campaign_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_campaign" */
export type Rangers_User_Campaign_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Campaign_Insert_Input>;
};

/** aggregate avg on columns */
export type Rangers_User_Campaign_Avg_Fields = {
  __typename?: 'rangers_user_campaign_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "rangers.user_campaign". All fields are combined with a logical 'AND'. */
export type Rangers_User_Campaign_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Campaign_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Campaign_Bool_Exp>>;
  campaign?: InputMaybe<Rangers_Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_campaign" */
export type Rangers_User_Campaign_Insert_Input = {
  campaign?: InputMaybe<Rangers_Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Campaign_Max_Fields = {
  __typename?: 'rangers_user_campaign_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Campaign_Min_Fields = {
  __typename?: 'rangers_user_campaign_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "rangers.user_campaign". */
export type Rangers_User_Campaign_Order_By = {
  campaign?: InputMaybe<Rangers_Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_campaign" */
export enum Rangers_User_Campaign_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** aggregate stddev on columns */
export type Rangers_User_Campaign_Stddev_Fields = {
  __typename?: 'rangers_user_campaign_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Rangers_User_Campaign_Stddev_Pop_Fields = {
  __typename?: 'rangers_user_campaign_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Rangers_User_Campaign_Stddev_Samp_Fields = {
  __typename?: 'rangers_user_campaign_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "rangers_user_campaign" */
export type Rangers_User_Campaign_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Campaign_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Campaign_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Rangers_User_Campaign_Sum_Fields = {
  __typename?: 'rangers_user_campaign_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Rangers_User_Campaign_Var_Pop_Fields = {
  __typename?: 'rangers_user_campaign_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Rangers_User_Campaign_Var_Samp_Fields = {
  __typename?: 'rangers_user_campaign_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Rangers_User_Campaign_Variance_Fields = {
  __typename?: 'rangers_user_campaign_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "rangers.user_campaign" */
export type Rangers_User_Campaign_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "rangers.user_friends" */
export type Rangers_User_Friends = {
  __typename?: 'rangers_user_friends';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate = {
  __typename?: 'rangers_user_friends_aggregate';
  aggregate?: Maybe<Rangers_User_Friends_Aggregate_Fields>;
  nodes: Array<Rangers_User_Friends>;
};

export type Rangers_User_Friends_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Friends_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Friends_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_Fields = {
  __typename?: 'rangers_user_friends_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Friends_Max_Fields>;
  min?: Maybe<Rangers_User_Friends_Min_Fields>;
};


/** aggregate fields of "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_friends" */
export type Rangers_User_Friends_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Friends_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Friends_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_friends" */
export type Rangers_User_Friends_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Friends_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_friends". All fields are combined with a logical 'AND'. */
export type Rangers_User_Friends_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Friends_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Friends_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_friends" */
export type Rangers_User_Friends_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Friends_Max_Fields = {
  __typename?: 'rangers_user_friends_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_friends" */
export type Rangers_User_Friends_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Friends_Min_Fields = {
  __typename?: 'rangers_user_friends_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_friends" */
export type Rangers_User_Friends_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_friends" */
export type Rangers_User_Friends_Mutation_Response = {
  __typename?: 'rangers_user_friends_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Friends>;
};

/** Ordering options when selecting data from "rangers.user_friends". */
export type Rangers_User_Friends_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_friends" */
export enum Rangers_User_Friends_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_friends" */
export type Rangers_User_Friends_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_friends" */
export type Rangers_User_Friends_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Friends_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Friends_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Friends_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Friends_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Friends_Bool_Exp;
};

/** columns and relationships of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests = {
  __typename?: 'rangers_user_received_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate = {
  __typename?: 'rangers_user_received_friend_requests_aggregate';
  aggregate?: Maybe<Rangers_User_Received_Friend_Requests_Aggregate_Fields>;
  nodes: Array<Rangers_User_Received_Friend_Requests>;
};

export type Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_Fields = {
  __typename?: 'rangers_user_received_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Received_Friend_Requests_Max_Fields>;
  min?: Maybe<Rangers_User_Received_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Received_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Received_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Received_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_received_friend_requests". All fields are combined with a logical 'AND'. */
export type Rangers_User_Received_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Received_Friend_Requests_Max_Fields = {
  __typename?: 'rangers_user_received_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Received_Friend_Requests_Min_Fields = {
  __typename?: 'rangers_user_received_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Mutation_Response = {
  __typename?: 'rangers_user_received_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Received_Friend_Requests>;
};

/** Ordering options when selecting data from "rangers.user_received_friend_requests". */
export type Rangers_User_Received_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_received_friend_requests" */
export enum Rangers_User_Received_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_received_friend_requests" */
export type Rangers_User_Received_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Received_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Received_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Received_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Received_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Received_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "rangers.user_role" */
export type Rangers_User_Role = {
  __typename?: 'rangers_user_role';
  id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.user_role" */
export type Rangers_User_Role_Aggregate = {
  __typename?: 'rangers_user_role_aggregate';
  aggregate?: Maybe<Rangers_User_Role_Aggregate_Fields>;
  nodes: Array<Rangers_User_Role>;
};

/** aggregate fields of "rangers.user_role" */
export type Rangers_User_Role_Aggregate_Fields = {
  __typename?: 'rangers_user_role_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Role_Max_Fields>;
  min?: Maybe<Rangers_User_Role_Min_Fields>;
};


/** aggregate fields of "rangers.user_role" */
export type Rangers_User_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.user_role". All fields are combined with a logical 'AND'. */
export type Rangers_User_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Role_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Role_Bool_Exp>>;
  id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.user_role" */
export enum Rangers_User_Role_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolePkey = 'user_role_pkey'
}

export enum Rangers_User_Role_Enum {
  Admin = 'admin',
  Moderator = 'moderator'
}

/** Boolean expression to compare columns of type "rangers_user_role_enum". All fields are combined with logical 'AND'. */
export type Rangers_User_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Rangers_User_Role_Enum>;
  _in?: InputMaybe<Array<Rangers_User_Role_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Rangers_User_Role_Enum>;
  _nin?: InputMaybe<Array<Rangers_User_Role_Enum>>;
};

/** input type for inserting data into table "rangers.user_role" */
export type Rangers_User_Role_Insert_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Role_Max_Fields = {
  __typename?: 'rangers_user_role_max_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_User_Role_Min_Fields = {
  __typename?: 'rangers_user_role_min_fields';
  id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.user_role" */
export type Rangers_User_Role_Mutation_Response = {
  __typename?: 'rangers_user_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Role>;
};

/** on_conflict condition type for table "rangers.user_role" */
export type Rangers_User_Role_On_Conflict = {
  constraint: Rangers_User_Role_Constraint;
  update_columns?: Array<Rangers_User_Role_Update_Column>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.user_role". */
export type Rangers_User_Role_Order_By = {
  id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.user_role */
export type Rangers_User_Role_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.user_role" */
export enum Rangers_User_Role_Select_Column {
  /** column name */
  Id = 'id'
}

/** input type for updating data in table "rangers.user_role" */
export type Rangers_User_Role_Set_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_role" */
export type Rangers_User_Role_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Role_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Role_Stream_Cursor_Value_Input = {
  id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.user_role" */
export enum Rangers_User_Role_Update_Column {
  /** column name */
  Id = 'id'
}

export type Rangers_User_Role_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Role_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Role_Bool_Exp;
};

/** columns and relationships of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests = {
  __typename?: 'rangers_user_sent_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Rangers_Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate = {
  __typename?: 'rangers_user_sent_friend_requests_aggregate';
  aggregate?: Maybe<Rangers_User_Sent_Friend_Requests_Aggregate_Fields>;
  nodes: Array<Rangers_User_Sent_Friend_Requests>;
};

export type Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Sent_Friend_Requests_Max_Fields>;
  min?: Maybe<Rangers_User_Sent_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Rangers_User_Sent_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<Rangers_User_Sent_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<Rangers_User_Sent_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "rangers.user_sent_friend_requests". All fields are combined with a logical 'AND'. */
export type Rangers_User_Sent_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Rangers_Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Rangers_Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Sent_Friend_Requests_Max_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Rangers_User_Sent_Friend_Requests_Min_Fields = {
  __typename?: 'rangers_user_sent_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Mutation_Response = {
  __typename?: 'rangers_user_sent_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Sent_Friend_Requests>;
};

/** Ordering options when selecting data from "rangers.user_sent_friend_requests". */
export type Rangers_User_Sent_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Rangers_Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "rangers.user_sent_friend_requests" */
export enum Rangers_User_Sent_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "rangers.user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_sent_friend_requests" */
export type Rangers_User_Sent_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Sent_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Sent_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type Rangers_User_Sent_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Sent_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Sent_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "rangers.user_settings" */
export type Rangers_User_Settings = {
  __typename?: 'rangers_user_settings';
  private_decks: Scalars['Boolean']['output'];
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate = {
  __typename?: 'rangers_user_settings_aggregate';
  aggregate?: Maybe<Rangers_User_Settings_Aggregate_Fields>;
  nodes: Array<Rangers_User_Settings>;
};

/** aggregate fields of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate_Fields = {
  __typename?: 'rangers_user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_User_Settings_Max_Fields>;
  min?: Maybe<Rangers_User_Settings_Min_Fields>;
};


/** aggregate fields of "rangers.user_settings" */
export type Rangers_User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.user_settings". All fields are combined with a logical 'AND'. */
export type Rangers_User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_User_Settings_Bool_Exp>>;
  _not?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_User_Settings_Bool_Exp>>;
  private_decks?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.user_settings" */
export enum Rangers_User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** input type for inserting data into table "rangers.user_settings" */
export type Rangers_User_Settings_Insert_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Rangers_User_Settings_Max_Fields = {
  __typename?: 'rangers_user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Rangers_User_Settings_Min_Fields = {
  __typename?: 'rangers_user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "rangers.user_settings" */
export type Rangers_User_Settings_Mutation_Response = {
  __typename?: 'rangers_user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_User_Settings>;
};

/** input type for inserting object relation for remote table "rangers.user_settings" */
export type Rangers_User_Settings_Obj_Rel_Insert_Input = {
  data: Rangers_User_Settings_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_User_Settings_On_Conflict>;
};

/** on_conflict condition type for table "rangers.user_settings" */
export type Rangers_User_Settings_On_Conflict = {
  constraint: Rangers_User_Settings_Constraint;
  update_columns?: Array<Rangers_User_Settings_Update_Column>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.user_settings". */
export type Rangers_User_Settings_Order_By = {
  private_decks?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.user_settings */
export type Rangers_User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** select columns of table "rangers.user_settings" */
export enum Rangers_User_Settings_Select_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "rangers.user_settings" */
export type Rangers_User_Settings_Set_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "rangers_user_settings" */
export type Rangers_User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_User_Settings_Stream_Cursor_Value_Input = {
  private_decks?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "rangers.user_settings" */
export enum Rangers_User_Settings_Update_Column {
  /** column name */
  PrivateDecks = 'private_decks',
  /** column name */
  UserId = 'user_id'
}

export type Rangers_User_Settings_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_User_Settings_Bool_Exp;
};

/** columns and relationships of "rangers.users" */
export type Rangers_Users = {
  __typename?: 'rangers_users';
  /** An array relationship */
  campaigns: Array<Rangers_User_Campaign>;
  /** An aggregate relationship */
  campaigns_aggregate: Rangers_User_Campaign_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  friends: Array<Rangers_User_Friends>;
  /** An aggregate relationship */
  friends_aggregate: Rangers_User_Friends_Aggregate;
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  normalized_handle?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  received_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** An aggregate relationship */
  received_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  role?: Maybe<Rangers_User_Role_Enum>;
  /** An array relationship */
  sent_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** An aggregate relationship */
  sent_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** An object relationship */
  settings?: Maybe<Rangers_User_Settings>;
  updated_at: Scalars['timestamptz']['output'];
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersCampaignsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersCampaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersFriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersFriends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersReceived_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersReceived_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersSent_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "rangers.users" */
export type Rangers_UsersSent_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};

/** aggregated selection of "rangers.users" */
export type Rangers_Users_Aggregate = {
  __typename?: 'rangers_users_aggregate';
  aggregate?: Maybe<Rangers_Users_Aggregate_Fields>;
  nodes: Array<Rangers_Users>;
};

/** aggregate fields of "rangers.users" */
export type Rangers_Users_Aggregate_Fields = {
  __typename?: 'rangers_users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Rangers_Users_Max_Fields>;
  min?: Maybe<Rangers_Users_Min_Fields>;
};


/** aggregate fields of "rangers.users" */
export type Rangers_Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "rangers.users". All fields are combined with a logical 'AND'. */
export type Rangers_Users_Bool_Exp = {
  _and?: InputMaybe<Array<Rangers_Users_Bool_Exp>>;
  _not?: InputMaybe<Rangers_Users_Bool_Exp>;
  _or?: InputMaybe<Array<Rangers_Users_Bool_Exp>>;
  campaigns?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
  campaigns_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  friends?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
  friends_aggregate?: InputMaybe<Rangers_User_Friends_Aggregate_Bool_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  received_requests?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
  received_requests_aggregate?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Bool_Exp>;
  role?: InputMaybe<Rangers_User_Role_Enum_Comparison_Exp>;
  sent_requests?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
  sent_requests_aggregate?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Bool_Exp>;
  settings?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "rangers.users" */
export enum Rangers_Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "rangers.users" */
export type Rangers_Users_Insert_Input = {
  campaigns?: InputMaybe<Rangers_User_Campaign_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  friends?: InputMaybe<Rangers_User_Friends_Arr_Rel_Insert_Input>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  received_requests?: InputMaybe<Rangers_User_Received_Friend_Requests_Arr_Rel_Insert_Input>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  sent_requests?: InputMaybe<Rangers_User_Sent_Friend_Requests_Arr_Rel_Insert_Input>;
  settings?: InputMaybe<Rangers_User_Settings_Obj_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** aggregate max on columns */
export type Rangers_Users_Max_Fields = {
  __typename?: 'rangers_users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** aggregate min on columns */
export type Rangers_Users_Min_Fields = {
  __typename?: 'rangers_users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamptz']['output']>;
};

/** response of any mutation on the table "rangers.users" */
export type Rangers_Users_Mutation_Response = {
  __typename?: 'rangers_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Rangers_Users>;
};

/** input type for inserting object relation for remote table "rangers.users" */
export type Rangers_Users_Obj_Rel_Insert_Input = {
  data: Rangers_Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Rangers_Users_On_Conflict>;
};

/** on_conflict condition type for table "rangers.users" */
export type Rangers_Users_On_Conflict = {
  constraint: Rangers_Users_Constraint;
  update_columns?: Array<Rangers_Users_Update_Column>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};

/** Ordering options when selecting data from "rangers.users". */
export type Rangers_Users_Order_By = {
  campaigns_aggregate?: InputMaybe<Rangers_User_Campaign_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  friends_aggregate?: InputMaybe<Rangers_User_Friends_Aggregate_Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  received_requests_aggregate?: InputMaybe<Rangers_User_Received_Friend_Requests_Aggregate_Order_By>;
  role?: InputMaybe<Order_By>;
  sent_requests_aggregate?: InputMaybe<Rangers_User_Sent_Friend_Requests_Aggregate_Order_By>;
  settings?: InputMaybe<Rangers_User_Settings_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: rangers.users */
export type Rangers_Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "rangers.users" */
export enum Rangers_Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "rangers.users" */
export type Rangers_Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** Streaming cursor of the table "rangers_users" */
export type Rangers_Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Rangers_Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Rangers_Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Rangers_User_Role_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']['input']>;
};

/** update columns of table "rangers.users" */
export enum Rangers_Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  Role = 'role',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Rangers_Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Rangers_Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Rangers_Users_Bool_Exp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "all_card" */
  all_card: Array<All_Card>;
  /** fetch aggregated fields from the table: "all_card" */
  all_card_aggregate: All_Card_Aggregate;
  /** fetch data from the table: "all_card" using primary key columns */
  all_card_by_pk?: Maybe<All_Card>;
  /** fetch data from the table in a streaming manner: "all_card" */
  all_card_stream: Array<All_Card>;
  /** fetch data from the table: "all_card_text" */
  all_card_text: Array<All_Card_Text>;
  /** fetch aggregated fields from the table: "all_card_text" */
  all_card_text_aggregate: All_Card_Text_Aggregate;
  /** fetch data from the table: "all_card_text" using primary key columns */
  all_card_text_by_pk?: Maybe<All_Card_Text>;
  /** fetch data from the table in a streaming manner: "all_card_text" */
  all_card_text_stream: Array<All_Card_Text>;
  /** fetch data from the table: "all_card_updated" */
  all_card_updated: Array<All_Card_Updated>;
  /** fetch aggregated fields from the table: "all_card_updated" */
  all_card_updated_aggregate: All_Card_Updated_Aggregate;
  /** fetch data from the table: "all_card_updated" using primary key columns */
  all_card_updated_by_pk?: Maybe<All_Card_Updated>;
  /** fetch data from the table: "all_card_updated_by_version" */
  all_card_updated_by_version: Array<All_Card_Updated_By_Version>;
  /** fetch aggregated fields from the table: "all_card_updated_by_version" */
  all_card_updated_by_version_aggregate: All_Card_Updated_By_Version_Aggregate;
  /** fetch data from the table: "all_card_updated_by_version" using primary key columns */
  all_card_updated_by_version_by_pk?: Maybe<All_Card_Updated_By_Version>;
  /** fetch data from the table in a streaming manner: "all_card_updated_by_version" */
  all_card_updated_by_version_stream: Array<All_Card_Updated_By_Version>;
  /** fetch data from the table in a streaming manner: "all_card_updated" */
  all_card_updated_stream: Array<All_Card_Updated>;
  /** fetch data from the table: "arkhamdb_auth" */
  arkhamdb_auth: Array<Arkhamdb_Auth>;
  /** fetch aggregated fields from the table: "arkhamdb_auth" */
  arkhamdb_auth_aggregate: Arkhamdb_Auth_Aggregate;
  /** fetch data from the table: "arkhamdb_auth" using primary key columns */
  arkhamdb_auth_by_pk?: Maybe<Arkhamdb_Auth>;
  /** fetch data from the table in a streaming manner: "arkhamdb_auth" */
  arkhamdb_auth_stream: Array<Arkhamdb_Auth>;
  /** fetch data from the table: "arkhamdb_deck" */
  arkhamdb_deck: Array<Arkhamdb_Deck>;
  /** fetch aggregated fields from the table: "arkhamdb_deck" */
  arkhamdb_deck_aggregate: Arkhamdb_Deck_Aggregate;
  /** fetch data from the table: "arkhamdb_deck" using primary key columns */
  arkhamdb_deck_by_pk?: Maybe<Arkhamdb_Deck>;
  /** fetch data from the table in a streaming manner: "arkhamdb_deck" */
  arkhamdb_deck_stream: Array<Arkhamdb_Deck>;
  /** An array relationship */
  base_decks: Array<Base_Decks>;
  /** An aggregate relationship */
  base_decks_aggregate: Base_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "base_decks" */
  base_decks_stream: Array<Base_Decks>;
  /** fetch data from the table: "campaign" */
  campaign: Array<Campaign>;
  /** fetch data from the table: "campaign_access" */
  campaign_access: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign_access" */
  campaign_access_aggregate: Campaign_Access_Aggregate;
  /** fetch data from the table: "campaign_access" using primary key columns */
  campaign_access_by_pk?: Maybe<Campaign_Access>;
  /** fetch data from the table in a streaming manner: "campaign_access" */
  campaign_access_stream: Array<Campaign_Access>;
  /** fetch aggregated fields from the table: "campaign" */
  campaign_aggregate: Campaign_Aggregate;
  /** fetch data from the table: "campaign" using primary key columns */
  campaign_by_pk?: Maybe<Campaign>;
  /** fetch data from the table: "campaign_deck" */
  campaign_deck: Array<Campaign_Deck>;
  /** fetch aggregated fields from the table: "campaign_deck" */
  campaign_deck_aggregate: Campaign_Deck_Aggregate;
  /** fetch data from the table: "campaign_deck" using primary key columns */
  campaign_deck_by_pk?: Maybe<Campaign_Deck>;
  /** fetch data from the table in a streaming manner: "campaign_deck" */
  campaign_deck_stream: Array<Campaign_Deck>;
  /** fetch data from the table: "campaign_difficulty" */
  campaign_difficulty: Array<Campaign_Difficulty>;
  /** fetch aggregated fields from the table: "campaign_difficulty" */
  campaign_difficulty_aggregate: Campaign_Difficulty_Aggregate;
  /** fetch data from the table: "campaign_difficulty" using primary key columns */
  campaign_difficulty_by_pk?: Maybe<Campaign_Difficulty>;
  /** fetch data from the table in a streaming manner: "campaign_difficulty" */
  campaign_difficulty_stream: Array<Campaign_Difficulty>;
  /** fetch data from the table: "campaign_guide" */
  campaign_guide: Array<Campaign_Guide>;
  /** fetch aggregated fields from the table: "campaign_guide" */
  campaign_guide_aggregate: Campaign_Guide_Aggregate;
  /** fetch data from the table in a streaming manner: "campaign_guide" */
  campaign_guide_stream: Array<Campaign_Guide>;
  /** fetch data from the table: "campaign_investigator" */
  campaign_investigator: Array<Campaign_Investigator>;
  /** fetch aggregated fields from the table: "campaign_investigator" */
  campaign_investigator_aggregate: Campaign_Investigator_Aggregate;
  /** fetch data from the table: "campaign_investigator" using primary key columns */
  campaign_investigator_by_pk?: Maybe<Campaign_Investigator>;
  /** fetch data from the table in a streaming manner: "campaign_investigator" */
  campaign_investigator_stream: Array<Campaign_Investigator>;
  /** fetch data from the table in a streaming manner: "campaign" */
  campaign_stream: Array<Campaign>;
  /** fetch data from the table: "campaigns_by_cycle" */
  campaigns_by_cycle: Array<Campaigns_By_Cycle>;
  /** fetch aggregated fields from the table: "campaigns_by_cycle" */
  campaigns_by_cycle_aggregate: Campaigns_By_Cycle_Aggregate;
  /** fetch data from the table in a streaming manner: "campaigns_by_cycle" */
  campaigns_by_cycle_stream: Array<Campaigns_By_Cycle>;
  /** fetch data from the table: "card" */
  card: Array<Card>;
  /** fetch aggregated fields from the table: "card" */
  card_aggregate: Card_Aggregate;
  /** fetch data from the table: "card" using primary key columns */
  card_by_pk?: Maybe<Card>;
  /** fetch data from the table: "card_cycle" */
  card_cycle: Array<Card_Cycle>;
  /** fetch aggregated fields from the table: "card_cycle" */
  card_cycle_aggregate: Card_Cycle_Aggregate;
  /** fetch data from the table: "card_cycle" using primary key columns */
  card_cycle_by_pk?: Maybe<Card_Cycle>;
  /** fetch data from the table in a streaming manner: "card_cycle" */
  card_cycle_stream: Array<Card_Cycle>;
  /** fetch data from the table: "card_encounter_set" */
  card_encounter_set: Array<Card_Encounter_Set>;
  /** fetch aggregated fields from the table: "card_encounter_set" */
  card_encounter_set_aggregate: Card_Encounter_Set_Aggregate;
  /** fetch data from the table: "card_encounter_set" using primary key columns */
  card_encounter_set_by_pk?: Maybe<Card_Encounter_Set>;
  /** fetch data from the table in a streaming manner: "card_encounter_set" */
  card_encounter_set_stream: Array<Card_Encounter_Set>;
  /** fetch data from the table: "card_pack" */
  card_pack: Array<Card_Pack>;
  /** fetch aggregated fields from the table: "card_pack" */
  card_pack_aggregate: Card_Pack_Aggregate;
  /** fetch data from the table: "card_pack" using primary key columns */
  card_pack_by_pk?: Maybe<Card_Pack>;
  /** fetch data from the table in a streaming manner: "card_pack" */
  card_pack_stream: Array<Card_Pack>;
  /** fetch data from the table in a streaming manner: "card" */
  card_stream: Array<Card>;
  /** fetch data from the table: "card_subtype_name" */
  card_subtype_name: Array<Card_Subtype_Name>;
  /** fetch aggregated fields from the table: "card_subtype_name" */
  card_subtype_name_aggregate: Card_Subtype_Name_Aggregate;
  /** fetch data from the table: "card_subtype_name" using primary key columns */
  card_subtype_name_by_pk?: Maybe<Card_Subtype_Name>;
  /** fetch data from the table in a streaming manner: "card_subtype_name" */
  card_subtype_name_stream: Array<Card_Subtype_Name>;
  /** fetch data from the table: "card_text" */
  card_text: Array<Card_Text>;
  /** fetch aggregated fields from the table: "card_text" */
  card_text_aggregate: Card_Text_Aggregate;
  /** fetch data from the table: "card_text" using primary key columns */
  card_text_by_pk?: Maybe<Card_Text>;
  /** fetch data from the table in a streaming manner: "card_text" */
  card_text_stream: Array<Card_Text>;
  /** fetch data from the table: "card_type_code" */
  card_type_code: Array<Card_Type_Code>;
  /** fetch aggregated fields from the table: "card_type_code" */
  card_type_code_aggregate: Card_Type_Code_Aggregate;
  /** fetch data from the table: "card_type_code" using primary key columns */
  card_type_code_by_pk?: Maybe<Card_Type_Code>;
  /** fetch data from the table in a streaming manner: "card_type_code" */
  card_type_code_stream: Array<Card_Type_Code>;
  /** fetch data from the table: "card_type_name" */
  card_type_name: Array<Card_Type_Name>;
  /** fetch aggregated fields from the table: "card_type_name" */
  card_type_name_aggregate: Card_Type_Name_Aggregate;
  /** fetch data from the table: "card_type_name" using primary key columns */
  card_type_name_by_pk?: Maybe<Card_Type_Name>;
  /** fetch data from the table in a streaming manner: "card_type_name" */
  card_type_name_stream: Array<Card_Type_Name>;
  /** An array relationship */
  chaos_bag_result: Array<Chaos_Bag_Result>;
  /** An aggregate relationship */
  chaos_bag_result_aggregate: Chaos_Bag_Result_Aggregate;
  /** fetch data from the table: "chaos_bag_result" using primary key columns */
  chaos_bag_result_by_pk?: Maybe<Chaos_Bag_Result>;
  /** fetch data from the table in a streaming manner: "chaos_bag_result" */
  chaos_bag_result_stream: Array<Chaos_Bag_Result>;
  /** fetch data from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch aggregated fields from the table: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_aggregate: Chaos_Bag_Tarot_Mode_Aggregate;
  /** fetch data from the table: "chaos_bag_tarot_mode" using primary key columns */
  chaos_bag_tarot_mode_by_pk?: Maybe<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table in a streaming manner: "chaos_bag_tarot_mode" */
  chaos_bag_tarot_mode_stream: Array<Chaos_Bag_Tarot_Mode>;
  /** fetch data from the table: "conquest.card" */
  conquest_card: Array<Conquest_Card>;
  /** fetch aggregated fields from the table: "conquest.card" */
  conquest_card_aggregate: Conquest_Card_Aggregate;
  /** fetch data from the table: "conquest.card" using primary key columns */
  conquest_card_by_pk?: Maybe<Conquest_Card>;
  /** fetch data from the table: "conquest.card_localized" */
  conquest_card_localized: Array<Conquest_Card_Localized>;
  /** fetch aggregated fields from the table: "conquest.card_localized" */
  conquest_card_localized_aggregate: Conquest_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "conquest.card_localized" */
  conquest_card_localized_stream: Array<Conquest_Card_Localized>;
  /** fetch data from the table in a streaming manner: "conquest.card" */
  conquest_card_stream: Array<Conquest_Card>;
  /** fetch data from the table: "conquest.card_text" */
  conquest_card_text: Array<Conquest_Card_Text>;
  /** fetch aggregated fields from the table: "conquest.card_text" */
  conquest_card_text_aggregate: Conquest_Card_Text_Aggregate;
  /** fetch data from the table: "conquest.card_text" using primary key columns */
  conquest_card_text_by_pk?: Maybe<Conquest_Card_Text>;
  /** fetch data from the table in a streaming manner: "conquest.card_text" */
  conquest_card_text_stream: Array<Conquest_Card_Text>;
  /** fetch data from the table: "conquest.card_updated" */
  conquest_card_updated: Array<Conquest_Card_Updated>;
  /** fetch aggregated fields from the table: "conquest.card_updated" */
  conquest_card_updated_aggregate: Conquest_Card_Updated_Aggregate;
  /** fetch data from the table in a streaming manner: "conquest.card_updated" */
  conquest_card_updated_stream: Array<Conquest_Card_Updated>;
  /** fetch data from the table: "conquest.comment" */
  conquest_comment: Array<Conquest_Comment>;
  /** fetch aggregated fields from the table: "conquest.comment" */
  conquest_comment_aggregate: Conquest_Comment_Aggregate;
  /** fetch data from the table: "conquest.comment" using primary key columns */
  conquest_comment_by_pk?: Maybe<Conquest_Comment>;
  /** fetch data from the table in a streaming manner: "conquest.comment" */
  conquest_comment_stream: Array<Conquest_Comment>;
  /** fetch data from the table: "conquest.cycle" */
  conquest_cycle: Array<Conquest_Cycle>;
  /** fetch aggregated fields from the table: "conquest.cycle" */
  conquest_cycle_aggregate: Conquest_Cycle_Aggregate;
  /** fetch data from the table: "conquest.cycle" using primary key columns */
  conquest_cycle_by_pk?: Maybe<Conquest_Cycle>;
  /** fetch data from the table in a streaming manner: "conquest.cycle" */
  conquest_cycle_stream: Array<Conquest_Cycle>;
  /** fetch data from the table: "conquest.cycle_text" */
  conquest_cycle_text: Array<Conquest_Cycle_Text>;
  /** fetch aggregated fields from the table: "conquest.cycle_text" */
  conquest_cycle_text_aggregate: Conquest_Cycle_Text_Aggregate;
  /** fetch data from the table: "conquest.cycle_text" using primary key columns */
  conquest_cycle_text_by_pk?: Maybe<Conquest_Cycle_Text>;
  /** fetch data from the table in a streaming manner: "conquest.cycle_text" */
  conquest_cycle_text_stream: Array<Conquest_Cycle_Text>;
  /** fetch data from the table: "conquest.deck" */
  conquest_deck: Array<Conquest_Deck>;
  /** fetch aggregated fields from the table: "conquest.deck" */
  conquest_deck_aggregate: Conquest_Deck_Aggregate;
  /** fetch data from the table: "conquest.deck" using primary key columns */
  conquest_deck_by_pk?: Maybe<Conquest_Deck>;
  /** fetch data from the table: "conquest.deck_copy" */
  conquest_deck_copy: Array<Conquest_Deck_Copy>;
  /** fetch aggregated fields from the table: "conquest.deck_copy" */
  conquest_deck_copy_aggregate: Conquest_Deck_Copy_Aggregate;
  /** fetch data from the table: "conquest.deck_copy" using primary key columns */
  conquest_deck_copy_by_pk?: Maybe<Conquest_Deck_Copy>;
  /** fetch data from the table in a streaming manner: "conquest.deck_copy" */
  conquest_deck_copy_stream: Array<Conquest_Deck_Copy>;
  /** fetch data from the table: "conquest.deck_like" */
  conquest_deck_like: Array<Conquest_Deck_Like>;
  /** fetch aggregated fields from the table: "conquest.deck_like" */
  conquest_deck_like_aggregate: Conquest_Deck_Like_Aggregate;
  /** fetch data from the table: "conquest.deck_like" using primary key columns */
  conquest_deck_like_by_pk?: Maybe<Conquest_Deck_Like>;
  /** fetch data from the table in a streaming manner: "conquest.deck_like" */
  conquest_deck_like_stream: Array<Conquest_Deck_Like>;
  /** fetch data from the table in a streaming manner: "conquest.deck" */
  conquest_deck_stream: Array<Conquest_Deck>;
  /** fetch data from the table: "conquest.faction" */
  conquest_faction: Array<Conquest_Faction>;
  /** fetch aggregated fields from the table: "conquest.faction" */
  conquest_faction_aggregate: Conquest_Faction_Aggregate;
  /** fetch data from the table: "conquest.faction" using primary key columns */
  conquest_faction_by_pk?: Maybe<Conquest_Faction>;
  /** fetch data from the table in a streaming manner: "conquest.faction" */
  conquest_faction_stream: Array<Conquest_Faction>;
  /** fetch data from the table: "conquest.faction_text" */
  conquest_faction_text: Array<Conquest_Faction_Text>;
  /** fetch aggregated fields from the table: "conquest.faction_text" */
  conquest_faction_text_aggregate: Conquest_Faction_Text_Aggregate;
  /** fetch data from the table: "conquest.faction_text" using primary key columns */
  conquest_faction_text_by_pk?: Maybe<Conquest_Faction_Text>;
  /** fetch data from the table in a streaming manner: "conquest.faction_text" */
  conquest_faction_text_stream: Array<Conquest_Faction_Text>;
  /** fetch data from the table: "conquest.loyalty" */
  conquest_loyalty: Array<Conquest_Loyalty>;
  /** fetch aggregated fields from the table: "conquest.loyalty" */
  conquest_loyalty_aggregate: Conquest_Loyalty_Aggregate;
  /** fetch data from the table: "conquest.loyalty" using primary key columns */
  conquest_loyalty_by_pk?: Maybe<Conquest_Loyalty>;
  /** fetch data from the table in a streaming manner: "conquest.loyalty" */
  conquest_loyalty_stream: Array<Conquest_Loyalty>;
  /** fetch data from the table: "conquest.loyalty_text" */
  conquest_loyalty_text: Array<Conquest_Loyalty_Text>;
  /** fetch aggregated fields from the table: "conquest.loyalty_text" */
  conquest_loyalty_text_aggregate: Conquest_Loyalty_Text_Aggregate;
  /** fetch data from the table: "conquest.loyalty_text" using primary key columns */
  conquest_loyalty_text_by_pk?: Maybe<Conquest_Loyalty_Text>;
  /** fetch data from the table in a streaming manner: "conquest.loyalty_text" */
  conquest_loyalty_text_stream: Array<Conquest_Loyalty_Text>;
  /** fetch data from the table: "conquest.pack" */
  conquest_pack: Array<Conquest_Pack>;
  /** fetch aggregated fields from the table: "conquest.pack" */
  conquest_pack_aggregate: Conquest_Pack_Aggregate;
  /** fetch data from the table: "conquest.pack" using primary key columns */
  conquest_pack_by_pk?: Maybe<Conquest_Pack>;
  /** fetch data from the table in a streaming manner: "conquest.pack" */
  conquest_pack_stream: Array<Conquest_Pack>;
  /** fetch data from the table: "conquest.pack_text" */
  conquest_pack_text: Array<Conquest_Pack_Text>;
  /** fetch aggregated fields from the table: "conquest.pack_text" */
  conquest_pack_text_aggregate: Conquest_Pack_Text_Aggregate;
  /** fetch data from the table: "conquest.pack_text" using primary key columns */
  conquest_pack_text_by_pk?: Maybe<Conquest_Pack_Text>;
  /** fetch data from the table in a streaming manner: "conquest.pack_text" */
  conquest_pack_text_stream: Array<Conquest_Pack_Text>;
  /** fetch data from the table: "conquest.type" */
  conquest_type: Array<Conquest_Type>;
  /** fetch aggregated fields from the table: "conquest.type" */
  conquest_type_aggregate: Conquest_Type_Aggregate;
  /** fetch data from the table: "conquest.type" using primary key columns */
  conquest_type_by_pk?: Maybe<Conquest_Type>;
  /** fetch data from the table in a streaming manner: "conquest.type" */
  conquest_type_stream: Array<Conquest_Type>;
  /** fetch data from the table: "conquest.type_text" */
  conquest_type_text: Array<Conquest_Type_Text>;
  /** fetch aggregated fields from the table: "conquest.type_text" */
  conquest_type_text_aggregate: Conquest_Type_Text_Aggregate;
  /** fetch data from the table: "conquest.type_text" using primary key columns */
  conquest_type_text_by_pk?: Maybe<Conquest_Type_Text>;
  /** fetch data from the table in a streaming manner: "conquest.type_text" */
  conquest_type_text_stream: Array<Conquest_Type_Text>;
  /** fetch data from the table: "conquest.user_role" */
  conquest_user_role: Array<Conquest_User_Role>;
  /** fetch aggregated fields from the table: "conquest.user_role" */
  conquest_user_role_aggregate: Conquest_User_Role_Aggregate;
  /** fetch data from the table: "conquest.user_role" using primary key columns */
  conquest_user_role_by_pk?: Maybe<Conquest_User_Role>;
  /** fetch data from the table in a streaming manner: "conquest.user_role" */
  conquest_user_role_stream: Array<Conquest_User_Role>;
  /** fetch data from the table: "conquest.user_settings" */
  conquest_user_settings: Array<Conquest_User_Settings>;
  /** fetch aggregated fields from the table: "conquest.user_settings" */
  conquest_user_settings_aggregate: Conquest_User_Settings_Aggregate;
  /** fetch data from the table: "conquest.user_settings" using primary key columns */
  conquest_user_settings_by_pk?: Maybe<Conquest_User_Settings>;
  /** fetch data from the table in a streaming manner: "conquest.user_settings" */
  conquest_user_settings_stream: Array<Conquest_User_Settings>;
  /** fetch data from the table: "conquest.users" */
  conquest_users: Array<Conquest_Users>;
  /** fetch aggregated fields from the table: "conquest.users" */
  conquest_users_aggregate: Conquest_Users_Aggregate;
  /** fetch data from the table: "conquest.users" using primary key columns */
  conquest_users_by_pk?: Maybe<Conquest_Users>;
  /** fetch data from the table in a streaming manner: "conquest.users" */
  conquest_users_stream: Array<Conquest_Users>;
  /** fetch data from the table: "cycle" */
  cycle: Array<Cycle>;
  /** fetch aggregated fields from the table: "cycle" */
  cycle_aggregate: Cycle_Aggregate;
  /** fetch data from the table: "cycle" using primary key columns */
  cycle_by_pk?: Maybe<Cycle>;
  /** fetch data from the table: "cycle_name" */
  cycle_name: Array<Cycle_Name>;
  /** fetch aggregated fields from the table: "cycle_name" */
  cycle_name_aggregate: Cycle_Name_Aggregate;
  /** fetch data from the table: "cycle_name" using primary key columns */
  cycle_name_by_pk?: Maybe<Cycle_Name>;
  /** fetch data from the table in a streaming manner: "cycle_name" */
  cycle_name_stream: Array<Cycle_Name>;
  /** fetch data from the table in a streaming manner: "cycle" */
  cycle_stream: Array<Cycle>;
  /** fetch data from the table: "faction_name" */
  faction_name: Array<Faction_Name>;
  /** fetch aggregated fields from the table: "faction_name" */
  faction_name_aggregate: Faction_Name_Aggregate;
  /** fetch data from the table: "faction_name" using primary key columns */
  faction_name_by_pk?: Maybe<Faction_Name>;
  /** fetch data from the table in a streaming manner: "faction_name" */
  faction_name_stream: Array<Faction_Name>;
  /** fetch data from the table: "faq" */
  faq: Array<Faq>;
  /** fetch aggregated fields from the table: "faq" */
  faq_aggregate: Faq_Aggregate;
  /** fetch data from the table: "faq" using primary key columns */
  faq_by_pk?: Maybe<Faq>;
  /** fetch data from the table in a streaming manner: "faq" */
  faq_stream: Array<Faq>;
  /** fetch data from the table: "faq_text" */
  faq_text: Array<Faq_Text>;
  /** fetch aggregated fields from the table: "faq_text" */
  faq_text_aggregate: Faq_Text_Aggregate;
  /** fetch data from the table: "faq_text" using primary key columns */
  faq_text_by_pk?: Maybe<Faq_Text>;
  /** fetch data from the table in a streaming manner: "faq_text" */
  faq_text_stream: Array<Faq_Text>;
  /** fetch data from the table: "friend_status" */
  friend_status: Array<Friend_Status>;
  /** fetch aggregated fields from the table: "friend_status" */
  friend_status_aggregate: Friend_Status_Aggregate;
  /** fetch data from the table: "friend_status" using primary key columns */
  friend_status_by_pk?: Maybe<Friend_Status>;
  /** fetch data from the table in a streaming manner: "friend_status" */
  friend_status_stream: Array<Friend_Status>;
  /** fetch data from the table: "friend_status_type" */
  friend_status_type: Array<Friend_Status_Type>;
  /** fetch aggregated fields from the table: "friend_status_type" */
  friend_status_type_aggregate: Friend_Status_Type_Aggregate;
  /** fetch data from the table: "friend_status_type" using primary key columns */
  friend_status_type_by_pk?: Maybe<Friend_Status_Type>;
  /** fetch data from the table in a streaming manner: "friend_status_type" */
  friend_status_type_stream: Array<Friend_Status_Type>;
  /** fetch data from the table: "full_card" */
  full_card: Array<Full_Card>;
  /** fetch aggregated fields from the table: "full_card" */
  full_card_aggregate: Full_Card_Aggregate;
  /** fetch data from the table: "full_card" using primary key columns */
  full_card_by_pk?: Maybe<Full_Card>;
  /** fetch data from the table in a streaming manner: "full_card" */
  full_card_stream: Array<Full_Card>;
  /** fetch data from the table: "full_card_text" */
  full_card_text: Array<Full_Card_Text>;
  /** fetch aggregated fields from the table: "full_card_text" */
  full_card_text_aggregate: Full_Card_Text_Aggregate;
  /** fetch data from the table: "full_card_text" using primary key columns */
  full_card_text_by_pk?: Maybe<Full_Card_Text>;
  /** fetch data from the table in a streaming manner: "full_card_text" */
  full_card_text_stream: Array<Full_Card_Text>;
  /** fetch data from the table: "gender" */
  gender: Array<Gender>;
  /** fetch aggregated fields from the table: "gender" */
  gender_aggregate: Gender_Aggregate;
  /** fetch data from the table: "gender" using primary key columns */
  gender_by_pk?: Maybe<Gender>;
  /** fetch data from the table in a streaming manner: "gender" */
  gender_stream: Array<Gender>;
  /** fetch data from the table: "guide_achievement" */
  guide_achievement: Array<Guide_Achievement>;
  /** fetch aggregated fields from the table: "guide_achievement" */
  guide_achievement_aggregate: Guide_Achievement_Aggregate;
  /** fetch data from the table: "guide_achievement" using primary key columns */
  guide_achievement_by_pk?: Maybe<Guide_Achievement>;
  /** fetch data from the table in a streaming manner: "guide_achievement" */
  guide_achievement_stream: Array<Guide_Achievement>;
  /** fetch data from the table: "guide_input" */
  guide_input: Array<Guide_Input>;
  /** fetch aggregated fields from the table: "guide_input" */
  guide_input_aggregate: Guide_Input_Aggregate;
  /** fetch data from the table: "guide_input" using primary key columns */
  guide_input_by_pk?: Maybe<Guide_Input>;
  /** fetch data from the table in a streaming manner: "guide_input" */
  guide_input_stream: Array<Guide_Input>;
  /** An array relationship */
  investigator_data: Array<Investigator_Data>;
  /** An aggregate relationship */
  investigator_data_aggregate: Investigator_Data_Aggregate;
  /** fetch data from the table: "investigator_data" using primary key columns */
  investigator_data_by_pk?: Maybe<Investigator_Data>;
  /** fetch data from the table in a streaming manner: "investigator_data" */
  investigator_data_stream: Array<Investigator_Data>;
  /** An array relationship */
  latest_decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  latest_decks_aggregate: Latest_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "latest_decks" */
  latest_decks_stream: Array<Latest_Decks>;
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  /** fetch data from the table in a streaming manner: "local_decks" */
  local_decks_stream: Array<Local_Decks>;
  /** fetch data from the table: "pack" */
  pack: Array<Pack>;
  /** fetch aggregated fields from the table: "pack" */
  pack_aggregate: Pack_Aggregate;
  /** fetch data from the table: "pack" using primary key columns */
  pack_by_pk?: Maybe<Pack>;
  /** fetch data from the table: "pack_name" */
  pack_name: Array<Pack_Name>;
  /** fetch aggregated fields from the table: "pack_name" */
  pack_name_aggregate: Pack_Name_Aggregate;
  /** fetch data from the table: "pack_name" using primary key columns */
  pack_name_by_pk?: Maybe<Pack_Name>;
  /** fetch data from the table in a streaming manner: "pack_name" */
  pack_name_stream: Array<Pack_Name>;
  /** fetch data from the table in a streaming manner: "pack" */
  pack_stream: Array<Pack>;
  /** fetch data from the table: "rangers.area" */
  rangers_area: Array<Rangers_Area>;
  /** fetch aggregated fields from the table: "rangers.area" */
  rangers_area_aggregate: Rangers_Area_Aggregate;
  /** fetch data from the table: "rangers.area" using primary key columns */
  rangers_area_by_pk?: Maybe<Rangers_Area>;
  /** fetch data from the table in a streaming manner: "rangers.area" */
  rangers_area_stream: Array<Rangers_Area>;
  /** fetch data from the table: "rangers.area_text" */
  rangers_area_text: Array<Rangers_Area_Text>;
  /** fetch aggregated fields from the table: "rangers.area_text" */
  rangers_area_text_aggregate: Rangers_Area_Text_Aggregate;
  /** fetch data from the table: "rangers.area_text" using primary key columns */
  rangers_area_text_by_pk?: Maybe<Rangers_Area_Text>;
  /** fetch data from the table in a streaming manner: "rangers.area_text" */
  rangers_area_text_stream: Array<Rangers_Area_Text>;
  /** fetch data from the table: "rangers.aspect" */
  rangers_aspect: Array<Rangers_Aspect>;
  /** fetch aggregated fields from the table: "rangers.aspect" */
  rangers_aspect_aggregate: Rangers_Aspect_Aggregate;
  /** fetch data from the table: "rangers.aspect" using primary key columns */
  rangers_aspect_by_pk?: Maybe<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_localized" */
  rangers_aspect_localized: Array<Rangers_Aspect_Localized>;
  /** fetch aggregated fields from the table: "rangers.aspect_localized" */
  rangers_aspect_localized_aggregate: Rangers_Aspect_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.aspect_localized" */
  rangers_aspect_localized_stream: Array<Rangers_Aspect_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.aspect" */
  rangers_aspect_stream: Array<Rangers_Aspect>;
  /** fetch data from the table: "rangers.aspect_text" */
  rangers_aspect_text: Array<Rangers_Aspect_Text>;
  /** fetch aggregated fields from the table: "rangers.aspect_text" */
  rangers_aspect_text_aggregate: Rangers_Aspect_Text_Aggregate;
  /** fetch data from the table: "rangers.aspect_text" using primary key columns */
  rangers_aspect_text_by_pk?: Maybe<Rangers_Aspect_Text>;
  /** fetch data from the table in a streaming manner: "rangers.aspect_text" */
  rangers_aspect_text_stream: Array<Rangers_Aspect_Text>;
  /** fetch data from the table: "rangers.campaign" */
  rangers_campaign: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.campaign_access" */
  rangers_campaign_access: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign_access" */
  rangers_campaign_access_aggregate: Rangers_Campaign_Access_Aggregate;
  /** fetch data from the table: "rangers.campaign_access" using primary key columns */
  rangers_campaign_access_by_pk?: Maybe<Rangers_Campaign_Access>;
  /** fetch data from the table in a streaming manner: "rangers.campaign_access" */
  rangers_campaign_access_stream: Array<Rangers_Campaign_Access>;
  /** fetch aggregated fields from the table: "rangers.campaign" */
  rangers_campaign_aggregate: Rangers_Campaign_Aggregate;
  /** fetch data from the table: "rangers.campaign" using primary key columns */
  rangers_campaign_by_pk?: Maybe<Rangers_Campaign>;
  /** fetch data from the table in a streaming manner: "rangers.campaign" */
  rangers_campaign_stream: Array<Rangers_Campaign>;
  /** fetch data from the table: "rangers.card" */
  rangers_card: Array<Rangers_Card>;
  /** fetch aggregated fields from the table: "rangers.card" */
  rangers_card_aggregate: Rangers_Card_Aggregate;
  /** fetch data from the table: "rangers.card" using primary key columns */
  rangers_card_by_pk?: Maybe<Rangers_Card>;
  /** fetch data from the table: "rangers.card_localized" */
  rangers_card_localized: Array<Rangers_Card_Localized>;
  /** fetch aggregated fields from the table: "rangers.card_localized" */
  rangers_card_localized_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card_localized" */
  rangers_card_localized_stream: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" which returns "rangers.card_localized" */
  rangers_card_search: Array<Rangers_Card_Localized>;
  /** execute function "rangers.card_search" and query aggregates on result of table type "rangers.card_localized" */
  rangers_card_search_aggregate: Rangers_Card_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card" */
  rangers_card_stream: Array<Rangers_Card>;
  /** fetch data from the table: "rangers.card_text" */
  rangers_card_text: Array<Rangers_Card_Text>;
  /** fetch aggregated fields from the table: "rangers.card_text" */
  rangers_card_text_aggregate: Rangers_Card_Text_Aggregate;
  /** fetch data from the table: "rangers.card_text" using primary key columns */
  rangers_card_text_by_pk?: Maybe<Rangers_Card_Text>;
  /** fetch data from the table in a streaming manner: "rangers.card_text" */
  rangers_card_text_stream: Array<Rangers_Card_Text>;
  /** fetch data from the table: "rangers.card_updated" */
  rangers_card_updated: Array<Rangers_Card_Updated>;
  /** fetch aggregated fields from the table: "rangers.card_updated" */
  rangers_card_updated_aggregate: Rangers_Card_Updated_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.card_updated" */
  rangers_card_updated_stream: Array<Rangers_Card_Updated>;
  /** fetch data from the table: "rangers.comment" */
  rangers_comment: Array<Rangers_Comment>;
  /** fetch aggregated fields from the table: "rangers.comment" */
  rangers_comment_aggregate: Rangers_Comment_Aggregate;
  /** fetch data from the table: "rangers.comment" using primary key columns */
  rangers_comment_by_pk?: Maybe<Rangers_Comment>;
  /** fetch data from the table in a streaming manner: "rangers.comment" */
  rangers_comment_stream: Array<Rangers_Comment>;
  /** fetch data from the table: "rangers.deck" */
  rangers_deck: Array<Rangers_Deck>;
  /** fetch aggregated fields from the table: "rangers.deck" */
  rangers_deck_aggregate: Rangers_Deck_Aggregate;
  /** fetch data from the table: "rangers.deck" using primary key columns */
  rangers_deck_by_pk?: Maybe<Rangers_Deck>;
  /** fetch data from the table: "rangers.deck_copy" */
  rangers_deck_copy: Array<Rangers_Deck_Copy>;
  /** fetch aggregated fields from the table: "rangers.deck_copy" */
  rangers_deck_copy_aggregate: Rangers_Deck_Copy_Aggregate;
  /** fetch data from the table: "rangers.deck_copy" using primary key columns */
  rangers_deck_copy_by_pk?: Maybe<Rangers_Deck_Copy>;
  /** fetch data from the table in a streaming manner: "rangers.deck_copy" */
  rangers_deck_copy_stream: Array<Rangers_Deck_Copy>;
  /** fetch data from the table: "rangers.deck_like" */
  rangers_deck_like: Array<Rangers_Deck_Like>;
  /** fetch aggregated fields from the table: "rangers.deck_like" */
  rangers_deck_like_aggregate: Rangers_Deck_Like_Aggregate;
  /** fetch data from the table: "rangers.deck_like" using primary key columns */
  rangers_deck_like_by_pk?: Maybe<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_like_count" */
  rangers_deck_like_count: Array<Rangers_Deck_Like_Count>;
  /** fetch aggregated fields from the table: "rangers.deck_like_count" */
  rangers_deck_like_count_aggregate: Rangers_Deck_Like_Count_Aggregate;
  /** fetch data from the table: "rangers.deck_like_count" using primary key columns */
  rangers_deck_like_count_by_pk?: Maybe<Rangers_Deck_Like_Count>;
  /** fetch data from the table in a streaming manner: "rangers.deck_like_count" */
  rangers_deck_like_count_stream: Array<Rangers_Deck_Like_Count>;
  /** fetch data from the table in a streaming manner: "rangers.deck_like" */
  rangers_deck_like_stream: Array<Rangers_Deck_Like>;
  /** fetch data from the table: "rangers.deck_rank" */
  rangers_deck_rank: Array<Rangers_Deck_Rank>;
  /** fetch aggregated fields from the table: "rangers.deck_rank" */
  rangers_deck_rank_aggregate: Rangers_Deck_Rank_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.deck_rank" */
  rangers_deck_rank_stream: Array<Rangers_Deck_Rank>;
  /** execute function "rangers.deck_search" which returns "rangers.search_deck" */
  rangers_deck_search: Array<Rangers_Search_Deck>;
  /** execute function "rangers.deck_search" and query aggregates on result of table type "rangers.search_deck" */
  rangers_deck_search_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.deck" */
  rangers_deck_stream: Array<Rangers_Deck>;
  /** fetch data from the table: "rangers.faq_entry" */
  rangers_faq_entry: Array<Rangers_Faq_Entry>;
  /** fetch aggregated fields from the table: "rangers.faq_entry" */
  rangers_faq_entry_aggregate: Rangers_Faq_Entry_Aggregate;
  /** fetch data from the table: "rangers.faq_entry" using primary key columns */
  rangers_faq_entry_by_pk?: Maybe<Rangers_Faq_Entry>;
  /** fetch data from the table in a streaming manner: "rangers.faq_entry" */
  rangers_faq_entry_stream: Array<Rangers_Faq_Entry>;
  /** fetch data from the table: "rangers.friend_status" */
  rangers_friend_status: Array<Rangers_Friend_Status>;
  /** fetch aggregated fields from the table: "rangers.friend_status" */
  rangers_friend_status_aggregate: Rangers_Friend_Status_Aggregate;
  /** fetch data from the table: "rangers.friend_status" using primary key columns */
  rangers_friend_status_by_pk?: Maybe<Rangers_Friend_Status>;
  /** fetch data from the table in a streaming manner: "rangers.friend_status" */
  rangers_friend_status_stream: Array<Rangers_Friend_Status>;
  /** fetch data from the table: "rangers.friend_status_type" */
  rangers_friend_status_type: Array<Rangers_Friend_Status_Type>;
  /** fetch aggregated fields from the table: "rangers.friend_status_type" */
  rangers_friend_status_type_aggregate: Rangers_Friend_Status_Type_Aggregate;
  /** fetch data from the table: "rangers.friend_status_type" using primary key columns */
  rangers_friend_status_type_by_pk?: Maybe<Rangers_Friend_Status_Type>;
  /** fetch data from the table in a streaming manner: "rangers.friend_status_type" */
  rangers_friend_status_type_stream: Array<Rangers_Friend_Status_Type>;
  /** fetch data from the table: "rangers.latest_deck" */
  rangers_latest_deck: Array<Rangers_Latest_Deck>;
  /** fetch aggregated fields from the table: "rangers.latest_deck" */
  rangers_latest_deck_aggregate: Rangers_Latest_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.latest_deck" */
  rangers_latest_deck_stream: Array<Rangers_Latest_Deck>;
  /** fetch data from the table: "rangers.locale" */
  rangers_locale: Array<Rangers_Locale>;
  /** fetch aggregated fields from the table: "rangers.locale" */
  rangers_locale_aggregate: Rangers_Locale_Aggregate;
  /** fetch data from the table: "rangers.locale" using primary key columns */
  rangers_locale_by_pk?: Maybe<Rangers_Locale>;
  /** fetch data from the table in a streaming manner: "rangers.locale" */
  rangers_locale_stream: Array<Rangers_Locale>;
  /** fetch data from the table: "rangers.pack" */
  rangers_pack: Array<Rangers_Pack>;
  /** fetch aggregated fields from the table: "rangers.pack" */
  rangers_pack_aggregate: Rangers_Pack_Aggregate;
  /** fetch data from the table: "rangers.pack" using primary key columns */
  rangers_pack_by_pk?: Maybe<Rangers_Pack>;
  /** fetch data from the table in a streaming manner: "rangers.pack" */
  rangers_pack_stream: Array<Rangers_Pack>;
  /** fetch data from the table: "rangers.pack_text" */
  rangers_pack_text: Array<Rangers_Pack_Text>;
  /** fetch aggregated fields from the table: "rangers.pack_text" */
  rangers_pack_text_aggregate: Rangers_Pack_Text_Aggregate;
  /** fetch data from the table: "rangers.pack_text" using primary key columns */
  rangers_pack_text_by_pk?: Maybe<Rangers_Pack_Text>;
  /** fetch data from the table in a streaming manner: "rangers.pack_text" */
  rangers_pack_text_stream: Array<Rangers_Pack_Text>;
  /** fetch data from the table: "rangers.search_deck" */
  rangers_search_deck: Array<Rangers_Search_Deck>;
  /** fetch aggregated fields from the table: "rangers.search_deck" */
  rangers_search_deck_aggregate: Rangers_Search_Deck_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.search_deck" */
  rangers_search_deck_stream: Array<Rangers_Search_Deck>;
  /** fetch data from the table: "rangers.set" */
  rangers_set: Array<Rangers_Set>;
  /** fetch aggregated fields from the table: "rangers.set" */
  rangers_set_aggregate: Rangers_Set_Aggregate;
  /** fetch data from the table: "rangers.set" using primary key columns */
  rangers_set_by_pk?: Maybe<Rangers_Set>;
  /** fetch data from the table: "rangers.set_localized" */
  rangers_set_localized: Array<Rangers_Set_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_localized" */
  rangers_set_localized_aggregate: Rangers_Set_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.set_localized" */
  rangers_set_localized_stream: Array<Rangers_Set_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.set" */
  rangers_set_stream: Array<Rangers_Set>;
  /** fetch data from the table: "rangers.set_text" */
  rangers_set_text: Array<Rangers_Set_Text>;
  /** fetch aggregated fields from the table: "rangers.set_text" */
  rangers_set_text_aggregate: Rangers_Set_Text_Aggregate;
  /** fetch data from the table: "rangers.set_text" using primary key columns */
  rangers_set_text_by_pk?: Maybe<Rangers_Set_Text>;
  /** fetch data from the table in a streaming manner: "rangers.set_text" */
  rangers_set_text_stream: Array<Rangers_Set_Text>;
  /** fetch data from the table: "rangers.set_type" */
  rangers_set_type: Array<Rangers_Set_Type>;
  /** fetch aggregated fields from the table: "rangers.set_type" */
  rangers_set_type_aggregate: Rangers_Set_Type_Aggregate;
  /** fetch data from the table: "rangers.set_type" using primary key columns */
  rangers_set_type_by_pk?: Maybe<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_localized" */
  rangers_set_type_localized: Array<Rangers_Set_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.set_type_localized" */
  rangers_set_type_localized_aggregate: Rangers_Set_Type_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.set_type_localized" */
  rangers_set_type_localized_stream: Array<Rangers_Set_Type_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.set_type" */
  rangers_set_type_stream: Array<Rangers_Set_Type>;
  /** fetch data from the table: "rangers.set_type_text" */
  rangers_set_type_text: Array<Rangers_Set_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.set_type_text" */
  rangers_set_type_text_aggregate: Rangers_Set_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.set_type_text" using primary key columns */
  rangers_set_type_text_by_pk?: Maybe<Rangers_Set_Type_Text>;
  /** fetch data from the table in a streaming manner: "rangers.set_type_text" */
  rangers_set_type_text_stream: Array<Rangers_Set_Type_Text>;
  /** fetch data from the table: "rangers.token" */
  rangers_token: Array<Rangers_Token>;
  /** fetch aggregated fields from the table: "rangers.token" */
  rangers_token_aggregate: Rangers_Token_Aggregate;
  /** fetch data from the table: "rangers.token" using primary key columns */
  rangers_token_by_pk?: Maybe<Rangers_Token>;
  /** fetch data from the table in a streaming manner: "rangers.token" */
  rangers_token_stream: Array<Rangers_Token>;
  /** fetch data from the table: "rangers.token_text" */
  rangers_token_text: Array<Rangers_Token_Text>;
  /** fetch aggregated fields from the table: "rangers.token_text" */
  rangers_token_text_aggregate: Rangers_Token_Text_Aggregate;
  /** fetch data from the table: "rangers.token_text" using primary key columns */
  rangers_token_text_by_pk?: Maybe<Rangers_Token_Text>;
  /** fetch data from the table in a streaming manner: "rangers.token_text" */
  rangers_token_text_stream: Array<Rangers_Token_Text>;
  /** fetch data from the table: "rangers.type" */
  rangers_type: Array<Rangers_Type>;
  /** fetch aggregated fields from the table: "rangers.type" */
  rangers_type_aggregate: Rangers_Type_Aggregate;
  /** fetch data from the table: "rangers.type" using primary key columns */
  rangers_type_by_pk?: Maybe<Rangers_Type>;
  /** fetch data from the table: "rangers.type_localized" */
  rangers_type_localized: Array<Rangers_Type_Localized>;
  /** fetch aggregated fields from the table: "rangers.type_localized" */
  rangers_type_localized_aggregate: Rangers_Type_Localized_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.type_localized" */
  rangers_type_localized_stream: Array<Rangers_Type_Localized>;
  /** fetch data from the table in a streaming manner: "rangers.type" */
  rangers_type_stream: Array<Rangers_Type>;
  /** fetch data from the table: "rangers.type_text" */
  rangers_type_text: Array<Rangers_Type_Text>;
  /** fetch aggregated fields from the table: "rangers.type_text" */
  rangers_type_text_aggregate: Rangers_Type_Text_Aggregate;
  /** fetch data from the table: "rangers.type_text" using primary key columns */
  rangers_type_text_by_pk?: Maybe<Rangers_Type_Text>;
  /** fetch data from the table in a streaming manner: "rangers.type_text" */
  rangers_type_text_stream: Array<Rangers_Type_Text>;
  /** fetch data from the table: "rangers.user_campaign" */
  rangers_user_campaign: Array<Rangers_User_Campaign>;
  /** fetch aggregated fields from the table: "rangers.user_campaign" */
  rangers_user_campaign_aggregate: Rangers_User_Campaign_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_campaign" */
  rangers_user_campaign_stream: Array<Rangers_User_Campaign>;
  /** fetch data from the table: "rangers.user_friends" */
  rangers_user_friends: Array<Rangers_User_Friends>;
  /** fetch aggregated fields from the table: "rangers.user_friends" */
  rangers_user_friends_aggregate: Rangers_User_Friends_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_friends" */
  rangers_user_friends_stream: Array<Rangers_User_Friends>;
  /** fetch data from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_aggregate: Rangers_User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_received_friend_requests" */
  rangers_user_received_friend_requests_stream: Array<Rangers_User_Received_Friend_Requests>;
  /** fetch data from the table: "rangers.user_role" */
  rangers_user_role: Array<Rangers_User_Role>;
  /** fetch aggregated fields from the table: "rangers.user_role" */
  rangers_user_role_aggregate: Rangers_User_Role_Aggregate;
  /** fetch data from the table: "rangers.user_role" using primary key columns */
  rangers_user_role_by_pk?: Maybe<Rangers_User_Role>;
  /** fetch data from the table in a streaming manner: "rangers.user_role" */
  rangers_user_role_stream: Array<Rangers_User_Role>;
  /** fetch data from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_aggregate: Rangers_User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "rangers.user_sent_friend_requests" */
  rangers_user_sent_friend_requests_stream: Array<Rangers_User_Sent_Friend_Requests>;
  /** fetch data from the table: "rangers.user_settings" */
  rangers_user_settings: Array<Rangers_User_Settings>;
  /** fetch aggregated fields from the table: "rangers.user_settings" */
  rangers_user_settings_aggregate: Rangers_User_Settings_Aggregate;
  /** fetch data from the table: "rangers.user_settings" using primary key columns */
  rangers_user_settings_by_pk?: Maybe<Rangers_User_Settings>;
  /** fetch data from the table in a streaming manner: "rangers.user_settings" */
  rangers_user_settings_stream: Array<Rangers_User_Settings>;
  /** fetch data from the table: "rangers.users" */
  rangers_users: Array<Rangers_Users>;
  /** fetch aggregated fields from the table: "rangers.users" */
  rangers_users_aggregate: Rangers_Users_Aggregate;
  /** fetch data from the table: "rangers.users" using primary key columns */
  rangers_users_by_pk?: Maybe<Rangers_Users>;
  /** fetch data from the table in a streaming manner: "rangers.users" */
  rangers_users_stream: Array<Rangers_Users>;
  /** fetch data from the table: "taboo_set" */
  taboo_set: Array<Taboo_Set>;
  /** fetch aggregated fields from the table: "taboo_set" */
  taboo_set_aggregate: Taboo_Set_Aggregate;
  /** fetch data from the table: "taboo_set" using primary key columns */
  taboo_set_by_pk?: Maybe<Taboo_Set>;
  /** fetch data from the table in a streaming manner: "taboo_set" */
  taboo_set_stream: Array<Taboo_Set>;
  /** fetch data from the table: "user_campaigns" */
  user_campaigns: Array<User_Campaigns>;
  /** fetch aggregated fields from the table: "user_campaigns" */
  user_campaigns_aggregate: User_Campaigns_Aggregate;
  /** fetch data from the table in a streaming manner: "user_campaigns" */
  user_campaigns_stream: Array<User_Campaigns>;
  /** fetch data from the table: "user_flag" */
  user_flag: Array<User_Flag>;
  /** fetch aggregated fields from the table: "user_flag" */
  user_flag_aggregate: User_Flag_Aggregate;
  /** fetch data from the table: "user_flag" using primary key columns */
  user_flag_by_pk?: Maybe<User_Flag>;
  /** fetch data from the table in a streaming manner: "user_flag" */
  user_flag_stream: Array<User_Flag>;
  /** fetch data from the table: "user_flag_type" */
  user_flag_type: Array<User_Flag_Type>;
  /** fetch aggregated fields from the table: "user_flag_type" */
  user_flag_type_aggregate: User_Flag_Type_Aggregate;
  /** fetch data from the table: "user_flag_type" using primary key columns */
  user_flag_type_by_pk?: Maybe<User_Flag_Type>;
  /** fetch data from the table in a streaming manner: "user_flag_type" */
  user_flag_type_stream: Array<User_Flag_Type>;
  /** fetch data from the table: "user_friends" */
  user_friends: Array<User_Friends>;
  /** fetch aggregated fields from the table: "user_friends" */
  user_friends_aggregate: User_Friends_Aggregate;
  /** fetch data from the table in a streaming manner: "user_friends" */
  user_friends_stream: Array<User_Friends>;
  /** fetch data from the table: "user_received_friend_requests" */
  user_received_friend_requests: Array<User_Received_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_received_friend_requests" */
  user_received_friend_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "user_received_friend_requests" */
  user_received_friend_requests_stream: Array<User_Received_Friend_Requests>;
  /** fetch data from the table: "user_sent_friend_requests" */
  user_sent_friend_requests: Array<User_Sent_Friend_Requests>;
  /** fetch aggregated fields from the table: "user_sent_friend_requests" */
  user_sent_friend_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  /** fetch data from the table in a streaming manner: "user_sent_friend_requests" */
  user_sent_friend_requests_stream: Array<User_Sent_Friend_Requests>;
  /** fetch data from the table: "user_settings" */
  user_settings: Array<User_Settings>;
  /** fetch aggregated fields from the table: "user_settings" */
  user_settings_aggregate: User_Settings_Aggregate;
  /** fetch data from the table: "user_settings" using primary key columns */
  user_settings_by_pk?: Maybe<User_Settings>;
  /** fetch data from the table in a streaming manner: "user_settings" */
  user_settings_stream: Array<User_Settings>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
};


export type Subscription_RootAll_CardArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


export type Subscription_RootAll_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Text_Order_By>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Text_Bool_Exp>;
};


export type Subscription_RootAll_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_Order_By>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Subscription_RootAll_Card_Updated_By_VersionArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_Version_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Updated_By_Version_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Updated_By_Version_Order_By>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_By_Version_By_PkArgs = {
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
};


export type Subscription_RootAll_Card_Updated_By_Version_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Updated_By_Version_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Updated_By_Version_Bool_Exp>;
};


export type Subscription_RootAll_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<All_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<All_Card_Updated_Bool_Exp>;
};


export type Subscription_RootArkhamdb_AuthArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Auth_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Auth_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Auth_Order_By>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Auth_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootArkhamdb_Auth_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arkhamdb_Auth_Stream_Cursor_Input>>;
  where?: InputMaybe<Arkhamdb_Auth_Bool_Exp>;
};


export type Subscription_RootArkhamdb_DeckArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Arkhamdb_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Arkhamdb_Deck_Order_By>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootArkhamdb_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootArkhamdb_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Arkhamdb_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Arkhamdb_Deck_Bool_Exp>;
};


export type Subscription_RootBase_DecksArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootBase_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Base_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Base_Decks_Order_By>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootBase_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Base_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Base_Decks_Bool_Exp>;
};


export type Subscription_RootCampaignArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Access_Order_By>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_Access_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_Access_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Access_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Access_Bool_Exp>;
};


export type Subscription_RootCampaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Order_By>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_DeckArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootCampaign_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


export type Subscription_RootCampaign_DifficultyArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_Difficulty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Difficulty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Difficulty_Order_By>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_Difficulty_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootCampaign_Difficulty_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Difficulty_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Difficulty_Bool_Exp>;
};


export type Subscription_RootCampaign_GuideArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_Guide_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Guide_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Guide_Order_By>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_Guide_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Guide_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Guide_Bool_Exp>;
};


export type Subscription_RootCampaign_InvestigatorArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_Investigator_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Investigator_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Investigator_Order_By>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_Investigator_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Subscription_RootCampaign_Investigator_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Investigator_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Investigator_Bool_Exp>;
};


export type Subscription_RootCampaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaign_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_CycleArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaigns_By_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaigns_By_Cycle_Order_By>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCampaigns_By_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Campaigns_By_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Campaigns_By_Cycle_Bool_Exp>;
};


export type Subscription_RootCardArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Order_By>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCard_CycleArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Cycle_Order_By>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Cycle_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Cycle_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_SetArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Encounter_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Encounter_Set_Order_By>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_Encounter_Set_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Encounter_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Encounter_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Encounter_Set_Bool_Exp>;
};


export type Subscription_RootCard_PackArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Pack_Order_By>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_Pack_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Pack_Bool_Exp>;
};


export type Subscription_RootCard_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Subtype_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Subtype_Name_Order_By>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_Subtype_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Subtype_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Subtype_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Subtype_Name_Bool_Exp>;
};


export type Subscription_RootCard_TextArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Text_Order_By>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Text_Bool_Exp>;
};


export type Subscription_RootCard_Type_CodeArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Code_Order_By>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_Code_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCard_Type_Code_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Type_Code_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Type_Code_Bool_Exp>;
};


export type Subscription_RootCard_Type_NameArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootCard_Type_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Card_Type_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Card_Type_Name_Order_By>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootCard_Type_Name_By_PkArgs = {
  code: Card_Type_Code_Enum;
  locale: Scalars['String']['input'];
};


export type Subscription_RootCard_Type_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Card_Type_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Card_Type_Name_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_ResultArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Result_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Result_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Result_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Result_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootChaos_Bag_Result_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chaos_Bag_Result_Stream_Cursor_Input>>;
  where?: InputMaybe<Chaos_Bag_Result_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_ModeArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_Mode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Chaos_Bag_Tarot_Mode_Order_By>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootChaos_Bag_Tarot_Mode_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootChaos_Bag_Tarot_Mode_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Chaos_Bag_Tarot_Mode_Stream_Cursor_Input>>;
  where?: InputMaybe<Chaos_Bag_Tarot_Mode_Bool_Exp>;
};


export type Subscription_RootConquest_CardArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Order_By>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Localized_Order_By>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Localized_Bool_Exp>;
};


export type Subscription_RootConquest_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Bool_Exp>;
};


export type Subscription_RootConquest_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Text_Order_By>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Card_Updated_Order_By>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Card_Updated_Bool_Exp>;
};


export type Subscription_RootConquest_CommentArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Comment_Order_By>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootConquest_Comment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Comment_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Comment_Bool_Exp>;
};


export type Subscription_RootConquest_CycleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Cycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Cycle_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Cycle_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Cycle_Text_Order_By>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Cycle_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Cycle_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Cycle_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Cycle_Text_Bool_Exp>;
};


export type Subscription_RootConquest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootConquest_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Copy_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Subscription_RootConquest_Deck_Copy_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Copy_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Deck_Like_Order_By>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Deck_Like_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Like_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Like_Bool_Exp>;
};


export type Subscription_RootConquest_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Deck_Bool_Exp>;
};


export type Subscription_RootConquest_FactionArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Faction_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Faction_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Faction_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Faction_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Faction_Text_Order_By>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Faction_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Faction_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Faction_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Faction_Text_Bool_Exp>;
};


export type Subscription_RootConquest_LoyaltyArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Loyalty_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Loyalty_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Loyalty_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Loyalty_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Loyalty_Text_Order_By>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Loyalty_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Loyalty_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Loyalty_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Loyalty_Text_Bool_Exp>;
};


export type Subscription_RootConquest_PackArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Pack_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Pack_Text_Order_By>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Pack_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Pack_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Pack_Text_Bool_Exp>;
};


export type Subscription_RootConquest_TypeArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Order_By>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Type_Bool_Exp>;
};


export type Subscription_RootConquest_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Type_Text_Order_By>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootConquest_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Type_Text_Bool_Exp>;
};


export type Subscription_RootConquest_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Role_Order_By>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_User_Role_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_User_Role_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_User_Role_Bool_Exp>;
};


export type Subscription_RootConquest_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_User_Settings_Order_By>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootConquest_User_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_User_Settings_Bool_Exp>;
};


export type Subscription_RootConquest_UsersArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootConquest_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Conquest_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Conquest_Users_Order_By>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootConquest_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootConquest_Users_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Conquest_Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Conquest_Users_Bool_Exp>;
};


export type Subscription_RootCycleArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootCycle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Order_By>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootCycle_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootCycle_NameArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cycle_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Cycle_Name_Order_By>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootCycle_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Cycle_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Cycle_Name_Bool_Exp>;
};


export type Subscription_RootCycle_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Cycle_Stream_Cursor_Input>>;
  where?: InputMaybe<Cycle_Bool_Exp>;
};


export type Subscription_RootFaction_NameArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaction_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faction_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faction_Name_Order_By>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaction_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFaction_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faction_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Faction_Name_Bool_Exp>;
};


export type Subscription_RootFaqArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Order_By>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootFaq_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faq_Stream_Cursor_Input>>;
  where?: InputMaybe<Faq_Bool_Exp>;
};


export type Subscription_RootFaq_TextArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFaq_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Faq_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Faq_Text_Order_By>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFaq_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFaq_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Faq_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Faq_Text_Bool_Exp>;
};


export type Subscription_RootFriend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Order_By>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Subscription_RootFriend_Status_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Friend_Status_Stream_Cursor_Input>>;
  where?: InputMaybe<Friend_Status_Bool_Exp>;
};


export type Subscription_RootFriend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFriend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFriend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootFriend_Status_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Friend_Status_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootFull_CardArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Order_By>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootFull_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Full_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Full_Card_Bool_Exp>;
};


export type Subscription_RootFull_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootFull_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Full_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Full_Card_Text_Order_By>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootFull_Card_Text_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootFull_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Full_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Full_Card_Text_Bool_Exp>;
};


export type Subscription_RootGenderArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGender_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Gender_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Gender_Order_By>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGender_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootGender_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Gender_Stream_Cursor_Input>>;
  where?: InputMaybe<Gender_Bool_Exp>;
};


export type Subscription_RootGuide_AchievementArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_Achievement_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Achievement_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Achievement_Order_By>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_Achievement_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Subscription_RootGuide_Achievement_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Guide_Achievement_Stream_Cursor_Input>>;
  where?: InputMaybe<Guide_Achievement_Bool_Exp>;
};


export type Subscription_RootGuide_InputArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootGuide_Input_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Guide_Input_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Guide_Input_Order_By>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootGuide_Input_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
};


export type Subscription_RootGuide_Input_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Guide_Input_Stream_Cursor_Input>>;
  where?: InputMaybe<Guide_Input_Bool_Exp>;
};


export type Subscription_RootInvestigator_DataArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootInvestigator_Data_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Investigator_Data_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Investigator_Data_Order_By>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootInvestigator_Data_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
};


export type Subscription_RootInvestigator_Data_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Investigator_Data_Stream_Cursor_Input>>;
  where?: InputMaybe<Investigator_Data_Bool_Exp>;
};


export type Subscription_RootLatest_DecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLatest_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLatest_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Latest_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootLocal_Decks_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Local_Decks_Stream_Cursor_Input>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


export type Subscription_RootPackArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootPack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Order_By>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootPack_By_PkArgs = {
  code: Scalars['String']['input'];
};


export type Subscription_RootPack_NameArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_Name_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Pack_Name_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Pack_Name_Order_By>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_Name_By_PkArgs = {
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootPack_Name_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Pack_Name_Stream_Cursor_Input>>;
  where?: InputMaybe<Pack_Name_Bool_Exp>;
};


export type Subscription_RootPack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Pack_Bool_Exp>;
};


export type Subscription_RootRangers_AreaArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Order_By>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Area_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Area_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Area_Bool_Exp>;
};


export type Subscription_RootRangers_Area_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Area_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Area_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Area_Text_Order_By>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Area_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Area_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Area_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Area_Text_Bool_Exp>;
};


export type Subscription_RootRangers_AspectArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Aspect_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Aspect_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Aspect_Text_Order_By>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Aspect_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Aspect_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Aspect_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Aspect_Text_Bool_Exp>;
};


export type Subscription_RootRangers_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_AccessArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_Access_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Access_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Access_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_Access_By_PkArgs = {
  campaign_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Campaign_Access_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Campaign_Access_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Campaign_Access_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_Campaign_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Campaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_CardArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Order_By>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Card_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_SearchArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Card_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Card_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Card_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Card_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Bool_Exp>;
};


export type Subscription_RootRangers_Card_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Text_Order_By>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Card_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Card_UpdatedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Updated_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Card_Updated_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Card_Updated_Order_By>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_Card_Updated_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Card_Updated_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Card_Updated_Bool_Exp>;
};


export type Subscription_RootRangers_CommentArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_Comment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Comment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Comment_Order_By>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_Comment_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootRangers_Comment_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Comment_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Comment_Bool_Exp>;
};


export type Subscription_RootRangers_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_CopyArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Copy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Copy_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Copy_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Copy_By_PkArgs = {
  copy_deck_id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_Copy_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Copy_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Copy_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_LikeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Deck_Like_CountArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_Count_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Like_Count_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Like_Count_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_Count_By_PkArgs = {
  deck_id: Scalars['Int']['input'];
};


export type Subscription_RootRangers_Deck_Like_Count_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Like_Count_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Like_Count_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Like_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Like_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Like_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_RankArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Rank_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Deck_Rank_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Deck_Rank_Order_By>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Rank_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Rank_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Rank_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_SearchArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_Search_AggregateArgs = {
  args?: InputMaybe<Rangers_Deck_Search_Args>;
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_EntryArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_Entry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Faq_Entry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Faq_Entry_Order_By>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Faq_Entry_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Faq_Entry_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Faq_Entry_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Faq_Entry_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_StatusArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_By_PkArgs = {
  user_id_a: Scalars['String']['input'];
  user_id_b: Scalars['String']['input'];
};


export type Subscription_RootRangers_Friend_Status_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Friend_Status_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Friend_Status_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Friend_Status_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Friend_Status_Type_Order_By>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Friend_Status_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootRangers_Friend_Status_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Friend_Status_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Friend_Status_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Latest_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Latest_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Latest_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Latest_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Latest_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_LocaleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_Locale_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Locale_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Locale_Order_By>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_Locale_By_PkArgs = {
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Locale_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Locale_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Locale_Bool_Exp>;
};


export type Subscription_RootRangers_PackArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Pack_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Pack_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Pack_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Pack_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Pack_Text_Order_By>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Pack_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Pack_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Pack_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Pack_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Search_DeckArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_Deck_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Search_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Search_Deck_Order_By>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_Search_Deck_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Search_Deck_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Search_Deck_Bool_Exp>;
};


export type Subscription_RootRangers_SetArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Order_By>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Bool_Exp>;
};


export type Subscription_RootRangers_Set_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Set_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Set_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Set_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Set_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Set_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Set_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_TokenArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Order_By>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Token_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Token_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Token_Bool_Exp>;
};


export type Subscription_RootRangers_Token_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Token_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Token_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Token_Text_Order_By>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Token_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Token_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Token_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Token_Text_Bool_Exp>;
};


export type Subscription_RootRangers_TypeArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Order_By>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Type_LocalizedArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Localized_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Localized_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Localized_Order_By>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Localized_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Localized_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Localized_Bool_Exp>;
};


export type Subscription_RootRangers_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Bool_Exp>;
};


export type Subscription_RootRangers_Type_TextArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Text_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Type_Text_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Type_Text_Order_By>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_Type_Text_By_PkArgs = {
  id: Scalars['String']['input'];
  locale: Scalars['String']['input'];
};


export type Subscription_RootRangers_Type_Text_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Type_Text_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Type_Text_Bool_Exp>;
};


export type Subscription_RootRangers_User_CampaignArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_Campaign_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Campaign_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Campaign_Order_By>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_Campaign_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Campaign_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Campaign_Bool_Exp>;
};


export type Subscription_RootRangers_User_FriendsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Friends_Order_By>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Friends_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Friends_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Friends_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Received_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Received_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_RoleArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Role_Order_By>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Role_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_User_Role_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Role_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Role_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_Sent_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Sent_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootRangers_User_SettingsArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_User_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_User_Settings_Order_By>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_User_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootRangers_User_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_User_Settings_Bool_Exp>;
};


export type Subscription_RootRangers_UsersArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootRangers_Users_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Rangers_Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Rangers_Users_Order_By>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootRangers_Users_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootRangers_Users_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Rangers_Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Rangers_Users_Bool_Exp>;
};


export type Subscription_RootTaboo_SetArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootTaboo_Set_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Taboo_Set_Order_By>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootTaboo_Set_By_PkArgs = {
  id: Scalars['Int']['input'];
};


export type Subscription_RootTaboo_Set_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Taboo_Set_Stream_Cursor_Input>>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};


export type Subscription_RootUser_CampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_Campaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_Campaigns_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Campaigns_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


export type Subscription_RootUser_FlagArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_By_PkArgs = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};


export type Subscription_RootUser_Flag_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Flag_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


export type Subscription_RootUser_Flag_TypeArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_Flag_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Type_Order_By>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_Flag_Type_By_PkArgs = {
  value: Scalars['String']['input'];
};


export type Subscription_RootUser_Flag_Type_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Flag_Type_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};


export type Subscription_RootUser_FriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Friends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Friends_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Friends_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Received_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Received_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_Sent_Friend_Requests_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Sent_Friend_Requests_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


export type Subscription_RootUser_SettingsArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUser_Settings_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Settings_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Settings_Order_By>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUser_Settings_By_PkArgs = {
  user_id: Scalars['String']['input'];
};


export type Subscription_RootUser_Settings_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Settings_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};


export type Subscription_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['String']['input'];
};


export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Users_Stream_Cursor_Input>>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** columns and relationships of "taboo_set" */
export type Taboo_Set = {
  __typename?: 'taboo_set';
  active: Scalars['Boolean']['output'];
  card_count: Scalars['Int']['output'];
  /** An array relationship */
  cards: Array<All_Card>;
  /** An aggregate relationship */
  cards_aggregate: All_Card_Aggregate;
  code: Scalars['String']['output'];
  current: Scalars['Boolean']['output'];
  date: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "taboo_set" */
export type Taboo_SetCardsArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};


/** columns and relationships of "taboo_set" */
export type Taboo_SetCards_AggregateArgs = {
  distinct_on?: InputMaybe<Array<All_Card_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<All_Card_Order_By>>;
  where?: InputMaybe<All_Card_Bool_Exp>;
};

/** aggregated selection of "taboo_set" */
export type Taboo_Set_Aggregate = {
  __typename?: 'taboo_set_aggregate';
  aggregate?: Maybe<Taboo_Set_Aggregate_Fields>;
  nodes: Array<Taboo_Set>;
};

/** aggregate fields of "taboo_set" */
export type Taboo_Set_Aggregate_Fields = {
  __typename?: 'taboo_set_aggregate_fields';
  avg?: Maybe<Taboo_Set_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<Taboo_Set_Max_Fields>;
  min?: Maybe<Taboo_Set_Min_Fields>;
  stddev?: Maybe<Taboo_Set_Stddev_Fields>;
  stddev_pop?: Maybe<Taboo_Set_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Taboo_Set_Stddev_Samp_Fields>;
  sum?: Maybe<Taboo_Set_Sum_Fields>;
  var_pop?: Maybe<Taboo_Set_Var_Pop_Fields>;
  var_samp?: Maybe<Taboo_Set_Var_Samp_Fields>;
  variance?: Maybe<Taboo_Set_Variance_Fields>;
};


/** aggregate fields of "taboo_set" */
export type Taboo_Set_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Taboo_Set_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type Taboo_Set_Avg_Fields = {
  __typename?: 'taboo_set_avg_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "taboo_set". All fields are combined with a logical 'AND'. */
export type Taboo_Set_Bool_Exp = {
  _and?: InputMaybe<Array<Taboo_Set_Bool_Exp>>;
  _not?: InputMaybe<Taboo_Set_Bool_Exp>;
  _or?: InputMaybe<Array<Taboo_Set_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  card_count?: InputMaybe<Int_Comparison_Exp>;
  cards?: InputMaybe<All_Card_Bool_Exp>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  current?: InputMaybe<Boolean_Comparison_Exp>;
  date?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "taboo_set" */
export enum Taboo_Set_Constraint {
  /** unique or primary key constraint on columns "id" */
  TabooSetPkey = 'taboo_set_pkey'
}

/** input type for incrementing numeric columns in table "taboo_set" */
export type Taboo_Set_Inc_Input = {
  card_count?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "taboo_set" */
export type Taboo_Set_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  cards?: InputMaybe<All_Card_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type Taboo_Set_Max_Fields = {
  __typename?: 'taboo_set_max_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type Taboo_Set_Min_Fields = {
  __typename?: 'taboo_set_min_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  date?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "taboo_set" */
export type Taboo_Set_Mutation_Response = {
  __typename?: 'taboo_set_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Taboo_Set>;
};

/** input type for inserting object relation for remote table "taboo_set" */
export type Taboo_Set_Obj_Rel_Insert_Input = {
  data: Taboo_Set_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Taboo_Set_On_Conflict>;
};

/** on_conflict condition type for table "taboo_set" */
export type Taboo_Set_On_Conflict = {
  constraint: Taboo_Set_Constraint;
  update_columns?: Array<Taboo_Set_Update_Column>;
  where?: InputMaybe<Taboo_Set_Bool_Exp>;
};

/** Ordering options when selecting data from "taboo_set". */
export type Taboo_Set_Order_By = {
  active?: InputMaybe<Order_By>;
  card_count?: InputMaybe<Order_By>;
  cards_aggregate?: InputMaybe<All_Card_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  current?: InputMaybe<Order_By>;
  date?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: taboo_set */
export type Taboo_Set_Pk_Columns_Input = {
  id: Scalars['Int']['input'];
};

/** select columns of table "taboo_set" */
export enum Taboo_Set_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CardCount = 'card_count',
  /** column name */
  Code = 'code',
  /** column name */
  Current = 'current',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "taboo_set" */
export type Taboo_Set_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type Taboo_Set_Stddev_Fields = {
  __typename?: 'taboo_set_stddev_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type Taboo_Set_Stddev_Pop_Fields = {
  __typename?: 'taboo_set_stddev_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type Taboo_Set_Stddev_Samp_Fields = {
  __typename?: 'taboo_set_stddev_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "taboo_set" */
export type Taboo_Set_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Taboo_Set_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Taboo_Set_Stream_Cursor_Value_Input = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  card_count?: InputMaybe<Scalars['Int']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  current?: InputMaybe<Scalars['Boolean']['input']>;
  date?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type Taboo_Set_Sum_Fields = {
  __typename?: 'taboo_set_sum_fields';
  card_count?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** update columns of table "taboo_set" */
export enum Taboo_Set_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CardCount = 'card_count',
  /** column name */
  Code = 'code',
  /** column name */
  Current = 'current',
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

export type Taboo_Set_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<Taboo_Set_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Taboo_Set_Set_Input>;
  /** filter the rows which have to be updated */
  where: Taboo_Set_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Taboo_Set_Var_Pop_Fields = {
  __typename?: 'taboo_set_var_pop_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type Taboo_Set_Var_Samp_Fields = {
  __typename?: 'taboo_set_var_samp_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type Taboo_Set_Variance_Fields = {
  __typename?: 'taboo_set_variance_fields';
  card_count?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** columns and relationships of "user_campaigns" */
export type User_Campaigns = {
  __typename?: 'user_campaigns';
  /** An object relationship */
  campaign?: Maybe<Campaign>;
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_campaigns" */
export type User_Campaigns_Aggregate = {
  __typename?: 'user_campaigns_aggregate';
  aggregate?: Maybe<User_Campaigns_Aggregate_Fields>;
  nodes: Array<User_Campaigns>;
};

export type User_Campaigns_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Campaigns_Aggregate_Bool_Exp_Count>;
};

export type User_Campaigns_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Campaigns_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_campaigns" */
export type User_Campaigns_Aggregate_Fields = {
  __typename?: 'user_campaigns_aggregate_fields';
  avg?: Maybe<User_Campaigns_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<User_Campaigns_Max_Fields>;
  min?: Maybe<User_Campaigns_Min_Fields>;
  stddev?: Maybe<User_Campaigns_Stddev_Fields>;
  stddev_pop?: Maybe<User_Campaigns_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Campaigns_Stddev_Samp_Fields>;
  sum?: Maybe<User_Campaigns_Sum_Fields>;
  var_pop?: Maybe<User_Campaigns_Var_Pop_Fields>;
  var_samp?: Maybe<User_Campaigns_Var_Samp_Fields>;
  variance?: Maybe<User_Campaigns_Variance_Fields>;
};


/** aggregate fields of "user_campaigns" */
export type User_Campaigns_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_campaigns" */
export type User_Campaigns_Aggregate_Order_By = {
  avg?: InputMaybe<User_Campaigns_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Campaigns_Max_Order_By>;
  min?: InputMaybe<User_Campaigns_Min_Order_By>;
  stddev?: InputMaybe<User_Campaigns_Stddev_Order_By>;
  stddev_pop?: InputMaybe<User_Campaigns_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<User_Campaigns_Stddev_Samp_Order_By>;
  sum?: InputMaybe<User_Campaigns_Sum_Order_By>;
  var_pop?: InputMaybe<User_Campaigns_Var_Pop_Order_By>;
  var_samp?: InputMaybe<User_Campaigns_Var_Samp_Order_By>;
  variance?: InputMaybe<User_Campaigns_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_campaigns" */
export type User_Campaigns_Arr_Rel_Insert_Input = {
  data: Array<User_Campaigns_Insert_Input>;
};

/** aggregate avg on columns */
export type User_Campaigns_Avg_Fields = {
  __typename?: 'user_campaigns_avg_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "user_campaigns" */
export type User_Campaigns_Avg_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_campaigns". All fields are combined with a logical 'AND'. */
export type User_Campaigns_Bool_Exp = {
  _and?: InputMaybe<Array<User_Campaigns_Bool_Exp>>;
  _not?: InputMaybe<User_Campaigns_Bool_Exp>;
  _or?: InputMaybe<Array<User_Campaigns_Bool_Exp>>;
  campaign?: InputMaybe<Campaign_Bool_Exp>;
  campaign_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "user_campaigns" */
export type User_Campaigns_Inc_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "user_campaigns" */
export type User_Campaigns_Insert_Input = {
  campaign?: InputMaybe<Campaign_Obj_Rel_Insert_Input>;
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Campaigns_Max_Fields = {
  __typename?: 'user_campaigns_max_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_campaigns" */
export type User_Campaigns_Max_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Campaigns_Min_Fields = {
  __typename?: 'user_campaigns_min_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_campaigns" */
export type User_Campaigns_Min_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_campaigns" */
export type User_Campaigns_Mutation_Response = {
  __typename?: 'user_campaigns_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Campaigns>;
};

/** Ordering options when selecting data from "user_campaigns". */
export type User_Campaigns_Order_By = {
  campaign?: InputMaybe<Campaign_Order_By>;
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** select columns of table "user_campaigns" */
export enum User_Campaigns_Select_Column {
  /** column name */
  CampaignId = 'campaign_id',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_campaigns" */
export type User_Campaigns_Set_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate stddev on columns */
export type User_Campaigns_Stddev_Fields = {
  __typename?: 'user_campaigns_stddev_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Campaigns_Stddev_Pop_Fields = {
  __typename?: 'user_campaigns_stddev_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Campaigns_Stddev_Samp_Fields = {
  __typename?: 'user_campaigns_stddev_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "user_campaigns" */
export type User_Campaigns_Stddev_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "user_campaigns" */
export type User_Campaigns_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Campaigns_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Campaigns_Stream_Cursor_Value_Input = {
  campaign_id?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate sum on columns */
export type User_Campaigns_Sum_Fields = {
  __typename?: 'user_campaigns_sum_fields';
  campaign_id?: Maybe<Scalars['Int']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "user_campaigns" */
export type User_Campaigns_Sum_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

export type User_Campaigns_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<User_Campaigns_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Campaigns_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Campaigns_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Campaigns_Var_Pop_Fields = {
  __typename?: 'user_campaigns_var_pop_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "user_campaigns" */
export type User_Campaigns_Var_Pop_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Campaigns_Var_Samp_Fields = {
  __typename?: 'user_campaigns_var_samp_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "user_campaigns" */
export type User_Campaigns_Var_Samp_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Campaigns_Variance_Fields = {
  __typename?: 'user_campaigns_variance_fields';
  campaign_id?: Maybe<Scalars['Float']['output']>;
  id?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "user_campaigns" */
export type User_Campaigns_Variance_Order_By = {
  campaign_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
};

/** columns and relationships of "user_flag" */
export type User_Flag = {
  __typename?: 'user_flag';
  flag: User_Flag_Type_Enum;
  /** An object relationship */
  user: Users;
  user_id: Scalars['String']['output'];
};

/** aggregated selection of "user_flag" */
export type User_Flag_Aggregate = {
  __typename?: 'user_flag_aggregate';
  aggregate?: Maybe<User_Flag_Aggregate_Fields>;
  nodes: Array<User_Flag>;
};

export type User_Flag_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Flag_Aggregate_Bool_Exp_Count>;
};

export type User_Flag_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Flag_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Flag_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_flag" */
export type User_Flag_Aggregate_Fields = {
  __typename?: 'user_flag_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Flag_Max_Fields>;
  min?: Maybe<User_Flag_Min_Fields>;
};


/** aggregate fields of "user_flag" */
export type User_Flag_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Flag_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_flag" */
export type User_Flag_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Flag_Max_Order_By>;
  min?: InputMaybe<User_Flag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_flag" */
export type User_Flag_Arr_Rel_Insert_Input = {
  data: Array<User_Flag_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Flag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_flag". All fields are combined with a logical 'AND'. */
export type User_Flag_Bool_Exp = {
  _and?: InputMaybe<Array<User_Flag_Bool_Exp>>;
  _not?: InputMaybe<User_Flag_Bool_Exp>;
  _or?: InputMaybe<Array<User_Flag_Bool_Exp>>;
  flag?: InputMaybe<User_Flag_Type_Enum_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_flag" */
export enum User_Flag_Constraint {
  /** unique or primary key constraint on columns "user_id", "flag" */
  UserFlagPkey = 'user_flag_pkey'
}

/** input type for inserting data into table "user_flag" */
export type User_Flag_Insert_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Flag_Max_Fields = {
  __typename?: 'user_flag_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_flag" */
export type User_Flag_Max_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Flag_Min_Fields = {
  __typename?: 'user_flag_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_flag" */
export type User_Flag_Min_Order_By = {
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_flag" */
export type User_Flag_Mutation_Response = {
  __typename?: 'user_flag_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Flag>;
};

/** on_conflict condition type for table "user_flag" */
export type User_Flag_On_Conflict = {
  constraint: User_Flag_Constraint;
  update_columns?: Array<User_Flag_Update_Column>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};

/** Ordering options when selecting data from "user_flag". */
export type User_Flag_Order_By = {
  flag?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_flag */
export type User_Flag_Pk_Columns_Input = {
  flag: User_Flag_Type_Enum;
  user_id: Scalars['String']['input'];
};

/** select columns of table "user_flag" */
export enum User_Flag_Select_Column {
  /** column name */
  Flag = 'flag',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_flag" */
export type User_Flag_Set_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_flag" */
export type User_Flag_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Flag_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Flag_Stream_Cursor_Value_Input = {
  flag?: InputMaybe<User_Flag_Type_Enum>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "user_flag_type" */
export type User_Flag_Type = {
  __typename?: 'user_flag_type';
  value: Scalars['String']['output'];
};

/** aggregated selection of "user_flag_type" */
export type User_Flag_Type_Aggregate = {
  __typename?: 'user_flag_type_aggregate';
  aggregate?: Maybe<User_Flag_Type_Aggregate_Fields>;
  nodes: Array<User_Flag_Type>;
};

/** aggregate fields of "user_flag_type" */
export type User_Flag_Type_Aggregate_Fields = {
  __typename?: 'user_flag_type_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Flag_Type_Max_Fields>;
  min?: Maybe<User_Flag_Type_Min_Fields>;
};


/** aggregate fields of "user_flag_type" */
export type User_Flag_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Flag_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "user_flag_type". All fields are combined with a logical 'AND'. */
export type User_Flag_Type_Bool_Exp = {
  _and?: InputMaybe<Array<User_Flag_Type_Bool_Exp>>;
  _not?: InputMaybe<User_Flag_Type_Bool_Exp>;
  _or?: InputMaybe<Array<User_Flag_Type_Bool_Exp>>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_flag_type" */
export enum User_Flag_Type_Constraint {
  /** unique or primary key constraint on columns "value" */
  UserFlagTypePkey = 'user_flag_type_pkey'
}

export enum User_Flag_Type_Enum {
  Admin = 'admin',
  EsDv = 'es_dv',
  EsDvAdmin = 'es_dv_admin'
}

/** Boolean expression to compare columns of type "user_flag_type_enum". All fields are combined with logical 'AND'. */
export type User_Flag_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<User_Flag_Type_Enum>;
  _in?: InputMaybe<Array<User_Flag_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<User_Flag_Type_Enum>;
  _nin?: InputMaybe<Array<User_Flag_Type_Enum>>;
};

/** input type for inserting data into table "user_flag_type" */
export type User_Flag_Type_Insert_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Flag_Type_Max_Fields = {
  __typename?: 'user_flag_type_max_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type User_Flag_Type_Min_Fields = {
  __typename?: 'user_flag_type_min_fields';
  value?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "user_flag_type" */
export type User_Flag_Type_Mutation_Response = {
  __typename?: 'user_flag_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Flag_Type>;
};

/** on_conflict condition type for table "user_flag_type" */
export type User_Flag_Type_On_Conflict = {
  constraint: User_Flag_Type_Constraint;
  update_columns?: Array<User_Flag_Type_Update_Column>;
  where?: InputMaybe<User_Flag_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "user_flag_type". */
export type User_Flag_Type_Order_By = {
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_flag_type */
export type User_Flag_Type_Pk_Columns_Input = {
  value: Scalars['String']['input'];
};

/** select columns of table "user_flag_type" */
export enum User_Flag_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "user_flag_type" */
export type User_Flag_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_flag_type" */
export type User_Flag_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Flag_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Flag_Type_Stream_Cursor_Value_Input = {
  value?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "user_flag_type" */
export enum User_Flag_Type_Update_Column {
  /** column name */
  Value = 'value'
}

export type User_Flag_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Flag_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Flag_Type_Bool_Exp;
};

/** update columns of table "user_flag" */
export enum User_Flag_Update_Column {
  /** column name */
  Flag = 'flag',
  /** column name */
  UserId = 'user_id'
}

export type User_Flag_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Flag_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Flag_Bool_Exp;
};

/** columns and relationships of "user_friends" */
export type User_Friends = {
  __typename?: 'user_friends';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_friends" */
export type User_Friends_Aggregate = {
  __typename?: 'user_friends_aggregate';
  aggregate?: Maybe<User_Friends_Aggregate_Fields>;
  nodes: Array<User_Friends>;
};

export type User_Friends_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Friends_Aggregate_Bool_Exp_Count>;
};

export type User_Friends_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Friends_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_friends" */
export type User_Friends_Aggregate_Fields = {
  __typename?: 'user_friends_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Friends_Max_Fields>;
  min?: Maybe<User_Friends_Min_Fields>;
};


/** aggregate fields of "user_friends" */
export type User_Friends_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Friends_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_friends" */
export type User_Friends_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Friends_Max_Order_By>;
  min?: InputMaybe<User_Friends_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_friends" */
export type User_Friends_Arr_Rel_Insert_Input = {
  data: Array<User_Friends_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_friends". All fields are combined with a logical 'AND'. */
export type User_Friends_Bool_Exp = {
  _and?: InputMaybe<Array<User_Friends_Bool_Exp>>;
  _not?: InputMaybe<User_Friends_Bool_Exp>;
  _or?: InputMaybe<Array<User_Friends_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_friends" */
export type User_Friends_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Friends_Max_Fields = {
  __typename?: 'user_friends_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_friends" */
export type User_Friends_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Friends_Min_Fields = {
  __typename?: 'user_friends_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_friends" */
export type User_Friends_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_friends" */
export type User_Friends_Mutation_Response = {
  __typename?: 'user_friends_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Friends>;
};

/** Ordering options when selecting data from "user_friends". */
export type User_Friends_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_friends" */
export enum User_Friends_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_friends" */
export type User_Friends_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_friends" */
export type User_Friends_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Friends_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Friends_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Friends_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Friends_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Friends_Bool_Exp;
};

/** columns and relationships of "user_received_friend_requests" */
export type User_Received_Friend_Requests = {
  __typename?: 'user_received_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate = {
  __typename?: 'user_received_friend_requests_aggregate';
  aggregate?: Maybe<User_Received_Friend_Requests_Aggregate_Fields>;
  nodes: Array<User_Received_Friend_Requests>;
};

export type User_Received_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Received_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type User_Received_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_Fields = {
  __typename?: 'user_received_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Received_Friend_Requests_Max_Fields>;
  min?: Maybe<User_Received_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Received_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<User_Received_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<User_Received_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_received_friend_requests". All fields are combined with a logical 'AND'. */
export type User_Received_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<User_Received_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<User_Received_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Received_Friend_Requests_Max_Fields = {
  __typename?: 'user_received_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Received_Friend_Requests_Min_Fields = {
  __typename?: 'user_received_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Mutation_Response = {
  __typename?: 'user_received_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Received_Friend_Requests>;
};

/** Ordering options when selecting data from "user_received_friend_requests". */
export type User_Received_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_received_friend_requests" */
export enum User_Received_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_received_friend_requests" */
export type User_Received_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Received_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Received_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Received_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Received_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Received_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests = {
  __typename?: 'user_sent_friend_requests';
  status?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** aggregated selection of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate = {
  __typename?: 'user_sent_friend_requests_aggregate';
  aggregate?: Maybe<User_Sent_Friend_Requests_Aggregate_Fields>;
  nodes: Array<User_Sent_Friend_Requests>;
};

export type User_Sent_Friend_Requests_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count>;
};

export type User_Sent_Friend_Requests_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_Fields = {
  __typename?: 'user_sent_friend_requests_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Sent_Friend_Requests_Max_Fields>;
  min?: Maybe<User_Sent_Friend_Requests_Min_Fields>;
};


/** aggregate fields of "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Sent_Friend_Requests_Max_Order_By>;
  min?: InputMaybe<User_Sent_Friend_Requests_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Arr_Rel_Insert_Input = {
  data: Array<User_Sent_Friend_Requests_Insert_Input>;
};

/** Boolean expression to filter rows from the table "user_sent_friend_requests". All fields are combined with a logical 'AND'. */
export type User_Sent_Friend_Requests_Bool_Exp = {
  _and?: InputMaybe<Array<User_Sent_Friend_Requests_Bool_Exp>>;
  _not?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  _or?: InputMaybe<Array<User_Sent_Friend_Requests_Bool_Exp>>;
  status?: InputMaybe<String_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id_a?: InputMaybe<String_Comparison_Exp>;
  user_id_b?: InputMaybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Insert_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Sent_Friend_Requests_Max_Fields = {
  __typename?: 'user_sent_friend_requests_max_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Max_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Sent_Friend_Requests_Min_Fields = {
  __typename?: 'user_sent_friend_requests_min_fields';
  status?: Maybe<Scalars['String']['output']>;
  user_id_a?: Maybe<Scalars['String']['output']>;
  user_id_b?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Min_Order_By = {
  status?: InputMaybe<Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Mutation_Response = {
  __typename?: 'user_sent_friend_requests_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Sent_Friend_Requests>;
};

/** Ordering options when selecting data from "user_sent_friend_requests". */
export type User_Sent_Friend_Requests_Order_By = {
  status?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id_a?: InputMaybe<Order_By>;
  user_id_b?: InputMaybe<Order_By>;
};

/** select columns of table "user_sent_friend_requests" */
export enum User_Sent_Friend_Requests_Select_Column {
  /** column name */
  Status = 'status',
  /** column name */
  UserIdA = 'user_id_a',
  /** column name */
  UserIdB = 'user_id_b'
}

/** input type for updating data in table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Set_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_sent_friend_requests" */
export type User_Sent_Friend_Requests_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Sent_Friend_Requests_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Sent_Friend_Requests_Stream_Cursor_Value_Input = {
  status?: InputMaybe<Scalars['String']['input']>;
  user_id_a?: InputMaybe<Scalars['String']['input']>;
  user_id_b?: InputMaybe<Scalars['String']['input']>;
};

export type User_Sent_Friend_Requests_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Sent_Friend_Requests_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Sent_Friend_Requests_Bool_Exp;
};

/** columns and relationships of "user_settings" */
export type User_Settings = {
  __typename?: 'user_settings';
  alphabetize?: Maybe<Scalars['Boolean']['output']>;
  campaign_show_deck_id?: Maybe<Scalars['Boolean']['output']>;
  colorblind?: Maybe<Scalars['Boolean']['output']>;
  custom_content?: Maybe<Scalars['Boolean']['output']>;
  ignore_collection?: Maybe<Scalars['Boolean']['output']>;
  in_collection?: Maybe<Scalars['jsonb']['output']>;
  onboarding?: Maybe<Scalars['jsonb']['output']>;
  show_spoilers?: Maybe<Scalars['jsonb']['output']>;
  single_card?: Maybe<Scalars['Boolean']['output']>;
  sort_quotes?: Maybe<Scalars['Boolean']['output']>;
  user_id: Scalars['String']['output'];
};


/** columns and relationships of "user_settings" */
export type User_SettingsIn_CollectionArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "user_settings" */
export type User_SettingsOnboardingArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};


/** columns and relationships of "user_settings" */
export type User_SettingsShow_SpoilersArgs = {
  path?: InputMaybe<Scalars['String']['input']>;
};

/** aggregated selection of "user_settings" */
export type User_Settings_Aggregate = {
  __typename?: 'user_settings_aggregate';
  aggregate?: Maybe<User_Settings_Aggregate_Fields>;
  nodes: Array<User_Settings>;
};

/** aggregate fields of "user_settings" */
export type User_Settings_Aggregate_Fields = {
  __typename?: 'user_settings_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Settings_Max_Fields>;
  min?: Maybe<User_Settings_Min_Fields>;
};


/** aggregate fields of "user_settings" */
export type User_Settings_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Settings_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type User_Settings_Append_Input = {
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** Boolean expression to filter rows from the table "user_settings". All fields are combined with a logical 'AND'. */
export type User_Settings_Bool_Exp = {
  _and?: InputMaybe<Array<User_Settings_Bool_Exp>>;
  _not?: InputMaybe<User_Settings_Bool_Exp>;
  _or?: InputMaybe<Array<User_Settings_Bool_Exp>>;
  alphabetize?: InputMaybe<Boolean_Comparison_Exp>;
  campaign_show_deck_id?: InputMaybe<Boolean_Comparison_Exp>;
  colorblind?: InputMaybe<Boolean_Comparison_Exp>;
  custom_content?: InputMaybe<Boolean_Comparison_Exp>;
  ignore_collection?: InputMaybe<Boolean_Comparison_Exp>;
  in_collection?: InputMaybe<Jsonb_Comparison_Exp>;
  onboarding?: InputMaybe<Jsonb_Comparison_Exp>;
  show_spoilers?: InputMaybe<Jsonb_Comparison_Exp>;
  single_card?: InputMaybe<Boolean_Comparison_Exp>;
  sort_quotes?: InputMaybe<Boolean_Comparison_Exp>;
  user_id?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_settings" */
export enum User_Settings_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  UserSettingsPkey = 'user_settings_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type User_Settings_Delete_At_Path_Input = {
  in_collection?: InputMaybe<Array<Scalars['String']['input']>>;
  onboarding?: InputMaybe<Array<Scalars['String']['input']>>;
  show_spoilers?: InputMaybe<Array<Scalars['String']['input']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type User_Settings_Delete_Elem_Input = {
  in_collection?: InputMaybe<Scalars['Int']['input']>;
  onboarding?: InputMaybe<Scalars['Int']['input']>;
  show_spoilers?: InputMaybe<Scalars['Int']['input']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type User_Settings_Delete_Key_Input = {
  in_collection?: InputMaybe<Scalars['String']['input']>;
  onboarding?: InputMaybe<Scalars['String']['input']>;
  show_spoilers?: InputMaybe<Scalars['String']['input']>;
};

/** input type for inserting data into table "user_settings" */
export type User_Settings_Insert_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type User_Settings_Max_Fields = {
  __typename?: 'user_settings_max_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** aggregate min on columns */
export type User_Settings_Min_Fields = {
  __typename?: 'user_settings_min_fields';
  user_id?: Maybe<Scalars['String']['output']>;
};

/** response of any mutation on the table "user_settings" */
export type User_Settings_Mutation_Response = {
  __typename?: 'user_settings_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Settings>;
};

/** on_conflict condition type for table "user_settings" */
export type User_Settings_On_Conflict = {
  constraint: User_Settings_Constraint;
  update_columns?: Array<User_Settings_Update_Column>;
  where?: InputMaybe<User_Settings_Bool_Exp>;
};

/** Ordering options when selecting data from "user_settings". */
export type User_Settings_Order_By = {
  alphabetize?: InputMaybe<Order_By>;
  campaign_show_deck_id?: InputMaybe<Order_By>;
  colorblind?: InputMaybe<Order_By>;
  custom_content?: InputMaybe<Order_By>;
  ignore_collection?: InputMaybe<Order_By>;
  in_collection?: InputMaybe<Order_By>;
  onboarding?: InputMaybe<Order_By>;
  show_spoilers?: InputMaybe<Order_By>;
  single_card?: InputMaybe<Order_By>;
  sort_quotes?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_settings */
export type User_Settings_Pk_Columns_Input = {
  user_id: Scalars['String']['input'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type User_Settings_Prepend_Input = {
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
};

/** select columns of table "user_settings" */
export enum User_Settings_Select_Column {
  /** column name */
  Alphabetize = 'alphabetize',
  /** column name */
  CampaignShowDeckId = 'campaign_show_deck_id',
  /** column name */
  Colorblind = 'colorblind',
  /** column name */
  CustomContent = 'custom_content',
  /** column name */
  IgnoreCollection = 'ignore_collection',
  /** column name */
  InCollection = 'in_collection',
  /** column name */
  Onboarding = 'onboarding',
  /** column name */
  ShowSpoilers = 'show_spoilers',
  /** column name */
  SingleCard = 'single_card',
  /** column name */
  SortQuotes = 'sort_quotes',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "user_settings" */
export type User_Settings_Set_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "user_settings" */
export type User_Settings_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Settings_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Settings_Stream_Cursor_Value_Input = {
  alphabetize?: InputMaybe<Scalars['Boolean']['input']>;
  campaign_show_deck_id?: InputMaybe<Scalars['Boolean']['input']>;
  colorblind?: InputMaybe<Scalars['Boolean']['input']>;
  custom_content?: InputMaybe<Scalars['Boolean']['input']>;
  ignore_collection?: InputMaybe<Scalars['Boolean']['input']>;
  in_collection?: InputMaybe<Scalars['jsonb']['input']>;
  onboarding?: InputMaybe<Scalars['jsonb']['input']>;
  show_spoilers?: InputMaybe<Scalars['jsonb']['input']>;
  single_card?: InputMaybe<Scalars['Boolean']['input']>;
  sort_quotes?: InputMaybe<Scalars['Boolean']['input']>;
  user_id?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "user_settings" */
export enum User_Settings_Update_Column {
  /** column name */
  Alphabetize = 'alphabetize',
  /** column name */
  CampaignShowDeckId = 'campaign_show_deck_id',
  /** column name */
  Colorblind = 'colorblind',
  /** column name */
  CustomContent = 'custom_content',
  /** column name */
  IgnoreCollection = 'ignore_collection',
  /** column name */
  InCollection = 'in_collection',
  /** column name */
  Onboarding = 'onboarding',
  /** column name */
  ShowSpoilers = 'show_spoilers',
  /** column name */
  SingleCard = 'single_card',
  /** column name */
  SortQuotes = 'sort_quotes',
  /** column name */
  UserId = 'user_id'
}

export type User_Settings_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: InputMaybe<User_Settings_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: InputMaybe<User_Settings_Delete_At_Path_Input>;
  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
  _delete_elem?: InputMaybe<User_Settings_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: InputMaybe<User_Settings_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: InputMaybe<User_Settings_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Settings_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Settings_Bool_Exp;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  /** An array relationship */
  all_decks: Array<Campaign_Deck>;
  /** An aggregate relationship */
  all_decks_aggregate: Campaign_Deck_Aggregate;
  /** An array relationship */
  campaigns: Array<User_Campaigns>;
  /** An aggregate relationship */
  campaigns_aggregate: User_Campaigns_Aggregate;
  created_at: Scalars['timestamptz']['output'];
  /** An array relationship */
  decks: Array<Latest_Decks>;
  /** An aggregate relationship */
  decks_aggregate: Latest_Decks_Aggregate;
  /** An array relationship */
  flags: Array<User_Flag>;
  /** An aggregate relationship */
  flags_aggregate: User_Flag_Aggregate;
  /** An array relationship */
  friends: Array<User_Friends>;
  /** An aggregate relationship */
  friends_aggregate: User_Friends_Aggregate;
  handle?: Maybe<Scalars['String']['output']>;
  id: Scalars['String']['output'];
  /** An array relationship */
  local_decks: Array<Local_Decks>;
  /** An aggregate relationship */
  local_decks_aggregate: Local_Decks_Aggregate;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  received_requests: Array<User_Received_Friend_Requests>;
  /** An aggregate relationship */
  received_requests_aggregate: User_Received_Friend_Requests_Aggregate;
  /** An array relationship */
  sent_requests: Array<User_Sent_Friend_Requests>;
  /** An aggregate relationship */
  sent_requests_aggregate: User_Sent_Friend_Requests_Aggregate;
  updated_at: Scalars['timestamp']['output'];
};


/** columns and relationships of "users" */
export type UsersAll_DecksArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersAll_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Campaign_Deck_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Campaign_Deck_Order_By>>;
  where?: InputMaybe<Campaign_Deck_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersCampaignsArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersCampaigns_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Campaigns_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Campaigns_Order_By>>;
  where?: InputMaybe<User_Campaigns_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDecksArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersDecks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Latest_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Latest_Decks_Order_By>>;
  where?: InputMaybe<Latest_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFlagsArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFlags_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Flag_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Flag_Order_By>>;
  where?: InputMaybe<User_Flag_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFriendsArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersFriends_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Friends_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Friends_Order_By>>;
  where?: InputMaybe<User_Friends_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersLocal_DecksArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersLocal_Decks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Local_Decks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Local_Decks_Order_By>>;
  where?: InputMaybe<Local_Decks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersReceived_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersReceived_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Received_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Received_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersSent_RequestsArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersSent_Requests_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Sent_Friend_Requests_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Sent_Friend_Requests_Order_By>>;
  where?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: InputMaybe<Array<Users_Bool_Exp>>;
  _not?: InputMaybe<Users_Bool_Exp>;
  _or?: InputMaybe<Array<Users_Bool_Exp>>;
  all_decks?: InputMaybe<Campaign_Deck_Bool_Exp>;
  all_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Bool_Exp>;
  campaigns?: InputMaybe<User_Campaigns_Bool_Exp>;
  campaigns_aggregate?: InputMaybe<User_Campaigns_Aggregate_Bool_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  decks?: InputMaybe<Latest_Decks_Bool_Exp>;
  decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Bool_Exp>;
  flags?: InputMaybe<User_Flag_Bool_Exp>;
  flags_aggregate?: InputMaybe<User_Flag_Aggregate_Bool_Exp>;
  friends?: InputMaybe<User_Friends_Bool_Exp>;
  friends_aggregate?: InputMaybe<User_Friends_Aggregate_Bool_Exp>;
  handle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<String_Comparison_Exp>;
  local_decks?: InputMaybe<Local_Decks_Bool_Exp>;
  local_decks_aggregate?: InputMaybe<Local_Decks_Aggregate_Bool_Exp>;
  normalized_handle?: InputMaybe<String_Comparison_Exp>;
  received_requests?: InputMaybe<User_Received_Friend_Requests_Bool_Exp>;
  received_requests_aggregate?: InputMaybe<User_Received_Friend_Requests_Aggregate_Bool_Exp>;
  sent_requests?: InputMaybe<User_Sent_Friend_Requests_Bool_Exp>;
  sent_requests_aggregate?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Bool_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "normalized_handle" */
  UsersNormalizedHandleKey = 'users_normalized_handle_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey'
}

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  all_decks?: InputMaybe<Campaign_Deck_Arr_Rel_Insert_Input>;
  campaigns?: InputMaybe<User_Campaigns_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  decks?: InputMaybe<Latest_Decks_Arr_Rel_Insert_Input>;
  flags?: InputMaybe<User_Flag_Arr_Rel_Insert_Input>;
  friends?: InputMaybe<User_Friends_Arr_Rel_Insert_Input>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  local_decks?: InputMaybe<Local_Decks_Arr_Rel_Insert_Input>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  received_requests?: InputMaybe<User_Received_Friend_Requests_Arr_Rel_Insert_Input>;
  sent_requests?: InputMaybe<User_Sent_Friend_Requests_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']['output']>;
  handle?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['String']['output']>;
  normalized_handle?: Maybe<Scalars['String']['output']>;
  updated_at?: Maybe<Scalars['timestamp']['output']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  all_decks_aggregate?: InputMaybe<Campaign_Deck_Aggregate_Order_By>;
  campaigns_aggregate?: InputMaybe<User_Campaigns_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  decks_aggregate?: InputMaybe<Latest_Decks_Aggregate_Order_By>;
  flags_aggregate?: InputMaybe<User_Flag_Aggregate_Order_By>;
  friends_aggregate?: InputMaybe<User_Friends_Aggregate_Order_By>;
  handle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  local_decks_aggregate?: InputMaybe<Local_Decks_Aggregate_Order_By>;
  normalized_handle?: InputMaybe<Order_By>;
  received_requests_aggregate?: InputMaybe<User_Received_Friend_Requests_Aggregate_Order_By>;
  sent_requests_aggregate?: InputMaybe<User_Sent_Friend_Requests_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['String']['input'];
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']['input']>;
  handle?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['String']['input']>;
  normalized_handle?: InputMaybe<Scalars['String']['input']>;
  updated_at?: InputMaybe<Scalars['timestamp']['input']>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Handle = 'handle',
  /** column name */
  Id = 'id',
  /** column name */
  NormalizedHandle = 'normalized_handle',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Users_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

export type RefreshArkhamDbDecksMutationVariables = Exact<{
  force: Scalars['Boolean']['input'];
}>;


export type RefreshArkhamDbDecksMutation = { __typename?: 'mutation_root', refreshArkhamDbDecks?: { __typename?: 'RefreshDecksOutput', updated: boolean } | null };

export type GetArkhamDbDecksQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetArkhamDbDecksQuery = { __typename?: 'query_root', arkhamdb_deck: Array<{ __typename?: 'arkhamdb_deck', id: number, owner_id: string, slots: any, side_slots: any, meta: any, tags: any, archived?: boolean | null, investigator: string, name: string, created_at: any, updated_at: any, description: string, next_deck_id?: number | null, ignore_deck_limit_slots: any, deleted: boolean }> };

export type MigrateLoginMutationVariables = Exact<{
  accessToken: Scalars['String']['input'];
  refreshToken: Scalars['String']['input'];
}>;


export type MigrateLoginMutation = { __typename?: 'mutation_root', migrateLoginToArkhamDb?: { __typename?: 'MigrateLoginOutput', success: boolean } | null };

export type LoginMutationVariables = Exact<{
  code: Scalars['String']['input'];
  redirectUri: Scalars['String']['input'];
  state: Scalars['String']['input'];
}>;


export type LoginMutation = { __typename?: 'mutation_root', loginToArkhamDb?: { __typename?: 'LoginOutput', success: boolean } | null };

export type LogoutMutationVariables = Exact<{ [key: string]: never; }>;


export type LogoutMutation = { __typename?: 'mutation_root', logoutFromArkhamDb?: { __typename?: 'LogoutOutput', success: boolean } | null };

export type CreateArkhamDbDeckMutationVariables = Exact<{
  investigator: Scalars['String']['input'];
  name: Scalars['String']['input'];
  slots: Scalars['jsonb']['input'];
  ignoreDeckLimitSlots: Scalars['jsonb']['input'];
  problem?: InputMaybe<Scalars['String']['input']>;
  tabooSetId?: InputMaybe<Scalars['Int']['input']>;
  meta?: InputMaybe<Scalars['jsonb']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  tags?: InputMaybe<Scalars['String']['input']>;
}>;


export type CreateArkhamDbDeckMutation = { __typename?: 'mutation_root', createArkhamDbDeck?: { __typename?: 'CreateDeckOutput', deckId: string } | null };

export type UpgradeArkhamDbDeckMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
  xp: Scalars['Int']['input'];
  exiles?: InputMaybe<Scalars['jsonb']['input']>;
}>;


export type UpgradeArkhamDbDeckMutation = { __typename?: 'mutation_root', upgradeArkhamDbDeck?: { __typename?: 'UpgradeDeckOutput', deckId: number, upgradedDeckId: number } | null };

export type ApiDeleteArkhamDbDeckMutationVariables = Exact<{
  deckId: Scalars['Int']['input'];
  deleteAllVersions: Scalars['Boolean']['input'];
}>;


export type ApiDeleteArkhamDbDeckMutation = { __typename?: 'mutation_root', apiDeleteArkhamDbDeck?: { __typename?: 'DeleteDeckOutput', success: boolean } | null };

export type GetCardsCacheQueryVariables = Exact<{
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
}>;


export type GetCardsCacheQuery = { __typename?: 'query_root', all_card_updated: Array<{ __typename?: 'all_card_updated_by_version', translation_updated_at: any, cards_updated_at: any, card_count: number }> };

export type GetTranslationDataQueryVariables = Exact<{
  locale: Scalars['String']['input'];
}>;


export type GetTranslationDataQuery = { __typename?: 'query_root', faction_name: Array<{ __typename?: 'faction_name', code: string, name: string }>, card_type_name: Array<{ __typename?: 'card_type_name', code: Card_Type_Code_Enum, name: string }>, card_subtype_name: Array<{ __typename?: 'card_subtype_name', code: string, name: string }>, card_encounter_set: Array<{ __typename?: 'card_encounter_set', code: string, name: string }>, cycle: Array<{ __typename?: 'cycle', code: string, real_name: string, position: number, official: boolean, translations: Array<{ __typename?: 'cycle_name', name: string }>, packs: Array<{ __typename?: 'pack', code: string, cycle_code: string, real_name: string, position: number, official: boolean, translations: Array<{ __typename?: 'pack_name', name: string }> }> }> };

export type GetPlayerCardsQueryVariables = Exact<{
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
}>;


export type GetPlayerCardsQuery = { __typename?: 'query_root', all_card: Array<{ __typename?: 'all_card', id: string, code: string, cost?: number | null, clues?: number | null, doom?: number | null, stage?: number | null, illustrator?: string | null, double_sided?: boolean | null, deck_limit?: number | null, encounter_code?: string | null, encounter_position?: number | null, exceptional?: boolean | null, exile?: boolean | null, faction_code: string, health?: number | null, health_per_investigator?: boolean | null, is_unique?: boolean | null, myriad?: boolean | null, pack_code: string, pack_position: number, permanent?: boolean | null, position: number, quantity: number, real_flavor?: string | null, real_name: string, real_pack_name: string, real_slot?: string | null, real_subname?: string | null, real_text?: string | null, real_traits?: string | null, real_back_name?: string | null, real_back_text?: string | null, real_back_flavor?: string | null, real_encounter_set_name?: string | null, sanity?: number | null, skill_agility?: number | null, skill_combat?: number | null, skill_intellect?: number | null, skill_willpower?: number | null, skill_wild?: number | null, subtype_code?: string | null, type_code: Card_Type_Code_Enum, victory?: number | null, shroud?: number | null, back_link_id?: string | null, enemy_horror?: number | null, enemy_damage?: number | null, enemy_evade?: number | null, enemy_fight?: number | null, hidden?: boolean | null, deck_options?: any | null, deck_requirements?: any | null, side_deck_options?: any | null, side_deck_requirements?: any | null, restrictions?: any | null, imageurl?: string | null, backimageurl?: string | null, faction2_code?: string | null, faction3_code?: string | null, xp?: number | null, version: number, alternate_required_code?: string | null, clues_fixed?: boolean | null, errata_date?: string | null, alternate_of_code?: string | null, duplicate_of_code?: string | null, spoiler?: boolean | null, vengeance?: number | null, customization_options?: any | null, taboo_set_id?: number | null, taboo_xp?: number | null, real_customization_text?: string | null, real_customization_change?: string | null, real_taboo_text_change?: string | null, real_taboo_original_text?: string | null, real_taboo_original_back_text?: string | null, preview?: boolean | null, official: boolean, taboo_placeholder?: boolean | null, gender?: Gender_Enum | null, alt_art_investigator?: boolean | null, tags?: any | null, translations: Array<{ __typename?: 'all_card_text', flavor?: string | null, name: string, slot?: string | null, subname?: string | null, text?: string | null, traits?: string | null, back_flavor?: string | null, back_text?: string | null, back_name?: string | null, customization_change?: string | null, customization_text?: string | null, taboo_text_change?: string | null, taboo_original_text?: string | null, taboo_original_back_text?: string | null }>, linked_card?: { __typename?: 'all_card', id: string, code: string, cost?: number | null, clues?: number | null, doom?: number | null, stage?: number | null, illustrator?: string | null, double_sided?: boolean | null, deck_limit?: number | null, encounter_code?: string | null, encounter_position?: number | null, exceptional?: boolean | null, exile?: boolean | null, faction_code: string, health?: number | null, health_per_investigator?: boolean | null, is_unique?: boolean | null, myriad?: boolean | null, pack_code: string, pack_position: number, permanent?: boolean | null, position: number, quantity: number, real_flavor?: string | null, real_name: string, real_pack_name: string, real_slot?: string | null, real_subname?: string | null, real_text?: string | null, real_traits?: string | null, real_back_name?: string | null, real_back_text?: string | null, real_back_flavor?: string | null, real_encounter_set_name?: string | null, sanity?: number | null, skill_agility?: number | null, skill_combat?: number | null, skill_intellect?: number | null, skill_willpower?: number | null, skill_wild?: number | null, subtype_code?: string | null, type_code: Card_Type_Code_Enum, victory?: number | null, shroud?: number | null, back_link_id?: string | null, enemy_horror?: number | null, enemy_damage?: number | null, enemy_evade?: number | null, enemy_fight?: number | null, hidden?: boolean | null, deck_options?: any | null, deck_requirements?: any | null, side_deck_options?: any | null, side_deck_requirements?: any | null, restrictions?: any | null, imageurl?: string | null, backimageurl?: string | null, faction2_code?: string | null, faction3_code?: string | null, xp?: number | null, version: number, alternate_required_code?: string | null, clues_fixed?: boolean | null, errata_date?: string | null, alternate_of_code?: string | null, duplicate_of_code?: string | null, spoiler?: boolean | null, vengeance?: number | null, customization_options?: any | null, taboo_set_id?: number | null, taboo_xp?: number | null, real_customization_text?: string | null, real_customization_change?: string | null, real_taboo_text_change?: string | null, real_taboo_original_text?: string | null, real_taboo_original_back_text?: string | null, preview?: boolean | null, official: boolean, taboo_placeholder?: boolean | null, gender?: Gender_Enum | null, alt_art_investigator?: boolean | null, tags?: any | null, translations: Array<{ __typename?: 'all_card_text', flavor?: string | null, name: string, slot?: string | null, subname?: string | null, text?: string | null, traits?: string | null, back_flavor?: string | null, back_text?: string | null, back_name?: string | null, customization_change?: string | null, customization_text?: string | null, taboo_text_change?: string | null, taboo_original_text?: string | null, taboo_original_back_text?: string | null }> } | null }>, all_card_updated: Array<{ __typename?: 'all_card_updated_by_version', translation_updated_at: any, cards_updated_at: any, card_count: number }>, taboo_set: Array<{ __typename?: 'taboo_set', id: number, name?: string | null, code: string, active: boolean, date: string, card_count: number, current: boolean }> };

export type GetEncounterCardsQueryVariables = Exact<{
  locale: Scalars['String']['input'];
  version: Scalars['Int']['input'];
}>;


export type GetEncounterCardsQuery = { __typename?: 'query_root', all_card: Array<{ __typename?: 'all_card', id: string, code: string, cost?: number | null, clues?: number | null, doom?: number | null, stage?: number | null, illustrator?: string | null, double_sided?: boolean | null, deck_limit?: number | null, encounter_code?: string | null, encounter_position?: number | null, exceptional?: boolean | null, exile?: boolean | null, faction_code: string, health?: number | null, health_per_investigator?: boolean | null, is_unique?: boolean | null, myriad?: boolean | null, pack_code: string, pack_position: number, permanent?: boolean | null, position: number, quantity: number, real_flavor?: string | null, real_name: string, real_pack_name: string, real_slot?: string | null, real_subname?: string | null, real_text?: string | null, real_traits?: string | null, real_back_name?: string | null, real_back_text?: string | null, real_back_flavor?: string | null, real_encounter_set_name?: string | null, sanity?: number | null, skill_agility?: number | null, skill_combat?: number | null, skill_intellect?: number | null, skill_willpower?: number | null, skill_wild?: number | null, subtype_code?: string | null, type_code: Card_Type_Code_Enum, victory?: number | null, shroud?: number | null, back_link_id?: string | null, enemy_horror?: number | null, enemy_damage?: number | null, enemy_evade?: number | null, enemy_fight?: number | null, hidden?: boolean | null, deck_options?: any | null, deck_requirements?: any | null, side_deck_options?: any | null, side_deck_requirements?: any | null, restrictions?: any | null, imageurl?: string | null, backimageurl?: string | null, faction2_code?: string | null, faction3_code?: string | null, xp?: number | null, version: number, alternate_required_code?: string | null, clues_fixed?: boolean | null, errata_date?: string | null, alternate_of_code?: string | null, duplicate_of_code?: string | null, spoiler?: boolean | null, vengeance?: number | null, customization_options?: any | null, taboo_set_id?: number | null, taboo_xp?: number | null, real_customization_text?: string | null, real_customization_change?: string | null, real_taboo_text_change?: string | null, real_taboo_original_text?: string | null, real_taboo_original_back_text?: string | null, preview?: boolean | null, official: boolean, taboo_placeholder?: boolean | null, gender?: Gender_Enum | null, alt_art_investigator?: boolean | null, tags?: any | null, translations: Array<{ __typename?: 'all_card_text', flavor?: string | null, name: string, slot?: string | null, subname?: string | null, text?: string | null, traits?: string | null, back_flavor?: string | null, back_text?: string | null, back_name?: string | null, customization_change?: string | null, customization_text?: string | null, taboo_text_change?: string | null, taboo_original_text?: string | null, taboo_original_back_text?: string | null }>, linked_card?: { __typename?: 'all_card', id: string, code: string, cost?: number | null, clues?: number | null, doom?: number | null, stage?: number | null, illustrator?: string | null, double_sided?: boolean | null, deck_limit?: number | null, encounter_code?: string | null, encounter_position?: number | null, exceptional?: boolean | null, exile?: boolean | null, faction_code: string, health?: number | null, health_per_investigator?: boolean | null, is_unique?: boolean | null, myriad?: boolean | null, pack_code: string, pack_position: number, permanent?: boolean | null, position: number, quantity: number, real_flavor?: string | null, real_name: string, real_pack_name: string, real_slot?: string | null, real_subname?: string | null, real_text?: string | null, real_traits?: string | null, real_back_name?: string | null, real_back_text?: string | null, real_back_flavor?: string | null, real_encounter_set_name?: string | null, sanity?: number | null, skill_agility?: number | null, skill_combat?: number | null, skill_intellect?: number | null, skill_willpower?: number | null, skill_wild?: number | null, subtype_code?: string | null, type_code: Card_Type_Code_Enum, victory?: number | null, shroud?: number | null, back_link_id?: string | null, enemy_horror?: number | null, enemy_damage?: number | null, enemy_evade?: number | null, enemy_fight?: number | null, hidden?: boolean | null, deck_options?: any | null, deck_requirements?: any | null, side_deck_options?: any | null, side_deck_requirements?: any | null, restrictions?: any | null, imageurl?: string | null, backimageurl?: string | null, faction2_code?: string | null, faction3_code?: string | null, xp?: number | null, version: number, alternate_required_code?: string | null, clues_fixed?: boolean | null, errata_date?: string | null, alternate_of_code?: string | null, duplicate_of_code?: string | null, spoiler?: boolean | null, vengeance?: number | null, customization_options?: any | null, taboo_set_id?: number | null, taboo_xp?: number | null, real_customization_text?: string | null, real_customization_change?: string | null, real_taboo_text_change?: string | null, real_taboo_original_text?: string | null, real_taboo_original_back_text?: string | null, preview?: boolean | null, official: boolean, taboo_placeholder?: boolean | null, gender?: Gender_Enum | null, alt_art_investigator?: boolean | null, tags?: any | null, translations: Array<{ __typename?: 'all_card_text', flavor?: string | null, name: string, slot?: string | null, subname?: string | null, text?: string | null, traits?: string | null, back_flavor?: string | null, back_text?: string | null, back_name?: string | null, customization_change?: string | null, customization_text?: string | null, taboo_text_change?: string | null, taboo_original_text?: string | null, taboo_original_back_text?: string | null }> } | null }>, all_card_updated: Array<{ __typename?: 'all_card_updated_by_version', translation_updated_at: any, cards_updated_at: any, card_count: number }> };

export type GetCardFaqQueryVariables = Exact<{
  code: Scalars['String']['input'];
  locale: Scalars['String']['input'];
}>;


export type GetCardFaqQuery = { __typename?: 'query_root', faq_by_pk?: { __typename?: 'faq', code: string, text: string, faq_texts: Array<{ __typename?: 'faq_text', code: string, locale: string, text: string }> } | null };

export type UploadChaosBagResultsMutationVariables = Exact<{
  id: Scalars['Int']['input'];
  bless: Scalars['Int']['input'];
  curse: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
  sealed: Scalars['jsonb']['input'];
  totalDrawn: Scalars['Int']['input'];
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
}>;


export type UploadChaosBagResultsMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number, drawn: any, sealed: any, totalDrawn?: number | null, tarot?: Chaos_Bag_Tarot_Mode_Enum | null, difficulty?: Campaign_Difficulty_Enum | null, history: any } | null };

export type ChaosBagClearTokensMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  bless: Scalars['Int']['input'];
  curse: Scalars['Int']['input'];
}>;


export type ChaosBagClearTokensMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, drawn: any, bless: number, curse: number } | null };

export type ChaosBagDrawTokenMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
  history: Scalars['jsonb']['input'];
}>;


export type ChaosBagDrawTokenMutation = { __typename?: 'mutation_root', remove_elem?: { __typename?: 'chaos_bag_result', id: number } | null, update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, drawn: any, totalDrawn?: number | null, history: any } | null };

export type UpdateChaosBagDrawTokenMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
  history: Scalars['jsonb']['input'];
}>;


export type UpdateChaosBagDrawTokenMutation = { __typename?: 'mutation_root', remove_elem?: { __typename?: 'chaos_bag_result', id: number } | null, update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, drawn: any, totalDrawn?: number | null, history: any } | null };

export type ReturnChaosBagTokensWithBlurseMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
  bless: Scalars['Int']['input'];
  curse: Scalars['Int']['input'];
}>;


export type ReturnChaosBagTokensWithBlurseMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, drawn: any, totalDrawn?: number | null, bless: number, curse: number } | null };

export type ReturnChaosBagTokensMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
}>;


export type ReturnChaosBagTokensMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, drawn: any, totalDrawn?: number | null } | null };

export type ChaosBagResetBlessCurseMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  drawn: Scalars['jsonb']['input'];
  sealed: Scalars['jsonb']['input'];
}>;


export type ChaosBagResetBlessCurseMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number, drawn: any, sealed: any } | null };

export type ChaosBagSealTokensMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  sealed: Scalars['jsonb']['input'];
}>;


export type ChaosBagSealTokensMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, sealed: any } | null };

export type ChaosBagSetBlessCurseMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  bless: Scalars['Int']['input'];
  curse: Scalars['Int']['input'];
}>;


export type ChaosBagSetBlessCurseMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number } | null };

export type ChaosBagSetTarotMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  tarot?: InputMaybe<Chaos_Bag_Tarot_Mode_Enum>;
}>;


export type ChaosBagSetTarotMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, tarot?: Chaos_Bag_Tarot_Mode_Enum | null } | null };

export type ChaosBagSetDifficultyMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  difficulty?: InputMaybe<Campaign_Difficulty_Enum>;
}>;


export type ChaosBagSetDifficultyMutation = { __typename?: 'mutation_root', update_chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, difficulty?: Campaign_Difficulty_Enum | null } | null };

export type CreateCampaignMutationVariables = Exact<{
  campaignId: Scalars['String']['input'];
  linked?: InputMaybe<LinkedCampaignId>;
  guided?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type CreateCampaignMutation = { __typename?: 'mutation_root', createCampaign?: { __typename?: 'CreateCampaignOutput', campaignId: number, campaignIdA?: number | null, campaignIdB?: number | null } | null };

export type UploadLocalCampaignDeckMutationVariables = Exact<{
  localDeckId: Scalars['String']['input'];
  arkhamDbId: Scalars['Int']['input'];
}>;


export type UploadLocalCampaignDeckMutation = { __typename?: 'mutation_root', uploadLocalCampaignDeck?: { __typename?: 'UploadLocalCampaignDeckOutput', deckIds: Array<{ __typename?: 'DeckId', id: number, campaignId: number }> } | null };

export type UploadNewCampaignMutationVariables = Exact<{
  campaignId: Scalars['Int']['input'];
  cycleCode: Scalars['String']['input'];
  standaloneId?: InputMaybe<Scalars['jsonb']['input']>;
  showInterludes?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  difficulty?: InputMaybe<Scalars['String']['input']>;
  campaignNotes?: InputMaybe<Scalars['jsonb']['input']>;
  scenarioResults?: InputMaybe<Scalars['jsonb']['input']>;
  chaosBag?: InputMaybe<Scalars['jsonb']['input']>;
  weaknessSet?: InputMaybe<Scalars['jsonb']['input']>;
  tarotReading?: InputMaybe<Scalars['jsonb']['input']>;
  guideVersion?: InputMaybe<Scalars['Int']['input']>;
  inputs: Array<Guide_Input_Insert_Input> | Guide_Input_Insert_Input;
  achievements: Array<Guide_Achievement_Insert_Input> | Guide_Achievement_Insert_Input;
  investigator_data: Array<Investigator_Data_Insert_Input> | Investigator_Data_Insert_Input;
  investigators: Array<Campaign_Investigator_Insert_Input> | Campaign_Investigator_Insert_Input;
}>;


export type UploadNewCampaignMutation = { __typename?: 'mutation_root', insert_guide_input?: { __typename?: 'guide_input_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'guide_input', id: string, campaign_id: number, scenario?: string | null, step?: string | null, payload?: any | null, created_at: any, inserted_idx?: number | null }> } | null, insert_guide_achievement?: { __typename?: 'guide_achievement_mutation_response', affected_rows: number } | null, insert_investigator_data?: { __typename?: 'investigator_data_mutation_response', affected_rows: number } | null, insert_campaign_investigator?: { __typename?: 'campaign_investigator_mutation_response', affected_rows: number } | null, update_campaign_by_pk?: { __typename?: 'campaign', id: number, updated_at: any, uuid: string, name?: string | null, deleted?: boolean | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, campaignNotes?: any | null, chaosBag?: any | null, showInterludes?: boolean | null, scenarioResults?: any | null, weaknessSet?: any | null, guided?: boolean | null, guide_version?: number | null, tarot_reading?: any | null, archived?: boolean | null, owner_id: string, link_a_campaign?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> } | null, link_b_campaign?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> } | null, campaign_guide?: { __typename?: 'campaign_guide', id?: number | null, uuid?: string | null, updated_at?: any | null, guide_inputs: Array<{ __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null }>, guide_achievements: Array<{ __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null }> } | null, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', spentXp?: number | null, addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }>, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }>, linked_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null } | null };

export type InsertNewDeckMutationVariables = Exact<{
  arkhamdb_id?: InputMaybe<Scalars['Int']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  content: Scalars['jsonb']['input'];
  content_hash: Scalars['String']['input'];
  userId: Scalars['String']['input'];
}>;


export type InsertNewDeckMutation = { __typename?: 'mutation_root', insert_campaign_deck_one?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null };

export type InsertNextLocalDeckMutationVariables = Exact<{
  previous_local_uuid?: InputMaybe<Scalars['String']['input']>;
  local_uuid?: InputMaybe<Scalars['String']['input']>;
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  content: Scalars['jsonb']['input'];
  content_hash: Scalars['String']['input'];
  userId: Scalars['String']['input'];
}>;


export type InsertNextLocalDeckMutation = { __typename?: 'mutation_root', insert_campaign_deck_one?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null };

export type InsertNextArkhamDbDeckMutationVariables = Exact<{
  previous_arkhamdb_id: Scalars['Int']['input'];
  arkhamdb_id: Scalars['Int']['input'];
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  content: Scalars['jsonb']['input'];
  content_hash: Scalars['String']['input'];
  userId: Scalars['String']['input'];
}>;


export type InsertNextArkhamDbDeckMutation = { __typename?: 'mutation_root', insert_campaign_deck_one?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null };

export type UpdateArkhamDbDeckMutationVariables = Exact<{
  arkhamdb_id: Scalars['Int']['input'];
  campaign_id: Scalars['Int']['input'];
  content: Scalars['jsonb']['input'];
  content_hash: Scalars['String']['input'];
  arkhamdb_user?: InputMaybe<Scalars['Int']['input']>;
}>;


export type UpdateArkhamDbDeckMutation = { __typename?: 'mutation_root', update_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', content?: any | null, content_hash?: string | null, arkhamdb_user?: number | null, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number }> } | null };

export type UpdateLocalDeckMutationVariables = Exact<{
  local_uuid: Scalars['String']['input'];
  campaign_id: Scalars['Int']['input'];
  content: Scalars['jsonb']['input'];
  content_hash: Scalars['String']['input'];
}>;


export type UpdateLocalDeckMutation = { __typename?: 'mutation_root', update_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', content?: any | null, content_hash?: string | null, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number }> } | null };

export type DeleteAllLocalDecksMutationVariables = Exact<{
  local_uuid: Scalars['String']['input'];
  campaign_id: Scalars['Int']['input'];
}>;


export type DeleteAllLocalDecksMutation = { __typename?: 'mutation_root', delete_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number }> } | null };

export type DeleteAllArkhamDbDecksMutationVariables = Exact<{
  arkhamdb_id: Scalars['Int']['input'];
  campaign_id: Scalars['Int']['input'];
}>;


export type DeleteAllArkhamDbDecksMutation = { __typename?: 'mutation_root', delete_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number }> } | null };

export type DeleteLocalDeckMutationVariables = Exact<{
  local_uuid: Scalars['String']['input'];
  campaign_id: Scalars['Int']['input'];
}>;


export type DeleteLocalDeckMutation = { __typename?: 'mutation_root', update_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', returning: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> } | null, delete_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }> } | null };

export type DeleteArkhamDbDeckMutationVariables = Exact<{
  arkhamdb_id: Scalars['Int']['input'];
  campaign_id: Scalars['Int']['input'];
}>;


export type DeleteArkhamDbDeckMutation = { __typename?: 'mutation_root', update_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', returning: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> } | null, delete_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }> } | null };

export type GetMyDecksQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetMyDecksQuery = { __typename?: 'query_root', users_by_pk?: { __typename?: 'users', id: string, decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }>, all_decks: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, campaign: { __typename?: 'campaign', id: number, uuid: string }, next_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> } | null };

export type GetLatestLocalDeckQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  local_uuid: Scalars['String']['input'];
}>;


export type GetLatestLocalDeckQuery = { __typename?: 'query_root', campaign_deck: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> };

export type GetLatestArkhamDbDeckQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  arkhamdb_id: Scalars['Int']['input'];
}>;


export type GetLatestArkhamDbDeckQuery = { __typename?: 'query_root', campaign_deck: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> };

export type GetLatestDeckQueryVariables = Exact<{
  deckId: Scalars['Int']['input'];
}>;


export type GetLatestDeckQuery = { __typename?: 'query_root', campaign_deck_by_pk?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null };

export type GetDeckHistoryQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
}>;


export type GetDeckHistoryQuery = { __typename?: 'query_root', campaign_deck: Array<{ __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, next_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }> };

export type TabooSetFragment = { __typename?: 'taboo_set', id: number, name?: string | null, code: string, active: boolean, date: string, card_count: number, current: boolean };

export type EncounterSetFragment = { __typename?: 'card_encounter_set', code: string, name: string };

export type PackFragment = { __typename?: 'pack', code: string, cycle_code: string, real_name: string, position: number, official: boolean };

export type CycleFragment = { __typename?: 'cycle', code: string, real_name: string, position: number, official: boolean };

export type SingleCardFragment = { __typename?: 'all_card', id: string, code: string, cost?: number | null, clues?: number | null, doom?: number | null, stage?: number | null, illustrator?: string | null, double_sided?: boolean | null, deck_limit?: number | null, encounter_code?: string | null, encounter_position?: number | null, exceptional?: boolean | null, exile?: boolean | null, faction_code: string, health?: number | null, health_per_investigator?: boolean | null, is_unique?: boolean | null, myriad?: boolean | null, pack_code: string, pack_position: number, permanent?: boolean | null, position: number, quantity: number, real_flavor?: string | null, real_name: string, real_pack_name: string, real_slot?: string | null, real_subname?: string | null, real_text?: string | null, real_traits?: string | null, real_back_name?: string | null, real_back_text?: string | null, real_back_flavor?: string | null, real_encounter_set_name?: string | null, sanity?: number | null, skill_agility?: number | null, skill_combat?: number | null, skill_intellect?: number | null, skill_willpower?: number | null, skill_wild?: number | null, subtype_code?: string | null, type_code: Card_Type_Code_Enum, victory?: number | null, shroud?: number | null, back_link_id?: string | null, enemy_horror?: number | null, enemy_damage?: number | null, enemy_evade?: number | null, enemy_fight?: number | null, hidden?: boolean | null, deck_options?: any | null, deck_requirements?: any | null, side_deck_options?: any | null, side_deck_requirements?: any | null, restrictions?: any | null, imageurl?: string | null, backimageurl?: string | null, faction2_code?: string | null, faction3_code?: string | null, xp?: number | null, version: number, alternate_required_code?: string | null, clues_fixed?: boolean | null, errata_date?: string | null, alternate_of_code?: string | null, duplicate_of_code?: string | null, spoiler?: boolean | null, vengeance?: number | null, customization_options?: any | null, taboo_set_id?: number | null, taboo_xp?: number | null, real_customization_text?: string | null, real_customization_change?: string | null, real_taboo_text_change?: string | null, real_taboo_original_text?: string | null, real_taboo_original_back_text?: string | null, preview?: boolean | null, official: boolean, taboo_placeholder?: boolean | null, gender?: Gender_Enum | null, alt_art_investigator?: boolean | null, tags?: any | null };

export type CoreCardTextFragment = { __typename?: 'all_card_text', flavor?: string | null, name: string, slot?: string | null, subname?: string | null, text?: string | null, traits?: string | null, back_flavor?: string | null, back_text?: string | null, back_name?: string | null, customization_change?: string | null, customization_text?: string | null, taboo_text_change?: string | null, taboo_original_text?: string | null, taboo_original_back_text?: string | null };

export type UserInfoFragment = { __typename?: 'users', id: string, handle?: string | null };

export type GuideInputFragment = { __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null };

export type GuideAchievementFragment = { __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null };

export type IdDeckFragment = { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number };

export type FullChaosBagResultFragment = { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number, drawn: any, sealed: any, totalDrawn?: number | null, tarot?: Chaos_Bag_Tarot_Mode_Enum | null, difficulty?: Campaign_Difficulty_Enum | null, history: any };

export type MiniDeckFragment = { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number };

export type BasicDeckFragment = { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number };

export type AllDeckFragment = { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, campaign: { __typename?: 'campaign', id: number, uuid: string }, next_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null };

export type HistoryDeckFragment = { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, next_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null, previous_deck?: { __typename?: 'campaign_deck', id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null };

export type LatestDeckFragment = { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null };

export type MiniInvestigatorDataFragment = { __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null };

export type FullGuideInvestigatorDataFragment = { __typename?: 'investigator_data', addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null };

export type FullInvestigatorDataFragment = { __typename?: 'investigator_data', spentXp?: number | null, addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null };

export type MiniCampaignFragment = { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> };

export type FullCampaignFragment = { __typename?: 'campaign', id: number, updated_at: any, uuid: string, name?: string | null, deleted?: boolean | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, campaignNotes?: any | null, chaosBag?: any | null, showInterludes?: boolean | null, scenarioResults?: any | null, weaknessSet?: any | null, guided?: boolean | null, guide_version?: number | null, tarot_reading?: any | null, archived?: boolean | null, owner_id: string, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', spentXp?: number | null, addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }>, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }>, link_a_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, link_b_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, linked_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null };

export type FullCampaignGuideStateFragment = { __typename?: 'campaign_guide', id?: number | null, uuid?: string | null, updated_at?: any | null, guide_inputs: Array<{ __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null }>, guide_achievements: Array<{ __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null }> };

export type GetMyCampaignsQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetMyCampaignsQuery = { __typename?: 'query_root', users_by_pk?: { __typename?: 'users', id: string, campaigns: Array<{ __typename?: 'user_campaigns', campaign?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, link_a_campaign?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> } | null, link_b_campaign?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, scenarioResults?: any | null, guided?: boolean | null, archived?: boolean | null, owner_id: string, updated_at: any, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> } | null, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null }>, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }> } | null }> } | null };

export type GetCampaignQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type GetCampaignQuery = { __typename?: 'query_root', campaign_by_pk?: { __typename?: 'campaign', id: number, updated_at: any, uuid: string, name?: string | null, deleted?: boolean | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, campaignNotes?: any | null, chaosBag?: any | null, showInterludes?: boolean | null, scenarioResults?: any | null, weaknessSet?: any | null, guided?: boolean | null, guide_version?: number | null, tarot_reading?: any | null, archived?: boolean | null, owner_id: string, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', spentXp?: number | null, addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }>, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }>, link_a_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, link_b_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, linked_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null } | null };

export type GetCampaignGuideQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type GetCampaignGuideQuery = { __typename?: 'query_root', campaign_guide: Array<{ __typename?: 'campaign_guide', id?: number | null, uuid?: string | null, updated_at?: any | null, guide_inputs: Array<{ __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null }>, guide_achievements: Array<{ __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null }> }> };

export type GetCampaignAccessQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type GetCampaignAccessQuery = { __typename?: 'query_root', campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, owner: { __typename?: 'users', id: string, handle?: string | null }, access: Array<{ __typename?: 'campaign_access', user: { __typename?: 'users', id: string, handle?: string | null } }> } | null };

export type GetChaosBagResultsQueryVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type GetChaosBagResultsQuery = { __typename?: 'query_root', chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number, drawn: any, sealed: any, totalDrawn?: number | null, tarot?: Chaos_Bag_Tarot_Mode_Enum | null, difficulty?: Campaign_Difficulty_Enum | null, history: any } | null };

export type CampaignSubscriptionVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type CampaignSubscription = { __typename?: 'subscription_root', campaign_by_pk?: { __typename?: 'campaign', id: number, updated_at: any, uuid: string, name?: string | null, deleted?: boolean | null, cycleCode?: string | null, standaloneId?: any | null, difficulty?: string | null, campaignNotes?: any | null, chaosBag?: any | null, showInterludes?: boolean | null, scenarioResults?: any | null, weaknessSet?: any | null, guided?: boolean | null, guide_version?: number | null, tarot_reading?: any | null, archived?: boolean | null, owner_id: string, investigators: Array<{ __typename?: 'campaign_investigator', id?: string | null, investigator: string }>, investigator_data: Array<{ __typename?: 'investigator_data', spentXp?: number | null, addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null }>, latest_decks: Array<{ __typename?: 'latest_decks', deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number, owner: { __typename?: 'users', id: string, handle?: string | null }, campaign: { __typename?: 'campaign', id: number, uuid: string, name?: string | null, cycleCode?: string | null }, investigator_data?: { __typename?: 'investigator_data', id?: string | null, killed?: boolean | null, insane?: boolean | null, physical?: number | null, mental?: number | null } | null, previous_deck?: { __typename?: 'campaign_deck', arkhamdb_user?: number | null, content?: any | null, content_hash?: string | null, investigator: string, id: number, owner_id: string, arkhamdb_id?: number | null, local_uuid?: string | null, campaign_id: number } | null } | null }>, link_a_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, link_b_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null, linked_campaign?: { __typename?: 'campaign', id: number, uuid: string } | null } | null };

export type CampaignAccessSubscriptionVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type CampaignAccessSubscription = { __typename?: 'subscription_root', campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, owner: { __typename?: 'users', id: string, handle?: string | null }, access: Array<{ __typename?: 'campaign_access', user: { __typename?: 'users', id: string, handle?: string | null } }> } | null };

export type CampaignGuideSubscriptionVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type CampaignGuideSubscription = { __typename?: 'subscription_root', campaign_guide: Array<{ __typename?: 'campaign_guide', id?: number | null, uuid?: string | null, updated_at?: any | null, guide_inputs: Array<{ __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null }>, guide_achievements: Array<{ __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null }> }> };

export type ChaosBagResultsSubscriptionVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
}>;


export type ChaosBagResultsSubscription = { __typename?: 'subscription_root', chaos_bag_result_by_pk?: { __typename?: 'chaos_bag_result', id: number, bless: number, curse: number, drawn: any, sealed: any, totalDrawn?: number | null, tarot?: Chaos_Bag_Tarot_Mode_Enum | null, difficulty?: Campaign_Difficulty_Enum | null, history: any } | null };

export type GetSettingsQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetSettingsQuery = { __typename?: 'query_root', user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, alphabetize?: boolean | null, colorblind?: boolean | null, ignore_collection?: boolean | null, single_card?: boolean | null, sort_quotes?: boolean | null, custom_content?: boolean | null, campaign_show_deck_id?: boolean | null, in_collection?: any | null, show_spoilers?: any | null, onboarding?: any | null } | null };

export type GetPacksQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetPacksQuery = { __typename?: 'query_root', user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, in_collection?: any | null, show_spoilers?: any | null } | null };

export type UpdateSettingAlphabetizeMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingAlphabetizeMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, alphabetize?: boolean | null } | null };

export type UpdateSettingColorblindMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingColorblindMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, colorblind?: boolean | null } | null };

export type UpdateSettingIgnoreCollectionMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingIgnoreCollectionMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, ignore_collection?: boolean | null } | null };

export type UpdateSettingSingleCardMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingSingleCardMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, single_card?: boolean | null } | null };

export type UpdateSettingSortQuotesMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingSortQuotesMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, sort_quotes?: boolean | null } | null };

export type UpdateSettingCustomContentMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingCustomContentMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, custom_content?: boolean | null } | null };

export type UpdateSettingCampaignShowDeckIdMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type UpdateSettingCampaignShowDeckIdMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, campaign_show_deck_id?: boolean | null } | null };

export type UpsertSettingsMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  in_collection: Scalars['jsonb']['input'];
  show_spoilers: Scalars['jsonb']['input'];
  onboarding: Scalars['jsonb']['input'];
  alphabetize: Scalars['Boolean']['input'];
  colorblind: Scalars['Boolean']['input'];
  ignore_collection: Scalars['Boolean']['input'];
  single_card: Scalars['Boolean']['input'];
  sort_quotes: Scalars['Boolean']['input'];
  custom_content: Scalars['Boolean']['input'];
  campaign_show_deck_id: Scalars['Boolean']['input'];
}>;


export type UpsertSettingsMutation = { __typename?: 'mutation_root', insert_user_settings_one?: { __typename?: 'user_settings', user_id: string, alphabetize?: boolean | null, colorblind?: boolean | null, ignore_collection?: boolean | null, single_card?: boolean | null, sort_quotes?: boolean | null, custom_content?: boolean | null, campaign_show_deck_id?: boolean | null, onboarding?: any | null, in_collection?: any | null, show_spoilers?: any | null } | null };

export type UpdateInCollectionMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  update: Scalars['jsonb']['input'];
}>;


export type UpdateInCollectionMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, in_collection?: any | null } | null };

export type UpdateShowSpoilersMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  update: Scalars['jsonb']['input'];
}>;


export type UpdateShowSpoilersMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, show_spoilers?: any | null } | null };

export type UpdateOnboardingMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  update: Scalars['jsonb']['input'];
}>;


export type UpdateOnboardingMutation = { __typename?: 'mutation_root', update_user_settings_by_pk?: { __typename?: 'user_settings', user_id: string, onboarding?: any | null } | null };

export type GetProfileQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetProfileQuery = { __typename?: 'query_root', users_by_pk?: { __typename?: 'users', id: string, handle?: string | null, friends: Array<{ __typename?: 'user_friends', user?: { __typename?: 'users', id: string, handle?: string | null } | null }>, sent_requests: Array<{ __typename?: 'user_sent_friend_requests', user?: { __typename?: 'users', id: string, handle?: string | null } | null }>, received_requests: Array<{ __typename?: 'user_received_friend_requests', user?: { __typename?: 'users', id: string, handle?: string | null } | null }>, flags: Array<{ __typename?: 'user_flag', flag: User_Flag_Type_Enum }> } | null };

export type GetDeleteInformationQueryVariables = Exact<{
  userId: Scalars['String']['input'];
}>;


export type GetDeleteInformationQuery = { __typename?: 'query_root', users_by_pk?: { __typename?: 'users', id: string, handle?: string | null, arkhamDBDeckCount: { __typename?: 'campaign_deck_aggregate', aggregate?: { __typename?: 'campaign_deck_aggregate_fields', count: number } | null }, localDeckCount: { __typename?: 'campaign_deck_aggregate', aggregate?: { __typename?: 'campaign_deck_aggregate_fields', count: number } | null }, createdCampaignCount: { __typename?: 'user_campaigns_aggregate', aggregate?: { __typename?: 'user_campaigns_aggregate_fields', count: number } | null, nodes: Array<{ __typename?: 'user_campaigns', campaign?: { __typename?: 'campaign', id: number, name?: string | null, cycleCode?: string | null } | null }> }, joinedCampaignCount: { __typename?: 'user_campaigns_aggregate', aggregate?: { __typename?: 'user_campaigns_aggregate_fields', count: number } | null, nodes: Array<{ __typename?: 'user_campaigns', campaign?: { __typename?: 'campaign', id: number, name?: string | null, cycleCode?: string | null } | null }> } } | null };

export type UpdateHandleMutationVariables = Exact<{
  handle: Scalars['String']['input'];
}>;


export type UpdateHandleMutation = { __typename?: 'mutation_root', updateHandle?: { __typename?: 'UpdateHandleOutput', success: boolean, user?: { __typename?: 'users', id: string, handle?: string | null } | null } | null };

export type UpdateFriendRequestMutationVariables = Exact<{
  userId: Scalars['String']['input'];
  action: FriendRequestAction;
}>;


export type UpdateFriendRequestMutation = { __typename?: 'mutation_root', updateFriendRequest?: { __typename?: 'FriendRequestOutput', success: boolean } | null };

export type SearchUsersQueryVariables = Exact<{
  search: Scalars['String']['input'];
  continueToken?: InputMaybe<Scalars['String']['input']>;
}>;


export type SearchUsersQuery = { __typename?: 'query_root', results?: { __typename?: 'UsersSearchOutput', hasMore: string, users: Array<{ __typename?: 'UserSearchResult', id: string, handle: string }> } | null };

export type EditCampaignAccessMutationVariables = Exact<{
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
  users: Array<Scalars['String']['input']> | Scalars['String']['input'];
  action: EditAccessAction;
}>;


export type EditCampaignAccessMutation = { __typename?: 'mutation_root', editCampaignAccess?: { __typename?: 'EditCampaignAccessOutput', campaignId: number } | null };

export type DeleteCampaignMutationVariables = Exact<{
  campaignId: Scalars['String']['input'];
  serverId: Scalars['Int']['input'];
}>;


export type DeleteCampaignMutation = { __typename?: 'mutation_root', deleteCampaign?: { __typename?: 'DeleteCampaignOutput', campaignId: number } | null };

export type DeleteInvestigatorDecksMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  user_id: Scalars['String']['input'];
}>;


export type DeleteInvestigatorDecksMutation = { __typename?: 'mutation_root', delete_campaign_deck?: { __typename?: 'campaign_deck_mutation_response', returning: Array<{ __typename?: 'campaign_deck', id: number, campaign_id: number, arkhamdb_id?: number | null, local_uuid?: string | null, investigator: string, owner_id: string }> } | null };

export type SetBinaryAchievementMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
  value: Scalars['Boolean']['input'];
}>;


export type SetBinaryAchievementMutation = { __typename?: 'mutation_root', insert_guide_achievement_one?: { __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null } | null };

export type SetCountAchievementMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  id: Scalars['String']['input'];
  value: Scalars['Int']['input'];
}>;


export type SetCountAchievementMutation = { __typename?: 'mutation_root', insert_guide_achievement_one?: { __typename?: 'guide_achievement', id: string, campaign_id: number, type: string, value?: number | null, bool_value?: boolean | null } | null };

export type AddGuideInputMutationVariables = Exact<{
  id: Scalars['String']['input'];
  campaign_id: Scalars['Int']['input'];
  type: Scalars['String']['input'];
  scenario?: InputMaybe<Scalars['String']['input']>;
  step?: InputMaybe<Scalars['String']['input']>;
  payload?: InputMaybe<Scalars['jsonb']['input']>;
}>;


export type AddGuideInputMutation = { __typename?: 'mutation_root', insert_guide_input_one?: { __typename?: 'guide_input', id: string, campaign_id: number, step?: string | null, scenario?: string | null, type: string, payload?: any | null } | null };

export type RemoveGuideInputsMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  ids: Array<Scalars['String']['input']> | Scalars['String']['input'];
}>;


export type RemoveGuideInputsMutation = { __typename?: 'mutation_root', delete_guide_input?: { __typename?: 'guide_input_mutation_response', affected_rows: number, returning: Array<{ __typename?: 'guide_input', id: string, campaign_id: number }> } | null };

export type UpdateInvestigatorTraumaMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  physical?: InputMaybe<Scalars['Int']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type UpdateInvestigatorTraumaMutation = { __typename?: 'mutation_root', insert_investigator_data_one?: { __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null } | null };

export type UpdateInvestigatorDataMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  physical?: InputMaybe<Scalars['Int']['input']>;
  mental?: InputMaybe<Scalars['Int']['input']>;
  killed?: InputMaybe<Scalars['Boolean']['input']>;
  insane?: InputMaybe<Scalars['Boolean']['input']>;
  addedCards?: InputMaybe<Scalars['jsonb']['input']>;
  availableXp?: InputMaybe<Scalars['Int']['input']>;
  specialXp?: InputMaybe<Scalars['jsonb']['input']>;
  storyAssets?: InputMaybe<Scalars['jsonb']['input']>;
  ignoreStoryAssets?: InputMaybe<Scalars['jsonb']['input']>;
  removedCards?: InputMaybe<Scalars['jsonb']['input']>;
  cardCounts?: InputMaybe<Scalars['jsonb']['input']>;
}>;


export type UpdateInvestigatorDataMutation = { __typename?: 'mutation_root', insert_investigator_data_one?: { __typename?: 'investigator_data', addedCards?: any | null, ignoreStoryAssets?: any | null, removedCards?: any | null, cardCounts?: any | null, specialXp?: any | null, availableXp?: number | null, id?: string | null, campaign_id: number, investigator: string, mental?: number | null, physical?: number | null, insane?: boolean | null, killed?: boolean | null, storyAssets?: any | null } | null };

export type UpdateSpentXpMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  spent_xp: Scalars['Int']['input'];
}>;


export type UpdateSpentXpMutation = { __typename?: 'mutation_root', insert_investigator_data_one?: { __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, spentXp?: number | null } | null };

export type UpdateAvailableXpMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
  available_xp: Scalars['Int']['input'];
}>;


export type UpdateAvailableXpMutation = { __typename?: 'mutation_root', insert_investigator_data_one?: { __typename?: 'investigator_data', id?: string | null, campaign_id: number, investigator: string, availableXp?: number | null } | null };

export type UpdateCampaignArchivedMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  archived: Scalars['Boolean']['input'];
}>;


export type UpdateCampaignArchivedMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, archived?: boolean | null } | null };

export type UpdateWeaknessSetMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  weakness_set: Scalars['jsonb']['input'];
}>;


export type UpdateWeaknessSetMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, weaknessSet?: any | null } | null };

export type UpdateTarotReadingMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  tarotReading: Scalars['jsonb']['input'];
}>;


export type UpdateTarotReadingMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, tarot_reading?: any | null } | null };

export type UpdateCampaignDifficultyMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  difficulty?: InputMaybe<Scalars['String']['input']>;
}>;


export type UpdateCampaignDifficultyMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, difficulty?: string | null } | null };

export type UpdateCampaignScenarioResultsMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  scenarioResults: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignScenarioResultsMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, scenarioResults?: any | null } | null };

export type UpdateCampaignGuideVersionMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  guideVersion: Scalars['Int']['input'];
}>;


export type UpdateCampaignGuideVersionMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, guide_version?: number | null } | null };

export type UpdateCampaignNotesMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  campaign_notes: Scalars['jsonb']['input'];
}>;


export type UpdateCampaignNotesMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, campaignNotes?: any | null } | null };

export type UpdateCampaignShowInterludesMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  show_interludes: Scalars['Boolean']['input'];
}>;


export type UpdateCampaignShowInterludesMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, showInterludes?: boolean | null } | null };

export type UpdateChaosBagMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  chaos_bag: Scalars['jsonb']['input'];
}>;


export type UpdateChaosBagMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, chaosBag?: any | null } | null };

export type UpdateCampaignNameMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
}>;


export type UpdateCampaignNameMutation = { __typename?: 'mutation_root', update_campaign_by_pk?: { __typename?: 'campaign', id: number, uuid: string, name?: string | null } | null };

export type AddCampaignInvestigatorMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
}>;


export type AddCampaignInvestigatorMutation = { __typename?: 'mutation_root', insert_campaign_investigator_one?: { __typename?: 'campaign_investigator', id?: string | null, investigator: string, campaign_id: number } | null };

export type RemoveCampaignInvestigatorMutationVariables = Exact<{
  campaign_id: Scalars['Int']['input'];
  investigator: Scalars['String']['input'];
}>;


export type RemoveCampaignInvestigatorMutation = { __typename?: 'mutation_root', delete_campaign_investigator?: { __typename?: 'campaign_investigator_mutation_response', returning: Array<{ __typename?: 'campaign_investigator', id?: string | null, campaign_id: number, investigator: string }> } | null };

export const TabooSetFragmentDoc = gql`
    fragment TabooSet on taboo_set {
  id
  name
  code
  active
  date
  card_count
  current
}
    `;
export const EncounterSetFragmentDoc = gql`
    fragment EncounterSet on card_encounter_set {
  code
  name
}
    `;
export const PackFragmentDoc = gql`
    fragment Pack on pack {
  code
  cycle_code
  real_name
  position
  official
}
    `;
export const CycleFragmentDoc = gql`
    fragment Cycle on cycle {
  code
  real_name
  position
  official
}
    `;
export const SingleCardFragmentDoc = gql`
    fragment SingleCard on all_card {
  id
  code
  cost
  clues
  doom
  stage
  illustrator
  double_sided
  deck_limit
  encounter_code
  encounter_position
  exceptional
  exile
  faction_code
  health
  health_per_investigator
  is_unique
  myriad
  pack_code
  pack_position
  permanent
  position
  quantity
  real_flavor
  real_name
  real_pack_name
  real_slot
  real_subname
  real_text
  real_traits
  real_back_name
  real_back_text
  real_back_flavor
  real_encounter_set_name
  sanity
  skill_agility
  skill_combat
  skill_intellect
  skill_willpower
  skill_wild
  subtype_code
  type_code
  victory
  shroud
  back_link_id
  enemy_horror
  enemy_damage
  enemy_evade
  enemy_fight
  hidden
  deck_options
  deck_requirements
  side_deck_options
  side_deck_requirements
  restrictions
  imageurl
  backimageurl
  faction2_code
  faction3_code
  xp
  version
  alternate_required_code
  clues_fixed
  errata_date
  alternate_of_code
  duplicate_of_code
  spoiler
  vengeance
  customization_options
  taboo_set_id
  taboo_xp
  errata_date
  real_customization_text
  real_customization_change
  real_taboo_text_change
  real_taboo_original_text
  real_taboo_original_back_text
  preview
  official
  taboo_placeholder
  gender
  alt_art_investigator
  tags
}
    `;
export const CoreCardTextFragmentDoc = gql`
    fragment CoreCardText on all_card_text {
  flavor
  name
  slot
  subname
  text
  traits
  back_flavor
  back_text
  back_name
  customization_change
  customization_text
  taboo_text_change
  taboo_original_text
  taboo_original_back_text
}
    `;
export const FullChaosBagResultFragmentDoc = gql`
    fragment FullChaosBagResult on chaos_bag_result {
  id
  bless
  curse
  drawn
  sealed
  totalDrawn
  tarot
  difficulty
  history
}
    `;
export const IdDeckFragmentDoc = gql`
    fragment IdDeck on campaign_deck {
  id
  owner_id
  arkhamdb_id
  local_uuid
  campaign_id
}
    `;
export const MiniDeckFragmentDoc = gql`
    fragment MiniDeck on campaign_deck {
  ...IdDeck
  investigator
}
    ${IdDeckFragmentDoc}`;
export const BasicDeckFragmentDoc = gql`
    fragment BasicDeck on campaign_deck {
  ...MiniDeck
  arkhamdb_user
  content
  content_hash
}
    ${MiniDeckFragmentDoc}`;
export const AllDeckFragmentDoc = gql`
    fragment AllDeck on campaign_deck {
  ...BasicDeck
  campaign {
    id
    uuid
  }
  next_deck {
    ...IdDeck
  }
  previous_deck {
    ...IdDeck
  }
}
    ${BasicDeckFragmentDoc}
${IdDeckFragmentDoc}`;
export const UserInfoFragmentDoc = gql`
    fragment UserInfo on users {
  id
  handle
}
    `;
export const HistoryDeckFragmentDoc = gql`
    fragment HistoryDeck on campaign_deck {
  ...BasicDeck
  owner {
    ...UserInfo
  }
  next_deck {
    ...IdDeck
  }
  previous_deck {
    ...IdDeck
  }
}
    ${BasicDeckFragmentDoc}
${UserInfoFragmentDoc}
${IdDeckFragmentDoc}`;
export const MiniInvestigatorDataFragmentDoc = gql`
    fragment MiniInvestigatorData on investigator_data {
  id
  campaign_id
  investigator
  mental
  physical
  insane
  killed
  storyAssets
}
    `;
export const MiniCampaignFragmentDoc = gql`
    fragment MiniCampaign on campaign {
  id
  uuid
  name
  cycleCode
  standaloneId
  difficulty
  scenarioResults
  guided
  archived
  owner_id
  latest_decks(order_by: {owner_id: asc}) {
    deck {
      ...MiniDeck
    }
  }
  investigators(order_by: {created_at: asc}) {
    id
    investigator
  }
  investigator_data(order_by: {created_at: asc}) {
    ...MiniInvestigatorData
  }
  updated_at
}
    ${MiniDeckFragmentDoc}
${MiniInvestigatorDataFragmentDoc}`;
export const FullGuideInvestigatorDataFragmentDoc = gql`
    fragment FullGuideInvestigatorData on investigator_data {
  ...MiniInvestigatorData
  addedCards
  ignoreStoryAssets
  removedCards
  cardCounts
  specialXp
  availableXp
}
    ${MiniInvestigatorDataFragmentDoc}`;
export const FullInvestigatorDataFragmentDoc = gql`
    fragment FullInvestigatorData on investigator_data {
  ...FullGuideInvestigatorData
  spentXp
}
    ${FullGuideInvestigatorDataFragmentDoc}`;
export const LatestDeckFragmentDoc = gql`
    fragment LatestDeck on campaign_deck {
  ...BasicDeck
  owner {
    ...UserInfo
  }
  campaign {
    id
    uuid
    name
    cycleCode
  }
  investigator_data {
    id
    killed
    insane
    physical
    mental
  }
  previous_deck {
    ...BasicDeck
  }
}
    ${BasicDeckFragmentDoc}
${UserInfoFragmentDoc}`;
export const FullCampaignFragmentDoc = gql`
    fragment FullCampaign on campaign {
  id
  updated_at
  uuid
  name
  deleted
  cycleCode
  standaloneId
  difficulty
  campaignNotes
  chaosBag
  showInterludes
  scenarioResults
  weaknessSet
  guided
  guide_version
  tarot_reading
  archived
  owner_id
  investigators(order_by: {created_at: asc}) {
    id
    investigator
  }
  investigator_data(order_by: {created_at: asc}) {
    ...FullInvestigatorData
  }
  latest_decks(order_by: {owner_id: asc}) {
    deck {
      ...LatestDeck
    }
  }
  link_a_campaign {
    id
    uuid
  }
  link_b_campaign {
    id
    uuid
  }
  linked_campaign {
    id
    uuid
  }
}
    ${FullInvestigatorDataFragmentDoc}
${LatestDeckFragmentDoc}`;
export const GuideInputFragmentDoc = gql`
    fragment GuideInput on guide_input {
  id
  campaign_id
  step
  scenario
  type
  payload
}
    `;
export const GuideAchievementFragmentDoc = gql`
    fragment GuideAchievement on guide_achievement {
  id
  campaign_id
  type
  value
  bool_value
}
    `;
export const FullCampaignGuideStateFragmentDoc = gql`
    fragment FullCampaignGuideState on campaign_guide {
  id
  uuid
  updated_at
  guide_inputs(order_by: [{created_at: asc}, {inserted_idx: asc}]) {
    ...GuideInput
  }
  guide_achievements(order_by: {created_at: asc}) {
    ...GuideAchievement
  }
}
    ${GuideInputFragmentDoc}
${GuideAchievementFragmentDoc}`;
export const RefreshArkhamDbDecksDocument = gql`
    mutation refreshArkhamDbDecks($force: Boolean!) {
  refreshArkhamDbDecks(args: {force: $force}) {
    updated
  }
}
    `;
export type RefreshArkhamDbDecksMutationFn = Apollo.MutationFunction<RefreshArkhamDbDecksMutation, RefreshArkhamDbDecksMutationVariables>;

/**
 * __useRefreshArkhamDbDecksMutation__
 *
 * To run a mutation, you first call `useRefreshArkhamDbDecksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRefreshArkhamDbDecksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [refreshArkhamDbDecksMutation, { data, loading, error }] = useRefreshArkhamDbDecksMutation({
 *   variables: {
 *      force: // value for 'force'
 *   },
 * });
 */
export function useRefreshArkhamDbDecksMutation(baseOptions?: Apollo.MutationHookOptions<RefreshArkhamDbDecksMutation, RefreshArkhamDbDecksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RefreshArkhamDbDecksMutation, RefreshArkhamDbDecksMutationVariables>(RefreshArkhamDbDecksDocument, options);
      }
export type RefreshArkhamDbDecksMutationHookResult = ReturnType<typeof useRefreshArkhamDbDecksMutation>;
export type RefreshArkhamDbDecksMutationResult = Apollo.MutationResult<RefreshArkhamDbDecksMutation>;
export type RefreshArkhamDbDecksMutationOptions = Apollo.BaseMutationOptions<RefreshArkhamDbDecksMutation, RefreshArkhamDbDecksMutationVariables>;
export const GetArkhamDbDecksDocument = gql`
    query getArkhamDbDecks($userId: String!) {
  arkhamdb_deck(where: {owner_id: {_eq: $userId}}) {
    id
    owner_id
    slots
    side_slots
    meta
    tags
    archived
    investigator
    name
    created_at
    updated_at
    description
    next_deck_id
    ignore_deck_limit_slots
    deleted
  }
}
    `;

/**
 * __useGetArkhamDbDecksQuery__
 *
 * To run a query within a React component, call `useGetArkhamDbDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetArkhamDbDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetArkhamDbDecksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetArkhamDbDecksQuery(baseOptions: Apollo.QueryHookOptions<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables> & ({ variables: GetArkhamDbDecksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>(GetArkhamDbDecksDocument, options);
      }
export function useGetArkhamDbDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>(GetArkhamDbDecksDocument, options);
        }
export function useGetArkhamDbDecksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>(GetArkhamDbDecksDocument, options);
        }
export type GetArkhamDbDecksQueryHookResult = ReturnType<typeof useGetArkhamDbDecksQuery>;
export type GetArkhamDbDecksLazyQueryHookResult = ReturnType<typeof useGetArkhamDbDecksLazyQuery>;
export type GetArkhamDbDecksSuspenseQueryHookResult = ReturnType<typeof useGetArkhamDbDecksSuspenseQuery>;
export type GetArkhamDbDecksQueryResult = Apollo.QueryResult<GetArkhamDbDecksQuery, GetArkhamDbDecksQueryVariables>;
export const MigrateLoginDocument = gql`
    mutation migrateLogin($accessToken: String!, $refreshToken: String!) {
  migrateLoginToArkhamDb(
    args: {accessToken: $accessToken, refreshToken: $refreshToken}
  ) {
    success
  }
}
    `;
export type MigrateLoginMutationFn = Apollo.MutationFunction<MigrateLoginMutation, MigrateLoginMutationVariables>;

/**
 * __useMigrateLoginMutation__
 *
 * To run a mutation, you first call `useMigrateLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMigrateLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [migrateLoginMutation, { data, loading, error }] = useMigrateLoginMutation({
 *   variables: {
 *      accessToken: // value for 'accessToken'
 *      refreshToken: // value for 'refreshToken'
 *   },
 * });
 */
export function useMigrateLoginMutation(baseOptions?: Apollo.MutationHookOptions<MigrateLoginMutation, MigrateLoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MigrateLoginMutation, MigrateLoginMutationVariables>(MigrateLoginDocument, options);
      }
export type MigrateLoginMutationHookResult = ReturnType<typeof useMigrateLoginMutation>;
export type MigrateLoginMutationResult = Apollo.MutationResult<MigrateLoginMutation>;
export type MigrateLoginMutationOptions = Apollo.BaseMutationOptions<MigrateLoginMutation, MigrateLoginMutationVariables>;
export const LoginDocument = gql`
    mutation login($code: String!, $redirectUri: String!, $state: String!) {
  loginToArkhamDb(args: {code: $code, redirectUri: $redirectUri, state: $state}) {
    success
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      code: // value for 'code'
 *      redirectUri: // value for 'redirectUri'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, options);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const LogoutDocument = gql`
    mutation logout {
  logoutFromArkhamDb {
    success
  }
}
    `;
export type LogoutMutationFn = Apollo.MutationFunction<LogoutMutation, LogoutMutationVariables>;

/**
 * __useLogoutMutation__
 *
 * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [logoutMutation, { data, loading, error }] = useLogoutMutation({
 *   variables: {
 *   },
 * });
 */
export function useLogoutMutation(baseOptions?: Apollo.MutationHookOptions<LogoutMutation, LogoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument, options);
      }
export type LogoutMutationHookResult = ReturnType<typeof useLogoutMutation>;
export type LogoutMutationResult = Apollo.MutationResult<LogoutMutation>;
export type LogoutMutationOptions = Apollo.BaseMutationOptions<LogoutMutation, LogoutMutationVariables>;
export const CreateArkhamDbDeckDocument = gql`
    mutation createArkhamDbDeck($investigator: String!, $name: String!, $slots: jsonb!, $ignoreDeckLimitSlots: jsonb!, $problem: String, $tabooSetId: Int, $meta: jsonb, $description: String, $tags: String) {
  createArkhamDbDeck(
    args: {investigator: $investigator, name: $name, slots: $slots, ignoreDeckLimitSlots: $ignoreDeckLimitSlots, problem: $problem, tabooSetId: $tabooSetId, meta: $meta, description: $description, tags: $tags}
  ) {
    deckId
  }
}
    `;
export type CreateArkhamDbDeckMutationFn = Apollo.MutationFunction<CreateArkhamDbDeckMutation, CreateArkhamDbDeckMutationVariables>;

/**
 * __useCreateArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useCreateArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createArkhamDbDeckMutation, { data, loading, error }] = useCreateArkhamDbDeckMutation({
 *   variables: {
 *      investigator: // value for 'investigator'
 *      name: // value for 'name'
 *      slots: // value for 'slots'
 *      ignoreDeckLimitSlots: // value for 'ignoreDeckLimitSlots'
 *      problem: // value for 'problem'
 *      tabooSetId: // value for 'tabooSetId'
 *      meta: // value for 'meta'
 *      description: // value for 'description'
 *      tags: // value for 'tags'
 *   },
 * });
 */
export function useCreateArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<CreateArkhamDbDeckMutation, CreateArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateArkhamDbDeckMutation, CreateArkhamDbDeckMutationVariables>(CreateArkhamDbDeckDocument, options);
      }
export type CreateArkhamDbDeckMutationHookResult = ReturnType<typeof useCreateArkhamDbDeckMutation>;
export type CreateArkhamDbDeckMutationResult = Apollo.MutationResult<CreateArkhamDbDeckMutation>;
export type CreateArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<CreateArkhamDbDeckMutation, CreateArkhamDbDeckMutationVariables>;
export const UpgradeArkhamDbDeckDocument = gql`
    mutation upgradeArkhamDbDeck($deckId: Int!, $xp: Int!, $exiles: jsonb) {
  upgradeArkhamDbDeck(args: {deckId: $deckId, xp: $xp, exiles: $exiles}) {
    deckId
    upgradedDeckId
  }
}
    `;
export type UpgradeArkhamDbDeckMutationFn = Apollo.MutationFunction<UpgradeArkhamDbDeckMutation, UpgradeArkhamDbDeckMutationVariables>;

/**
 * __useUpgradeArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useUpgradeArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpgradeArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upgradeArkhamDbDeckMutation, { data, loading, error }] = useUpgradeArkhamDbDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      xp: // value for 'xp'
 *      exiles: // value for 'exiles'
 *   },
 * });
 */
export function useUpgradeArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<UpgradeArkhamDbDeckMutation, UpgradeArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpgradeArkhamDbDeckMutation, UpgradeArkhamDbDeckMutationVariables>(UpgradeArkhamDbDeckDocument, options);
      }
export type UpgradeArkhamDbDeckMutationHookResult = ReturnType<typeof useUpgradeArkhamDbDeckMutation>;
export type UpgradeArkhamDbDeckMutationResult = Apollo.MutationResult<UpgradeArkhamDbDeckMutation>;
export type UpgradeArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<UpgradeArkhamDbDeckMutation, UpgradeArkhamDbDeckMutationVariables>;
export const ApiDeleteArkhamDbDeckDocument = gql`
    mutation apiDeleteArkhamDbDeck($deckId: Int!, $deleteAllVersions: Boolean!) {
  apiDeleteArkhamDbDeck(
    args: {deckId: $deckId, deleteAllVersions: $deleteAllVersions}
  ) {
    success
  }
}
    `;
export type ApiDeleteArkhamDbDeckMutationFn = Apollo.MutationFunction<ApiDeleteArkhamDbDeckMutation, ApiDeleteArkhamDbDeckMutationVariables>;

/**
 * __useApiDeleteArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useApiDeleteArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApiDeleteArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [apiDeleteArkhamDbDeckMutation, { data, loading, error }] = useApiDeleteArkhamDbDeckMutation({
 *   variables: {
 *      deckId: // value for 'deckId'
 *      deleteAllVersions: // value for 'deleteAllVersions'
 *   },
 * });
 */
export function useApiDeleteArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<ApiDeleteArkhamDbDeckMutation, ApiDeleteArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApiDeleteArkhamDbDeckMutation, ApiDeleteArkhamDbDeckMutationVariables>(ApiDeleteArkhamDbDeckDocument, options);
      }
export type ApiDeleteArkhamDbDeckMutationHookResult = ReturnType<typeof useApiDeleteArkhamDbDeckMutation>;
export type ApiDeleteArkhamDbDeckMutationResult = Apollo.MutationResult<ApiDeleteArkhamDbDeckMutation>;
export type ApiDeleteArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<ApiDeleteArkhamDbDeckMutation, ApiDeleteArkhamDbDeckMutationVariables>;
export const GetCardsCacheDocument = gql`
    query getCardsCache($locale: String!, $version: Int!) {
  all_card_updated: all_card_updated_by_version(
    where: {locale: {_eq: $locale}, version: {_eq: $version}}
  ) {
    translation_updated_at
    cards_updated_at
    card_count
  }
}
    `;

/**
 * __useGetCardsCacheQuery__
 *
 * To run a query within a React component, call `useGetCardsCacheQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCardsCacheQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCardsCacheQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useGetCardsCacheQuery(baseOptions: Apollo.QueryHookOptions<GetCardsCacheQuery, GetCardsCacheQueryVariables> & ({ variables: GetCardsCacheQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCardsCacheQuery, GetCardsCacheQueryVariables>(GetCardsCacheDocument, options);
      }
export function useGetCardsCacheLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCardsCacheQuery, GetCardsCacheQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCardsCacheQuery, GetCardsCacheQueryVariables>(GetCardsCacheDocument, options);
        }
export function useGetCardsCacheSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCardsCacheQuery, GetCardsCacheQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCardsCacheQuery, GetCardsCacheQueryVariables>(GetCardsCacheDocument, options);
        }
export type GetCardsCacheQueryHookResult = ReturnType<typeof useGetCardsCacheQuery>;
export type GetCardsCacheLazyQueryHookResult = ReturnType<typeof useGetCardsCacheLazyQuery>;
export type GetCardsCacheSuspenseQueryHookResult = ReturnType<typeof useGetCardsCacheSuspenseQuery>;
export type GetCardsCacheQueryResult = Apollo.QueryResult<GetCardsCacheQuery, GetCardsCacheQueryVariables>;
export const GetTranslationDataDocument = gql`
    query getTranslationData($locale: String!) {
  faction_name(where: {locale: {_eq: $locale}}) {
    code
    name
  }
  card_type_name(where: {locale: {_eq: $locale}}) {
    code
    name
  }
  card_subtype_name(where: {locale: {_eq: $locale}}) {
    code
    name
  }
  card_encounter_set(where: {locale: {_eq: $locale}}) {
    ...EncounterSet
  }
  cycle(order_by: {position: asc}) {
    ...Cycle
    translations(where: {locale: {_eq: $locale}}) {
      name
    }
    packs(order_by: {position: asc}) {
      ...Pack
      translations(where: {locale: {_eq: $locale}}) {
        name
      }
    }
  }
}
    ${EncounterSetFragmentDoc}
${CycleFragmentDoc}
${PackFragmentDoc}`;

/**
 * __useGetTranslationDataQuery__
 *
 * To run a query within a React component, call `useGetTranslationDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetTranslationDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetTranslationDataQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetTranslationDataQuery(baseOptions: Apollo.QueryHookOptions<GetTranslationDataQuery, GetTranslationDataQueryVariables> & ({ variables: GetTranslationDataQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetTranslationDataQuery, GetTranslationDataQueryVariables>(GetTranslationDataDocument, options);
      }
export function useGetTranslationDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetTranslationDataQuery, GetTranslationDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetTranslationDataQuery, GetTranslationDataQueryVariables>(GetTranslationDataDocument, options);
        }
export function useGetTranslationDataSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetTranslationDataQuery, GetTranslationDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetTranslationDataQuery, GetTranslationDataQueryVariables>(GetTranslationDataDocument, options);
        }
export type GetTranslationDataQueryHookResult = ReturnType<typeof useGetTranslationDataQuery>;
export type GetTranslationDataLazyQueryHookResult = ReturnType<typeof useGetTranslationDataLazyQuery>;
export type GetTranslationDataSuspenseQueryHookResult = ReturnType<typeof useGetTranslationDataSuspenseQuery>;
export type GetTranslationDataQueryResult = Apollo.QueryResult<GetTranslationDataQuery, GetTranslationDataQueryVariables>;
export const GetPlayerCardsDocument = gql`
    query getPlayerCards($locale: String!, $version: Int!) {
  all_card(
    where: {version: {_lte: $version}, linked: {_is_null: true}, encounter_code: {_is_null: true}}
  ) {
    ...SingleCard
    translations(where: {locale: {_eq: $locale}}) {
      ...CoreCardText
    }
    linked_card {
      ...SingleCard
      translations(where: {locale: {_eq: $locale}}) {
        ...CoreCardText
      }
    }
  }
  all_card_updated: all_card_updated_by_version(
    where: {locale: {_eq: $locale}, version: {_eq: $version}}
  ) {
    translation_updated_at
    cards_updated_at
    card_count
  }
  taboo_set(where: {active: {_eq: true}}) {
    ...TabooSet
  }
}
    ${SingleCardFragmentDoc}
${CoreCardTextFragmentDoc}
${TabooSetFragmentDoc}`;

/**
 * __useGetPlayerCardsQuery__
 *
 * To run a query within a React component, call `useGetPlayerCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerCardsQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useGetPlayerCardsQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerCardsQuery, GetPlayerCardsQueryVariables> & ({ variables: GetPlayerCardsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>(GetPlayerCardsDocument, options);
      }
export function useGetPlayerCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>(GetPlayerCardsDocument, options);
        }
export function useGetPlayerCardsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>(GetPlayerCardsDocument, options);
        }
export type GetPlayerCardsQueryHookResult = ReturnType<typeof useGetPlayerCardsQuery>;
export type GetPlayerCardsLazyQueryHookResult = ReturnType<typeof useGetPlayerCardsLazyQuery>;
export type GetPlayerCardsSuspenseQueryHookResult = ReturnType<typeof useGetPlayerCardsSuspenseQuery>;
export type GetPlayerCardsQueryResult = Apollo.QueryResult<GetPlayerCardsQuery, GetPlayerCardsQueryVariables>;
export const GetEncounterCardsDocument = gql`
    query getEncounterCards($locale: String!, $version: Int!) {
  all_card(
    where: {version: {_lte: 7}, linked: {_is_null: true}, encounter_code: {_is_null: false}}
  ) {
    ...SingleCard
    translations(where: {locale: {_eq: $locale}}) {
      ...CoreCardText
    }
    linked_card {
      ...SingleCard
      translations(where: {locale: {_eq: $locale}}) {
        ...CoreCardText
      }
    }
  }
  all_card_updated: all_card_updated_by_version(
    where: {locale: {_eq: $locale}, version: {_eq: $version}}
  ) {
    translation_updated_at
    cards_updated_at
    card_count
  }
}
    ${SingleCardFragmentDoc}
${CoreCardTextFragmentDoc}`;

/**
 * __useGetEncounterCardsQuery__
 *
 * To run a query within a React component, call `useGetEncounterCardsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEncounterCardsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEncounterCardsQuery({
 *   variables: {
 *      locale: // value for 'locale'
 *      version: // value for 'version'
 *   },
 * });
 */
export function useGetEncounterCardsQuery(baseOptions: Apollo.QueryHookOptions<GetEncounterCardsQuery, GetEncounterCardsQueryVariables> & ({ variables: GetEncounterCardsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>(GetEncounterCardsDocument, options);
      }
export function useGetEncounterCardsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>(GetEncounterCardsDocument, options);
        }
export function useGetEncounterCardsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>(GetEncounterCardsDocument, options);
        }
export type GetEncounterCardsQueryHookResult = ReturnType<typeof useGetEncounterCardsQuery>;
export type GetEncounterCardsLazyQueryHookResult = ReturnType<typeof useGetEncounterCardsLazyQuery>;
export type GetEncounterCardsSuspenseQueryHookResult = ReturnType<typeof useGetEncounterCardsSuspenseQuery>;
export type GetEncounterCardsQueryResult = Apollo.QueryResult<GetEncounterCardsQuery, GetEncounterCardsQueryVariables>;
export const GetCardFaqDocument = gql`
    query getCardFaq($code: String!, $locale: String!) {
  faq_by_pk(code: $code) {
    code
    text
    faq_texts(where: {locale: {_eq: $locale}}) {
      code
      locale
      text
    }
  }
}
    `;

/**
 * __useGetCardFaqQuery__
 *
 * To run a query within a React component, call `useGetCardFaqQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCardFaqQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCardFaqQuery({
 *   variables: {
 *      code: // value for 'code'
 *      locale: // value for 'locale'
 *   },
 * });
 */
export function useGetCardFaqQuery(baseOptions: Apollo.QueryHookOptions<GetCardFaqQuery, GetCardFaqQueryVariables> & ({ variables: GetCardFaqQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCardFaqQuery, GetCardFaqQueryVariables>(GetCardFaqDocument, options);
      }
export function useGetCardFaqLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCardFaqQuery, GetCardFaqQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCardFaqQuery, GetCardFaqQueryVariables>(GetCardFaqDocument, options);
        }
export function useGetCardFaqSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCardFaqQuery, GetCardFaqQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCardFaqQuery, GetCardFaqQueryVariables>(GetCardFaqDocument, options);
        }
export type GetCardFaqQueryHookResult = ReturnType<typeof useGetCardFaqQuery>;
export type GetCardFaqLazyQueryHookResult = ReturnType<typeof useGetCardFaqLazyQuery>;
export type GetCardFaqSuspenseQueryHookResult = ReturnType<typeof useGetCardFaqSuspenseQuery>;
export type GetCardFaqQueryResult = Apollo.QueryResult<GetCardFaqQuery, GetCardFaqQueryVariables>;
export const UploadChaosBagResultsDocument = gql`
    mutation uploadChaosBagResults($id: Int!, $bless: Int!, $curse: Int!, $drawn: jsonb!, $sealed: jsonb!, $totalDrawn: Int!, $tarot: chaos_bag_tarot_mode_enum, $difficulty: campaign_difficulty_enum) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $id}
    _set: {bless: $bless, curse: $curse, drawn: $drawn, sealed: $sealed, totalDrawn: $totalDrawn, tarot: $tarot, difficulty: $difficulty}
  ) {
    ...FullChaosBagResult
  }
}
    ${FullChaosBagResultFragmentDoc}`;
export type UploadChaosBagResultsMutationFn = Apollo.MutationFunction<UploadChaosBagResultsMutation, UploadChaosBagResultsMutationVariables>;

/**
 * __useUploadChaosBagResultsMutation__
 *
 * To run a mutation, you first call `useUploadChaosBagResultsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadChaosBagResultsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadChaosBagResultsMutation, { data, loading, error }] = useUploadChaosBagResultsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      bless: // value for 'bless'
 *      curse: // value for 'curse'
 *      drawn: // value for 'drawn'
 *      sealed: // value for 'sealed'
 *      totalDrawn: // value for 'totalDrawn'
 *      tarot: // value for 'tarot'
 *      difficulty: // value for 'difficulty'
 *   },
 * });
 */
export function useUploadChaosBagResultsMutation(baseOptions?: Apollo.MutationHookOptions<UploadChaosBagResultsMutation, UploadChaosBagResultsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadChaosBagResultsMutation, UploadChaosBagResultsMutationVariables>(UploadChaosBagResultsDocument, options);
      }
export type UploadChaosBagResultsMutationHookResult = ReturnType<typeof useUploadChaosBagResultsMutation>;
export type UploadChaosBagResultsMutationResult = Apollo.MutationResult<UploadChaosBagResultsMutation>;
export type UploadChaosBagResultsMutationOptions = Apollo.BaseMutationOptions<UploadChaosBagResultsMutation, UploadChaosBagResultsMutationVariables>;
export const ChaosBagClearTokensDocument = gql`
    mutation chaosBagClearTokens($campaign_id: Int!, $bless: Int!, $curse: Int!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {drawn: [], bless: $bless, curse: $curse}
  ) {
    id
    drawn
    bless
    curse
  }
}
    `;
export type ChaosBagClearTokensMutationFn = Apollo.MutationFunction<ChaosBagClearTokensMutation, ChaosBagClearTokensMutationVariables>;

/**
 * __useChaosBagClearTokensMutation__
 *
 * To run a mutation, you first call `useChaosBagClearTokensMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagClearTokensMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagClearTokensMutation, { data, loading, error }] = useChaosBagClearTokensMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      bless: // value for 'bless'
 *      curse: // value for 'curse'
 *   },
 * });
 */
export function useChaosBagClearTokensMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagClearTokensMutation, ChaosBagClearTokensMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagClearTokensMutation, ChaosBagClearTokensMutationVariables>(ChaosBagClearTokensDocument, options);
      }
export type ChaosBagClearTokensMutationHookResult = ReturnType<typeof useChaosBagClearTokensMutation>;
export type ChaosBagClearTokensMutationResult = Apollo.MutationResult<ChaosBagClearTokensMutation>;
export type ChaosBagClearTokensMutationOptions = Apollo.BaseMutationOptions<ChaosBagClearTokensMutation, ChaosBagClearTokensMutationVariables>;
export const ChaosBagDrawTokenDocument = gql`
    mutation chaosBagDrawToken($campaign_id: Int!, $drawn: jsonb!, $history: jsonb!) {
  remove_elem: update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _delete_elem: {history: 19}
  ) {
    id
  }
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {drawn: $drawn}
    _prepend: {history: $history}
    _inc: {totalDrawn: 1}
  ) {
    id
    drawn
    totalDrawn
    history
  }
}
    `;
export type ChaosBagDrawTokenMutationFn = Apollo.MutationFunction<ChaosBagDrawTokenMutation, ChaosBagDrawTokenMutationVariables>;

/**
 * __useChaosBagDrawTokenMutation__
 *
 * To run a mutation, you first call `useChaosBagDrawTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagDrawTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagDrawTokenMutation, { data, loading, error }] = useChaosBagDrawTokenMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      drawn: // value for 'drawn'
 *      history: // value for 'history'
 *   },
 * });
 */
export function useChaosBagDrawTokenMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagDrawTokenMutation, ChaosBagDrawTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagDrawTokenMutation, ChaosBagDrawTokenMutationVariables>(ChaosBagDrawTokenDocument, options);
      }
export type ChaosBagDrawTokenMutationHookResult = ReturnType<typeof useChaosBagDrawTokenMutation>;
export type ChaosBagDrawTokenMutationResult = Apollo.MutationResult<ChaosBagDrawTokenMutation>;
export type ChaosBagDrawTokenMutationOptions = Apollo.BaseMutationOptions<ChaosBagDrawTokenMutation, ChaosBagDrawTokenMutationVariables>;
export const UpdateChaosBagDrawTokenDocument = gql`
    mutation updateChaosBagDrawToken($campaign_id: Int!, $drawn: jsonb!, $history: jsonb!) {
  remove_elem: update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _delete_elem: {history: 0}
  ) {
    id
  }
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {drawn: $drawn}
    _prepend: {history: $history}
    _inc: {totalDrawn: 1}
  ) {
    id
    drawn
    totalDrawn
    history
  }
}
    `;
export type UpdateChaosBagDrawTokenMutationFn = Apollo.MutationFunction<UpdateChaosBagDrawTokenMutation, UpdateChaosBagDrawTokenMutationVariables>;

/**
 * __useUpdateChaosBagDrawTokenMutation__
 *
 * To run a mutation, you first call `useUpdateChaosBagDrawTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChaosBagDrawTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChaosBagDrawTokenMutation, { data, loading, error }] = useUpdateChaosBagDrawTokenMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      drawn: // value for 'drawn'
 *      history: // value for 'history'
 *   },
 * });
 */
export function useUpdateChaosBagDrawTokenMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChaosBagDrawTokenMutation, UpdateChaosBagDrawTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChaosBagDrawTokenMutation, UpdateChaosBagDrawTokenMutationVariables>(UpdateChaosBagDrawTokenDocument, options);
      }
export type UpdateChaosBagDrawTokenMutationHookResult = ReturnType<typeof useUpdateChaosBagDrawTokenMutation>;
export type UpdateChaosBagDrawTokenMutationResult = Apollo.MutationResult<UpdateChaosBagDrawTokenMutation>;
export type UpdateChaosBagDrawTokenMutationOptions = Apollo.BaseMutationOptions<UpdateChaosBagDrawTokenMutation, UpdateChaosBagDrawTokenMutationVariables>;
export const ReturnChaosBagTokensWithBlurseDocument = gql`
    mutation returnChaosBagTokensWithBlurse($campaign_id: Int!, $drawn: jsonb!, $bless: Int!, $curse: Int!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {drawn: $drawn, bless: $bless, curse: $curse}
    _inc: {totalDrawn: 1}
  ) {
    id
    drawn
    totalDrawn
    bless
    curse
  }
}
    `;
export type ReturnChaosBagTokensWithBlurseMutationFn = Apollo.MutationFunction<ReturnChaosBagTokensWithBlurseMutation, ReturnChaosBagTokensWithBlurseMutationVariables>;

/**
 * __useReturnChaosBagTokensWithBlurseMutation__
 *
 * To run a mutation, you first call `useReturnChaosBagTokensWithBlurseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReturnChaosBagTokensWithBlurseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [returnChaosBagTokensWithBlurseMutation, { data, loading, error }] = useReturnChaosBagTokensWithBlurseMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      drawn: // value for 'drawn'
 *      bless: // value for 'bless'
 *      curse: // value for 'curse'
 *   },
 * });
 */
export function useReturnChaosBagTokensWithBlurseMutation(baseOptions?: Apollo.MutationHookOptions<ReturnChaosBagTokensWithBlurseMutation, ReturnChaosBagTokensWithBlurseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReturnChaosBagTokensWithBlurseMutation, ReturnChaosBagTokensWithBlurseMutationVariables>(ReturnChaosBagTokensWithBlurseDocument, options);
      }
export type ReturnChaosBagTokensWithBlurseMutationHookResult = ReturnType<typeof useReturnChaosBagTokensWithBlurseMutation>;
export type ReturnChaosBagTokensWithBlurseMutationResult = Apollo.MutationResult<ReturnChaosBagTokensWithBlurseMutation>;
export type ReturnChaosBagTokensWithBlurseMutationOptions = Apollo.BaseMutationOptions<ReturnChaosBagTokensWithBlurseMutation, ReturnChaosBagTokensWithBlurseMutationVariables>;
export const ReturnChaosBagTokensDocument = gql`
    mutation returnChaosBagTokens($campaign_id: Int!, $drawn: jsonb!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {drawn: $drawn}
    _inc: {totalDrawn: 1}
  ) {
    id
    drawn
    totalDrawn
  }
}
    `;
export type ReturnChaosBagTokensMutationFn = Apollo.MutationFunction<ReturnChaosBagTokensMutation, ReturnChaosBagTokensMutationVariables>;

/**
 * __useReturnChaosBagTokensMutation__
 *
 * To run a mutation, you first call `useReturnChaosBagTokensMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReturnChaosBagTokensMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [returnChaosBagTokensMutation, { data, loading, error }] = useReturnChaosBagTokensMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      drawn: // value for 'drawn'
 *   },
 * });
 */
export function useReturnChaosBagTokensMutation(baseOptions?: Apollo.MutationHookOptions<ReturnChaosBagTokensMutation, ReturnChaosBagTokensMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReturnChaosBagTokensMutation, ReturnChaosBagTokensMutationVariables>(ReturnChaosBagTokensDocument, options);
      }
export type ReturnChaosBagTokensMutationHookResult = ReturnType<typeof useReturnChaosBagTokensMutation>;
export type ReturnChaosBagTokensMutationResult = Apollo.MutationResult<ReturnChaosBagTokensMutation>;
export type ReturnChaosBagTokensMutationOptions = Apollo.BaseMutationOptions<ReturnChaosBagTokensMutation, ReturnChaosBagTokensMutationVariables>;
export const ChaosBagResetBlessCurseDocument = gql`
    mutation chaosBagResetBlessCurse($campaign_id: Int!, $drawn: jsonb!, $sealed: jsonb!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {bless: 0, curse: 0, drawn: $drawn, sealed: $sealed}
  ) {
    id
    bless
    curse
    drawn
    sealed
  }
}
    `;
export type ChaosBagResetBlessCurseMutationFn = Apollo.MutationFunction<ChaosBagResetBlessCurseMutation, ChaosBagResetBlessCurseMutationVariables>;

/**
 * __useChaosBagResetBlessCurseMutation__
 *
 * To run a mutation, you first call `useChaosBagResetBlessCurseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagResetBlessCurseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagResetBlessCurseMutation, { data, loading, error }] = useChaosBagResetBlessCurseMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      drawn: // value for 'drawn'
 *      sealed: // value for 'sealed'
 *   },
 * });
 */
export function useChaosBagResetBlessCurseMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagResetBlessCurseMutation, ChaosBagResetBlessCurseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagResetBlessCurseMutation, ChaosBagResetBlessCurseMutationVariables>(ChaosBagResetBlessCurseDocument, options);
      }
export type ChaosBagResetBlessCurseMutationHookResult = ReturnType<typeof useChaosBagResetBlessCurseMutation>;
export type ChaosBagResetBlessCurseMutationResult = Apollo.MutationResult<ChaosBagResetBlessCurseMutation>;
export type ChaosBagResetBlessCurseMutationOptions = Apollo.BaseMutationOptions<ChaosBagResetBlessCurseMutation, ChaosBagResetBlessCurseMutationVariables>;
export const ChaosBagSealTokensDocument = gql`
    mutation chaosBagSealTokens($campaign_id: Int!, $sealed: jsonb!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {sealed: $sealed}
  ) {
    id
    sealed
  }
}
    `;
export type ChaosBagSealTokensMutationFn = Apollo.MutationFunction<ChaosBagSealTokensMutation, ChaosBagSealTokensMutationVariables>;

/**
 * __useChaosBagSealTokensMutation__
 *
 * To run a mutation, you first call `useChaosBagSealTokensMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagSealTokensMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagSealTokensMutation, { data, loading, error }] = useChaosBagSealTokensMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      sealed: // value for 'sealed'
 *   },
 * });
 */
export function useChaosBagSealTokensMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagSealTokensMutation, ChaosBagSealTokensMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagSealTokensMutation, ChaosBagSealTokensMutationVariables>(ChaosBagSealTokensDocument, options);
      }
export type ChaosBagSealTokensMutationHookResult = ReturnType<typeof useChaosBagSealTokensMutation>;
export type ChaosBagSealTokensMutationResult = Apollo.MutationResult<ChaosBagSealTokensMutation>;
export type ChaosBagSealTokensMutationOptions = Apollo.BaseMutationOptions<ChaosBagSealTokensMutation, ChaosBagSealTokensMutationVariables>;
export const ChaosBagSetBlessCurseDocument = gql`
    mutation chaosBagSetBlessCurse($campaign_id: Int!, $bless: Int!, $curse: Int!) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {bless: $bless, curse: $curse}
  ) {
    id
    bless
    curse
  }
}
    `;
export type ChaosBagSetBlessCurseMutationFn = Apollo.MutationFunction<ChaosBagSetBlessCurseMutation, ChaosBagSetBlessCurseMutationVariables>;

/**
 * __useChaosBagSetBlessCurseMutation__
 *
 * To run a mutation, you first call `useChaosBagSetBlessCurseMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagSetBlessCurseMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagSetBlessCurseMutation, { data, loading, error }] = useChaosBagSetBlessCurseMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      bless: // value for 'bless'
 *      curse: // value for 'curse'
 *   },
 * });
 */
export function useChaosBagSetBlessCurseMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagSetBlessCurseMutation, ChaosBagSetBlessCurseMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagSetBlessCurseMutation, ChaosBagSetBlessCurseMutationVariables>(ChaosBagSetBlessCurseDocument, options);
      }
export type ChaosBagSetBlessCurseMutationHookResult = ReturnType<typeof useChaosBagSetBlessCurseMutation>;
export type ChaosBagSetBlessCurseMutationResult = Apollo.MutationResult<ChaosBagSetBlessCurseMutation>;
export type ChaosBagSetBlessCurseMutationOptions = Apollo.BaseMutationOptions<ChaosBagSetBlessCurseMutation, ChaosBagSetBlessCurseMutationVariables>;
export const ChaosBagSetTarotDocument = gql`
    mutation chaosBagSetTarot($campaign_id: Int!, $tarot: chaos_bag_tarot_mode_enum) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {tarot: $tarot}
  ) {
    id
    tarot
  }
}
    `;
export type ChaosBagSetTarotMutationFn = Apollo.MutationFunction<ChaosBagSetTarotMutation, ChaosBagSetTarotMutationVariables>;

/**
 * __useChaosBagSetTarotMutation__
 *
 * To run a mutation, you first call `useChaosBagSetTarotMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagSetTarotMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagSetTarotMutation, { data, loading, error }] = useChaosBagSetTarotMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      tarot: // value for 'tarot'
 *   },
 * });
 */
export function useChaosBagSetTarotMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagSetTarotMutation, ChaosBagSetTarotMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagSetTarotMutation, ChaosBagSetTarotMutationVariables>(ChaosBagSetTarotDocument, options);
      }
export type ChaosBagSetTarotMutationHookResult = ReturnType<typeof useChaosBagSetTarotMutation>;
export type ChaosBagSetTarotMutationResult = Apollo.MutationResult<ChaosBagSetTarotMutation>;
export type ChaosBagSetTarotMutationOptions = Apollo.BaseMutationOptions<ChaosBagSetTarotMutation, ChaosBagSetTarotMutationVariables>;
export const ChaosBagSetDifficultyDocument = gql`
    mutation chaosBagSetDifficulty($campaign_id: Int!, $difficulty: campaign_difficulty_enum) {
  update_chaos_bag_result_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {difficulty: $difficulty}
  ) {
    id
    difficulty
  }
}
    `;
export type ChaosBagSetDifficultyMutationFn = Apollo.MutationFunction<ChaosBagSetDifficultyMutation, ChaosBagSetDifficultyMutationVariables>;

/**
 * __useChaosBagSetDifficultyMutation__
 *
 * To run a mutation, you first call `useChaosBagSetDifficultyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChaosBagSetDifficultyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [chaosBagSetDifficultyMutation, { data, loading, error }] = useChaosBagSetDifficultyMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      difficulty: // value for 'difficulty'
 *   },
 * });
 */
export function useChaosBagSetDifficultyMutation(baseOptions?: Apollo.MutationHookOptions<ChaosBagSetDifficultyMutation, ChaosBagSetDifficultyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ChaosBagSetDifficultyMutation, ChaosBagSetDifficultyMutationVariables>(ChaosBagSetDifficultyDocument, options);
      }
export type ChaosBagSetDifficultyMutationHookResult = ReturnType<typeof useChaosBagSetDifficultyMutation>;
export type ChaosBagSetDifficultyMutationResult = Apollo.MutationResult<ChaosBagSetDifficultyMutation>;
export type ChaosBagSetDifficultyMutationOptions = Apollo.BaseMutationOptions<ChaosBagSetDifficultyMutation, ChaosBagSetDifficultyMutationVariables>;
export const CreateCampaignDocument = gql`
    mutation createCampaign($campaignId: String!, $linked: LinkedCampaignId, $guided: Boolean) {
  createCampaign(
    args: {campaignId: $campaignId, linked: $linked, guided: $guided}
  ) {
    campaignId
    campaignIdA
    campaignIdB
  }
}
    `;
export type CreateCampaignMutationFn = Apollo.MutationFunction<CreateCampaignMutation, CreateCampaignMutationVariables>;

/**
 * __useCreateCampaignMutation__
 *
 * To run a mutation, you first call `useCreateCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCampaignMutation, { data, loading, error }] = useCreateCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      linked: // value for 'linked'
 *      guided: // value for 'guided'
 *   },
 * });
 */
export function useCreateCampaignMutation(baseOptions?: Apollo.MutationHookOptions<CreateCampaignMutation, CreateCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCampaignMutation, CreateCampaignMutationVariables>(CreateCampaignDocument, options);
      }
export type CreateCampaignMutationHookResult = ReturnType<typeof useCreateCampaignMutation>;
export type CreateCampaignMutationResult = Apollo.MutationResult<CreateCampaignMutation>;
export type CreateCampaignMutationOptions = Apollo.BaseMutationOptions<CreateCampaignMutation, CreateCampaignMutationVariables>;
export const UploadLocalCampaignDeckDocument = gql`
    mutation uploadLocalCampaignDeck($localDeckId: String!, $arkhamDbId: Int!) {
  uploadLocalCampaignDeck(
    args: {localDeckId: $localDeckId, arkhamDbId: $arkhamDbId}
  ) {
    deckIds {
      id
      campaignId
    }
  }
}
    `;
export type UploadLocalCampaignDeckMutationFn = Apollo.MutationFunction<UploadLocalCampaignDeckMutation, UploadLocalCampaignDeckMutationVariables>;

/**
 * __useUploadLocalCampaignDeckMutation__
 *
 * To run a mutation, you first call `useUploadLocalCampaignDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadLocalCampaignDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadLocalCampaignDeckMutation, { data, loading, error }] = useUploadLocalCampaignDeckMutation({
 *   variables: {
 *      localDeckId: // value for 'localDeckId'
 *      arkhamDbId: // value for 'arkhamDbId'
 *   },
 * });
 */
export function useUploadLocalCampaignDeckMutation(baseOptions?: Apollo.MutationHookOptions<UploadLocalCampaignDeckMutation, UploadLocalCampaignDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadLocalCampaignDeckMutation, UploadLocalCampaignDeckMutationVariables>(UploadLocalCampaignDeckDocument, options);
      }
export type UploadLocalCampaignDeckMutationHookResult = ReturnType<typeof useUploadLocalCampaignDeckMutation>;
export type UploadLocalCampaignDeckMutationResult = Apollo.MutationResult<UploadLocalCampaignDeckMutation>;
export type UploadLocalCampaignDeckMutationOptions = Apollo.BaseMutationOptions<UploadLocalCampaignDeckMutation, UploadLocalCampaignDeckMutationVariables>;
export const UploadNewCampaignDocument = gql`
    mutation uploadNewCampaign($campaignId: Int!, $cycleCode: String!, $standaloneId: jsonb, $showInterludes: Boolean, $name: String!, $difficulty: String, $campaignNotes: jsonb, $scenarioResults: jsonb, $chaosBag: jsonb, $weaknessSet: jsonb, $tarotReading: jsonb, $guideVersion: Int, $inputs: [guide_input_insert_input!]!, $achievements: [guide_achievement_insert_input!]!, $investigator_data: [investigator_data_insert_input!]!, $investigators: [campaign_investigator_insert_input!]!) {
  insert_guide_input(objects: $inputs) {
    affected_rows
    returning {
      id
      campaign_id
      scenario
      step
      payload
      created_at
      inserted_idx
    }
  }
  insert_guide_achievement(objects: $achievements) {
    affected_rows
  }
  insert_investigator_data(objects: $investigator_data) {
    affected_rows
  }
  insert_campaign_investigator(objects: $investigators) {
    affected_rows
  }
  update_campaign_by_pk(
    pk_columns: {id: $campaignId}
    _set: {name: $name, cycleCode: $cycleCode, standaloneId: $standaloneId, difficulty: $difficulty, campaignNotes: $campaignNotes, chaosBag: $chaosBag, showInterludes: $showInterludes, scenarioResults: $scenarioResults, weaknessSet: $weaknessSet, guide_version: $guideVersion, tarot_reading: $tarotReading}
  ) {
    ...FullCampaign
    link_a_campaign {
      ...MiniCampaign
    }
    link_b_campaign {
      ...MiniCampaign
    }
    campaign_guide {
      ...FullCampaignGuideState
    }
  }
}
    ${FullCampaignFragmentDoc}
${MiniCampaignFragmentDoc}
${FullCampaignGuideStateFragmentDoc}`;
export type UploadNewCampaignMutationFn = Apollo.MutationFunction<UploadNewCampaignMutation, UploadNewCampaignMutationVariables>;

/**
 * __useUploadNewCampaignMutation__
 *
 * To run a mutation, you first call `useUploadNewCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadNewCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadNewCampaignMutation, { data, loading, error }] = useUploadNewCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      cycleCode: // value for 'cycleCode'
 *      standaloneId: // value for 'standaloneId'
 *      showInterludes: // value for 'showInterludes'
 *      name: // value for 'name'
 *      difficulty: // value for 'difficulty'
 *      campaignNotes: // value for 'campaignNotes'
 *      scenarioResults: // value for 'scenarioResults'
 *      chaosBag: // value for 'chaosBag'
 *      weaknessSet: // value for 'weaknessSet'
 *      tarotReading: // value for 'tarotReading'
 *      guideVersion: // value for 'guideVersion'
 *      inputs: // value for 'inputs'
 *      achievements: // value for 'achievements'
 *      investigator_data: // value for 'investigator_data'
 *      investigators: // value for 'investigators'
 *   },
 * });
 */
export function useUploadNewCampaignMutation(baseOptions?: Apollo.MutationHookOptions<UploadNewCampaignMutation, UploadNewCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadNewCampaignMutation, UploadNewCampaignMutationVariables>(UploadNewCampaignDocument, options);
      }
export type UploadNewCampaignMutationHookResult = ReturnType<typeof useUploadNewCampaignMutation>;
export type UploadNewCampaignMutationResult = Apollo.MutationResult<UploadNewCampaignMutation>;
export type UploadNewCampaignMutationOptions = Apollo.BaseMutationOptions<UploadNewCampaignMutation, UploadNewCampaignMutationVariables>;
export const InsertNewDeckDocument = gql`
    mutation insertNewDeck($arkhamdb_id: Int, $local_uuid: String, $arkhamdb_user: Int, $campaign_id: Int!, $investigator: String!, $content: jsonb!, $content_hash: String!, $userId: String!) {
  insert_campaign_deck_one(
    object: {arkhamdb_id: $arkhamdb_id, arkhamdb_user: $arkhamdb_user, local_uuid: $local_uuid, campaign_id: $campaign_id, investigator: $investigator, content: $content, content_hash: $content_hash, owner_id: $userId, base: true}
  ) {
    ...LatestDeck
  }
}
    ${LatestDeckFragmentDoc}`;
export type InsertNewDeckMutationFn = Apollo.MutationFunction<InsertNewDeckMutation, InsertNewDeckMutationVariables>;

/**
 * __useInsertNewDeckMutation__
 *
 * To run a mutation, you first call `useInsertNewDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNewDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNewDeckMutation, { data, loading, error }] = useInsertNewDeckMutation({
 *   variables: {
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *      local_uuid: // value for 'local_uuid'
 *      arkhamdb_user: // value for 'arkhamdb_user'
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      content: // value for 'content'
 *      content_hash: // value for 'content_hash'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertNewDeckMutation(baseOptions?: Apollo.MutationHookOptions<InsertNewDeckMutation, InsertNewDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNewDeckMutation, InsertNewDeckMutationVariables>(InsertNewDeckDocument, options);
      }
export type InsertNewDeckMutationHookResult = ReturnType<typeof useInsertNewDeckMutation>;
export type InsertNewDeckMutationResult = Apollo.MutationResult<InsertNewDeckMutation>;
export type InsertNewDeckMutationOptions = Apollo.BaseMutationOptions<InsertNewDeckMutation, InsertNewDeckMutationVariables>;
export const InsertNextLocalDeckDocument = gql`
    mutation insertNextLocalDeck($previous_local_uuid: String, $local_uuid: String, $campaign_id: Int!, $investigator: String!, $content: jsonb!, $content_hash: String!, $userId: String!) {
  insert_campaign_deck_one(
    object: {local_uuid: $local_uuid, arkhamdb_id: null, campaign_id: $campaign_id, investigator: $investigator, content: $content, content_hash: $content_hash, owner_id: $userId, previous_decks: {data: {local_uuid: $previous_local_uuid, arkhamdb_id: null, investigator: $investigator, campaign_id: $campaign_id, owner_id: $userId}, on_conflict: {constraint: deck_local_uuid_campaign_id_key, update_columns: [next_deck_id]}}}
  ) {
    ...BasicDeck
    previous_deck {
      ...IdDeck
    }
  }
}
    ${BasicDeckFragmentDoc}
${IdDeckFragmentDoc}`;
export type InsertNextLocalDeckMutationFn = Apollo.MutationFunction<InsertNextLocalDeckMutation, InsertNextLocalDeckMutationVariables>;

/**
 * __useInsertNextLocalDeckMutation__
 *
 * To run a mutation, you first call `useInsertNextLocalDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNextLocalDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNextLocalDeckMutation, { data, loading, error }] = useInsertNextLocalDeckMutation({
 *   variables: {
 *      previous_local_uuid: // value for 'previous_local_uuid'
 *      local_uuid: // value for 'local_uuid'
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      content: // value for 'content'
 *      content_hash: // value for 'content_hash'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertNextLocalDeckMutation(baseOptions?: Apollo.MutationHookOptions<InsertNextLocalDeckMutation, InsertNextLocalDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNextLocalDeckMutation, InsertNextLocalDeckMutationVariables>(InsertNextLocalDeckDocument, options);
      }
export type InsertNextLocalDeckMutationHookResult = ReturnType<typeof useInsertNextLocalDeckMutation>;
export type InsertNextLocalDeckMutationResult = Apollo.MutationResult<InsertNextLocalDeckMutation>;
export type InsertNextLocalDeckMutationOptions = Apollo.BaseMutationOptions<InsertNextLocalDeckMutation, InsertNextLocalDeckMutationVariables>;
export const InsertNextArkhamDbDeckDocument = gql`
    mutation insertNextArkhamDbDeck($previous_arkhamdb_id: Int!, $arkhamdb_id: Int!, $arkhamdb_user: Int, $campaign_id: Int!, $investigator: String!, $content: jsonb!, $content_hash: String!, $userId: String!) {
  insert_campaign_deck_one(
    object: {arkhamdb_id: $arkhamdb_id, arkhamdb_user: $arkhamdb_user, local_uuid: null, investigator: $investigator, campaign_id: $campaign_id, owner_id: $userId, content: $content, content_hash: $content_hash, previous_decks: {data: {arkhamdb_id: $previous_arkhamdb_id, local_uuid: null, campaign_id: $campaign_id, investigator: $investigator, owner_id: $userId}, on_conflict: {constraint: deck_arkhamdb_id_campaign_id_key, update_columns: [next_deck_id]}}}
  ) {
    ...BasicDeck
    previous_deck {
      ...IdDeck
    }
  }
}
    ${BasicDeckFragmentDoc}
${IdDeckFragmentDoc}`;
export type InsertNextArkhamDbDeckMutationFn = Apollo.MutationFunction<InsertNextArkhamDbDeckMutation, InsertNextArkhamDbDeckMutationVariables>;

/**
 * __useInsertNextArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useInsertNextArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertNextArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertNextArkhamDbDeckMutation, { data, loading, error }] = useInsertNextArkhamDbDeckMutation({
 *   variables: {
 *      previous_arkhamdb_id: // value for 'previous_arkhamdb_id'
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *      arkhamdb_user: // value for 'arkhamdb_user'
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      content: // value for 'content'
 *      content_hash: // value for 'content_hash'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertNextArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<InsertNextArkhamDbDeckMutation, InsertNextArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertNextArkhamDbDeckMutation, InsertNextArkhamDbDeckMutationVariables>(InsertNextArkhamDbDeckDocument, options);
      }
export type InsertNextArkhamDbDeckMutationHookResult = ReturnType<typeof useInsertNextArkhamDbDeckMutation>;
export type InsertNextArkhamDbDeckMutationResult = Apollo.MutationResult<InsertNextArkhamDbDeckMutation>;
export type InsertNextArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<InsertNextArkhamDbDeckMutation, InsertNextArkhamDbDeckMutationVariables>;
export const UpdateArkhamDbDeckDocument = gql`
    mutation updateArkhamDbDeck($arkhamdb_id: Int!, $campaign_id: Int!, $content: jsonb!, $content_hash: String!, $arkhamdb_user: Int) {
  update_campaign_deck(
    where: {arkhamdb_id: {_eq: $arkhamdb_id}, campaign_id: {_eq: $campaign_id}}
    _set: {content: $content, content_hash: $content_hash, arkhamdb_user: $arkhamdb_user}
  ) {
    affected_rows
    returning {
      ...IdDeck
      content
      content_hash
      arkhamdb_user
    }
  }
}
    ${IdDeckFragmentDoc}`;
export type UpdateArkhamDbDeckMutationFn = Apollo.MutationFunction<UpdateArkhamDbDeckMutation, UpdateArkhamDbDeckMutationVariables>;

/**
 * __useUpdateArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useUpdateArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateArkhamDbDeckMutation, { data, loading, error }] = useUpdateArkhamDbDeckMutation({
 *   variables: {
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *      campaign_id: // value for 'campaign_id'
 *      content: // value for 'content'
 *      content_hash: // value for 'content_hash'
 *      arkhamdb_user: // value for 'arkhamdb_user'
 *   },
 * });
 */
export function useUpdateArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<UpdateArkhamDbDeckMutation, UpdateArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateArkhamDbDeckMutation, UpdateArkhamDbDeckMutationVariables>(UpdateArkhamDbDeckDocument, options);
      }
export type UpdateArkhamDbDeckMutationHookResult = ReturnType<typeof useUpdateArkhamDbDeckMutation>;
export type UpdateArkhamDbDeckMutationResult = Apollo.MutationResult<UpdateArkhamDbDeckMutation>;
export type UpdateArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<UpdateArkhamDbDeckMutation, UpdateArkhamDbDeckMutationVariables>;
export const UpdateLocalDeckDocument = gql`
    mutation updateLocalDeck($local_uuid: String!, $campaign_id: Int!, $content: jsonb!, $content_hash: String!) {
  update_campaign_deck(
    where: {local_uuid: {_eq: $local_uuid}, campaign_id: {_eq: $campaign_id}}
    _set: {content: $content, content_hash: $content_hash}
  ) {
    affected_rows
    returning {
      ...IdDeck
      content
      content_hash
    }
  }
}
    ${IdDeckFragmentDoc}`;
export type UpdateLocalDeckMutationFn = Apollo.MutationFunction<UpdateLocalDeckMutation, UpdateLocalDeckMutationVariables>;

/**
 * __useUpdateLocalDeckMutation__
 *
 * To run a mutation, you first call `useUpdateLocalDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLocalDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLocalDeckMutation, { data, loading, error }] = useUpdateLocalDeckMutation({
 *   variables: {
 *      local_uuid: // value for 'local_uuid'
 *      campaign_id: // value for 'campaign_id'
 *      content: // value for 'content'
 *      content_hash: // value for 'content_hash'
 *   },
 * });
 */
export function useUpdateLocalDeckMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLocalDeckMutation, UpdateLocalDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLocalDeckMutation, UpdateLocalDeckMutationVariables>(UpdateLocalDeckDocument, options);
      }
export type UpdateLocalDeckMutationHookResult = ReturnType<typeof useUpdateLocalDeckMutation>;
export type UpdateLocalDeckMutationResult = Apollo.MutationResult<UpdateLocalDeckMutation>;
export type UpdateLocalDeckMutationOptions = Apollo.BaseMutationOptions<UpdateLocalDeckMutation, UpdateLocalDeckMutationVariables>;
export const DeleteAllLocalDecksDocument = gql`
    mutation deleteAllLocalDecks($local_uuid: String!, $campaign_id: Int!) {
  delete_campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, other_decks: {local_uuid: {_eq: $local_uuid}}}
  ) {
    affected_rows
    returning {
      ...IdDeck
    }
  }
}
    ${IdDeckFragmentDoc}`;
export type DeleteAllLocalDecksMutationFn = Apollo.MutationFunction<DeleteAllLocalDecksMutation, DeleteAllLocalDecksMutationVariables>;

/**
 * __useDeleteAllLocalDecksMutation__
 *
 * To run a mutation, you first call `useDeleteAllLocalDecksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAllLocalDecksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAllLocalDecksMutation, { data, loading, error }] = useDeleteAllLocalDecksMutation({
 *   variables: {
 *      local_uuid: // value for 'local_uuid'
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useDeleteAllLocalDecksMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAllLocalDecksMutation, DeleteAllLocalDecksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAllLocalDecksMutation, DeleteAllLocalDecksMutationVariables>(DeleteAllLocalDecksDocument, options);
      }
export type DeleteAllLocalDecksMutationHookResult = ReturnType<typeof useDeleteAllLocalDecksMutation>;
export type DeleteAllLocalDecksMutationResult = Apollo.MutationResult<DeleteAllLocalDecksMutation>;
export type DeleteAllLocalDecksMutationOptions = Apollo.BaseMutationOptions<DeleteAllLocalDecksMutation, DeleteAllLocalDecksMutationVariables>;
export const DeleteAllArkhamDbDecksDocument = gql`
    mutation deleteAllArkhamDbDecks($arkhamdb_id: Int!, $campaign_id: Int!) {
  delete_campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, other_decks: {arkhamdb_id: {_eq: $arkhamdb_id}}}
  ) {
    affected_rows
    returning {
      ...IdDeck
    }
  }
}
    ${IdDeckFragmentDoc}`;
export type DeleteAllArkhamDbDecksMutationFn = Apollo.MutationFunction<DeleteAllArkhamDbDecksMutation, DeleteAllArkhamDbDecksMutationVariables>;

/**
 * __useDeleteAllArkhamDbDecksMutation__
 *
 * To run a mutation, you first call `useDeleteAllArkhamDbDecksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAllArkhamDbDecksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAllArkhamDbDecksMutation, { data, loading, error }] = useDeleteAllArkhamDbDecksMutation({
 *   variables: {
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useDeleteAllArkhamDbDecksMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAllArkhamDbDecksMutation, DeleteAllArkhamDbDecksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAllArkhamDbDecksMutation, DeleteAllArkhamDbDecksMutationVariables>(DeleteAllArkhamDbDecksDocument, options);
      }
export type DeleteAllArkhamDbDecksMutationHookResult = ReturnType<typeof useDeleteAllArkhamDbDecksMutation>;
export type DeleteAllArkhamDbDecksMutationResult = Apollo.MutationResult<DeleteAllArkhamDbDecksMutation>;
export type DeleteAllArkhamDbDecksMutationOptions = Apollo.BaseMutationOptions<DeleteAllArkhamDbDecksMutation, DeleteAllArkhamDbDecksMutationVariables>;
export const DeleteLocalDeckDocument = gql`
    mutation deleteLocalDeck($local_uuid: String!, $campaign_id: Int!) {
  update_campaign_deck(
    where: {next_deck: {local_uuid: {_eq: $local_uuid}, campaign_id: {_eq: $campaign_id}}}
    _delete_key: {content: "nextDeckId"}
  ) {
    returning {
      ...LatestDeck
    }
  }
  delete_campaign_deck(
    where: {local_uuid: {_eq: $local_uuid}, campaign_id: {_eq: $campaign_id}}
  ) {
    affected_rows
    returning {
      ...IdDeck
      previous_deck {
        ...LatestDeck
      }
    }
  }
}
    ${LatestDeckFragmentDoc}
${IdDeckFragmentDoc}`;
export type DeleteLocalDeckMutationFn = Apollo.MutationFunction<DeleteLocalDeckMutation, DeleteLocalDeckMutationVariables>;

/**
 * __useDeleteLocalDeckMutation__
 *
 * To run a mutation, you first call `useDeleteLocalDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteLocalDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteLocalDeckMutation, { data, loading, error }] = useDeleteLocalDeckMutation({
 *   variables: {
 *      local_uuid: // value for 'local_uuid'
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useDeleteLocalDeckMutation(baseOptions?: Apollo.MutationHookOptions<DeleteLocalDeckMutation, DeleteLocalDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteLocalDeckMutation, DeleteLocalDeckMutationVariables>(DeleteLocalDeckDocument, options);
      }
export type DeleteLocalDeckMutationHookResult = ReturnType<typeof useDeleteLocalDeckMutation>;
export type DeleteLocalDeckMutationResult = Apollo.MutationResult<DeleteLocalDeckMutation>;
export type DeleteLocalDeckMutationOptions = Apollo.BaseMutationOptions<DeleteLocalDeckMutation, DeleteLocalDeckMutationVariables>;
export const DeleteArkhamDbDeckDocument = gql`
    mutation deleteArkhamDbDeck($arkhamdb_id: Int!, $campaign_id: Int!) {
  update_campaign_deck(
    where: {next_deck: {arkhamdb_id: {_eq: $arkhamdb_id}, campaign_id: {_eq: $campaign_id}}}
    _delete_key: {content: "nextDeckId"}
  ) {
    returning {
      ...LatestDeck
    }
  }
  delete_campaign_deck(
    where: {arkhamdb_id: {_eq: $arkhamdb_id}, campaign_id: {_eq: $campaign_id}}
  ) {
    affected_rows
    returning {
      ...IdDeck
      previous_deck {
        ...LatestDeck
      }
    }
  }
}
    ${LatestDeckFragmentDoc}
${IdDeckFragmentDoc}`;
export type DeleteArkhamDbDeckMutationFn = Apollo.MutationFunction<DeleteArkhamDbDeckMutation, DeleteArkhamDbDeckMutationVariables>;

/**
 * __useDeleteArkhamDbDeckMutation__
 *
 * To run a mutation, you first call `useDeleteArkhamDbDeckMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteArkhamDbDeckMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteArkhamDbDeckMutation, { data, loading, error }] = useDeleteArkhamDbDeckMutation({
 *   variables: {
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useDeleteArkhamDbDeckMutation(baseOptions?: Apollo.MutationHookOptions<DeleteArkhamDbDeckMutation, DeleteArkhamDbDeckMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteArkhamDbDeckMutation, DeleteArkhamDbDeckMutationVariables>(DeleteArkhamDbDeckDocument, options);
      }
export type DeleteArkhamDbDeckMutationHookResult = ReturnType<typeof useDeleteArkhamDbDeckMutation>;
export type DeleteArkhamDbDeckMutationResult = Apollo.MutationResult<DeleteArkhamDbDeckMutation>;
export type DeleteArkhamDbDeckMutationOptions = Apollo.BaseMutationOptions<DeleteArkhamDbDeckMutation, DeleteArkhamDbDeckMutationVariables>;
export const GetMyDecksDocument = gql`
    query getMyDecks($userId: String!) {
  users_by_pk(id: $userId) {
    id
    decks {
      deck {
        ...LatestDeck
      }
    }
    all_decks {
      ...AllDeck
    }
  }
}
    ${LatestDeckFragmentDoc}
${AllDeckFragmentDoc}`;

/**
 * __useGetMyDecksQuery__
 *
 * To run a query within a React component, call `useGetMyDecksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyDecksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyDecksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMyDecksQuery(baseOptions: Apollo.QueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables> & ({ variables: GetMyDecksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
      }
export function useGetMyDecksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
        }
export function useGetMyDecksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetMyDecksQuery, GetMyDecksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyDecksQuery, GetMyDecksQueryVariables>(GetMyDecksDocument, options);
        }
export type GetMyDecksQueryHookResult = ReturnType<typeof useGetMyDecksQuery>;
export type GetMyDecksLazyQueryHookResult = ReturnType<typeof useGetMyDecksLazyQuery>;
export type GetMyDecksSuspenseQueryHookResult = ReturnType<typeof useGetMyDecksSuspenseQuery>;
export type GetMyDecksQueryResult = Apollo.QueryResult<GetMyDecksQuery, GetMyDecksQueryVariables>;
export const GetLatestLocalDeckDocument = gql`
    query getLatestLocalDeck($campaign_id: Int!, $local_uuid: String!) {
  campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, local_uuid: {_eq: $local_uuid}}
  ) {
    ...LatestDeck
  }
}
    ${LatestDeckFragmentDoc}`;

/**
 * __useGetLatestLocalDeckQuery__
 *
 * To run a query within a React component, call `useGetLatestLocalDeckQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestLocalDeckQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestLocalDeckQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      local_uuid: // value for 'local_uuid'
 *   },
 * });
 */
export function useGetLatestLocalDeckQuery(baseOptions: Apollo.QueryHookOptions<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables> & ({ variables: GetLatestLocalDeckQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>(GetLatestLocalDeckDocument, options);
      }
export function useGetLatestLocalDeckLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>(GetLatestLocalDeckDocument, options);
        }
export function useGetLatestLocalDeckSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>(GetLatestLocalDeckDocument, options);
        }
export type GetLatestLocalDeckQueryHookResult = ReturnType<typeof useGetLatestLocalDeckQuery>;
export type GetLatestLocalDeckLazyQueryHookResult = ReturnType<typeof useGetLatestLocalDeckLazyQuery>;
export type GetLatestLocalDeckSuspenseQueryHookResult = ReturnType<typeof useGetLatestLocalDeckSuspenseQuery>;
export type GetLatestLocalDeckQueryResult = Apollo.QueryResult<GetLatestLocalDeckQuery, GetLatestLocalDeckQueryVariables>;
export const GetLatestArkhamDbDeckDocument = gql`
    query getLatestArkhamDbDeck($campaign_id: Int!, $arkhamdb_id: Int!) {
  campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, arkhamdb_id: {_eq: $arkhamdb_id}}
  ) {
    ...LatestDeck
  }
}
    ${LatestDeckFragmentDoc}`;

/**
 * __useGetLatestArkhamDbDeckQuery__
 *
 * To run a query within a React component, call `useGetLatestArkhamDbDeckQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestArkhamDbDeckQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestArkhamDbDeckQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      arkhamdb_id: // value for 'arkhamdb_id'
 *   },
 * });
 */
export function useGetLatestArkhamDbDeckQuery(baseOptions: Apollo.QueryHookOptions<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables> & ({ variables: GetLatestArkhamDbDeckQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>(GetLatestArkhamDbDeckDocument, options);
      }
export function useGetLatestArkhamDbDeckLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>(GetLatestArkhamDbDeckDocument, options);
        }
export function useGetLatestArkhamDbDeckSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>(GetLatestArkhamDbDeckDocument, options);
        }
export type GetLatestArkhamDbDeckQueryHookResult = ReturnType<typeof useGetLatestArkhamDbDeckQuery>;
export type GetLatestArkhamDbDeckLazyQueryHookResult = ReturnType<typeof useGetLatestArkhamDbDeckLazyQuery>;
export type GetLatestArkhamDbDeckSuspenseQueryHookResult = ReturnType<typeof useGetLatestArkhamDbDeckSuspenseQuery>;
export type GetLatestArkhamDbDeckQueryResult = Apollo.QueryResult<GetLatestArkhamDbDeckQuery, GetLatestArkhamDbDeckQueryVariables>;
export const GetLatestDeckDocument = gql`
    query getLatestDeck($deckId: Int!) {
  campaign_deck_by_pk(id: $deckId) {
    ...LatestDeck
  }
}
    ${LatestDeckFragmentDoc}`;

/**
 * __useGetLatestDeckQuery__
 *
 * To run a query within a React component, call `useGetLatestDeckQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestDeckQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestDeckQuery({
 *   variables: {
 *      deckId: // value for 'deckId'
 *   },
 * });
 */
export function useGetLatestDeckQuery(baseOptions: Apollo.QueryHookOptions<GetLatestDeckQuery, GetLatestDeckQueryVariables> & ({ variables: GetLatestDeckQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetLatestDeckQuery, GetLatestDeckQueryVariables>(GetLatestDeckDocument, options);
      }
export function useGetLatestDeckLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestDeckQuery, GetLatestDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetLatestDeckQuery, GetLatestDeckQueryVariables>(GetLatestDeckDocument, options);
        }
export function useGetLatestDeckSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetLatestDeckQuery, GetLatestDeckQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetLatestDeckQuery, GetLatestDeckQueryVariables>(GetLatestDeckDocument, options);
        }
export type GetLatestDeckQueryHookResult = ReturnType<typeof useGetLatestDeckQuery>;
export type GetLatestDeckLazyQueryHookResult = ReturnType<typeof useGetLatestDeckLazyQuery>;
export type GetLatestDeckSuspenseQueryHookResult = ReturnType<typeof useGetLatestDeckSuspenseQuery>;
export type GetLatestDeckQueryResult = Apollo.QueryResult<GetLatestDeckQuery, GetLatestDeckQueryVariables>;
export const GetDeckHistoryDocument = gql`
    query getDeckHistory($campaign_id: Int!, $investigator: String!) {
  campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, investigator: {_eq: $investigator}}
  ) {
    ...HistoryDeck
  }
}
    ${HistoryDeckFragmentDoc}`;

/**
 * __useGetDeckHistoryQuery__
 *
 * To run a query within a React component, call `useGetDeckHistoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDeckHistoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDeckHistoryQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *   },
 * });
 */
export function useGetDeckHistoryQuery(baseOptions: Apollo.QueryHookOptions<GetDeckHistoryQuery, GetDeckHistoryQueryVariables> & ({ variables: GetDeckHistoryQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>(GetDeckHistoryDocument, options);
      }
export function useGetDeckHistoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>(GetDeckHistoryDocument, options);
        }
export function useGetDeckHistorySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>(GetDeckHistoryDocument, options);
        }
export type GetDeckHistoryQueryHookResult = ReturnType<typeof useGetDeckHistoryQuery>;
export type GetDeckHistoryLazyQueryHookResult = ReturnType<typeof useGetDeckHistoryLazyQuery>;
export type GetDeckHistorySuspenseQueryHookResult = ReturnType<typeof useGetDeckHistorySuspenseQuery>;
export type GetDeckHistoryQueryResult = Apollo.QueryResult<GetDeckHistoryQuery, GetDeckHistoryQueryVariables>;
export const GetMyCampaignsDocument = gql`
    query getMyCampaigns($userId: String!) {
  users_by_pk(id: $userId) {
    id
    campaigns {
      campaign {
        ...MiniCampaign
        link_a_campaign {
          ...MiniCampaign
        }
        link_b_campaign {
          ...MiniCampaign
        }
      }
    }
  }
}
    ${MiniCampaignFragmentDoc}`;

/**
 * __useGetMyCampaignsQuery__
 *
 * To run a query within a React component, call `useGetMyCampaignsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMyCampaignsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMyCampaignsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetMyCampaignsQuery(baseOptions: Apollo.QueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables> & ({ variables: GetMyCampaignsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
      }
export function useGetMyCampaignsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
        }
export function useGetMyCampaignsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>(GetMyCampaignsDocument, options);
        }
export type GetMyCampaignsQueryHookResult = ReturnType<typeof useGetMyCampaignsQuery>;
export type GetMyCampaignsLazyQueryHookResult = ReturnType<typeof useGetMyCampaignsLazyQuery>;
export type GetMyCampaignsSuspenseQueryHookResult = ReturnType<typeof useGetMyCampaignsSuspenseQuery>;
export type GetMyCampaignsQueryResult = Apollo.QueryResult<GetMyCampaignsQuery, GetMyCampaignsQueryVariables>;
export const GetCampaignDocument = gql`
    query getCampaign($campaign_id: Int!) {
  campaign_by_pk(id: $campaign_id) {
    ...FullCampaign
  }
}
    ${FullCampaignFragmentDoc}`;

/**
 * __useGetCampaignQuery__
 *
 * To run a query within a React component, call `useGetCampaignQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCampaignQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCampaignQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useGetCampaignQuery(baseOptions: Apollo.QueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables> & ({ variables: GetCampaignQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
      }
export function useGetCampaignLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
        }
export function useGetCampaignSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCampaignQuery, GetCampaignQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCampaignQuery, GetCampaignQueryVariables>(GetCampaignDocument, options);
        }
export type GetCampaignQueryHookResult = ReturnType<typeof useGetCampaignQuery>;
export type GetCampaignLazyQueryHookResult = ReturnType<typeof useGetCampaignLazyQuery>;
export type GetCampaignSuspenseQueryHookResult = ReturnType<typeof useGetCampaignSuspenseQuery>;
export type GetCampaignQueryResult = Apollo.QueryResult<GetCampaignQuery, GetCampaignQueryVariables>;
export const GetCampaignGuideDocument = gql`
    query getCampaignGuide($campaign_id: Int!) {
  campaign_guide(where: {id: {_eq: $campaign_id}}) {
    ...FullCampaignGuideState
  }
}
    ${FullCampaignGuideStateFragmentDoc}`;

/**
 * __useGetCampaignGuideQuery__
 *
 * To run a query within a React component, call `useGetCampaignGuideQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCampaignGuideQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCampaignGuideQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useGetCampaignGuideQuery(baseOptions: Apollo.QueryHookOptions<GetCampaignGuideQuery, GetCampaignGuideQueryVariables> & ({ variables: GetCampaignGuideQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>(GetCampaignGuideDocument, options);
      }
export function useGetCampaignGuideLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>(GetCampaignGuideDocument, options);
        }
export function useGetCampaignGuideSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>(GetCampaignGuideDocument, options);
        }
export type GetCampaignGuideQueryHookResult = ReturnType<typeof useGetCampaignGuideQuery>;
export type GetCampaignGuideLazyQueryHookResult = ReturnType<typeof useGetCampaignGuideLazyQuery>;
export type GetCampaignGuideSuspenseQueryHookResult = ReturnType<typeof useGetCampaignGuideSuspenseQuery>;
export type GetCampaignGuideQueryResult = Apollo.QueryResult<GetCampaignGuideQuery, GetCampaignGuideQueryVariables>;
export const GetCampaignAccessDocument = gql`
    query getCampaignAccess($campaign_id: Int!) {
  campaign_by_pk(id: $campaign_id) {
    id
    uuid
    owner {
      ...UserInfo
    }
    access {
      user {
        ...UserInfo
      }
    }
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useGetCampaignAccessQuery__
 *
 * To run a query within a React component, call `useGetCampaignAccessQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCampaignAccessQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCampaignAccessQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useGetCampaignAccessQuery(baseOptions: Apollo.QueryHookOptions<GetCampaignAccessQuery, GetCampaignAccessQueryVariables> & ({ variables: GetCampaignAccessQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>(GetCampaignAccessDocument, options);
      }
export function useGetCampaignAccessLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>(GetCampaignAccessDocument, options);
        }
export function useGetCampaignAccessSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>(GetCampaignAccessDocument, options);
        }
export type GetCampaignAccessQueryHookResult = ReturnType<typeof useGetCampaignAccessQuery>;
export type GetCampaignAccessLazyQueryHookResult = ReturnType<typeof useGetCampaignAccessLazyQuery>;
export type GetCampaignAccessSuspenseQueryHookResult = ReturnType<typeof useGetCampaignAccessSuspenseQuery>;
export type GetCampaignAccessQueryResult = Apollo.QueryResult<GetCampaignAccessQuery, GetCampaignAccessQueryVariables>;
export const GetChaosBagResultsDocument = gql`
    query getChaosBagResults($campaign_id: Int!) {
  chaos_bag_result_by_pk(id: $campaign_id) {
    ...FullChaosBagResult
  }
}
    ${FullChaosBagResultFragmentDoc}`;

/**
 * __useGetChaosBagResultsQuery__
 *
 * To run a query within a React component, call `useGetChaosBagResultsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChaosBagResultsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChaosBagResultsQuery({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useGetChaosBagResultsQuery(baseOptions: Apollo.QueryHookOptions<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables> & ({ variables: GetChaosBagResultsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>(GetChaosBagResultsDocument, options);
      }
export function useGetChaosBagResultsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>(GetChaosBagResultsDocument, options);
        }
export function useGetChaosBagResultsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>(GetChaosBagResultsDocument, options);
        }
export type GetChaosBagResultsQueryHookResult = ReturnType<typeof useGetChaosBagResultsQuery>;
export type GetChaosBagResultsLazyQueryHookResult = ReturnType<typeof useGetChaosBagResultsLazyQuery>;
export type GetChaosBagResultsSuspenseQueryHookResult = ReturnType<typeof useGetChaosBagResultsSuspenseQuery>;
export type GetChaosBagResultsQueryResult = Apollo.QueryResult<GetChaosBagResultsQuery, GetChaosBagResultsQueryVariables>;
export const CampaignDocument = gql`
    subscription campaign($campaign_id: Int!) {
  campaign_by_pk(id: $campaign_id) {
    ...FullCampaign
  }
}
    ${FullCampaignFragmentDoc}`;

/**
 * __useCampaignSubscription__
 *
 * To run a query within a React component, call `useCampaignSubscription` and pass it any options that fit your needs.
 * When your component renders, `useCampaignSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCampaignSubscription({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useCampaignSubscription(baseOptions: Apollo.SubscriptionHookOptions<CampaignSubscription, CampaignSubscriptionVariables> & ({ variables: CampaignSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<CampaignSubscription, CampaignSubscriptionVariables>(CampaignDocument, options);
      }
export type CampaignSubscriptionHookResult = ReturnType<typeof useCampaignSubscription>;
export type CampaignSubscriptionResult = Apollo.SubscriptionResult<CampaignSubscription>;
export const CampaignAccessDocument = gql`
    subscription campaignAccess($campaign_id: Int!) {
  campaign_by_pk(id: $campaign_id) {
    id
    uuid
    owner {
      ...UserInfo
    }
    access {
      user {
        ...UserInfo
      }
    }
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useCampaignAccessSubscription__
 *
 * To run a query within a React component, call `useCampaignAccessSubscription` and pass it any options that fit your needs.
 * When your component renders, `useCampaignAccessSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCampaignAccessSubscription({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useCampaignAccessSubscription(baseOptions: Apollo.SubscriptionHookOptions<CampaignAccessSubscription, CampaignAccessSubscriptionVariables> & ({ variables: CampaignAccessSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<CampaignAccessSubscription, CampaignAccessSubscriptionVariables>(CampaignAccessDocument, options);
      }
export type CampaignAccessSubscriptionHookResult = ReturnType<typeof useCampaignAccessSubscription>;
export type CampaignAccessSubscriptionResult = Apollo.SubscriptionResult<CampaignAccessSubscription>;
export const CampaignGuideDocument = gql`
    subscription campaignGuide($campaign_id: Int!) {
  campaign_guide(where: {id: {_eq: $campaign_id}}) {
    ...FullCampaignGuideState
  }
}
    ${FullCampaignGuideStateFragmentDoc}`;

/**
 * __useCampaignGuideSubscription__
 *
 * To run a query within a React component, call `useCampaignGuideSubscription` and pass it any options that fit your needs.
 * When your component renders, `useCampaignGuideSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCampaignGuideSubscription({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useCampaignGuideSubscription(baseOptions: Apollo.SubscriptionHookOptions<CampaignGuideSubscription, CampaignGuideSubscriptionVariables> & ({ variables: CampaignGuideSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<CampaignGuideSubscription, CampaignGuideSubscriptionVariables>(CampaignGuideDocument, options);
      }
export type CampaignGuideSubscriptionHookResult = ReturnType<typeof useCampaignGuideSubscription>;
export type CampaignGuideSubscriptionResult = Apollo.SubscriptionResult<CampaignGuideSubscription>;
export const ChaosBagResultsDocument = gql`
    subscription chaosBagResults($campaign_id: Int!) {
  chaos_bag_result_by_pk(id: $campaign_id) {
    ...FullChaosBagResult
  }
}
    ${FullChaosBagResultFragmentDoc}`;

/**
 * __useChaosBagResultsSubscription__
 *
 * To run a query within a React component, call `useChaosBagResultsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useChaosBagResultsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChaosBagResultsSubscription({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *   },
 * });
 */
export function useChaosBagResultsSubscription(baseOptions: Apollo.SubscriptionHookOptions<ChaosBagResultsSubscription, ChaosBagResultsSubscriptionVariables> & ({ variables: ChaosBagResultsSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ChaosBagResultsSubscription, ChaosBagResultsSubscriptionVariables>(ChaosBagResultsDocument, options);
      }
export type ChaosBagResultsSubscriptionHookResult = ReturnType<typeof useChaosBagResultsSubscription>;
export type ChaosBagResultsSubscriptionResult = Apollo.SubscriptionResult<ChaosBagResultsSubscription>;
export const GetSettingsDocument = gql`
    query getSettings($userId: String!) {
  user_settings_by_pk(user_id: $userId) {
    user_id
    alphabetize
    colorblind
    ignore_collection
    single_card
    sort_quotes
    custom_content
    campaign_show_deck_id
    in_collection
    show_spoilers
    onboarding
  }
}
    `;

/**
 * __useGetSettingsQuery__
 *
 * To run a query within a React component, call `useGetSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSettingsQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetSettingsQuery(baseOptions: Apollo.QueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables> & ({ variables: GetSettingsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options);
      }
export function useGetSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options);
        }
export function useGetSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetSettingsQuery, GetSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetSettingsQuery, GetSettingsQueryVariables>(GetSettingsDocument, options);
        }
export type GetSettingsQueryHookResult = ReturnType<typeof useGetSettingsQuery>;
export type GetSettingsLazyQueryHookResult = ReturnType<typeof useGetSettingsLazyQuery>;
export type GetSettingsSuspenseQueryHookResult = ReturnType<typeof useGetSettingsSuspenseQuery>;
export type GetSettingsQueryResult = Apollo.QueryResult<GetSettingsQuery, GetSettingsQueryVariables>;
export const GetPacksDocument = gql`
    query getPacks($userId: String!) {
  user_settings_by_pk(user_id: $userId) {
    user_id
    in_collection
    show_spoilers
  }
}
    `;

/**
 * __useGetPacksQuery__
 *
 * To run a query within a React component, call `useGetPacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPacksQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetPacksQuery(baseOptions: Apollo.QueryHookOptions<GetPacksQuery, GetPacksQueryVariables> & ({ variables: GetPacksQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPacksQuery, GetPacksQueryVariables>(GetPacksDocument, options);
      }
export function useGetPacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPacksQuery, GetPacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPacksQuery, GetPacksQueryVariables>(GetPacksDocument, options);
        }
export function useGetPacksSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetPacksQuery, GetPacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPacksQuery, GetPacksQueryVariables>(GetPacksDocument, options);
        }
export type GetPacksQueryHookResult = ReturnType<typeof useGetPacksQuery>;
export type GetPacksLazyQueryHookResult = ReturnType<typeof useGetPacksLazyQuery>;
export type GetPacksSuspenseQueryHookResult = ReturnType<typeof useGetPacksSuspenseQuery>;
export type GetPacksQueryResult = Apollo.QueryResult<GetPacksQuery, GetPacksQueryVariables>;
export const UpdateSettingAlphabetizeDocument = gql`
    mutation updateSettingAlphabetize($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {alphabetize: $value}
  ) {
    user_id
    alphabetize
  }
}
    `;
export type UpdateSettingAlphabetizeMutationFn = Apollo.MutationFunction<UpdateSettingAlphabetizeMutation, UpdateSettingAlphabetizeMutationVariables>;

/**
 * __useUpdateSettingAlphabetizeMutation__
 *
 * To run a mutation, you first call `useUpdateSettingAlphabetizeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingAlphabetizeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingAlphabetizeMutation, { data, loading, error }] = useUpdateSettingAlphabetizeMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingAlphabetizeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingAlphabetizeMutation, UpdateSettingAlphabetizeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingAlphabetizeMutation, UpdateSettingAlphabetizeMutationVariables>(UpdateSettingAlphabetizeDocument, options);
      }
export type UpdateSettingAlphabetizeMutationHookResult = ReturnType<typeof useUpdateSettingAlphabetizeMutation>;
export type UpdateSettingAlphabetizeMutationResult = Apollo.MutationResult<UpdateSettingAlphabetizeMutation>;
export type UpdateSettingAlphabetizeMutationOptions = Apollo.BaseMutationOptions<UpdateSettingAlphabetizeMutation, UpdateSettingAlphabetizeMutationVariables>;
export const UpdateSettingColorblindDocument = gql`
    mutation updateSettingColorblind($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {colorblind: $value}
  ) {
    user_id
    colorblind
  }
}
    `;
export type UpdateSettingColorblindMutationFn = Apollo.MutationFunction<UpdateSettingColorblindMutation, UpdateSettingColorblindMutationVariables>;

/**
 * __useUpdateSettingColorblindMutation__
 *
 * To run a mutation, you first call `useUpdateSettingColorblindMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingColorblindMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingColorblindMutation, { data, loading, error }] = useUpdateSettingColorblindMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingColorblindMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingColorblindMutation, UpdateSettingColorblindMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingColorblindMutation, UpdateSettingColorblindMutationVariables>(UpdateSettingColorblindDocument, options);
      }
export type UpdateSettingColorblindMutationHookResult = ReturnType<typeof useUpdateSettingColorblindMutation>;
export type UpdateSettingColorblindMutationResult = Apollo.MutationResult<UpdateSettingColorblindMutation>;
export type UpdateSettingColorblindMutationOptions = Apollo.BaseMutationOptions<UpdateSettingColorblindMutation, UpdateSettingColorblindMutationVariables>;
export const UpdateSettingIgnoreCollectionDocument = gql`
    mutation updateSettingIgnoreCollection($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {ignore_collection: $value}
  ) {
    user_id
    ignore_collection
  }
}
    `;
export type UpdateSettingIgnoreCollectionMutationFn = Apollo.MutationFunction<UpdateSettingIgnoreCollectionMutation, UpdateSettingIgnoreCollectionMutationVariables>;

/**
 * __useUpdateSettingIgnoreCollectionMutation__
 *
 * To run a mutation, you first call `useUpdateSettingIgnoreCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingIgnoreCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingIgnoreCollectionMutation, { data, loading, error }] = useUpdateSettingIgnoreCollectionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingIgnoreCollectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingIgnoreCollectionMutation, UpdateSettingIgnoreCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingIgnoreCollectionMutation, UpdateSettingIgnoreCollectionMutationVariables>(UpdateSettingIgnoreCollectionDocument, options);
      }
export type UpdateSettingIgnoreCollectionMutationHookResult = ReturnType<typeof useUpdateSettingIgnoreCollectionMutation>;
export type UpdateSettingIgnoreCollectionMutationResult = Apollo.MutationResult<UpdateSettingIgnoreCollectionMutation>;
export type UpdateSettingIgnoreCollectionMutationOptions = Apollo.BaseMutationOptions<UpdateSettingIgnoreCollectionMutation, UpdateSettingIgnoreCollectionMutationVariables>;
export const UpdateSettingSingleCardDocument = gql`
    mutation updateSettingSingleCard($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {single_card: $value}
  ) {
    user_id
    single_card
  }
}
    `;
export type UpdateSettingSingleCardMutationFn = Apollo.MutationFunction<UpdateSettingSingleCardMutation, UpdateSettingSingleCardMutationVariables>;

/**
 * __useUpdateSettingSingleCardMutation__
 *
 * To run a mutation, you first call `useUpdateSettingSingleCardMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingSingleCardMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingSingleCardMutation, { data, loading, error }] = useUpdateSettingSingleCardMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingSingleCardMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingSingleCardMutation, UpdateSettingSingleCardMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingSingleCardMutation, UpdateSettingSingleCardMutationVariables>(UpdateSettingSingleCardDocument, options);
      }
export type UpdateSettingSingleCardMutationHookResult = ReturnType<typeof useUpdateSettingSingleCardMutation>;
export type UpdateSettingSingleCardMutationResult = Apollo.MutationResult<UpdateSettingSingleCardMutation>;
export type UpdateSettingSingleCardMutationOptions = Apollo.BaseMutationOptions<UpdateSettingSingleCardMutation, UpdateSettingSingleCardMutationVariables>;
export const UpdateSettingSortQuotesDocument = gql`
    mutation updateSettingSortQuotes($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {sort_quotes: $value}
  ) {
    user_id
    sort_quotes
  }
}
    `;
export type UpdateSettingSortQuotesMutationFn = Apollo.MutationFunction<UpdateSettingSortQuotesMutation, UpdateSettingSortQuotesMutationVariables>;

/**
 * __useUpdateSettingSortQuotesMutation__
 *
 * To run a mutation, you first call `useUpdateSettingSortQuotesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingSortQuotesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingSortQuotesMutation, { data, loading, error }] = useUpdateSettingSortQuotesMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingSortQuotesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingSortQuotesMutation, UpdateSettingSortQuotesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingSortQuotesMutation, UpdateSettingSortQuotesMutationVariables>(UpdateSettingSortQuotesDocument, options);
      }
export type UpdateSettingSortQuotesMutationHookResult = ReturnType<typeof useUpdateSettingSortQuotesMutation>;
export type UpdateSettingSortQuotesMutationResult = Apollo.MutationResult<UpdateSettingSortQuotesMutation>;
export type UpdateSettingSortQuotesMutationOptions = Apollo.BaseMutationOptions<UpdateSettingSortQuotesMutation, UpdateSettingSortQuotesMutationVariables>;
export const UpdateSettingCustomContentDocument = gql`
    mutation updateSettingCustomContent($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {custom_content: $value}
  ) {
    user_id
    custom_content
  }
}
    `;
export type UpdateSettingCustomContentMutationFn = Apollo.MutationFunction<UpdateSettingCustomContentMutation, UpdateSettingCustomContentMutationVariables>;

/**
 * __useUpdateSettingCustomContentMutation__
 *
 * To run a mutation, you first call `useUpdateSettingCustomContentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingCustomContentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingCustomContentMutation, { data, loading, error }] = useUpdateSettingCustomContentMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingCustomContentMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingCustomContentMutation, UpdateSettingCustomContentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingCustomContentMutation, UpdateSettingCustomContentMutationVariables>(UpdateSettingCustomContentDocument, options);
      }
export type UpdateSettingCustomContentMutationHookResult = ReturnType<typeof useUpdateSettingCustomContentMutation>;
export type UpdateSettingCustomContentMutationResult = Apollo.MutationResult<UpdateSettingCustomContentMutation>;
export type UpdateSettingCustomContentMutationOptions = Apollo.BaseMutationOptions<UpdateSettingCustomContentMutation, UpdateSettingCustomContentMutationVariables>;
export const UpdateSettingCampaignShowDeckIdDocument = gql`
    mutation updateSettingCampaignShowDeckId($userId: String!, $value: Boolean!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _set: {campaign_show_deck_id: $value}
  ) {
    user_id
    campaign_show_deck_id
  }
}
    `;
export type UpdateSettingCampaignShowDeckIdMutationFn = Apollo.MutationFunction<UpdateSettingCampaignShowDeckIdMutation, UpdateSettingCampaignShowDeckIdMutationVariables>;

/**
 * __useUpdateSettingCampaignShowDeckIdMutation__
 *
 * To run a mutation, you first call `useUpdateSettingCampaignShowDeckIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSettingCampaignShowDeckIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSettingCampaignShowDeckIdMutation, { data, loading, error }] = useUpdateSettingCampaignShowDeckIdMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useUpdateSettingCampaignShowDeckIdMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSettingCampaignShowDeckIdMutation, UpdateSettingCampaignShowDeckIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSettingCampaignShowDeckIdMutation, UpdateSettingCampaignShowDeckIdMutationVariables>(UpdateSettingCampaignShowDeckIdDocument, options);
      }
export type UpdateSettingCampaignShowDeckIdMutationHookResult = ReturnType<typeof useUpdateSettingCampaignShowDeckIdMutation>;
export type UpdateSettingCampaignShowDeckIdMutationResult = Apollo.MutationResult<UpdateSettingCampaignShowDeckIdMutation>;
export type UpdateSettingCampaignShowDeckIdMutationOptions = Apollo.BaseMutationOptions<UpdateSettingCampaignShowDeckIdMutation, UpdateSettingCampaignShowDeckIdMutationVariables>;
export const UpsertSettingsDocument = gql`
    mutation upsertSettings($userId: String!, $in_collection: jsonb!, $show_spoilers: jsonb!, $onboarding: jsonb!, $alphabetize: Boolean!, $colorblind: Boolean!, $ignore_collection: Boolean!, $single_card: Boolean!, $sort_quotes: Boolean!, $custom_content: Boolean!, $campaign_show_deck_id: Boolean!) {
  insert_user_settings_one(
    object: {user_id: $userId, alphabetize: $alphabetize, colorblind: $colorblind, ignore_collection: $ignore_collection, single_card: $single_card, sort_quotes: $sort_quotes, custom_content: $custom_content, campaign_show_deck_id: $campaign_show_deck_id, in_collection: $in_collection, show_spoilers: $show_spoilers, onboarding: $onboarding}
    on_conflict: {constraint: user_settings_pkey, update_columns: [alphabetize, colorblind, ignore_collection, single_card, sort_quotes, custom_content, campaign_show_deck_id, in_collection, show_spoilers, onboarding]}
  ) {
    user_id
    alphabetize
    colorblind
    ignore_collection
    single_card
    sort_quotes
    custom_content
    campaign_show_deck_id
    onboarding
    in_collection
    show_spoilers
  }
}
    `;
export type UpsertSettingsMutationFn = Apollo.MutationFunction<UpsertSettingsMutation, UpsertSettingsMutationVariables>;

/**
 * __useUpsertSettingsMutation__
 *
 * To run a mutation, you first call `useUpsertSettingsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertSettingsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertSettingsMutation, { data, loading, error }] = useUpsertSettingsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      in_collection: // value for 'in_collection'
 *      show_spoilers: // value for 'show_spoilers'
 *      onboarding: // value for 'onboarding'
 *      alphabetize: // value for 'alphabetize'
 *      colorblind: // value for 'colorblind'
 *      ignore_collection: // value for 'ignore_collection'
 *      single_card: // value for 'single_card'
 *      sort_quotes: // value for 'sort_quotes'
 *      custom_content: // value for 'custom_content'
 *      campaign_show_deck_id: // value for 'campaign_show_deck_id'
 *   },
 * });
 */
export function useUpsertSettingsMutation(baseOptions?: Apollo.MutationHookOptions<UpsertSettingsMutation, UpsertSettingsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertSettingsMutation, UpsertSettingsMutationVariables>(UpsertSettingsDocument, options);
      }
export type UpsertSettingsMutationHookResult = ReturnType<typeof useUpsertSettingsMutation>;
export type UpsertSettingsMutationResult = Apollo.MutationResult<UpsertSettingsMutation>;
export type UpsertSettingsMutationOptions = Apollo.BaseMutationOptions<UpsertSettingsMutation, UpsertSettingsMutationVariables>;
export const UpdateInCollectionDocument = gql`
    mutation updateInCollection($userId: String!, $update: jsonb!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _append: {in_collection: $update}
  ) {
    user_id
    in_collection
  }
}
    `;
export type UpdateInCollectionMutationFn = Apollo.MutationFunction<UpdateInCollectionMutation, UpdateInCollectionMutationVariables>;

/**
 * __useUpdateInCollectionMutation__
 *
 * To run a mutation, you first call `useUpdateInCollectionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInCollectionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInCollectionMutation, { data, loading, error }] = useUpdateInCollectionMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useUpdateInCollectionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInCollectionMutation, UpdateInCollectionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInCollectionMutation, UpdateInCollectionMutationVariables>(UpdateInCollectionDocument, options);
      }
export type UpdateInCollectionMutationHookResult = ReturnType<typeof useUpdateInCollectionMutation>;
export type UpdateInCollectionMutationResult = Apollo.MutationResult<UpdateInCollectionMutation>;
export type UpdateInCollectionMutationOptions = Apollo.BaseMutationOptions<UpdateInCollectionMutation, UpdateInCollectionMutationVariables>;
export const UpdateShowSpoilersDocument = gql`
    mutation updateShowSpoilers($userId: String!, $update: jsonb!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _append: {show_spoilers: $update}
  ) {
    user_id
    show_spoilers
  }
}
    `;
export type UpdateShowSpoilersMutationFn = Apollo.MutationFunction<UpdateShowSpoilersMutation, UpdateShowSpoilersMutationVariables>;

/**
 * __useUpdateShowSpoilersMutation__
 *
 * To run a mutation, you first call `useUpdateShowSpoilersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateShowSpoilersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateShowSpoilersMutation, { data, loading, error }] = useUpdateShowSpoilersMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useUpdateShowSpoilersMutation(baseOptions?: Apollo.MutationHookOptions<UpdateShowSpoilersMutation, UpdateShowSpoilersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateShowSpoilersMutation, UpdateShowSpoilersMutationVariables>(UpdateShowSpoilersDocument, options);
      }
export type UpdateShowSpoilersMutationHookResult = ReturnType<typeof useUpdateShowSpoilersMutation>;
export type UpdateShowSpoilersMutationResult = Apollo.MutationResult<UpdateShowSpoilersMutation>;
export type UpdateShowSpoilersMutationOptions = Apollo.BaseMutationOptions<UpdateShowSpoilersMutation, UpdateShowSpoilersMutationVariables>;
export const UpdateOnboardingDocument = gql`
    mutation updateOnboarding($userId: String!, $update: jsonb!) {
  update_user_settings_by_pk(
    pk_columns: {user_id: $userId}
    _append: {onboarding: $update}
  ) {
    user_id
    onboarding
  }
}
    `;
export type UpdateOnboardingMutationFn = Apollo.MutationFunction<UpdateOnboardingMutation, UpdateOnboardingMutationVariables>;

/**
 * __useUpdateOnboardingMutation__
 *
 * To run a mutation, you first call `useUpdateOnboardingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateOnboardingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateOnboardingMutation, { data, loading, error }] = useUpdateOnboardingMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useUpdateOnboardingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateOnboardingMutation, UpdateOnboardingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateOnboardingMutation, UpdateOnboardingMutationVariables>(UpdateOnboardingDocument, options);
      }
export type UpdateOnboardingMutationHookResult = ReturnType<typeof useUpdateOnboardingMutation>;
export type UpdateOnboardingMutationResult = Apollo.MutationResult<UpdateOnboardingMutation>;
export type UpdateOnboardingMutationOptions = Apollo.BaseMutationOptions<UpdateOnboardingMutation, UpdateOnboardingMutationVariables>;
export const GetProfileDocument = gql`
    query getProfile($userId: String!) {
  users_by_pk(id: $userId) {
    id
    handle
    friends {
      user {
        ...UserInfo
      }
    }
    sent_requests {
      user {
        ...UserInfo
      }
    }
    received_requests {
      user {
        ...UserInfo
      }
    }
    flags {
      flag
    }
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useGetProfileQuery__
 *
 * To run a query within a React component, call `useGetProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProfileQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetProfileQuery(baseOptions: Apollo.QueryHookOptions<GetProfileQuery, GetProfileQueryVariables> & ({ variables: GetProfileQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
      }
export function useGetProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProfileQuery, GetProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
        }
export function useGetProfileSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetProfileQuery, GetProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProfileQuery, GetProfileQueryVariables>(GetProfileDocument, options);
        }
export type GetProfileQueryHookResult = ReturnType<typeof useGetProfileQuery>;
export type GetProfileLazyQueryHookResult = ReturnType<typeof useGetProfileLazyQuery>;
export type GetProfileSuspenseQueryHookResult = ReturnType<typeof useGetProfileSuspenseQuery>;
export type GetProfileQueryResult = Apollo.QueryResult<GetProfileQuery, GetProfileQueryVariables>;
export const GetDeleteInformationDocument = gql`
    query getDeleteInformation($userId: String!) {
  users_by_pk(id: $userId) {
    id
    handle
    arkhamDBDeckCount: all_decks_aggregate(
      where: {_and: [{next_deck_id: {_is_null: true}}, {arkhamdb_id: {_is_null: false}}]}
    ) {
      aggregate {
        count
      }
    }
    localDeckCount: all_decks_aggregate(
      where: {_and: [{next_deck_id: {_is_null: true}}, {arkhamdb_id: {_is_null: true}}]}
    ) {
      aggregate {
        count
      }
    }
    createdCampaignCount: campaigns_aggregate(
      where: {campaign: {owner_id: {_eq: $userId}}}
    ) {
      aggregate {
        count
      }
      nodes {
        campaign {
          id
          name
          cycleCode
        }
      }
    }
    joinedCampaignCount: campaigns_aggregate(
      where: {campaign: {owner_id: {_neq: $userId}}}
    ) {
      aggregate {
        count
      }
      nodes {
        campaign {
          id
          name
          cycleCode
        }
      }
    }
  }
}
    `;

/**
 * __useGetDeleteInformationQuery__
 *
 * To run a query within a React component, call `useGetDeleteInformationQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetDeleteInformationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetDeleteInformationQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetDeleteInformationQuery(baseOptions: Apollo.QueryHookOptions<GetDeleteInformationQuery, GetDeleteInformationQueryVariables> & ({ variables: GetDeleteInformationQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>(GetDeleteInformationDocument, options);
      }
export function useGetDeleteInformationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>(GetDeleteInformationDocument, options);
        }
export function useGetDeleteInformationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>(GetDeleteInformationDocument, options);
        }
export type GetDeleteInformationQueryHookResult = ReturnType<typeof useGetDeleteInformationQuery>;
export type GetDeleteInformationLazyQueryHookResult = ReturnType<typeof useGetDeleteInformationLazyQuery>;
export type GetDeleteInformationSuspenseQueryHookResult = ReturnType<typeof useGetDeleteInformationSuspenseQuery>;
export type GetDeleteInformationQueryResult = Apollo.QueryResult<GetDeleteInformationQuery, GetDeleteInformationQueryVariables>;
export const UpdateHandleDocument = gql`
    mutation updateHandle($handle: String!) {
  updateHandle(args: {handle: $handle}) {
    success
    user {
      id
      handle
    }
  }
}
    `;
export type UpdateHandleMutationFn = Apollo.MutationFunction<UpdateHandleMutation, UpdateHandleMutationVariables>;

/**
 * __useUpdateHandleMutation__
 *
 * To run a mutation, you first call `useUpdateHandleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHandleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHandleMutation, { data, loading, error }] = useUpdateHandleMutation({
 *   variables: {
 *      handle: // value for 'handle'
 *   },
 * });
 */
export function useUpdateHandleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHandleMutation, UpdateHandleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateHandleMutation, UpdateHandleMutationVariables>(UpdateHandleDocument, options);
      }
export type UpdateHandleMutationHookResult = ReturnType<typeof useUpdateHandleMutation>;
export type UpdateHandleMutationResult = Apollo.MutationResult<UpdateHandleMutation>;
export type UpdateHandleMutationOptions = Apollo.BaseMutationOptions<UpdateHandleMutation, UpdateHandleMutationVariables>;
export const UpdateFriendRequestDocument = gql`
    mutation updateFriendRequest($userId: String!, $action: FriendRequestAction!) {
  updateFriendRequest(args: {userId: $userId, action: $action}) {
    success
  }
}
    `;
export type UpdateFriendRequestMutationFn = Apollo.MutationFunction<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>;

/**
 * __useUpdateFriendRequestMutation__
 *
 * To run a mutation, you first call `useUpdateFriendRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFriendRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFriendRequestMutation, { data, loading, error }] = useUpdateFriendRequestMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      action: // value for 'action'
 *   },
 * });
 */
export function useUpdateFriendRequestMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>(UpdateFriendRequestDocument, options);
      }
export type UpdateFriendRequestMutationHookResult = ReturnType<typeof useUpdateFriendRequestMutation>;
export type UpdateFriendRequestMutationResult = Apollo.MutationResult<UpdateFriendRequestMutation>;
export type UpdateFriendRequestMutationOptions = Apollo.BaseMutationOptions<UpdateFriendRequestMutation, UpdateFriendRequestMutationVariables>;
export const SearchUsersDocument = gql`
    query searchUsers($search: String!, $continueToken: String) {
  results: usersSearch(args: {search: $search, continueToken: $continueToken}) {
    users {
      id
      handle
    }
    hasMore
  }
}
    `;

/**
 * __useSearchUsersQuery__
 *
 * To run a query within a React component, call `useSearchUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchUsersQuery({
 *   variables: {
 *      search: // value for 'search'
 *      continueToken: // value for 'continueToken'
 *   },
 * });
 */
export function useSearchUsersQuery(baseOptions: Apollo.QueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables> & ({ variables: SearchUsersQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
      }
export function useSearchUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export function useSearchUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SearchUsersQuery, SearchUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchUsersQuery, SearchUsersQueryVariables>(SearchUsersDocument, options);
        }
export type SearchUsersQueryHookResult = ReturnType<typeof useSearchUsersQuery>;
export type SearchUsersLazyQueryHookResult = ReturnType<typeof useSearchUsersLazyQuery>;
export type SearchUsersSuspenseQueryHookResult = ReturnType<typeof useSearchUsersSuspenseQuery>;
export type SearchUsersQueryResult = Apollo.QueryResult<SearchUsersQuery, SearchUsersQueryVariables>;
export const EditCampaignAccessDocument = gql`
    mutation editCampaignAccess($campaignId: String!, $serverId: Int!, $users: [String!]!, $action: EditAccessAction!) {
  editCampaignAccess(
    args: {campaignId: $campaignId, serverId: $serverId, users: $users, action: $action}
  ) {
    campaignId
  }
}
    `;
export type EditCampaignAccessMutationFn = Apollo.MutationFunction<EditCampaignAccessMutation, EditCampaignAccessMutationVariables>;

/**
 * __useEditCampaignAccessMutation__
 *
 * To run a mutation, you first call `useEditCampaignAccessMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditCampaignAccessMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editCampaignAccessMutation, { data, loading, error }] = useEditCampaignAccessMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      serverId: // value for 'serverId'
 *      users: // value for 'users'
 *      action: // value for 'action'
 *   },
 * });
 */
export function useEditCampaignAccessMutation(baseOptions?: Apollo.MutationHookOptions<EditCampaignAccessMutation, EditCampaignAccessMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditCampaignAccessMutation, EditCampaignAccessMutationVariables>(EditCampaignAccessDocument, options);
      }
export type EditCampaignAccessMutationHookResult = ReturnType<typeof useEditCampaignAccessMutation>;
export type EditCampaignAccessMutationResult = Apollo.MutationResult<EditCampaignAccessMutation>;
export type EditCampaignAccessMutationOptions = Apollo.BaseMutationOptions<EditCampaignAccessMutation, EditCampaignAccessMutationVariables>;
export const DeleteCampaignDocument = gql`
    mutation deleteCampaign($campaignId: String!, $serverId: Int!) {
  deleteCampaign(args: {campaignId: $campaignId, serverId: $serverId}) {
    campaignId
  }
}
    `;
export type DeleteCampaignMutationFn = Apollo.MutationFunction<DeleteCampaignMutation, DeleteCampaignMutationVariables>;

/**
 * __useDeleteCampaignMutation__
 *
 * To run a mutation, you first call `useDeleteCampaignMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCampaignMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCampaignMutation, { data, loading, error }] = useDeleteCampaignMutation({
 *   variables: {
 *      campaignId: // value for 'campaignId'
 *      serverId: // value for 'serverId'
 *   },
 * });
 */
export function useDeleteCampaignMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCampaignMutation, DeleteCampaignMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCampaignMutation, DeleteCampaignMutationVariables>(DeleteCampaignDocument, options);
      }
export type DeleteCampaignMutationHookResult = ReturnType<typeof useDeleteCampaignMutation>;
export type DeleteCampaignMutationResult = Apollo.MutationResult<DeleteCampaignMutation>;
export type DeleteCampaignMutationOptions = Apollo.BaseMutationOptions<DeleteCampaignMutation, DeleteCampaignMutationVariables>;
export const DeleteInvestigatorDecksDocument = gql`
    mutation deleteInvestigatorDecks($campaign_id: Int!, $investigator: String!, $user_id: String!) {
  delete_campaign_deck(
    where: {campaign_id: {_eq: $campaign_id}, investigator: {_eq: $investigator}, owner_id: {_eq: $user_id}}
  ) {
    returning {
      id
      campaign_id
      arkhamdb_id
      local_uuid
      investigator
      owner_id
    }
  }
}
    `;
export type DeleteInvestigatorDecksMutationFn = Apollo.MutationFunction<DeleteInvestigatorDecksMutation, DeleteInvestigatorDecksMutationVariables>;

/**
 * __useDeleteInvestigatorDecksMutation__
 *
 * To run a mutation, you first call `useDeleteInvestigatorDecksMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteInvestigatorDecksMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteInvestigatorDecksMutation, { data, loading, error }] = useDeleteInvestigatorDecksMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      user_id: // value for 'user_id'
 *   },
 * });
 */
export function useDeleteInvestigatorDecksMutation(baseOptions?: Apollo.MutationHookOptions<DeleteInvestigatorDecksMutation, DeleteInvestigatorDecksMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteInvestigatorDecksMutation, DeleteInvestigatorDecksMutationVariables>(DeleteInvestigatorDecksDocument, options);
      }
export type DeleteInvestigatorDecksMutationHookResult = ReturnType<typeof useDeleteInvestigatorDecksMutation>;
export type DeleteInvestigatorDecksMutationResult = Apollo.MutationResult<DeleteInvestigatorDecksMutation>;
export type DeleteInvestigatorDecksMutationOptions = Apollo.BaseMutationOptions<DeleteInvestigatorDecksMutation, DeleteInvestigatorDecksMutationVariables>;
export const SetBinaryAchievementDocument = gql`
    mutation setBinaryAchievement($campaign_id: Int!, $id: String!, $value: Boolean!) {
  insert_guide_achievement_one(
    object: {campaign_id: $campaign_id, id: $id, type: "binary", bool_value: $value}
    on_conflict: {constraint: guide_achievement_pkey, update_columns: [bool_value]}
  ) {
    ...GuideAchievement
  }
}
    ${GuideAchievementFragmentDoc}`;
export type SetBinaryAchievementMutationFn = Apollo.MutationFunction<SetBinaryAchievementMutation, SetBinaryAchievementMutationVariables>;

/**
 * __useSetBinaryAchievementMutation__
 *
 * To run a mutation, you first call `useSetBinaryAchievementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetBinaryAchievementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setBinaryAchievementMutation, { data, loading, error }] = useSetBinaryAchievementMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      id: // value for 'id'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useSetBinaryAchievementMutation(baseOptions?: Apollo.MutationHookOptions<SetBinaryAchievementMutation, SetBinaryAchievementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetBinaryAchievementMutation, SetBinaryAchievementMutationVariables>(SetBinaryAchievementDocument, options);
      }
export type SetBinaryAchievementMutationHookResult = ReturnType<typeof useSetBinaryAchievementMutation>;
export type SetBinaryAchievementMutationResult = Apollo.MutationResult<SetBinaryAchievementMutation>;
export type SetBinaryAchievementMutationOptions = Apollo.BaseMutationOptions<SetBinaryAchievementMutation, SetBinaryAchievementMutationVariables>;
export const SetCountAchievementDocument = gql`
    mutation setCountAchievement($campaign_id: Int!, $id: String!, $value: Int!) {
  insert_guide_achievement_one(
    object: {campaign_id: $campaign_id, id: $id, type: "count", value: $value}
    on_conflict: {constraint: guide_achievement_pkey, update_columns: [value]}
  ) {
    ...GuideAchievement
  }
}
    ${GuideAchievementFragmentDoc}`;
export type SetCountAchievementMutationFn = Apollo.MutationFunction<SetCountAchievementMutation, SetCountAchievementMutationVariables>;

/**
 * __useSetCountAchievementMutation__
 *
 * To run a mutation, you first call `useSetCountAchievementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSetCountAchievementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [setCountAchievementMutation, { data, loading, error }] = useSetCountAchievementMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      id: // value for 'id'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useSetCountAchievementMutation(baseOptions?: Apollo.MutationHookOptions<SetCountAchievementMutation, SetCountAchievementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SetCountAchievementMutation, SetCountAchievementMutationVariables>(SetCountAchievementDocument, options);
      }
export type SetCountAchievementMutationHookResult = ReturnType<typeof useSetCountAchievementMutation>;
export type SetCountAchievementMutationResult = Apollo.MutationResult<SetCountAchievementMutation>;
export type SetCountAchievementMutationOptions = Apollo.BaseMutationOptions<SetCountAchievementMutation, SetCountAchievementMutationVariables>;
export const AddGuideInputDocument = gql`
    mutation addGuideInput($id: String!, $campaign_id: Int!, $type: String!, $scenario: String, $step: String, $payload: jsonb) {
  insert_guide_input_one(
    object: {id: $id, campaign_id: $campaign_id, scenario: $scenario, step: $step, type: $type, payload: $payload}
    on_conflict: {constraint: guide_input_pkey, update_columns: [payload]}
  ) {
    ...GuideInput
  }
}
    ${GuideInputFragmentDoc}`;
export type AddGuideInputMutationFn = Apollo.MutationFunction<AddGuideInputMutation, AddGuideInputMutationVariables>;

/**
 * __useAddGuideInputMutation__
 *
 * To run a mutation, you first call `useAddGuideInputMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddGuideInputMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addGuideInputMutation, { data, loading, error }] = useAddGuideInputMutation({
 *   variables: {
 *      id: // value for 'id'
 *      campaign_id: // value for 'campaign_id'
 *      type: // value for 'type'
 *      scenario: // value for 'scenario'
 *      step: // value for 'step'
 *      payload: // value for 'payload'
 *   },
 * });
 */
export function useAddGuideInputMutation(baseOptions?: Apollo.MutationHookOptions<AddGuideInputMutation, AddGuideInputMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddGuideInputMutation, AddGuideInputMutationVariables>(AddGuideInputDocument, options);
      }
export type AddGuideInputMutationHookResult = ReturnType<typeof useAddGuideInputMutation>;
export type AddGuideInputMutationResult = Apollo.MutationResult<AddGuideInputMutation>;
export type AddGuideInputMutationOptions = Apollo.BaseMutationOptions<AddGuideInputMutation, AddGuideInputMutationVariables>;
export const RemoveGuideInputsDocument = gql`
    mutation removeGuideInputs($campaign_id: Int!, $ids: [String!]!) {
  delete_guide_input(where: {campaign_id: {_eq: $campaign_id}, id: {_in: $ids}}) {
    affected_rows
    returning {
      id
      campaign_id
    }
  }
}
    `;
export type RemoveGuideInputsMutationFn = Apollo.MutationFunction<RemoveGuideInputsMutation, RemoveGuideInputsMutationVariables>;

/**
 * __useRemoveGuideInputsMutation__
 *
 * To run a mutation, you first call `useRemoveGuideInputsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveGuideInputsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeGuideInputsMutation, { data, loading, error }] = useRemoveGuideInputsMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useRemoveGuideInputsMutation(baseOptions?: Apollo.MutationHookOptions<RemoveGuideInputsMutation, RemoveGuideInputsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveGuideInputsMutation, RemoveGuideInputsMutationVariables>(RemoveGuideInputsDocument, options);
      }
export type RemoveGuideInputsMutationHookResult = ReturnType<typeof useRemoveGuideInputsMutation>;
export type RemoveGuideInputsMutationResult = Apollo.MutationResult<RemoveGuideInputsMutation>;
export type RemoveGuideInputsMutationOptions = Apollo.BaseMutationOptions<RemoveGuideInputsMutation, RemoveGuideInputsMutationVariables>;
export const UpdateInvestigatorTraumaDocument = gql`
    mutation updateInvestigatorTrauma($campaign_id: Int!, $investigator: String!, $physical: Int, $mental: Int, $killed: Boolean, $insane: Boolean) {
  insert_investigator_data_one(
    object: {campaign_id: $campaign_id, investigator: $investigator, physical: $physical, mental: $mental, killed: $killed, insane: $insane}
    on_conflict: {constraint: investigator_data_pkey, update_columns: [physical, mental, killed, insane]}
  ) {
    ...MiniInvestigatorData
  }
}
    ${MiniInvestigatorDataFragmentDoc}`;
export type UpdateInvestigatorTraumaMutationFn = Apollo.MutationFunction<UpdateInvestigatorTraumaMutation, UpdateInvestigatorTraumaMutationVariables>;

/**
 * __useUpdateInvestigatorTraumaMutation__
 *
 * To run a mutation, you first call `useUpdateInvestigatorTraumaMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvestigatorTraumaMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvestigatorTraumaMutation, { data, loading, error }] = useUpdateInvestigatorTraumaMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      physical: // value for 'physical'
 *      mental: // value for 'mental'
 *      killed: // value for 'killed'
 *      insane: // value for 'insane'
 *   },
 * });
 */
export function useUpdateInvestigatorTraumaMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvestigatorTraumaMutation, UpdateInvestigatorTraumaMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvestigatorTraumaMutation, UpdateInvestigatorTraumaMutationVariables>(UpdateInvestigatorTraumaDocument, options);
      }
export type UpdateInvestigatorTraumaMutationHookResult = ReturnType<typeof useUpdateInvestigatorTraumaMutation>;
export type UpdateInvestigatorTraumaMutationResult = Apollo.MutationResult<UpdateInvestigatorTraumaMutation>;
export type UpdateInvestigatorTraumaMutationOptions = Apollo.BaseMutationOptions<UpdateInvestigatorTraumaMutation, UpdateInvestigatorTraumaMutationVariables>;
export const UpdateInvestigatorDataDocument = gql`
    mutation updateInvestigatorData($campaign_id: Int!, $investigator: String!, $physical: Int, $mental: Int, $killed: Boolean, $insane: Boolean, $addedCards: jsonb, $availableXp: Int, $specialXp: jsonb, $storyAssets: jsonb, $ignoreStoryAssets: jsonb, $removedCards: jsonb, $cardCounts: jsonb) {
  insert_investigator_data_one(
    object: {campaign_id: $campaign_id, investigator: $investigator, physical: $physical, mental: $mental, killed: $killed, insane: $insane, cardCounts: $cardCounts, addedCards: $addedCards, storyAssets: $storyAssets, ignoreStoryAssets: $ignoreStoryAssets, removedCards: $removedCards, specialXp: $specialXp, availableXp: $availableXp}
    on_conflict: {constraint: investigator_data_pkey, update_columns: [physical, mental, killed, insane, addedCards, removedCards, storyAssets, ignoreStoryAssets, cardCounts, availableXp, specialXp]}
  ) {
    ...FullGuideInvestigatorData
  }
}
    ${FullGuideInvestigatorDataFragmentDoc}`;
export type UpdateInvestigatorDataMutationFn = Apollo.MutationFunction<UpdateInvestigatorDataMutation, UpdateInvestigatorDataMutationVariables>;

/**
 * __useUpdateInvestigatorDataMutation__
 *
 * To run a mutation, you first call `useUpdateInvestigatorDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateInvestigatorDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateInvestigatorDataMutation, { data, loading, error }] = useUpdateInvestigatorDataMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      physical: // value for 'physical'
 *      mental: // value for 'mental'
 *      killed: // value for 'killed'
 *      insane: // value for 'insane'
 *      addedCards: // value for 'addedCards'
 *      availableXp: // value for 'availableXp'
 *      specialXp: // value for 'specialXp'
 *      storyAssets: // value for 'storyAssets'
 *      ignoreStoryAssets: // value for 'ignoreStoryAssets'
 *      removedCards: // value for 'removedCards'
 *      cardCounts: // value for 'cardCounts'
 *   },
 * });
 */
export function useUpdateInvestigatorDataMutation(baseOptions?: Apollo.MutationHookOptions<UpdateInvestigatorDataMutation, UpdateInvestigatorDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateInvestigatorDataMutation, UpdateInvestigatorDataMutationVariables>(UpdateInvestigatorDataDocument, options);
      }
export type UpdateInvestigatorDataMutationHookResult = ReturnType<typeof useUpdateInvestigatorDataMutation>;
export type UpdateInvestigatorDataMutationResult = Apollo.MutationResult<UpdateInvestigatorDataMutation>;
export type UpdateInvestigatorDataMutationOptions = Apollo.BaseMutationOptions<UpdateInvestigatorDataMutation, UpdateInvestigatorDataMutationVariables>;
export const UpdateSpentXpDocument = gql`
    mutation updateSpentXp($campaign_id: Int!, $investigator: String!, $spent_xp: Int!) {
  insert_investigator_data_one(
    object: {campaign_id: $campaign_id, investigator: $investigator, spentXp: $spent_xp}
    on_conflict: {constraint: investigator_data_pkey, update_columns: [spentXp]}
  ) {
    id
    campaign_id
    investigator
    spentXp
  }
}
    `;
export type UpdateSpentXpMutationFn = Apollo.MutationFunction<UpdateSpentXpMutation, UpdateSpentXpMutationVariables>;

/**
 * __useUpdateSpentXpMutation__
 *
 * To run a mutation, you first call `useUpdateSpentXpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSpentXpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSpentXpMutation, { data, loading, error }] = useUpdateSpentXpMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      spent_xp: // value for 'spent_xp'
 *   },
 * });
 */
export function useUpdateSpentXpMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSpentXpMutation, UpdateSpentXpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSpentXpMutation, UpdateSpentXpMutationVariables>(UpdateSpentXpDocument, options);
      }
export type UpdateSpentXpMutationHookResult = ReturnType<typeof useUpdateSpentXpMutation>;
export type UpdateSpentXpMutationResult = Apollo.MutationResult<UpdateSpentXpMutation>;
export type UpdateSpentXpMutationOptions = Apollo.BaseMutationOptions<UpdateSpentXpMutation, UpdateSpentXpMutationVariables>;
export const UpdateAvailableXpDocument = gql`
    mutation updateAvailableXp($campaign_id: Int!, $investigator: String!, $available_xp: Int!) {
  insert_investigator_data_one(
    object: {campaign_id: $campaign_id, investigator: $investigator, availableXp: $available_xp}
    on_conflict: {constraint: investigator_data_pkey, update_columns: [availableXp]}
  ) {
    id
    campaign_id
    investigator
    availableXp
  }
}
    `;
export type UpdateAvailableXpMutationFn = Apollo.MutationFunction<UpdateAvailableXpMutation, UpdateAvailableXpMutationVariables>;

/**
 * __useUpdateAvailableXpMutation__
 *
 * To run a mutation, you first call `useUpdateAvailableXpMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAvailableXpMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAvailableXpMutation, { data, loading, error }] = useUpdateAvailableXpMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *      available_xp: // value for 'available_xp'
 *   },
 * });
 */
export function useUpdateAvailableXpMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAvailableXpMutation, UpdateAvailableXpMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAvailableXpMutation, UpdateAvailableXpMutationVariables>(UpdateAvailableXpDocument, options);
      }
export type UpdateAvailableXpMutationHookResult = ReturnType<typeof useUpdateAvailableXpMutation>;
export type UpdateAvailableXpMutationResult = Apollo.MutationResult<UpdateAvailableXpMutation>;
export type UpdateAvailableXpMutationOptions = Apollo.BaseMutationOptions<UpdateAvailableXpMutation, UpdateAvailableXpMutationVariables>;
export const UpdateCampaignArchivedDocument = gql`
    mutation updateCampaignArchived($campaign_id: Int!, $archived: Boolean!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {archived: $archived}
  ) {
    id
    uuid
    archived
  }
}
    `;
export type UpdateCampaignArchivedMutationFn = Apollo.MutationFunction<UpdateCampaignArchivedMutation, UpdateCampaignArchivedMutationVariables>;

/**
 * __useUpdateCampaignArchivedMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignArchivedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignArchivedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignArchivedMutation, { data, loading, error }] = useUpdateCampaignArchivedMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      archived: // value for 'archived'
 *   },
 * });
 */
export function useUpdateCampaignArchivedMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignArchivedMutation, UpdateCampaignArchivedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignArchivedMutation, UpdateCampaignArchivedMutationVariables>(UpdateCampaignArchivedDocument, options);
      }
export type UpdateCampaignArchivedMutationHookResult = ReturnType<typeof useUpdateCampaignArchivedMutation>;
export type UpdateCampaignArchivedMutationResult = Apollo.MutationResult<UpdateCampaignArchivedMutation>;
export type UpdateCampaignArchivedMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignArchivedMutation, UpdateCampaignArchivedMutationVariables>;
export const UpdateWeaknessSetDocument = gql`
    mutation updateWeaknessSet($campaign_id: Int!, $weakness_set: jsonb!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {weaknessSet: $weakness_set}
  ) {
    id
    uuid
    weaknessSet
  }
}
    `;
export type UpdateWeaknessSetMutationFn = Apollo.MutationFunction<UpdateWeaknessSetMutation, UpdateWeaknessSetMutationVariables>;

/**
 * __useUpdateWeaknessSetMutation__
 *
 * To run a mutation, you first call `useUpdateWeaknessSetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateWeaknessSetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateWeaknessSetMutation, { data, loading, error }] = useUpdateWeaknessSetMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      weakness_set: // value for 'weakness_set'
 *   },
 * });
 */
export function useUpdateWeaknessSetMutation(baseOptions?: Apollo.MutationHookOptions<UpdateWeaknessSetMutation, UpdateWeaknessSetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateWeaknessSetMutation, UpdateWeaknessSetMutationVariables>(UpdateWeaknessSetDocument, options);
      }
export type UpdateWeaknessSetMutationHookResult = ReturnType<typeof useUpdateWeaknessSetMutation>;
export type UpdateWeaknessSetMutationResult = Apollo.MutationResult<UpdateWeaknessSetMutation>;
export type UpdateWeaknessSetMutationOptions = Apollo.BaseMutationOptions<UpdateWeaknessSetMutation, UpdateWeaknessSetMutationVariables>;
export const UpdateTarotReadingDocument = gql`
    mutation updateTarotReading($campaign_id: Int!, $tarotReading: jsonb!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {tarot_reading: $tarotReading}
  ) {
    id
    uuid
    tarot_reading
  }
}
    `;
export type UpdateTarotReadingMutationFn = Apollo.MutationFunction<UpdateTarotReadingMutation, UpdateTarotReadingMutationVariables>;

/**
 * __useUpdateTarotReadingMutation__
 *
 * To run a mutation, you first call `useUpdateTarotReadingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTarotReadingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTarotReadingMutation, { data, loading, error }] = useUpdateTarotReadingMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      tarotReading: // value for 'tarotReading'
 *   },
 * });
 */
export function useUpdateTarotReadingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTarotReadingMutation, UpdateTarotReadingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTarotReadingMutation, UpdateTarotReadingMutationVariables>(UpdateTarotReadingDocument, options);
      }
export type UpdateTarotReadingMutationHookResult = ReturnType<typeof useUpdateTarotReadingMutation>;
export type UpdateTarotReadingMutationResult = Apollo.MutationResult<UpdateTarotReadingMutation>;
export type UpdateTarotReadingMutationOptions = Apollo.BaseMutationOptions<UpdateTarotReadingMutation, UpdateTarotReadingMutationVariables>;
export const UpdateCampaignDifficultyDocument = gql`
    mutation updateCampaignDifficulty($campaign_id: Int!, $difficulty: String) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {difficulty: $difficulty}
  ) {
    id
    uuid
    difficulty
  }
}
    `;
export type UpdateCampaignDifficultyMutationFn = Apollo.MutationFunction<UpdateCampaignDifficultyMutation, UpdateCampaignDifficultyMutationVariables>;

/**
 * __useUpdateCampaignDifficultyMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignDifficultyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignDifficultyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignDifficultyMutation, { data, loading, error }] = useUpdateCampaignDifficultyMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      difficulty: // value for 'difficulty'
 *   },
 * });
 */
export function useUpdateCampaignDifficultyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignDifficultyMutation, UpdateCampaignDifficultyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignDifficultyMutation, UpdateCampaignDifficultyMutationVariables>(UpdateCampaignDifficultyDocument, options);
      }
export type UpdateCampaignDifficultyMutationHookResult = ReturnType<typeof useUpdateCampaignDifficultyMutation>;
export type UpdateCampaignDifficultyMutationResult = Apollo.MutationResult<UpdateCampaignDifficultyMutation>;
export type UpdateCampaignDifficultyMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignDifficultyMutation, UpdateCampaignDifficultyMutationVariables>;
export const UpdateCampaignScenarioResultsDocument = gql`
    mutation updateCampaignScenarioResults($campaign_id: Int!, $scenarioResults: jsonb!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {scenarioResults: $scenarioResults}
  ) {
    id
    uuid
    scenarioResults
  }
}
    `;
export type UpdateCampaignScenarioResultsMutationFn = Apollo.MutationFunction<UpdateCampaignScenarioResultsMutation, UpdateCampaignScenarioResultsMutationVariables>;

/**
 * __useUpdateCampaignScenarioResultsMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignScenarioResultsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignScenarioResultsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignScenarioResultsMutation, { data, loading, error }] = useUpdateCampaignScenarioResultsMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      scenarioResults: // value for 'scenarioResults'
 *   },
 * });
 */
export function useUpdateCampaignScenarioResultsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignScenarioResultsMutation, UpdateCampaignScenarioResultsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignScenarioResultsMutation, UpdateCampaignScenarioResultsMutationVariables>(UpdateCampaignScenarioResultsDocument, options);
      }
export type UpdateCampaignScenarioResultsMutationHookResult = ReturnType<typeof useUpdateCampaignScenarioResultsMutation>;
export type UpdateCampaignScenarioResultsMutationResult = Apollo.MutationResult<UpdateCampaignScenarioResultsMutation>;
export type UpdateCampaignScenarioResultsMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignScenarioResultsMutation, UpdateCampaignScenarioResultsMutationVariables>;
export const UpdateCampaignGuideVersionDocument = gql`
    mutation updateCampaignGuideVersion($campaign_id: Int!, $guideVersion: Int!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {guide_version: $guideVersion}
  ) {
    id
    uuid
    guide_version
  }
}
    `;
export type UpdateCampaignGuideVersionMutationFn = Apollo.MutationFunction<UpdateCampaignGuideVersionMutation, UpdateCampaignGuideVersionMutationVariables>;

/**
 * __useUpdateCampaignGuideVersionMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignGuideVersionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignGuideVersionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignGuideVersionMutation, { data, loading, error }] = useUpdateCampaignGuideVersionMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      guideVersion: // value for 'guideVersion'
 *   },
 * });
 */
export function useUpdateCampaignGuideVersionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignGuideVersionMutation, UpdateCampaignGuideVersionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignGuideVersionMutation, UpdateCampaignGuideVersionMutationVariables>(UpdateCampaignGuideVersionDocument, options);
      }
export type UpdateCampaignGuideVersionMutationHookResult = ReturnType<typeof useUpdateCampaignGuideVersionMutation>;
export type UpdateCampaignGuideVersionMutationResult = Apollo.MutationResult<UpdateCampaignGuideVersionMutation>;
export type UpdateCampaignGuideVersionMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignGuideVersionMutation, UpdateCampaignGuideVersionMutationVariables>;
export const UpdateCampaignNotesDocument = gql`
    mutation updateCampaignNotes($campaign_id: Int!, $campaign_notes: jsonb!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {campaignNotes: $campaign_notes}
  ) {
    id
    uuid
    campaignNotes
  }
}
    `;
export type UpdateCampaignNotesMutationFn = Apollo.MutationFunction<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>;

/**
 * __useUpdateCampaignNotesMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignNotesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignNotesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignNotesMutation, { data, loading, error }] = useUpdateCampaignNotesMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      campaign_notes: // value for 'campaign_notes'
 *   },
 * });
 */
export function useUpdateCampaignNotesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>(UpdateCampaignNotesDocument, options);
      }
export type UpdateCampaignNotesMutationHookResult = ReturnType<typeof useUpdateCampaignNotesMutation>;
export type UpdateCampaignNotesMutationResult = Apollo.MutationResult<UpdateCampaignNotesMutation>;
export type UpdateCampaignNotesMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignNotesMutation, UpdateCampaignNotesMutationVariables>;
export const UpdateCampaignShowInterludesDocument = gql`
    mutation updateCampaignShowInterludes($campaign_id: Int!, $show_interludes: Boolean!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {showInterludes: $show_interludes}
  ) {
    id
    uuid
    showInterludes
  }
}
    `;
export type UpdateCampaignShowInterludesMutationFn = Apollo.MutationFunction<UpdateCampaignShowInterludesMutation, UpdateCampaignShowInterludesMutationVariables>;

/**
 * __useUpdateCampaignShowInterludesMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignShowInterludesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignShowInterludesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignShowInterludesMutation, { data, loading, error }] = useUpdateCampaignShowInterludesMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      show_interludes: // value for 'show_interludes'
 *   },
 * });
 */
export function useUpdateCampaignShowInterludesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignShowInterludesMutation, UpdateCampaignShowInterludesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignShowInterludesMutation, UpdateCampaignShowInterludesMutationVariables>(UpdateCampaignShowInterludesDocument, options);
      }
export type UpdateCampaignShowInterludesMutationHookResult = ReturnType<typeof useUpdateCampaignShowInterludesMutation>;
export type UpdateCampaignShowInterludesMutationResult = Apollo.MutationResult<UpdateCampaignShowInterludesMutation>;
export type UpdateCampaignShowInterludesMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignShowInterludesMutation, UpdateCampaignShowInterludesMutationVariables>;
export const UpdateChaosBagDocument = gql`
    mutation updateChaosBag($campaign_id: Int!, $chaos_bag: jsonb!) {
  update_campaign_by_pk(
    pk_columns: {id: $campaign_id}
    _set: {chaosBag: $chaos_bag}
  ) {
    id
    uuid
    chaosBag
  }
}
    `;
export type UpdateChaosBagMutationFn = Apollo.MutationFunction<UpdateChaosBagMutation, UpdateChaosBagMutationVariables>;

/**
 * __useUpdateChaosBagMutation__
 *
 * To run a mutation, you first call `useUpdateChaosBagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateChaosBagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateChaosBagMutation, { data, loading, error }] = useUpdateChaosBagMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      chaos_bag: // value for 'chaos_bag'
 *   },
 * });
 */
export function useUpdateChaosBagMutation(baseOptions?: Apollo.MutationHookOptions<UpdateChaosBagMutation, UpdateChaosBagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateChaosBagMutation, UpdateChaosBagMutationVariables>(UpdateChaosBagDocument, options);
      }
export type UpdateChaosBagMutationHookResult = ReturnType<typeof useUpdateChaosBagMutation>;
export type UpdateChaosBagMutationResult = Apollo.MutationResult<UpdateChaosBagMutation>;
export type UpdateChaosBagMutationOptions = Apollo.BaseMutationOptions<UpdateChaosBagMutation, UpdateChaosBagMutationVariables>;
export const UpdateCampaignNameDocument = gql`
    mutation updateCampaignName($campaign_id: Int!, $name: String!) {
  update_campaign_by_pk(pk_columns: {id: $campaign_id}, _set: {name: $name}) {
    id
    uuid
    name
  }
}
    `;
export type UpdateCampaignNameMutationFn = Apollo.MutationFunction<UpdateCampaignNameMutation, UpdateCampaignNameMutationVariables>;

/**
 * __useUpdateCampaignNameMutation__
 *
 * To run a mutation, you first call `useUpdateCampaignNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCampaignNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCampaignNameMutation, { data, loading, error }] = useUpdateCampaignNameMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateCampaignNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCampaignNameMutation, UpdateCampaignNameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCampaignNameMutation, UpdateCampaignNameMutationVariables>(UpdateCampaignNameDocument, options);
      }
export type UpdateCampaignNameMutationHookResult = ReturnType<typeof useUpdateCampaignNameMutation>;
export type UpdateCampaignNameMutationResult = Apollo.MutationResult<UpdateCampaignNameMutation>;
export type UpdateCampaignNameMutationOptions = Apollo.BaseMutationOptions<UpdateCampaignNameMutation, UpdateCampaignNameMutationVariables>;
export const AddCampaignInvestigatorDocument = gql`
    mutation addCampaignInvestigator($campaign_id: Int!, $investigator: String!) {
  insert_campaign_investigator_one(
    object: {campaign_id: $campaign_id, investigator: $investigator}
    on_conflict: {constraint: campaign_investigator_campaign_id_investigator_key, update_columns: [investigator]}
  ) {
    id
    investigator
    campaign_id
  }
}
    `;
export type AddCampaignInvestigatorMutationFn = Apollo.MutationFunction<AddCampaignInvestigatorMutation, AddCampaignInvestigatorMutationVariables>;

/**
 * __useAddCampaignInvestigatorMutation__
 *
 * To run a mutation, you first call `useAddCampaignInvestigatorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCampaignInvestigatorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCampaignInvestigatorMutation, { data, loading, error }] = useAddCampaignInvestigatorMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *   },
 * });
 */
export function useAddCampaignInvestigatorMutation(baseOptions?: Apollo.MutationHookOptions<AddCampaignInvestigatorMutation, AddCampaignInvestigatorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCampaignInvestigatorMutation, AddCampaignInvestigatorMutationVariables>(AddCampaignInvestigatorDocument, options);
      }
export type AddCampaignInvestigatorMutationHookResult = ReturnType<typeof useAddCampaignInvestigatorMutation>;
export type AddCampaignInvestigatorMutationResult = Apollo.MutationResult<AddCampaignInvestigatorMutation>;
export type AddCampaignInvestigatorMutationOptions = Apollo.BaseMutationOptions<AddCampaignInvestigatorMutation, AddCampaignInvestigatorMutationVariables>;
export const RemoveCampaignInvestigatorDocument = gql`
    mutation removeCampaignInvestigator($campaign_id: Int!, $investigator: String!) {
  delete_campaign_investigator(
    where: {campaign_id: {_eq: $campaign_id}, investigator: {_eq: $investigator}}
  ) {
    returning {
      id
      campaign_id
      investigator
    }
  }
}
    `;
export type RemoveCampaignInvestigatorMutationFn = Apollo.MutationFunction<RemoveCampaignInvestigatorMutation, RemoveCampaignInvestigatorMutationVariables>;

/**
 * __useRemoveCampaignInvestigatorMutation__
 *
 * To run a mutation, you first call `useRemoveCampaignInvestigatorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCampaignInvestigatorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCampaignInvestigatorMutation, { data, loading, error }] = useRemoveCampaignInvestigatorMutation({
 *   variables: {
 *      campaign_id: // value for 'campaign_id'
 *      investigator: // value for 'investigator'
 *   },
 * });
 */
export function useRemoveCampaignInvestigatorMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCampaignInvestigatorMutation, RemoveCampaignInvestigatorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCampaignInvestigatorMutation, RemoveCampaignInvestigatorMutationVariables>(RemoveCampaignInvestigatorDocument, options);
      }
export type RemoveCampaignInvestigatorMutationHookResult = ReturnType<typeof useRemoveCampaignInvestigatorMutation>;
export type RemoveCampaignInvestigatorMutationResult = Apollo.MutationResult<RemoveCampaignInvestigatorMutation>;
export type RemoveCampaignInvestigatorMutationOptions = Apollo.BaseMutationOptions<RemoveCampaignInvestigatorMutation, RemoveCampaignInvestigatorMutationVariables>;

      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {}
};
      export default result;
    